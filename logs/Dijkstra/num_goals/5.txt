Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.2 MiB     67.2 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/5.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     71.1 MiB      0.0 MiB         257       for row in grid:
     8     71.1 MiB      0.0 MiB       65792           for spot in row:
     9     71.1 MiB      3.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     71.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     71.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     71.1 MiB      0.0 MiB           1       came_from = {}
    18     77.7 MiB      6.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     77.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     77.8 MiB -1169537.6 MiB       54284       while not open_set.empty():
    22     77.8 MiB -1169537.9 MiB       54284           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     77.8 MiB -1169538.4 MiB       54284           current = open_set.get()[1]
    28                                         
    29     77.8 MiB -1169538.7 MiB       54284           if current in remaining_goals:
    30     65.8 MiB   -125.9 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     65.8 MiB    -61.0 MiB           5               if not remaining_goals:
    32     45.7 MiB    -20.1 MiB           1                   break  # All goals found
    33                                         
    34     77.8 MiB -10497393.0 MiB      487698           for neighbor in current.neighbors:
    35     77.8 MiB -9327926.8 MiB      433415               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     77.8 MiB -9327929.4 MiB      433415               if current.row != neighbor.row and current.col != neighbor.col:
    38     77.8 MiB -4659297.9 MiB      216566                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     77.8 MiB -9327936.2 MiB      433415               if temp_g_score < g_score[neighbor]:
    41     77.8 MiB -1176001.2 MiB       55019                   came_from[neighbor] = current
    42     77.8 MiB -1176002.3 MiB       55019                   g_score[neighbor] = temp_g_score
    43     77.8 MiB -1176008.0 MiB       55019                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     77.8 MiB -1169536.6 MiB       54283           if draw is not None:
    46                                                     draw()
    47                                                     
    48     77.8 MiB -1169536.9 MiB       54283           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.7 MiB      0.0 MiB           1       paths = {}
    53     45.8 MiB      0.0 MiB           6       for goal in goals:
    54     45.8 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.1 MiB     90.1 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/7.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.4 MiB    -92.0 MiB         257       for row in grid:
     8     93.4 MiB -23421.8 MiB       65792           for spot in row:
     9     93.4 MiB -23329.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.6 MiB     -3.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.6 MiB      0.0 MiB           1       came_from = {}
    18     94.2 MiB -27976.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.2 MiB -2574404.7 MiB       60988       while not open_set.empty():
    22     94.2 MiB -2574405.8 MiB       60988           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.2 MiB -2574407.3 MiB       60988           current = open_set.get()[1]
    28                                         
    29     94.2 MiB -2574408.2 MiB       60988           if current in remaining_goals:
    30     85.7 MiB   -209.9 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     85.7 MiB   -167.4 MiB           5               if not remaining_goals:
    32     44.4 MiB    -41.3 MiB           1                   break  # All goals found
    33                                         
    34     94.2 MiB -23077480.1 MiB      546555           for neighbor in current.neighbors:
    35     94.2 MiB -20503124.5 MiB      485568               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.2 MiB -20503137.4 MiB      485568               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.2 MiB -10236357.4 MiB      242397                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.2 MiB -20503154.2 MiB      485568               if temp_g_score < g_score[neighbor]:
    41     94.2 MiB -2573535.0 MiB       61232                   came_from[neighbor] = current
    42     94.2 MiB -2573535.8 MiB       61232                   g_score[neighbor] = temp_g_score
    43     94.2 MiB -2573537.2 MiB       61232                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.2 MiB -2574401.9 MiB       60987           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.2 MiB -2574403.3 MiB       60987           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.4 MiB      0.0 MiB           1       paths = {}
    53     44.7 MiB      0.0 MiB           6       for goal in goals:
    54     44.7 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.2 MiB     94.2 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.5 MiB      0.0 MiB         257       for row in grid:
     8     94.5 MiB      0.0 MiB       65792           for spot in row:
     9     94.5 MiB      0.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     94.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     94.5 MiB      0.0 MiB           1       came_from = {}
    18    101.2 MiB      6.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    101.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    102.0 MiB -1836020.3 MiB       52737       while not open_set.empty():
    22    102.0 MiB -1836023.3 MiB       52737           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    102.0 MiB -1836024.6 MiB       52737           current = open_set.get()[1]
    28                                         
    29    102.0 MiB -1836025.2 MiB       52737           if current in remaining_goals:
    30    101.7 MiB   -211.6 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31    101.7 MiB   -210.3 MiB           5               if not remaining_goals:
    32     48.1 MiB    -53.5 MiB           1                   break  # All goals found
    33                                         
    34    102.0 MiB -16458790.1 MiB      472769           for neighbor in current.neighbors:
    35    102.0 MiB -14622778.9 MiB      420033               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    102.0 MiB -14622778.4 MiB      420033               if current.row != neighbor.row and current.col != neighbor.col:
    38    102.0 MiB -7300593.5 MiB      209708                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    102.0 MiB -14622817.3 MiB      420033               if temp_g_score < g_score[neighbor]:
    41    102.0 MiB -1831411.3 MiB       53092                   came_from[neighbor] = current
    42    102.0 MiB -1831412.5 MiB       53092                   g_score[neighbor] = temp_g_score
    43    102.0 MiB -1831416.2 MiB       53092                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    102.0 MiB -1836019.3 MiB       52736           if draw is not None:
    46                                                     draw()
    47                                                     
    48    102.0 MiB -1836019.7 MiB       52736           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     48.1 MiB      0.0 MiB           1       paths = {}
    53     48.2 MiB      0.0 MiB           6       for goal in goals:
    54     48.2 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     48.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.3 MiB    -71.5 MiB         257       for row in grid:
     8    100.3 MiB -18030.1 MiB       65792           for spot in row:
     9    100.3 MiB -17960.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     98.1 MiB     -2.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     98.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     98.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     98.5 MiB      0.0 MiB           1       came_from = {}
    18    102.0 MiB -39109.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.6 MiB    -10.4 MiB           1       g_score[start] = 0
    20                                         
    21     91.6 MiB -2232496.8 MiB       52901       while not open_set.empty():
    22     91.6 MiB -2232497.0 MiB       52901           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.6 MiB -2232497.9 MiB       52901           current = open_set.get()[1]
    28                                         
    29     91.6 MiB -2232499.0 MiB       52901           if current in remaining_goals:
    30     45.2 MiB   -259.9 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.2 MiB     -1.6 MiB           5               if not remaining_goals:
    32     45.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.6 MiB -20032429.6 MiB      474434           for neighbor in current.neighbors:
    35     91.6 MiB -17800151.9 MiB      421534               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.6 MiB -17800146.9 MiB      421534               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.6 MiB -8890286.8 MiB      210490                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.6 MiB -17800194.5 MiB      421534               if temp_g_score < g_score[neighbor]:
    41     91.6 MiB -2243766.4 MiB       53357                   came_from[neighbor] = current
    42     91.6 MiB -2243766.8 MiB       53357                   g_score[neighbor] = temp_g_score
    43     91.6 MiB -2243767.2 MiB       53357                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.6 MiB -2232495.2 MiB       52900           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.6 MiB -2232495.9 MiB       52900           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.2 MiB      0.0 MiB           1       paths = {}
    53     45.4 MiB      0.0 MiB           6       for goal in goals:
    54     45.4 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.3 MiB   -300.4 MiB         257       for row in grid:
     8    100.3 MiB -76829.9 MiB       65792           for spot in row:
     9    100.3 MiB -76532.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     96.7 MiB     -3.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     96.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     96.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     96.7 MiB      0.0 MiB           1       came_from = {}
    18    101.8 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    101.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    101.8 MiB -2685347.0 MiB       60560       while not open_set.empty():
    22    101.8 MiB -2685347.5 MiB       60560           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    101.8 MiB -2685349.8 MiB       60560           current = open_set.get()[1]
    28                                         
    29    101.8 MiB -2685353.1 MiB       60560           if current in remaining_goals:
    30     90.8 MiB   -190.1 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.8 MiB   -135.1 MiB           5               if not remaining_goals:
    32     47.8 MiB    -43.0 MiB           1                   break  # All goals found
    33                                         
    34    101.8 MiB -24066188.7 MiB      542882           for neighbor in current.neighbors:
    35    101.8 MiB -21380929.8 MiB      482323               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    101.8 MiB -21380930.5 MiB      482323               if current.row != neighbor.row and current.col != neighbor.col:
    38    101.8 MiB -10673633.5 MiB      240804                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    101.8 MiB -21380936.0 MiB      482323               if temp_g_score < g_score[neighbor]:
    41    101.8 MiB -2680398.4 MiB       60863                   came_from[neighbor] = current
    42    101.8 MiB -2680398.7 MiB       60863                   g_score[neighbor] = temp_g_score
    43    101.8 MiB -2680401.4 MiB       60863                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    101.8 MiB -2685335.0 MiB       60559           if draw is not None:
    46                                                     draw()
    47                                                     
    48    101.8 MiB -2685346.4 MiB       60559           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     47.8 MiB      0.0 MiB           1       paths = {}
    53     48.0 MiB      0.0 MiB           6       for goal in goals:
    54     48.0 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     48.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.9 MiB     99.9 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.9 MiB    -15.3 MiB         257       for row in grid:
     8     99.9 MiB  -3913.4 MiB       65792           for spot in row:
     9     99.9 MiB  -3898.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     99.8 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     99.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     99.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     99.8 MiB      0.0 MiB           1       came_from = {}
    18    104.7 MiB   -257.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    104.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    104.7 MiB -3184103.4 MiB       65150       while not open_set.empty():
    22    104.7 MiB -3184105.0 MiB       65150           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    104.7 MiB -3184106.6 MiB       65150           current = open_set.get()[1]
    28                                         
    29    104.7 MiB -3184107.5 MiB       65150           if current in remaining_goals:
    30     94.5 MiB   -243.6 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     94.5 MiB   -192.6 MiB           5               if not remaining_goals:
    32     45.8 MiB    -48.7 MiB           1                   break  # All goals found
    33                                         
    34    104.7 MiB -28514797.6 MiB      583511           for neighbor in current.neighbors:
    35    104.7 MiB -25330748.4 MiB      518362               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    104.7 MiB -25330752.6 MiB      518362               if current.row != neighbor.row and current.col != neighbor.col:
    38    104.7 MiB -12641835.2 MiB      258710                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    104.7 MiB -25330765.8 MiB      518362               if temp_g_score < g_score[neighbor]:
    41    104.7 MiB -3168415.1 MiB       65226                   came_from[neighbor] = current
    42    104.7 MiB -3168415.8 MiB       65226                   g_score[neighbor] = temp_g_score
    43    104.7 MiB -3168418.4 MiB       65226                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    104.7 MiB -3184099.7 MiB       65149           if draw is not None:
    46                                                     draw()
    47                                                     
    48    104.7 MiB -3184100.5 MiB       65149           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.8 MiB      0.0 MiB           1       paths = {}
    53     45.9 MiB      0.0 MiB           6       for goal in goals:
    54     45.9 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.4 MiB     98.4 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.4 MiB    -39.9 MiB         257       for row in grid:
     8     98.4 MiB -10105.2 MiB       65792           for spot in row:
     9     98.4 MiB -10067.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     96.2 MiB     -2.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     96.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     96.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     96.2 MiB      0.0 MiB           1       came_from = {}
    18     98.9 MiB -62522.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.7 MiB     -2.2 MiB           1       g_score[start] = 0
    20                                         
    21     96.7 MiB -3409348.4 MiB       59130       while not open_set.empty():
    22     96.7 MiB -3409349.6 MiB       59130           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.7 MiB -3409356.2 MiB       59130           current = open_set.get()[1]
    28                                         
    29     96.7 MiB -3409357.9 MiB       59130           if current in remaining_goals:
    30     49.7 MiB   -283.6 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     49.7 MiB    -30.4 MiB           5               if not remaining_goals:
    32     33.3 MiB    -16.4 MiB           1                   break  # All goals found
    33                                         
    34     96.7 MiB -30575275.4 MiB      530111           for neighbor in current.neighbors:
    35     96.7 MiB -27166172.5 MiB      470982               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.7 MiB -27166170.7 MiB      470982               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.7 MiB -13565118.4 MiB      235150                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.7 MiB -27166196.4 MiB      470982               if temp_g_score < g_score[neighbor]:
    41     96.7 MiB -3420441.8 MiB       59466                   came_from[neighbor] = current
    42     96.7 MiB -3420442.9 MiB       59466                   g_score[neighbor] = temp_g_score
    43     96.7 MiB -3420445.8 MiB       59466                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.7 MiB -3409345.3 MiB       59129           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.7 MiB -3409346.4 MiB       59129           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.3 MiB      0.0 MiB           1       paths = {}
    53     35.3 MiB      0.0 MiB           6       for goal in goals:
    54     35.3 MiB      2.0 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     96.8 MiB     96.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     96.8 MiB  -5869.8 MiB         257       for row in grid:
     8     96.8 MiB -1504429.1 MiB       65792           for spot in row:
     9     96.8 MiB -1498596.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     30.9 MiB    -65.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     31.2 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     31.4 MiB      0.2 MiB           1       open_set.put((0, start))
    17     31.5 MiB      0.0 MiB           1       came_from = {}
    18     43.8 MiB     12.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     43.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     45.7 MiB -738104.4 MiB       58413       while not open_set.empty():
    22     45.7 MiB -738108.1 MiB       58413           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     45.7 MiB -738115.8 MiB       58413           current = open_set.get()[1]
    28                                         
    29     45.7 MiB -738119.5 MiB       58413           if current in remaining_goals:
    30     44.7 MiB    -53.4 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.7 MiB    -48.4 MiB           5               if not remaining_goals:
    32     33.7 MiB    -11.0 MiB           1                   break  # All goals found
    33                                         
    34     45.7 MiB -6617055.4 MiB      523721           for neighbor in current.neighbors:
    35     45.7 MiB -5878979.8 MiB      465309               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     45.7 MiB -5878956.3 MiB      465309               if current.row != neighbor.row and current.col != neighbor.col:
    38     45.7 MiB -2935318.7 MiB      232324                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     45.7 MiB -5878983.5 MiB      465309               if temp_g_score < g_score[neighbor]:
    41     45.7 MiB -739041.5 MiB       58768                   came_from[neighbor] = current
    42     45.7 MiB -739051.4 MiB       58768                   g_score[neighbor] = temp_g_score
    43     45.7 MiB -739054.8 MiB       58768                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     45.7 MiB -738098.9 MiB       58412           if draw is not None:
    46                                                     draw()
    47                                                     
    48     45.7 MiB -738102.2 MiB       58412           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.7 MiB      0.0 MiB           1       paths = {}
    53     34.0 MiB      0.0 MiB           6       for goal in goals:
    54     34.0 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.0 MiB     87.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.0 MiB  -7136.7 MiB         257       for row in grid:
     8     87.0 MiB -1825688.6 MiB       65792           for spot in row:
     9     87.0 MiB -1818587.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     19.1 MiB    -67.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     19.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     19.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     19.7 MiB      0.0 MiB           1       came_from = {}
    18     32.2 MiB  -4665.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     31.6 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21     40.6 MiB -578342.6 MiB       63834       while not open_set.empty():
    22     40.6 MiB -578343.8 MiB       63834           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     40.6 MiB -578344.4 MiB       63834           current = open_set.get()[1]
    28                                         
    29     40.6 MiB -578344.9 MiB       63834           if current in remaining_goals:
    30     35.7 MiB    -40.1 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.7 MiB      0.0 MiB           5               if not remaining_goals:
    32     35.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     40.6 MiB -5183799.2 MiB      571922           for neighbor in current.neighbors:
    35     40.6 MiB -4605514.1 MiB      508089               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     40.6 MiB -4605506.4 MiB      508089               if current.row != neighbor.row and current.col != neighbor.col:
    38     40.6 MiB -2299270.4 MiB      253616                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     40.6 MiB -4605522.6 MiB      508089               if temp_g_score < g_score[neighbor]:
    41     40.6 MiB -581377.5 MiB       63995                   came_from[neighbor] = current
    42     40.6 MiB -581379.3 MiB       63995                   g_score[neighbor] = temp_g_score
    43     40.6 MiB -581382.0 MiB       63995                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     40.6 MiB -578339.5 MiB       63833           if draw is not None:
    46                                                     draw()
    47                                                     
    48     40.6 MiB -578340.3 MiB       63833           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.7 MiB      0.0 MiB           1       paths = {}
    53     35.8 MiB      0.0 MiB           6       for goal in goals:
    54     35.8 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.3 MiB     86.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.3 MiB  -2053.5 MiB         257       for row in grid:
     8     86.3 MiB -526411.8 MiB       65792           for spot in row:
     9     86.3 MiB -524368.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     74.1 MiB    -12.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     74.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     74.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     74.1 MiB      0.0 MiB           1       came_from = {}
    18     77.1 MiB -38865.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     48.6 MiB    -28.5 MiB           1       g_score[start] = 0
    20                                         
    21     49.0 MiB -1157161.1 MiB       63157       while not open_set.empty():
    22     49.0 MiB -1157161.6 MiB       63157           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     49.0 MiB -1157161.5 MiB       63157           current = open_set.get()[1]
    28                                         
    29     49.0 MiB -1157162.2 MiB       63157           if current in remaining_goals:
    30     35.7 MiB    -90.4 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.7 MiB     -3.0 MiB           5               if not remaining_goals:
    32     32.6 MiB     -3.0 MiB           1                   break  # All goals found
    33                                         
    34     49.0 MiB -10367822.1 MiB      565788           for neighbor in current.neighbors:
    35     49.0 MiB -9210765.9 MiB      502632               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     49.0 MiB -9210752.6 MiB      502632               if current.row != neighbor.row and current.col != neighbor.col:
    38     49.0 MiB -4597713.1 MiB      250881                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     49.0 MiB -9210762.4 MiB      502632               if temp_g_score < g_score[neighbor]:
    41     49.0 MiB -1161143.8 MiB       63305                   came_from[neighbor] = current
    42     49.0 MiB -1161145.9 MiB       63305                   g_score[neighbor] = temp_g_score
    43     49.0 MiB -1161147.7 MiB       63305                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     49.0 MiB -1157159.4 MiB       63156           if draw is not None:
    46                                                     draw()
    47                                                     
    48     49.0 MiB -1157160.2 MiB       63156           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.6 MiB      0.0 MiB           1       paths = {}
    53     33.6 MiB      0.0 MiB           6       for goal in goals:
    54     33.6 MiB      1.0 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.7 MiB     85.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.7 MiB  -2508.5 MiB         257       for row in grid:
     8     85.7 MiB -643652.9 MiB       65792           for spot in row:
     9     85.7 MiB -641155.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     70.7 MiB    -14.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     70.9 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     71.1 MiB      0.2 MiB           1       open_set.put((0, start))
    17     71.1 MiB      0.0 MiB           1       came_from = {}
    18     76.4 MiB  -1542.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     76.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     76.5 MiB -2696490.7 MiB       62979       while not open_set.empty():
    22     76.5 MiB -2696491.0 MiB       62979           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     76.5 MiB -2696492.8 MiB       62979           current = open_set.get()[1]
    28                                         
    29     76.5 MiB -2696493.2 MiB       62979           if current in remaining_goals:
    30     42.7 MiB   -201.1 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.7 MiB    -14.5 MiB           5               if not remaining_goals:
    32     35.0 MiB     -7.7 MiB           1                   break  # All goals found
    33                                         
    34     76.5 MiB -24163817.0 MiB      564282           for neighbor in current.neighbors:
    35     76.5 MiB -21467485.7 MiB      501304               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     76.5 MiB -21467471.6 MiB      501304               if current.row != neighbor.row and current.col != neighbor.col:
    38     76.5 MiB -10716413.5 MiB      250233                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     76.5 MiB -21467486.8 MiB      501304               if temp_g_score < g_score[neighbor]:
    41     76.5 MiB -2701066.0 MiB       63159                   came_from[neighbor] = current
    42     76.5 MiB -2701073.3 MiB       63159                   g_score[neighbor] = temp_g_score
    43     76.5 MiB -2701074.7 MiB       63159                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     76.5 MiB -2696489.4 MiB       62978           if draw is not None:
    46                                                     draw()
    47                                                     
    48     76.5 MiB -2696490.4 MiB       62978           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.0 MiB      0.0 MiB           1       paths = {}
    53     35.1 MiB      0.0 MiB           6       for goal in goals:
    54     35.1 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.9 MiB     92.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.9 MiB   -489.0 MiB         257       for row in grid:
     8     92.9 MiB -124653.0 MiB       65792           for spot in row:
     9     92.9 MiB -124168.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.7 MiB     -6.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.9 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     87.1 MiB      0.2 MiB           1       open_set.put((0, start))
    17     87.1 MiB      0.0 MiB           1       came_from = {}
    18     92.7 MiB -52926.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.1 MiB     -2.6 MiB           1       g_score[start] = 0
    20                                         
    21     90.3 MiB -3422920.6 MiB       64068       while not open_set.empty():
    22     90.3 MiB -3422923.7 MiB       64068           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.3 MiB -3422928.5 MiB       64068           current = open_set.get()[1]
    28                                         
    29     90.3 MiB -3422929.3 MiB       64068           if current in remaining_goals:
    30     84.2 MiB   -205.8 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     84.2 MiB   -175.2 MiB           5               if not remaining_goals:
    32     19.2 MiB    -65.0 MiB           1                   break  # All goals found
    33                                         
    34     90.3 MiB -30665089.2 MiB      574025           for neighbor in current.neighbors:
    35     90.3 MiB -27242214.8 MiB      509958               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.3 MiB -27242222.7 MiB      509958               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.3 MiB -13597750.5 MiB      254550                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.3 MiB -27242242.2 MiB      509958               if temp_g_score < g_score[neighbor]:
    41     90.3 MiB -3410703.5 MiB       64228                   came_from[neighbor] = current
    42     90.3 MiB -3410705.6 MiB       64228                   g_score[neighbor] = temp_g_score
    43     90.3 MiB -3410708.5 MiB       64228                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.3 MiB -3422915.9 MiB       64067           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.3 MiB -3422917.2 MiB       64067           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     19.2 MiB      0.0 MiB           1       paths = {}
    53     21.5 MiB      0.0 MiB           6       for goal in goals:
    54     21.5 MiB      2.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     21.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.6 MiB     91.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.6 MiB   -843.1 MiB         257       for row in grid:
     8     91.6 MiB -215905.5 MiB       65792           for spot in row:
     9     91.6 MiB -215066.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.9 MiB     -4.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.9 MiB      0.0 MiB           1       came_from = {}
    18     90.8 MiB  -6231.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.7 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.8 MiB -3086952.1 MiB       54729       while not open_set.empty():
    22     90.8 MiB -3086953.2 MiB       54729           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.8 MiB -3086955.2 MiB       54729           current = open_set.get()[1]
    28                                         
    29     90.8 MiB -3086957.9 MiB       54729           if current in remaining_goals:
    30     37.5 MiB   -285.5 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.5 MiB     -8.8 MiB           5               if not remaining_goals:
    32     33.0 MiB     -4.5 MiB           1                   break  # All goals found
    33                                         
    34     90.8 MiB -27684062.1 MiB      490885           for neighbor in current.neighbors:
    35     90.8 MiB -24597349.7 MiB      436157               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.8 MiB -24597382.2 MiB      436157               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.8 MiB -12282445.4 MiB      217801                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.8 MiB -24597394.9 MiB      436157               if temp_g_score < g_score[neighbor]:
    41     90.8 MiB -3104488.7 MiB       55192                   came_from[neighbor] = current
    42     90.8 MiB -3104490.1 MiB       55192                   g_score[neighbor] = temp_g_score
    43     90.8 MiB -3104495.3 MiB       55192                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.8 MiB -3086949.3 MiB       54728           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.8 MiB -3086950.8 MiB       54728           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.0 MiB      0.0 MiB           1       paths = {}
    53     33.3 MiB      0.0 MiB           6       for goal in goals:
    54     33.3 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.6 MiB     90.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.6 MiB  -1140.2 MiB         257       for row in grid:
     8     90.6 MiB -291858.3 MiB       65792           for spot in row:
     9     90.6 MiB -290723.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.3 MiB     -7.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.4 MiB      0.0 MiB           1       came_from = {}
    18     88.5 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.7 MiB -2330352.8 MiB       52985       while not open_set.empty():
    22     88.7 MiB -2330353.6 MiB       52985           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.7 MiB -2330355.6 MiB       52985           current = open_set.get()[1]
    28                                         
    29     88.7 MiB -2330356.8 MiB       52985           if current in remaining_goals:
    30     43.2 MiB   -283.6 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.2 MiB    -21.5 MiB           5               if not remaining_goals:
    32     33.2 MiB    -10.0 MiB           1                   break  # All goals found
    33                                         
    34     88.7 MiB -20905641.6 MiB      475599           for neighbor in current.neighbors:
    35     88.7 MiB -18575533.4 MiB      422615               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.7 MiB -18575537.6 MiB      422615               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.7 MiB -9276671.3 MiB      211098                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.7 MiB -18575571.3 MiB      422615               if temp_g_score < g_score[neighbor]:
    41     88.7 MiB -2337474.6 MiB       53554                   came_from[neighbor] = current
    42     88.7 MiB -2337475.6 MiB       53554                   g_score[neighbor] = temp_g_score
    43     88.7 MiB -2337478.5 MiB       53554                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.7 MiB -2330350.1 MiB       52984           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.7 MiB -2330351.4 MiB       52984           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.2 MiB      0.0 MiB           1       paths = {}
    53     33.7 MiB      0.0 MiB           6       for goal in goals:
    54     33.7 MiB      0.5 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.6 MiB     89.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.6 MiB    -31.3 MiB         257       for row in grid:
     8     89.6 MiB  -7639.8 MiB       65792           for spot in row:
     9     89.6 MiB  -7610.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.6 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.6 MiB      0.0 MiB           1       came_from = {}
    18     88.5 MiB -131105.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.0 MiB     -4.6 MiB           1       g_score[start] = 0
    20                                         
    21     84.0 MiB -1595270.1 MiB       30569       while not open_set.empty():
    22     84.0 MiB -1595270.3 MiB       30569           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.0 MiB -1595270.9 MiB       30569           current = open_set.get()[1]
    28                                         
    29     84.0 MiB -1595271.2 MiB       30569           if current in remaining_goals:
    30     34.5 MiB   -270.3 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.5 MiB      0.0 MiB           5               if not remaining_goals:
    32     34.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.0 MiB -14297561.6 MiB      274069           for neighbor in current.neighbors:
    35     84.0 MiB -12702555.1 MiB      243501               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.0 MiB -12702555.5 MiB      243501               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.0 MiB -6341444.4 MiB      121577                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.0 MiB -12702561.4 MiB      243501               if temp_g_score < g_score[neighbor]:
    41     84.0 MiB -1607688.8 MiB       31002                   came_from[neighbor] = current
    42     84.0 MiB -1607689.6 MiB       31002                   g_score[neighbor] = temp_g_score
    43     84.0 MiB -1607690.5 MiB       31002                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.0 MiB -1595234.5 MiB       30568           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.0 MiB -1595269.3 MiB       30568           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.5 MiB      0.0 MiB           1       paths = {}
    53     34.6 MiB      0.0 MiB           6       for goal in goals:
    54     34.6 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.6 MiB    -94.6 MiB         257       for row in grid:
     8     86.6 MiB -24017.6 MiB       65792           for spot in row:
     9     86.6 MiB -23923.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.5 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.5 MiB      0.0 MiB           1       came_from = {}
    18     89.4 MiB   -508.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.4 MiB -2725192.2 MiB       53233       while not open_set.empty():
    22     89.4 MiB -2725193.6 MiB       53233           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.4 MiB -2725195.9 MiB       53233           current = open_set.get()[1]
    28                                         
    29     89.4 MiB -2725200.3 MiB       53233           if current in remaining_goals:
    30     87.5 MiB   -200.4 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     87.5 MiB   -190.7 MiB           5               if not remaining_goals:
    32     43.4 MiB    -44.1 MiB           1                   break  # All goals found
    33                                         
    34     89.4 MiB -24452347.1 MiB      477335           for neighbor in current.neighbors:
    35     89.4 MiB -21727173.7 MiB      424103               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.4 MiB -21727191.7 MiB      424103               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.4 MiB -10851284.3 MiB      211760                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.4 MiB -21727204.6 MiB      424103               if temp_g_score < g_score[neighbor]:
    41     89.4 MiB -2741538.9 MiB       53668                   came_from[neighbor] = current
    42     89.4 MiB -2741539.5 MiB       53668                   g_score[neighbor] = temp_g_score
    43     89.4 MiB -2741542.8 MiB       53668                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.4 MiB -2725189.8 MiB       53232           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.4 MiB -2725191.0 MiB       53232           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.4 MiB      0.0 MiB           1       paths = {}
    53     43.7 MiB      0.0 MiB           6       for goal in goals:
    54     43.7 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.3 MiB     87.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.3 MiB   -637.0 MiB         257       for row in grid:
     8     87.3 MiB -163351.2 MiB       65792           for spot in row:
     9     87.3 MiB -162714.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.9 MiB     -4.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.9 MiB      0.0 MiB           1       came_from = {}
    18     84.2 MiB -231217.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     80.6 MiB     -3.6 MiB           1       g_score[start] = 0
    20                                         
    21     81.2 MiB -2618375.8 MiB       55780       while not open_set.empty():
    22     81.2 MiB -2618376.7 MiB       55780           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.2 MiB -2618385.3 MiB       55780           current = open_set.get()[1]
    28                                         
    29     81.2 MiB -2618386.5 MiB       55780           if current in remaining_goals:
    30     34.5 MiB   -246.9 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.5 MiB     -7.8 MiB           5               if not remaining_goals:
    32     31.5 MiB     -3.1 MiB           1                   break  # All goals found
    33                                         
    34     81.2 MiB -23482971.4 MiB      500043           for neighbor in current.neighbors:
    35     81.2 MiB -20864800.5 MiB      444264               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.2 MiB -20864806.1 MiB      444264               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.2 MiB -10418815.7 MiB      221805                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.2 MiB -20864820.6 MiB      444264               if temp_g_score < g_score[neighbor]:
    41     81.2 MiB -2630517.3 MiB       56144                   came_from[neighbor] = current
    42     81.2 MiB -2630528.2 MiB       56144                   g_score[neighbor] = temp_g_score
    43     81.2 MiB -2630530.5 MiB       56144                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.2 MiB -2618373.7 MiB       55779           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.2 MiB -2618374.4 MiB       55779           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.5 MiB      0.0 MiB           1       paths = {}
    53     32.0 MiB      0.0 MiB           6       for goal in goals:
    54     32.0 MiB      0.5 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.8 MiB     85.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.9 MiB      0.0 MiB         257       for row in grid:
     8     85.9 MiB      0.0 MiB       65792           for spot in row:
     9     85.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.9 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.9 MiB      0.0 MiB           1       came_from = {}
    18     91.2 MiB      5.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.5 MiB -3051815.4 MiB       64545       while not open_set.empty():
    22     91.5 MiB -3051816.3 MiB       64545           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.5 MiB -3051817.7 MiB       64545           current = open_set.get()[1]
    28                                         
    29     91.5 MiB -3051820.8 MiB       64545           if current in remaining_goals:
    30     43.7 MiB   -282.5 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.7 MiB    -29.7 MiB           5               if not remaining_goals:
    32     32.6 MiB    -11.1 MiB           1                   break  # All goals found
    33                                         
    34     91.5 MiB -27348354.1 MiB      578169           for neighbor in current.neighbors:
    35     91.5 MiB -24296765.1 MiB      513625               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.5 MiB -24296784.1 MiB      513625               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.5 MiB -12128875.4 MiB      256359                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.5 MiB -24296807.3 MiB      513625               if temp_g_score < g_score[neighbor]:
    41     91.5 MiB -3043785.9 MiB       64656                   came_from[neighbor] = current
    42     91.5 MiB -3043787.1 MiB       64656                   g_score[neighbor] = temp_g_score
    43     91.5 MiB -3043789.1 MiB       64656                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.5 MiB -3051812.9 MiB       64544           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.5 MiB -3051814.2 MiB       64544           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.6 MiB      0.0 MiB           1       paths = {}
    53     33.2 MiB      0.0 MiB           6       for goal in goals:
    54     33.2 MiB      0.6 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.0 MiB     86.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.0 MiB   -260.3 MiB         257       for row in grid:
     8     86.0 MiB -66247.0 MiB       65792           for spot in row:
     9     86.0 MiB -65988.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.1 MiB     -3.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     82.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     82.5 MiB      0.0 MiB           1       came_from = {}
    18     84.3 MiB -90424.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     82.3 MiB     -2.0 MiB           1       g_score[start] = 0
    20                                         
    21     82.5 MiB -2560199.1 MiB       63827       while not open_set.empty():
    22     82.5 MiB -2560200.0 MiB       63827           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     82.5 MiB -2560201.3 MiB       63827           current = open_set.get()[1]
    28                                         
    29     82.5 MiB -2560202.2 MiB       63827           if current in remaining_goals:
    30     81.5 MiB   -178.3 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     81.5 MiB   -173.6 MiB           5               if not remaining_goals:
    32     40.3 MiB    -41.2 MiB           1                   break  # All goals found
    33                                         
    34     82.5 MiB -22928218.3 MiB      571898           for neighbor in current.neighbors:
    35     82.5 MiB -20368048.4 MiB      508072               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     82.5 MiB -20368044.3 MiB      508072               if current.row != neighbor.row and current.col != neighbor.col:
    38     82.5 MiB -10165184.0 MiB      253614                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     82.5 MiB -20368075.5 MiB      508072               if temp_g_score < g_score[neighbor]:
    41     82.5 MiB -2550176.8 MiB       64001                   came_from[neighbor] = current
    42     82.5 MiB -2550178.6 MiB       64001                   g_score[neighbor] = temp_g_score
    43     82.5 MiB -2550181.9 MiB       64001                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     82.5 MiB -2560195.0 MiB       63826           if draw is not None:
    46                                                     draw()
    47                                                     
    48     82.5 MiB -2560196.7 MiB       63826           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.3 MiB      0.0 MiB           1       paths = {}
    53     40.4 MiB      0.0 MiB           6       for goal in goals:
    54     40.4 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.0 MiB     86.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.0 MiB  -2593.1 MiB         257       for row in grid:
     8     86.0 MiB -663963.6 MiB       65792           for spot in row:
     9     86.0 MiB -661376.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     72.8 MiB    -13.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     72.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     72.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     72.8 MiB      0.0 MiB           1       came_from = {}
    18     78.7 MiB      5.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     78.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     78.9 MiB -2237079.9 MiB       49331       while not open_set.empty():
    22     78.9 MiB -2237081.1 MiB       49331           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     78.9 MiB -2237083.1 MiB       49331           current = open_set.get()[1]
    28                                         
    29     78.9 MiB -2237084.0 MiB       49331           if current in remaining_goals:
    30     32.0 MiB   -253.7 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.0 MiB     -1.2 MiB           5               if not remaining_goals:
    32     32.0 MiB     -0.0 MiB           1                   break  # All goals found
    33                                         
    34     78.9 MiB -20063053.3 MiB      442630           for neighbor in current.neighbors:
    35     78.9 MiB -17826190.2 MiB      393300               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     78.9 MiB -17826189.0 MiB      393300               if current.row != neighbor.row and current.col != neighbor.col:
    38     78.9 MiB -8901492.0 MiB      196427                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     78.9 MiB -17826218.1 MiB      393300               if temp_g_score < g_score[neighbor]:
    41     78.9 MiB -2246205.9 MiB       49869                   came_from[neighbor] = current
    42     78.9 MiB -2246210.2 MiB       49869                   g_score[neighbor] = temp_g_score
    43     78.9 MiB -2246213.1 MiB       49869                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     78.9 MiB -2237078.4 MiB       49330           if draw is not None:
    46                                                     draw()
    47                                                     
    48     78.9 MiB -2237079.1 MiB       49330           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.0 MiB      0.0 MiB           1       paths = {}
    53     32.1 MiB      0.0 MiB           6       for goal in goals:
    54     32.1 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.9 MiB     91.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.9 MiB   -599.2 MiB         257       for row in grid:
     8     91.9 MiB -153346.7 MiB       65792           for spot in row:
     9     91.9 MiB -152749.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.4 MiB     -3.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.4 MiB      0.0 MiB           1       came_from = {}
    18     89.7 MiB -508414.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     31.6 MiB    -58.1 MiB           1       g_score[start] = 0
    20                                         
    21     44.9 MiB -132153.2 MiB       26110       while not open_set.empty():
    22     44.9 MiB -132153.4 MiB       26110           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     44.9 MiB -132153.6 MiB       26110           current = open_set.get()[1]
    28                                         
    29     44.9 MiB -132153.7 MiB       26110           if current in remaining_goals:
    30     43.8 MiB    -27.1 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.8 MiB    -20.9 MiB           5               if not remaining_goals:
    32     33.9 MiB     -9.8 MiB           1                   break  # All goals found
    33                                         
    34     44.9 MiB -1183792.6 MiB      234261           for neighbor in current.neighbors:
    35     44.9 MiB -1051667.8 MiB      208152               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     44.9 MiB -1051663.3 MiB      208152               if current.row != neighbor.row and current.col != neighbor.col:
    38     44.9 MiB -524931.4 MiB      103956                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     44.9 MiB -1051670.2 MiB      208152               if temp_g_score < g_score[neighbor]:
    41     44.9 MiB -132440.9 MiB       26586                   came_from[neighbor] = current
    42     44.9 MiB -132441.4 MiB       26586                   g_score[neighbor] = temp_g_score
    43     44.9 MiB -132443.1 MiB       26586                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     44.9 MiB -132152.6 MiB       26109           if draw is not None:
    46                                                     draw()
    47                                                     
    48     44.9 MiB -132152.8 MiB       26109           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.9 MiB      0.0 MiB           1       paths = {}
    53     34.1 MiB      0.0 MiB           6       for goal in goals:
    54     34.1 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.1 MiB     91.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.1 MiB   -414.4 MiB         257       for row in grid:
     8     91.1 MiB -105732.9 MiB       65792           for spot in row:
     9     91.1 MiB -105321.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.5 MiB     -3.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.5 MiB      0.0 MiB           1       came_from = {}
    18     91.6 MiB -13829.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.0 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21     91.1 MiB -4250195.6 MiB       64036       while not open_set.empty():
    22     91.1 MiB -4250198.2 MiB       64036           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.1 MiB -4250204.5 MiB       64036           current = open_set.get()[1]
    28                                         
    29     91.1 MiB -4250216.2 MiB       64036           if current in remaining_goals:
    30     29.5 MiB   -341.6 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.5 MiB    -33.4 MiB           5               if not remaining_goals:
    32     20.2 MiB     -9.3 MiB           1                   break  # All goals found
    33                                         
    34     91.1 MiB -38083096.0 MiB      573737           for neighbor in current.neighbors:
    35     91.1 MiB -33833170.8 MiB      509702               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.1 MiB -33833161.0 MiB      509702               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.1 MiB -16888676.0 MiB      254422                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.1 MiB -33833197.0 MiB      509702               if temp_g_score < g_score[neighbor]:
    41     91.1 MiB -4253544.6 MiB       64196                   came_from[neighbor] = current
    42     91.1 MiB -4253545.7 MiB       64196                   g_score[neighbor] = temp_g_score
    43     91.1 MiB -4253550.0 MiB       64196                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.1 MiB -4250191.2 MiB       64035           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.1 MiB -4250192.9 MiB       64035           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     20.2 MiB      0.0 MiB           1       paths = {}
    53     22.5 MiB      0.0 MiB           6       for goal in goals:
    54     22.5 MiB      2.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     22.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.3 MiB     90.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.3 MiB  -9657.1 MiB         257       for row in grid:
     8     90.3 MiB -2475423.2 MiB       65792           for spot in row:
     9     90.3 MiB -2465773.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     33.8 MiB    -56.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     34.1 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     34.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     34.3 MiB      0.0 MiB           1       came_from = {}
    18     42.5 MiB -20368.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     41.8 MiB     -0.7 MiB           1       g_score[start] = 0
    20                                         
    21     43.8 MiB -733018.6 MiB       60926       while not open_set.empty():
    22     43.8 MiB -733019.1 MiB       60926           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     43.8 MiB -733019.8 MiB       60926           current = open_set.get()[1]
    28                                         
    29     43.8 MiB -733020.2 MiB       60926           if current in remaining_goals:
    30     30.5 MiB    -74.9 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.5 MiB     -7.8 MiB           5               if not remaining_goals:
    32     25.7 MiB     -4.8 MiB           1                   break  # All goals found
    33                                         
    34     43.8 MiB -6566048.9 MiB      545996           for neighbor in current.neighbors:
    35     43.8 MiB -5833108.8 MiB      485071               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     43.8 MiB -5833099.5 MiB      485071               if current.row != neighbor.row and current.col != neighbor.col:
    38     43.8 MiB -2911433.8 MiB      242148                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     43.8 MiB -5833109.9 MiB      485071               if temp_g_score < g_score[neighbor]:
    41     43.8 MiB -732594.1 MiB       61169                   came_from[neighbor] = current
    42     43.8 MiB -732594.8 MiB       61169                   g_score[neighbor] = temp_g_score
    43     43.8 MiB -732604.9 MiB       61169                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     43.8 MiB -733016.1 MiB       60925           if draw is not None:
    46                                                     draw()
    47                                                     
    48     43.8 MiB -733017.3 MiB       60925           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     25.7 MiB      0.0 MiB           1       paths = {}
    53     27.3 MiB      0.0 MiB           6       for goal in goals:
    54     27.3 MiB      1.6 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.8 MiB   -462.9 MiB         257       for row in grid:
     8     88.8 MiB -118364.9 MiB       65792           for spot in row:
     9     88.8 MiB -117908.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.5 MiB     -9.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     79.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     79.9 MiB      0.0 MiB           1       came_from = {}
    18     85.0 MiB  -2866.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.8 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     85.1 MiB -2498015.9 MiB       49238       while not open_set.empty():
    22     85.1 MiB -2498016.3 MiB       49238           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.1 MiB -2498020.3 MiB       49238           current = open_set.get()[1]
    28                                         
    29     85.1 MiB -2498021.3 MiB       49238           if current in remaining_goals:
    30     41.1 MiB   -269.2 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.1 MiB     -2.2 MiB           5               if not remaining_goals:
    32     41.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     85.1 MiB -22404592.3 MiB      441539           for neighbor in current.neighbors:
    35     85.1 MiB -19906825.5 MiB      392302               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.1 MiB -19906818.5 MiB      392302               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.1 MiB -9940667.7 MiB      195886                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.1 MiB -19906841.0 MiB      392302               if temp_g_score < g_score[neighbor]:
    41     85.1 MiB -2512544.5 MiB       49682                   came_from[neighbor] = current
    42     85.1 MiB -2512548.1 MiB       49682                   g_score[neighbor] = temp_g_score
    43     85.1 MiB -2512549.0 MiB       49682                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.1 MiB -2498013.5 MiB       49237           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.1 MiB -2498014.8 MiB       49237           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.1 MiB      0.0 MiB           1       paths = {}
    53     41.4 MiB      0.0 MiB           6       for goal in goals:
    54     41.4 MiB      0.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.8 MiB     89.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.0 MiB    -19.4 MiB         257       for row in grid:
     8     90.0 MiB  -4976.0 MiB       65792           for spot in row:
     9     90.0 MiB  -4957.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.9 MiB     -1.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.9 MiB      0.0 MiB           1       came_from = {}
    18     94.2 MiB    -14.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.1 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.2 MiB -2921652.4 MiB       64543       while not open_set.empty():
    22     94.2 MiB -2921653.8 MiB       64543           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.2 MiB -2921661.0 MiB       64543           current = open_set.get()[1]
    28                                         
    29     94.2 MiB -2921662.8 MiB       64543           if current in remaining_goals:
    30     35.8 MiB   -300.8 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.8 MiB     -2.7 MiB           5               if not remaining_goals:
    32     35.8 MiB     -0.1 MiB           1                   break  # All goals found
    33                                         
    34     94.2 MiB -26135406.7 MiB      578213           for neighbor in current.neighbors:
    35     94.2 MiB -23214011.1 MiB      513671               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.2 MiB -23214012.6 MiB      513671               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.2 MiB -11580616.9 MiB      256392                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.2 MiB -23214028.8 MiB      513671               if temp_g_score < g_score[neighbor]:
    41     94.2 MiB -2894820.1 MiB       64674                   came_from[neighbor] = current
    42     94.2 MiB -2894821.1 MiB       64674                   g_score[neighbor] = temp_g_score
    43     94.2 MiB -2894826.2 MiB       64674                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.2 MiB -2921647.4 MiB       64542           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.2 MiB -2921650.9 MiB       64542           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.8 MiB      0.0 MiB           1       paths = {}
    53     36.0 MiB      0.0 MiB           6       for goal in goals:
    54     36.0 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.1 MiB     87.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.1 MiB   -623.2 MiB         257       for row in grid:
     8     87.1 MiB -157700.5 MiB       65792           for spot in row:
     9     87.1 MiB -157087.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     76.2 MiB    -10.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     76.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     76.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     76.2 MiB      0.0 MiB           1       came_from = {}
    18     80.1 MiB -69889.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     76.3 MiB     -3.8 MiB           1       g_score[start] = 0
    20                                         
    21     76.3 MiB -1941995.6 MiB       54498       while not open_set.empty():
    22     76.3 MiB -1941996.4 MiB       54498           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     76.3 MiB -1941997.0 MiB       54498           current = open_set.get()[1]
    28                                         
    29     76.3 MiB -1941998.6 MiB       54498           if current in remaining_goals:
    30     36.1 MiB   -219.0 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.1 MiB    -10.7 MiB           5               if not remaining_goals:
    32     36.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     76.3 MiB -17421691.3 MiB      488633           for neighbor in current.neighbors:
    35     76.3 MiB -15479874.8 MiB      434136               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     76.3 MiB -15479887.5 MiB      434136               if current.row != neighbor.row and current.col != neighbor.col:
    38     76.3 MiB -7730717.9 MiB      216762                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     76.3 MiB -15479914.4 MiB      434136               if temp_g_score < g_score[neighbor]:
    41     76.3 MiB -1947259.4 MiB       54884                   came_from[neighbor] = current
    42     76.3 MiB -1947259.7 MiB       54884                   g_score[neighbor] = temp_g_score
    43     76.3 MiB -1947260.3 MiB       54884                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     76.3 MiB -1941994.8 MiB       54497           if draw is not None:
    46                                                     draw()
    47                                                     
    48     76.3 MiB -1941995.2 MiB       54497           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.1 MiB      0.0 MiB           1       paths = {}
    53     36.4 MiB      0.0 MiB           6       for goal in goals:
    54     36.4 MiB      0.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.6 MiB     85.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.6 MiB    -19.9 MiB         257       for row in grid:
     8     85.6 MiB  -5116.3 MiB       65792           for spot in row:
     9     85.6 MiB  -5096.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.5 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.5 MiB      0.0 MiB           1       came_from = {}
    18     90.5 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.8 MiB -2424051.0 MiB       55444       while not open_set.empty():
    22     90.8 MiB -2424051.9 MiB       55444           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.8 MiB -2424064.4 MiB       55444           current = open_set.get()[1]
    28                                         
    29     90.8 MiB -2424066.8 MiB       55444           if current in remaining_goals:
    30     85.6 MiB   -225.5 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     85.6 MiB   -199.5 MiB           5               if not remaining_goals:
    32     36.9 MiB    -48.7 MiB           1                   break  # All goals found
    33                                         
    34     90.8 MiB -21728600.4 MiB      497368           for neighbor in current.neighbors:
    35     90.8 MiB -19304588.8 MiB      441925               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.8 MiB -19304586.5 MiB      441925               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.8 MiB -9637762.5 MiB      220693                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.8 MiB -19304606.7 MiB      441925               if temp_g_score < g_score[neighbor]:
    41     90.8 MiB -2423345.4 MiB       55917                   came_from[neighbor] = current
    42     90.8 MiB -2423346.9 MiB       55917                   g_score[neighbor] = temp_g_score
    43     90.8 MiB -2423349.3 MiB       55917                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.8 MiB -2424045.3 MiB       55443           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.8 MiB -2424046.5 MiB       55443           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.9 MiB      0.0 MiB           1       paths = {}
    53     37.2 MiB      0.0 MiB           6       for goal in goals:
    54     37.2 MiB      0.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.7 MiB     85.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.7 MiB   -128.0 MiB         257       for row in grid:
     8     85.7 MiB -32647.4 MiB       65792           for spot in row:
     9     85.7 MiB -32520.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.2 MiB     -1.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.2 MiB      0.0 MiB           1       came_from = {}
    18     86.9 MiB   -126.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.0 MiB -1337154.6 MiB       33824       while not open_set.empty():
    22     87.0 MiB -1337156.0 MiB       33824           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.0 MiB -1337157.9 MiB       33824           current = open_set.get()[1]
    28                                         
    29     87.0 MiB -1337159.3 MiB       33824           if current in remaining_goals:
    30     30.5 MiB   -289.7 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.5 MiB      0.0 MiB           5               if not remaining_goals:
    32     30.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.0 MiB -11997212.1 MiB      303445           for neighbor in current.neighbors:
    35     87.0 MiB -10660304.2 MiB      269622               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.0 MiB -10660312.4 MiB      269622               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.0 MiB -5324118.4 MiB      134651                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.0 MiB -10660327.3 MiB      269622               if temp_g_score < g_score[neighbor]:
    41     87.0 MiB -1346872.7 MiB       34346                   came_from[neighbor] = current
    42     87.0 MiB -1346873.8 MiB       34346                   g_score[neighbor] = temp_g_score
    43     87.0 MiB -1346876.5 MiB       34346                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.0 MiB -1337152.9 MiB       33823           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.0 MiB -1337153.9 MiB       33823           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.5 MiB      0.0 MiB           1       paths = {}
    53     30.6 MiB      0.0 MiB           6       for goal in goals:
    54     30.6 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.8 MiB     92.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.8 MiB   -216.5 MiB         257       for row in grid:
     8     92.8 MiB -55410.3 MiB       65792           for spot in row:
     9     92.8 MiB -55194.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.8 MiB     -1.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.8 MiB      0.0 MiB           1       came_from = {}
    18     94.0 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.4 MiB -3179467.3 MiB       59067       while not open_set.empty():
    22     94.4 MiB -3179468.9 MiB       59067           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.4 MiB -3179472.0 MiB       59067           current = open_set.get()[1]
    28                                         
    29     94.4 MiB -3179473.2 MiB       59067           if current in remaining_goals:
    30     41.5 MiB   -304.8 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.5 MiB    -40.6 MiB           5               if not remaining_goals:
    32     30.8 MiB    -10.8 MiB           1                   break  # All goals found
    33                                         
    34     94.4 MiB -28514664.4 MiB      529574           for neighbor in current.neighbors:
    35     94.4 MiB -25335423.8 MiB      470508               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.4 MiB -25335436.6 MiB      470508               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.4 MiB -12651141.4 MiB      234918                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.4 MiB -25335465.2 MiB      470508               if temp_g_score < g_score[neighbor]:
    41     94.4 MiB -3187281.5 MiB       59413                   came_from[neighbor] = current
    42     94.4 MiB -3187283.0 MiB       59413                   g_score[neighbor] = temp_g_score
    43     94.4 MiB -3187288.6 MiB       59413                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.4 MiB -3179464.9 MiB       59066           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.4 MiB -3179466.2 MiB       59066           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.8 MiB      0.0 MiB           1       paths = {}
    53     31.9 MiB      0.0 MiB           6       for goal in goals:
    54     31.9 MiB      1.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.2 MiB     91.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.2 MiB   -150.2 MiB         257       for row in grid:
     8     91.2 MiB -38482.2 MiB       65792           for spot in row:
     9     91.2 MiB -38332.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.1 MiB     -1.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.1 MiB      0.0 MiB           1       came_from = {}
    18     95.0 MiB    -92.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.3 MiB -1506724.2 MiB       37907       while not open_set.empty():
    22     95.3 MiB -1506725.2 MiB       37907           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.3 MiB -1506726.8 MiB       37907           current = open_set.get()[1]
    28                                         
    29     95.3 MiB -1506727.6 MiB       37907           if current in remaining_goals:
    30     95.1 MiB   -206.6 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     95.1 MiB   -206.0 MiB           5               if not remaining_goals:
    32     43.3 MiB    -51.8 MiB           1                   break  # All goals found
    33                                         
    34     95.3 MiB -13504296.3 MiB      340075           for neighbor in current.neighbors:
    35     95.3 MiB -11997584.4 MiB      302169               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.3 MiB -11997590.2 MiB      302169               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.3 MiB -5989504.9 MiB      150905                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.3 MiB -11997600.3 MiB      302169               if temp_g_score < g_score[neighbor]:
    41     95.3 MiB -1508958.9 MiB       38400                   came_from[neighbor] = current
    42     95.3 MiB -1508959.6 MiB       38400                   g_score[neighbor] = temp_g_score
    43     95.3 MiB -1508960.4 MiB       38400                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.3 MiB -1506722.0 MiB       37906           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.3 MiB -1506723.1 MiB       37906           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.3 MiB      0.0 MiB           1       paths = {}
    53     43.4 MiB      0.0 MiB           6       for goal in goals:
    54     43.4 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.8 MiB     89.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.9 MiB   -363.2 MiB         257       for row in grid:
     8     89.9 MiB -93094.2 MiB       65792           for spot in row:
     9     89.9 MiB -92732.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.1 MiB     -1.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.1 MiB      0.0 MiB           1       came_from = {}
    18     93.4 MiB   -815.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.5 MiB -3480403.3 MiB       62240       while not open_set.empty():
    22     93.5 MiB -3480404.9 MiB       62240           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.5 MiB -3480407.9 MiB       62240           current = open_set.get()[1]
    28                                         
    29     93.5 MiB -3480409.8 MiB       62240           if current in remaining_goals:
    30     50.8 MiB   -310.1 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     50.8 MiB    -96.7 MiB           5               if not remaining_goals:
    32     20.3 MiB    -30.5 MiB           1                   break  # All goals found
    33                                         
    34     93.5 MiB -31194433.6 MiB      557825           for neighbor in current.neighbors:
    35     93.5 MiB -27714239.5 MiB      495586               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.5 MiB -27714240.4 MiB      495586               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.5 MiB -13835767.5 MiB      247406                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.5 MiB -27714253.4 MiB      495586               if temp_g_score < g_score[neighbor]:
    41     93.5 MiB -3478130.4 MiB       62484                   came_from[neighbor] = current
    42     93.5 MiB -3478131.3 MiB       62484                   g_score[neighbor] = temp_g_score
    43     93.5 MiB -3478132.1 MiB       62484                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.5 MiB -3480395.0 MiB       62239           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.5 MiB -3480397.2 MiB       62239           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     20.3 MiB      0.0 MiB           1       paths = {}
    53     22.8 MiB      0.1 MiB           6       for goal in goals:
    54     22.8 MiB      2.4 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     22.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.7 MiB     89.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.7 MiB      0.0 MiB         257       for row in grid:
     8     89.7 MiB      0.0 MiB       65792           for spot in row:
     9     89.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.7 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.7 MiB      0.0 MiB           1       came_from = {}
    18     92.8 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.8 MiB -2238085.2 MiB       56449       while not open_set.empty():
    22     92.8 MiB -2238086.3 MiB       56449           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.8 MiB -2238088.1 MiB       56449           current = open_set.get()[1]
    28                                         
    29     92.8 MiB -2238089.0 MiB       56449           if current in remaining_goals:
    30     88.0 MiB   -178.8 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     88.0 MiB   -154.6 MiB           5               if not remaining_goals:
    32     40.1 MiB    -47.8 MiB           1                   break  # All goals found
    33                                         
    34     92.8 MiB -20063981.9 MiB      506093           for neighbor in current.neighbors:
    35     92.8 MiB -17825928.0 MiB      449645               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.8 MiB -17825935.8 MiB      449645               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.8 MiB -8899971.3 MiB      224500                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.8 MiB -17825954.2 MiB      449645               if temp_g_score < g_score[neighbor]:
    41     92.8 MiB -2234520.3 MiB       56804                   came_from[neighbor] = current
    42     92.8 MiB -2234521.4 MiB       56804                   g_score[neighbor] = temp_g_score
    43     92.8 MiB -2234522.4 MiB       56804                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.8 MiB -2238083.0 MiB       56448           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.8 MiB -2238084.2 MiB       56448           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.1 MiB      0.0 MiB           1       paths = {}
    53     40.4 MiB      0.0 MiB           6       for goal in goals:
    54     40.4 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.2 MiB     89.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.2 MiB      0.0 MiB         257       for row in grid:
     8     89.2 MiB      0.0 MiB       65792           for spot in row:
     9     89.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.2 MiB      0.0 MiB           1       came_from = {}
    18     94.3 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.3 MiB -3532384.3 MiB       62575       while not open_set.empty():
    22     94.3 MiB -3532385.0 MiB       62575           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.3 MiB -3532388.6 MiB       62575           current = open_set.get()[1]
    28                                         
    29     94.3 MiB -3532393.5 MiB       62575           if current in remaining_goals:
    30     36.0 MiB   -330.9 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.0 MiB      0.0 MiB           5               if not remaining_goals:
    32     36.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.3 MiB -31651300.1 MiB      560667           for neighbor in current.neighbors:
    35     94.3 MiB -28119206.0 MiB      498093               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.3 MiB -28119199.6 MiB      498093               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.3 MiB -14036458.8 MiB      248631                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.3 MiB -28119224.0 MiB      498093               if temp_g_score < g_score[neighbor]:
    41     94.3 MiB -3528307.9 MiB       62762                   came_from[neighbor] = current
    42     94.3 MiB -3528310.7 MiB       62762                   g_score[neighbor] = temp_g_score
    43     94.3 MiB -3528315.5 MiB       62762                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.3 MiB -3532379.0 MiB       62574           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.3 MiB -3532382.9 MiB       62574           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.0 MiB      0.0 MiB           1       paths = {}
    53     36.3 MiB      0.0 MiB           6       for goal in goals:
    54     36.3 MiB      0.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.4 MiB     87.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.4 MiB   -410.2 MiB         257       for row in grid:
     8     87.4 MiB -105018.6 MiB       65792           for spot in row:
     9     87.4 MiB -104610.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.7 MiB     -3.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.9 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     84.1 MiB      0.2 MiB           1       open_set.put((0, start))
    17     84.1 MiB      0.0 MiB           1       came_from = {}
    18     87.9 MiB -15936.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.9 MiB -2726080.0 MiB       55115       while not open_set.empty():
    22     87.9 MiB -2726080.6 MiB       55115           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.9 MiB -2726082.0 MiB       55115           current = open_set.get()[1]
    28                                         
    29     87.9 MiB -2726082.7 MiB       55115           if current in remaining_goals:
    30     38.4 MiB   -260.4 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.4 MiB     -4.7 MiB           5               if not remaining_goals:
    32     38.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.9 MiB -24448349.0 MiB      494503           for neighbor in current.neighbors:
    35     87.9 MiB -21722503.2 MiB      439389               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.9 MiB -21722494.9 MiB      439389               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.9 MiB -10847081.0 MiB      219441                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.9 MiB -21722533.7 MiB      439389               if temp_g_score < g_score[neighbor]:
    41     87.9 MiB -2735771.6 MiB       55626                   came_from[neighbor] = current
    42     87.9 MiB -2735772.6 MiB       55626                   g_score[neighbor] = temp_g_score
    43     87.9 MiB -2735777.8 MiB       55626                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.9 MiB -2726077.7 MiB       55114           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.9 MiB -2726079.0 MiB       55114           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.4 MiB      0.0 MiB           1       paths = {}
    53     38.7 MiB      0.0 MiB           6       for goal in goals:
    54     38.7 MiB      0.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.2 MiB     88.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.2 MiB      0.0 MiB         257       for row in grid:
     8     88.2 MiB      0.0 MiB       65792           for spot in row:
     9     88.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.2 MiB      0.0 MiB           1       came_from = {}
    18     92.1 MiB -11801.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.1 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.1 MiB -1051978.3 MiB       41213       while not open_set.empty():
    22     92.1 MiB -1051980.0 MiB       41213           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.1 MiB -1051984.5 MiB       41213           current = open_set.get()[1]
    28                                         
    29     92.1 MiB -1051985.7 MiB       41213           if current in remaining_goals:
    30     80.4 MiB   -159.6 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     80.4 MiB   -101.0 MiB           5               if not remaining_goals:
    32     36.3 MiB    -44.1 MiB           1                   break  # All goals found
    33                                         
    34     92.1 MiB -9431432.7 MiB      369518           for neighbor in current.neighbors:
    35     92.1 MiB -8379506.6 MiB      328306               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.1 MiB -8379508.2 MiB      328306               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.1 MiB -4183814.7 MiB      163922                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.1 MiB -8379521.2 MiB      328306               if temp_g_score < g_score[neighbor]:
    41     92.1 MiB -1053271.8 MiB       41647                   came_from[neighbor] = current
    42     92.1 MiB -1053273.2 MiB       41647                   g_score[neighbor] = temp_g_score
    43     92.1 MiB -1053275.5 MiB       41647                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.1 MiB -1051976.7 MiB       41212           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.1 MiB -1051977.3 MiB       41212           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.3 MiB      0.0 MiB           1       paths = {}
    53     36.5 MiB      0.0 MiB           6       for goal in goals:
    54     36.5 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.5 MiB     85.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.5 MiB    -23.1 MiB         257       for row in grid:
     8     85.5 MiB  -5920.6 MiB       65792           for spot in row:
     9     85.5 MiB  -5898.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.9 MiB     -0.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.9 MiB      0.0 MiB           1       came_from = {}
    18     90.6 MiB      5.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.7 MiB -426338.9 MiB       50719       while not open_set.empty():
    22     91.7 MiB -426339.4 MiB       50719           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.7 MiB -426340.4 MiB       50719           current = open_set.get()[1]
    28                                         
    29     91.7 MiB -426340.8 MiB       50719           if current in remaining_goals:
    30     89.7 MiB    -81.1 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     89.7 MiB    -71.4 MiB           5               if not remaining_goals:
    32     46.0 MiB    -43.7 MiB           1                   break  # All goals found
    33                                         
    34     91.7 MiB -3821253.5 MiB      454823           for neighbor in current.neighbors:
    35     91.7 MiB -3394932.8 MiB      404105               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.7 MiB -3394939.8 MiB      404105               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.7 MiB -1694936.2 MiB      201780                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.7 MiB -3394952.1 MiB      404105               if temp_g_score < g_score[neighbor]:
    41     91.7 MiB -425759.4 MiB       51142                   came_from[neighbor] = current
    42     91.7 MiB -425761.8 MiB       51142                   g_score[neighbor] = temp_g_score
    43     91.7 MiB -425764.0 MiB       51142                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.7 MiB -426337.3 MiB       50718           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.7 MiB -426338.0 MiB       50718           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.0 MiB      0.0 MiB           1       paths = {}
    53     46.3 MiB      0.0 MiB           6       for goal in goals:
    54     46.3 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.5 MiB     88.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.5 MiB   -733.8 MiB         257       for row in grid:
     8     88.5 MiB -187839.5 MiB       65792           for spot in row:
     9     88.5 MiB -187108.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.2 MiB     -5.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.2 MiB      0.0 MiB           1       came_from = {}
    18     86.4 MiB -28197.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     86.4 MiB -2167013.4 MiB       44486       while not open_set.empty():
    22     86.4 MiB -2167016.1 MiB       44486           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.4 MiB -2167024.2 MiB       44486           current = open_set.get()[1]
    28                                         
    29     86.4 MiB -2167025.8 MiB       44486           if current in remaining_goals:
    30     40.2 MiB   -276.0 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.2 MiB      0.0 MiB           5               if not remaining_goals:
    32     40.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.4 MiB -19482350.1 MiB      399957           for neighbor in current.neighbors:
    35     86.4 MiB -17315576.1 MiB      355472               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.4 MiB -17315599.3 MiB      355472               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.4 MiB -8654457.4 MiB      177668                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.4 MiB -17315611.3 MiB      355472               if temp_g_score < g_score[neighbor]:
    41     86.4 MiB -2197638.2 MiB       45306                   came_from[neighbor] = current
    42     86.4 MiB -2197638.8 MiB       45306                   g_score[neighbor] = temp_g_score
    43     86.4 MiB -2197647.5 MiB       45306                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.4 MiB -2167011.8 MiB       44485           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.4 MiB -2167012.2 MiB       44485           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.2 MiB      0.0 MiB           1       paths = {}
    53     40.3 MiB      0.0 MiB           6       for goal in goals:
    54     40.3 MiB      0.0 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.0 MiB     94.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.0 MiB    -27.3 MiB         257       for row in grid:
     8     94.0 MiB  -6988.0 MiB       65792           for spot in row:
     9     94.0 MiB  -6960.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.8 MiB     -0.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.8 MiB      0.0 MiB           1       came_from = {}
    18     95.0 MiB -175916.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.8 MiB     -2.2 MiB           1       g_score[start] = 0
    20                                         
    21     92.8 MiB -1976121.1 MiB       36318       while not open_set.empty():
    22     92.8 MiB -1976121.9 MiB       36318           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.8 MiB -1976124.6 MiB       36318           current = open_set.get()[1]
    28                                         
    29     92.8 MiB -1976125.7 MiB       36318           if current in remaining_goals:
    30     36.6 MiB   -302.7 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.6 MiB      0.0 MiB           5               if not remaining_goals:
    32     36.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.8 MiB -17729457.5 MiB      325609           for neighbor in current.neighbors:
    35     92.8 MiB -15753602.2 MiB      289292               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.8 MiB -15753602.5 MiB      289292               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.8 MiB -7867685.3 MiB      144439                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.8 MiB -15753620.1 MiB      289292               if temp_g_score < g_score[neighbor]:
    41     92.8 MiB -1993959.6 MiB       36776                   came_from[neighbor] = current
    42     92.8 MiB -1993961.4 MiB       36776                   g_score[neighbor] = temp_g_score
    43     92.8 MiB -1993966.7 MiB       36776                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.8 MiB -1976117.2 MiB       36317           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.8 MiB -1976118.5 MiB       36317           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.6 MiB      0.0 MiB           1       paths = {}
    53     36.9 MiB      0.0 MiB           6       for goal in goals:
    54     36.9 MiB      0.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.1 MiB     91.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.1 MiB    -88.7 MiB         257       for row in grid:
     8     91.1 MiB -22716.4 MiB       65792           for spot in row:
     9     91.1 MiB -22628.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.7 MiB     -0.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.7 MiB      0.0 MiB           1       came_from = {}
    18     93.7 MiB  -5241.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.3 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     93.9 MiB -1225132.1 MiB       51417       while not open_set.empty():
    22     93.9 MiB -1225134.4 MiB       51417           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.9 MiB -1225138.3 MiB       51417           current = open_set.get()[1]
    28                                         
    29     93.9 MiB -1225139.6 MiB       51417           if current in remaining_goals:
    30     87.5 MiB   -176.1 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     87.5 MiB   -142.4 MiB           5               if not remaining_goals:
    32     41.0 MiB    -46.5 MiB           1                   break  # All goals found
    33                                         
    34     93.9 MiB -10975527.2 MiB      461625           for neighbor in current.neighbors:
    35     93.9 MiB -9750438.2 MiB      410209               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.9 MiB -9750444.2 MiB      410209               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.9 MiB -4866875.4 MiB      204918                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.9 MiB -9750459.7 MiB      410209               if temp_g_score < g_score[neighbor]:
    41     93.9 MiB -1219942.1 MiB       52026                   came_from[neighbor] = current
    42     93.9 MiB -1219944.8 MiB       52026                   g_score[neighbor] = temp_g_score
    43     93.9 MiB -1219947.7 MiB       52026                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.9 MiB -1225127.7 MiB       51416           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.9 MiB -1225129.0 MiB       51416           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.0 MiB      0.0 MiB           1       paths = {}
    53     41.3 MiB      0.0 MiB           6       for goal in goals:
    54     41.3 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.5 MiB     91.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.5 MiB    -13.0 MiB         257       for row in grid:
     8     91.5 MiB  -3336.0 MiB       65792           for spot in row:
     9     91.5 MiB  -3323.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.4 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.4 MiB      0.0 MiB           1       came_from = {}
    18     96.2 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.4 MiB -1092758.8 MiB       58946       while not open_set.empty():
    22     96.4 MiB -1092759.8 MiB       58946           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.4 MiB -1092763.3 MiB       58946           current = open_set.get()[1]
    28                                         
    29     96.4 MiB -1092765.4 MiB       58946           if current in remaining_goals:
    30     96.4 MiB    -95.3 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.4 MiB    -95.2 MiB           5               if not remaining_goals:
    32     36.1 MiB    -60.3 MiB           1                   break  # All goals found
    33                                         
    34     96.4 MiB -9779963.2 MiB      528339           for neighbor in current.neighbors:
    35     96.4 MiB -8687224.8 MiB      469394               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.4 MiB -8687232.9 MiB      469394               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.4 MiB -4334601.8 MiB      234337                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.4 MiB -8687247.1 MiB      469394               if temp_g_score < g_score[neighbor]:
    41     96.4 MiB -1082337.4 MiB       59244                   came_from[neighbor] = current
    42     96.4 MiB -1082338.5 MiB       59244                   g_score[neighbor] = temp_g_score
    43     96.4 MiB -1082341.0 MiB       59244                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.4 MiB -1092756.1 MiB       58945           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.4 MiB -1092757.3 MiB       58945           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.1 MiB      0.0 MiB           1       paths = {}
    53     36.4 MiB      0.0 MiB           6       for goal in goals:
    54     36.4 MiB      0.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.7 MiB     88.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.8 MiB   -440.7 MiB         257       for row in grid:
     8     88.8 MiB -113203.5 MiB       65792           for spot in row:
     9     88.8 MiB -112764.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.1 MiB     -2.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.1 MiB      0.0 MiB           1       came_from = {}
    18     91.1 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.3 MiB -2599061.8 MiB       58626       while not open_set.empty():
    22     91.3 MiB -2599063.9 MiB       58626           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.3 MiB -2599069.0 MiB       58626           current = open_set.get()[1]
    28                                         
    29     91.3 MiB -2599071.5 MiB       58626           if current in remaining_goals:
    30     44.7 MiB   -245.5 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.7 MiB    -11.2 MiB           5               if not remaining_goals:
    32     39.9 MiB     -4.7 MiB           1                   break  # All goals found
    33                                         
    34     91.3 MiB -23297987.9 MiB      525480           for neighbor in current.neighbors:
    35     91.3 MiB -20699133.2 MiB      466855               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.3 MiB -20699137.3 MiB      466855               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.3 MiB -10334144.0 MiB      233071                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.3 MiB -20699155.0 MiB      466855               if temp_g_score < g_score[neighbor]:
    41     91.3 MiB -2601864.1 MiB       58931                   came_from[neighbor] = current
    42     91.3 MiB -2601865.8 MiB       58931                   g_score[neighbor] = temp_g_score
    43     91.3 MiB -2601868.1 MiB       58931                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.3 MiB -2599058.8 MiB       58625           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.3 MiB -2599060.2 MiB       58625           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.9 MiB      0.0 MiB           1       paths = {}
    53     40.3 MiB      0.0 MiB           6       for goal in goals:
    54     40.3 MiB      0.4 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.1 MiB     89.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.1 MiB   -201.1 MiB         257       for row in grid:
     8     89.1 MiB -51544.1 MiB       65792           for spot in row:
     9     89.1 MiB -51344.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.8 MiB     -1.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.8 MiB      0.0 MiB           1       came_from = {}
    18     91.1 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.4 MiB -1917785.9 MiB       55424       while not open_set.empty():
    22     91.4 MiB -1917787.0 MiB       55424           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.4 MiB -1917789.6 MiB       55424           current = open_set.get()[1]
    28                                         
    29     91.4 MiB -1917795.0 MiB       55424           if current in remaining_goals:
    30     91.1 MiB   -220.9 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     91.1 MiB   -220.0 MiB           5               if not remaining_goals:
    32     38.3 MiB    -52.8 MiB           1                   break  # All goals found
    33                                         
    34     91.4 MiB -17203495.5 MiB      496857           for neighbor in current.neighbors:
    35     91.4 MiB -15285729.0 MiB      441434               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.4 MiB -15285733.7 MiB      441434               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.4 MiB -7633567.2 MiB      220393                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.4 MiB -15285748.2 MiB      441434               if temp_g_score < g_score[neighbor]:
    41     91.4 MiB -1920027.4 MiB       55794                   came_from[neighbor] = current
    42     91.4 MiB -1920028.7 MiB       55794                   g_score[neighbor] = temp_g_score
    43     91.4 MiB -1920030.5 MiB       55794                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.4 MiB -1917781.9 MiB       55423           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.4 MiB -1917783.7 MiB       55423           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.3 MiB      0.0 MiB           1       paths = {}
    53     38.7 MiB      0.0 MiB           6       for goal in goals:
    54     38.7 MiB      0.3 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.6 MiB     87.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.6 MiB    -62.6 MiB         257       for row in grid:
     8     87.6 MiB -15966.2 MiB       65792           for spot in row:
     9     87.6 MiB -15904.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.9 MiB     -0.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.9 MiB      0.0 MiB           1       came_from = {}
    18     89.4 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.2 MiB -1770743.4 MiB       64675       while not open_set.empty():
    22     90.2 MiB -1770744.4 MiB       64675           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.2 MiB -1770747.3 MiB       64675           current = open_set.get()[1]
    28                                         
    29     90.2 MiB -1770748.6 MiB       64675           if current in remaining_goals:
    30     89.6 MiB   -132.7 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     89.6 MiB   -131.0 MiB           5               if not remaining_goals:
    32     41.2 MiB    -48.5 MiB           1                   break  # All goals found
    33                                         
    34     90.2 MiB -15852315.2 MiB      579267           for neighbor in current.neighbors:
    35     90.2 MiB -14081590.2 MiB      514593               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.2 MiB -14081597.0 MiB      514593               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.2 MiB -7026836.8 MiB      256831                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.2 MiB -14081611.4 MiB      514593               if temp_g_score < g_score[neighbor]:
    41     90.2 MiB -1755313.2 MiB       64762                   came_from[neighbor] = current
    42     90.2 MiB -1755315.2 MiB       64762                   g_score[neighbor] = temp_g_score
    43     90.2 MiB -1755317.7 MiB       64762                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.2 MiB -1770739.5 MiB       64674           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.2 MiB -1770741.8 MiB       64674           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.2 MiB      0.0 MiB           1       paths = {}
    53     41.3 MiB      0.0 MiB           6       for goal in goals:
    54     41.3 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.3 MiB     86.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.3 MiB    -75.3 MiB         257       for row in grid:
     8     86.3 MiB -19281.1 MiB       65792           for spot in row:
     9     86.3 MiB -19206.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB     -0.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     88.9 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.9 MiB -1993260.3 MiB       64337       while not open_set.empty():
    22     89.9 MiB -1993261.4 MiB       64337           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.9 MiB -1993264.1 MiB       64337           current = open_set.get()[1]
    28                                         
    29     89.9 MiB -1993265.9 MiB       64337           if current in remaining_goals:
    30     89.1 MiB   -198.0 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     89.1 MiB   -195.0 MiB           5               if not remaining_goals:
    32     36.6 MiB    -52.5 MiB           1                   break  # All goals found
    33                                         
    34     89.9 MiB -17813442.0 MiB      576333           for neighbor in current.neighbors:
    35     89.9 MiB -15820199.4 MiB      511997               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.9 MiB -15820204.8 MiB      511997               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.9 MiB -7889264.4 MiB      255551                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.9 MiB -15820220.9 MiB      511997               if temp_g_score < g_score[neighbor]:
    41     89.9 MiB -1966720.7 MiB       64460                   came_from[neighbor] = current
    42     89.9 MiB -1966723.0 MiB       64460                   g_score[neighbor] = temp_g_score
    43     89.9 MiB -1966726.2 MiB       64460                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.9 MiB -1993257.0 MiB       64336           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.9 MiB -1993258.5 MiB       64336           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.6 MiB      0.0 MiB           1       paths = {}
    53     37.2 MiB      0.0 MiB           6       for goal in goals:
    54     37.2 MiB      0.6 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.4 MiB      0.0 MiB         257       for row in grid:
     8     86.4 MiB      0.0 MiB       65792           for spot in row:
     9     86.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.4 MiB      0.0 MiB           1       came_from = {}
    18     91.2 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.1 MiB -674905.4 MiB       58586       while not open_set.empty():
    22     92.1 MiB -674906.1 MiB       58586           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.1 MiB -674907.5 MiB       58586           current = open_set.get()[1]
    28                                         
    29     92.1 MiB -674910.0 MiB       58586           if current in remaining_goals:
    30     91.2 MiB    -57.1 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     91.2 MiB    -54.3 MiB           5               if not remaining_goals:
    32     44.2 MiB    -47.0 MiB           1                   break  # All goals found
    33                                         
    34     92.1 MiB -6035598.8 MiB      525442           for neighbor in current.neighbors:
    35     92.1 MiB -5360711.3 MiB      466857               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.1 MiB -5360718.9 MiB      466857               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.1 MiB -2674023.8 MiB      233125                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.1 MiB -5360730.8 MiB      466857               if temp_g_score < g_score[neighbor]:
    41     92.1 MiB -666455.6 MiB       58997                   came_from[neighbor] = current
    42     92.1 MiB -666457.0 MiB       58997                   g_score[neighbor] = temp_g_score
    43     92.1 MiB -666458.0 MiB       58997                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.1 MiB -674903.6 MiB       58585           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.1 MiB -674904.6 MiB       58585           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.2 MiB      0.0 MiB           1       paths = {}
    53     44.4 MiB      0.0 MiB           6       for goal in goals:
    54     44.4 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.5 MiB     94.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.5 MiB      0.0 MiB         257       for row in grid:
     8     94.5 MiB      0.0 MiB       65792           for spot in row:
     9     94.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     94.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     94.5 MiB      0.0 MiB           1       came_from = {}
    18     99.3 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     99.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.3 MiB -1847439.1 MiB       60081       while not open_set.empty():
    22     99.3 MiB -1847440.7 MiB       60081           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.3 MiB -1847443.4 MiB       60081           current = open_set.get()[1]
    28                                         
    29     99.3 MiB -1847444.5 MiB       60081           if current in remaining_goals:
    30     99.3 MiB   -212.1 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     99.3 MiB   -212.0 MiB           5               if not remaining_goals:
    32     36.7 MiB    -62.6 MiB           1                   break  # All goals found
    33                                         
    34     99.3 MiB -16562790.0 MiB      538607           for neighbor in current.neighbors:
    35     99.3 MiB -14715369.0 MiB      478527               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.3 MiB -14715379.3 MiB      478527               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.3 MiB -7347107.7 MiB      238912                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.3 MiB -14715393.5 MiB      478527               if temp_g_score < g_score[neighbor]:
    41     99.3 MiB -1839820.7 MiB       60396                   came_from[neighbor] = current
    42     99.3 MiB -1839822.2 MiB       60396                   g_score[neighbor] = temp_g_score
    43     99.3 MiB -1839824.8 MiB       60396                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.3 MiB -1847433.1 MiB       60080           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.3 MiB -1847437.8 MiB       60080           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.7 MiB      0.0 MiB           1       paths = {}
    53     37.3 MiB      0.0 MiB           6       for goal in goals:
    54     37.3 MiB      0.6 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.1 MiB     91.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.2 MiB     -0.1 MiB         257       for row in grid:
     8     91.2 MiB    -32.9 MiB       65792           for spot in row:
     9     91.2 MiB    -32.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.1 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.1 MiB      0.0 MiB           1       came_from = {}
    18     96.1 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.2 MiB -2377646.4 MiB       64805       while not open_set.empty():
    22     96.2 MiB -2377647.7 MiB       64805           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.2 MiB -2377650.5 MiB       64805           current = open_set.get()[1]
    28                                         
    29     96.2 MiB -2377651.7 MiB       64805           if current in remaining_goals:
    30     95.3 MiB   -188.8 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     95.3 MiB   -184.2 MiB           5               if not remaining_goals:
    32     48.0 MiB    -47.3 MiB           1                   break  # All goals found
    33                                         
    34     96.2 MiB -21268743.5 MiB      580499           for neighbor in current.neighbors:
    35     96.2 MiB -18891117.3 MiB      515695               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.2 MiB -18891123.2 MiB      515695               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.2 MiB -9423997.5 MiB      257392                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.2 MiB -18891138.8 MiB      515695               if temp_g_score < g_score[neighbor]:
    41     96.2 MiB -2355680.3 MiB       64912                   came_from[neighbor] = current
    42     96.2 MiB -2355681.4 MiB       64912                   g_score[neighbor] = temp_g_score
    43     96.2 MiB -2355683.6 MiB       64912                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.2 MiB -2377642.9 MiB       64804           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.2 MiB -2377644.8 MiB       64804           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     48.0 MiB      0.0 MiB           1       paths = {}
    53     48.2 MiB      0.0 MiB           6       for goal in goals:
    54     48.2 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     48.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.5 MiB     91.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.5 MiB      0.0 MiB         257       for row in grid:
     8     91.5 MiB      0.0 MiB       65792           for spot in row:
     9     91.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.5 MiB      0.0 MiB           1       came_from = {}
    18     96.0 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.7 MiB -68149.9 MiB       57149       while not open_set.empty():
    22     96.7 MiB -68149.9 MiB       57149           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.7 MiB -68149.9 MiB       57149           current = open_set.get()[1]
    28                                         
    29     96.7 MiB -68149.9 MiB       57149           if current in remaining_goals:
    30     96.7 MiB     -5.5 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.7 MiB     -1.0 MiB           5               if not remaining_goals:
    32     95.8 MiB     -1.0 MiB           1                   break  # All goals found
    33                                         
    34     96.7 MiB -612642.4 MiB      512778           for neighbor in current.neighbors:
    35     96.7 MiB -544497.5 MiB      455630               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.7 MiB -544497.8 MiB      455630               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.7 MiB -272135.5 MiB      227556                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.7 MiB -544498.8 MiB      455630               if temp_g_score < g_score[neighbor]:
    41     96.7 MiB -69307.9 MiB       57643                   came_from[neighbor] = current
    42     96.7 MiB -69308.9 MiB       57643                   g_score[neighbor] = temp_g_score
    43     96.7 MiB -69309.5 MiB       57643                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.7 MiB -68149.9 MiB       57148           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.7 MiB -68149.9 MiB       57148           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     95.8 MiB      0.0 MiB           1       paths = {}
    53     95.8 MiB      0.0 MiB           6       for goal in goals:
    54     95.8 MiB      0.0 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     95.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.4 MiB     97.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.4 MiB   -327.9 MiB         257       for row in grid:
     8     97.4 MiB -84046.1 MiB       65792           for spot in row:
     9     97.4 MiB -83720.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.7 MiB     -2.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     94.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     94.7 MiB      0.0 MiB           1       came_from = {}
    18     96.8 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.9 MiB -1091748.2 MiB       55252       while not open_set.empty():
    22     97.9 MiB -1091749.1 MiB       55252           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.9 MiB -1091751.7 MiB       55252           current = open_set.get()[1]
    28                                         
    29     97.9 MiB -1091753.0 MiB       55252           if current in remaining_goals:
    30     97.9 MiB   -153.8 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     97.9 MiB   -153.8 MiB           5               if not remaining_goals:
    32     45.0 MiB    -52.8 MiB           1                   break  # All goals found
    33                                         
    34     97.9 MiB -9792162.4 MiB      495518           for neighbor in current.neighbors:
    35     97.9 MiB -8700428.9 MiB      440267               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.9 MiB -8700437.4 MiB      440267               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.9 MiB -4344726.6 MiB      219844                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.9 MiB -8700453.5 MiB      440267               if temp_g_score < g_score[neighbor]:
    41     97.9 MiB -1091200.1 MiB       55687                   came_from[neighbor] = current
    42     97.9 MiB -1091202.2 MiB       55687                   g_score[neighbor] = temp_g_score
    43     97.9 MiB -1091203.6 MiB       55687                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.9 MiB -1091746.0 MiB       55251           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.9 MiB -1091746.9 MiB       55251           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.0 MiB      0.0 MiB           1       paths = {}
    53     45.2 MiB      0.0 MiB           6       for goal in goals:
    54     45.2 MiB      0.1 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.9 MiB     89.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.9 MiB   -175.3 MiB         257       for row in grid:
     8     89.9 MiB -44972.4 MiB       65792           for spot in row:
     9     89.9 MiB -44798.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.9 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.9 MiB      0.0 MiB           1       came_from = {}
    18     92.9 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.9 MiB -1940477.0 MiB       56631       while not open_set.empty():
    22     92.9 MiB -1940479.2 MiB       56631           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.9 MiB -1940481.4 MiB       56631           current = open_set.get()[1]
    28                                         
    29     92.9 MiB -1940484.3 MiB       56631           if current in remaining_goals:
    30     90.7 MiB   -169.3 MiB           5               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.7 MiB   -158.2 MiB           5               if not remaining_goals:
    32     43.8 MiB    -46.9 MiB           1                   break  # All goals found
    33                                         
    34     92.9 MiB -17410777.1 MiB      508605           for neighbor in current.neighbors:
    35     92.9 MiB -15470324.2 MiB      451975               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.9 MiB -15470332.3 MiB      451975               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.9 MiB -7726330.9 MiB      225810                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.9 MiB -15470346.1 MiB      451975               if temp_g_score < g_score[neighbor]:
    41     92.9 MiB -1941619.5 MiB       57294                   came_from[neighbor] = current
    42     92.9 MiB -1941620.2 MiB       57294                   g_score[neighbor] = temp_g_score
    43     92.9 MiB -1941621.6 MiB       57294                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.9 MiB -1940472.7 MiB       56630           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.9 MiB -1940475.3 MiB       56630           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.8 MiB      0.0 MiB           1       paths = {}
    53     44.0 MiB      0.0 MiB           6       for goal in goals:
    54     44.0 MiB      0.2 MiB           5           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.0 MiB      0.0 MiB           1       return paths


