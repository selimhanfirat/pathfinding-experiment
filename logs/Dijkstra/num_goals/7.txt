Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.1 MiB     67.1 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/7.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     71.0 MiB      0.0 MiB         257       for row in grid:
     8     71.0 MiB      0.0 MiB       65792           for spot in row:
     9     71.0 MiB      3.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     71.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     71.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     71.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     71.0 MiB      0.0 MiB           1       came_from = {}
    18     78.1 MiB      7.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     78.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     78.1 MiB -1472824.7 MiB       59673       while not open_set.empty():
    22     78.1 MiB -1472828.5 MiB       59673           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     78.1 MiB -1472839.8 MiB       59673           current = open_set.get()[1]
    28                                         
    29     78.1 MiB -1472839.8 MiB       59673           if current in remaining_goals:
    30     62.8 MiB   -195.2 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     62.8 MiB    -86.0 MiB           7               if not remaining_goals:
    32     43.9 MiB    -18.9 MiB           1                   break  # All goals found
    33                                         
    34     78.1 MiB -13198318.8 MiB      535299           for neighbor in current.neighbors:
    35     78.1 MiB -11725605.3 MiB      475627               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     78.1 MiB -11725602.1 MiB      475627               if current.row != neighbor.row and current.col != neighbor.col:
    38     78.1 MiB -5853334.2 MiB      237522                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     78.1 MiB -11725602.1 MiB      475627               if temp_g_score < g_score[neighbor]:
    41     78.1 MiB -1471916.0 MiB       60108                   came_from[neighbor] = current
    42     78.1 MiB -1471916.4 MiB       60108                   g_score[neighbor] = temp_g_score
    43     78.1 MiB -1471916.5 MiB       60108                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     78.1 MiB -1472814.2 MiB       59672           if draw is not None:
    46                                                     draw()
    47                                                     
    48     78.1 MiB -1472824.2 MiB       59672           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.9 MiB      0.0 MiB           1       paths = {}
    53     44.2 MiB      0.0 MiB           8       for goal in goals:
    54     44.2 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.6 MiB    -31.9 MiB         257       for row in grid:
     8     91.6 MiB  -8118.3 MiB       65792           for spot in row:
     9     91.6 MiB  -8084.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.6 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.6 MiB      0.0 MiB           1       came_from = {}
    18     98.0 MiB -60168.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.3 MiB     -2.7 MiB           1       g_score[start] = 0
    20                                         
    21     95.3 MiB -1971640.4 MiB       49728       while not open_set.empty():
    22     95.3 MiB -1971641.3 MiB       49728           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.3 MiB -1971641.8 MiB       49728           current = open_set.get()[1]
    28                                         
    29     95.3 MiB -1971642.4 MiB       49728           if current in remaining_goals:
    30     91.2 MiB   -272.5 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     91.2 MiB   -243.6 MiB           7               if not remaining_goals:
    32     44.5 MiB    -46.6 MiB           1                   break  # All goals found
    33                                         
    34     95.3 MiB -17674353.6 MiB      445886           for neighbor in current.neighbors:
    35     95.3 MiB -15702759.7 MiB      396159               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.3 MiB -15702758.7 MiB      396159               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.3 MiB -7839776.7 MiB      197804                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.3 MiB -15702781.7 MiB      396159               if temp_g_score < g_score[neighbor]:
    41     95.3 MiB -1972599.1 MiB       50131                   came_from[neighbor] = current
    42     95.3 MiB -1972599.3 MiB       50131                   g_score[neighbor] = temp_g_score
    43     95.3 MiB -1972600.3 MiB       50131                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.3 MiB -1971638.3 MiB       49727           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.3 MiB -1971639.4 MiB       49727           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.5 MiB      0.0 MiB           1       paths = {}
    53     44.7 MiB      0.0 MiB           8       for goal in goals:
    54     44.7 MiB      0.1 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.8 MiB     94.8 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     95.0 MiB   -392.3 MiB         257       for row in grid:
     8     95.0 MiB -100048.7 MiB       65792           for spot in row:
     9     95.0 MiB -99659.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.5 MiB     -4.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.5 MiB      0.0 MiB           1       came_from = {}
    18     94.5 MiB   -343.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.5 MiB -3019404.5 MiB       61783       while not open_set.empty():
    22     94.5 MiB -3019412.2 MiB       61783           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.5 MiB -3019414.7 MiB       61783           current = open_set.get()[1]
    28                                         
    29     94.5 MiB -3019416.1 MiB       61783           if current in remaining_goals:
    30     93.0 MiB   -332.5 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     93.0 MiB   -321.9 MiB           7               if not remaining_goals:
    32     43.8 MiB    -49.2 MiB           1                   break  # All goals found
    33                                         
    34     94.5 MiB -27070239.1 MiB      553638           for neighbor in current.neighbors:
    35     94.5 MiB -24050870.3 MiB      491856               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.5 MiB -24050868.4 MiB      491856               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.5 MiB -12008140.1 MiB      245529                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.5 MiB -24050882.5 MiB      491856               if temp_g_score < g_score[neighbor]:
    41     94.5 MiB -3024169.2 MiB       62003                   came_from[neighbor] = current
    42     94.5 MiB -3024171.2 MiB       62003                   g_score[neighbor] = temp_g_score
    43     94.5 MiB -3024173.4 MiB       62003                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.5 MiB -3019393.8 MiB       61782           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.5 MiB -3019402.9 MiB       61782           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.8 MiB      0.0 MiB           1       paths = {}
    53     44.0 MiB      0.0 MiB           8       for goal in goals:
    54     44.0 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.1 MiB     99.1 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.1 MiB   -731.7 MiB         257       for row in grid:
     8     99.1 MiB -187165.9 MiB       65792           for spot in row:
     9     99.1 MiB -186438.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.7 MiB     -7.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.7 MiB      0.0 MiB           1       came_from = {}
    18     96.9 MiB -55198.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.2 MiB     -4.7 MiB           1       g_score[start] = 0
    20                                         
    21     92.2 MiB -2552766.0 MiB       52827       while not open_set.empty():
    22     92.2 MiB -2552766.5 MiB       52827           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.2 MiB -2552768.6 MiB       52827           current = open_set.get()[1]
    28                                         
    29     92.2 MiB -2552793.7 MiB       52827           if current in remaining_goals:
    30     50.7 MiB   -325.7 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     50.7 MiB    -12.5 MiB           7               if not remaining_goals:
    32     44.1 MiB     -6.6 MiB           1                   break  # All goals found
    33                                         
    34     92.2 MiB -22897943.5 MiB      473755           for neighbor in current.neighbors:
    35     92.2 MiB -20345458.4 MiB      420929               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.2 MiB -20345451.7 MiB      420929               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.2 MiB -10160042.1 MiB      210185                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.2 MiB -20345464.0 MiB      420929               if temp_g_score < g_score[neighbor]:
    41     92.2 MiB -2572150.9 MiB       53244                   came_from[neighbor] = current
    42     92.2 MiB -2572151.9 MiB       53244                   g_score[neighbor] = temp_g_score
    43     92.2 MiB -2572152.5 MiB       53244                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.2 MiB -2552765.8 MiB       52826           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.2 MiB -2552765.9 MiB       52826           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.1 MiB      0.0 MiB           1       paths = {}
    53     44.4 MiB      0.0 MiB           8       for goal in goals:
    54     44.4 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.3 MiB   -787.2 MiB         257       for row in grid:
     8    100.3 MiB -201767.8 MiB       65792           for spot in row:
     9    100.3 MiB -200983.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     96.2 MiB     -4.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     96.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     96.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     96.2 MiB      0.0 MiB           1       came_from = {}
    18    101.1 MiB      4.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    101.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    101.1 MiB -1796839.1 MiB       45780       while not open_set.empty():
    22    101.1 MiB -1796840.2 MiB       45780           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    101.1 MiB -1796842.4 MiB       45780           current = open_set.get()[1]
    28                                         
    29    101.1 MiB -1796843.6 MiB       45780           if current in remaining_goals:
    30     92.4 MiB   -299.1 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     92.4 MiB   -238.2 MiB           7               if not remaining_goals:
    32     47.4 MiB    -44.9 MiB           1                   break  # All goals found
    33                                         
    34    101.1 MiB -16104923.1 MiB      410791           for neighbor in current.neighbors:
    35    101.1 MiB -14308151.7 MiB      365012               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    101.1 MiB -14308163.5 MiB      365012               if current.row != neighbor.row and current.col != neighbor.col:
    38    101.1 MiB -7143092.4 MiB      182303                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    101.1 MiB -14308175.7 MiB      365012               if temp_g_score < g_score[neighbor]:
    41    101.1 MiB -1796850.2 MiB       46310                   came_from[neighbor] = current
    42    101.1 MiB -1796851.4 MiB       46310                   g_score[neighbor] = temp_g_score
    43    101.1 MiB -1796854.9 MiB       46310                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    101.1 MiB -1796835.9 MiB       45779           if draw is not None:
    46                                                     draw()
    47                                                     
    48    101.1 MiB -1796836.7 MiB       45779           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     47.4 MiB      0.0 MiB           1       paths = {}
    53     47.7 MiB      0.0 MiB           8       for goal in goals:
    54     47.7 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    101.2 MiB    101.2 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    101.2 MiB   -610.2 MiB         257       for row in grid:
     8    101.2 MiB -156240.6 MiB       65792           for spot in row:
     9    101.2 MiB -155633.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.3 MiB     -4.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.3 MiB      0.0 MiB           1       came_from = {}
    18    101.5 MiB -10333.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    101.0 MiB     -0.5 MiB           1       g_score[start] = 0
    20                                         
    21    101.0 MiB -3564886.2 MiB       56548       while not open_set.empty():
    22    101.0 MiB -3564887.4 MiB       56548           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    101.0 MiB -3564888.9 MiB       56548           current = open_set.get()[1]
    28                                         
    29    101.0 MiB -3564889.4 MiB       56548           if current in remaining_goals:
    30     38.6 MiB   -452.7 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.6 MiB     -5.4 MiB           7               if not remaining_goals:
    32     37.4 MiB     -1.2 MiB           1                   break  # All goals found
    33                                         
    34    101.0 MiB -31968300.5 MiB      506963           for neighbor in current.neighbors:
    35    101.0 MiB -28403808.5 MiB      450416               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    101.0 MiB -28403814.0 MiB      450416               if current.row != neighbor.row and current.col != neighbor.col:
    38    101.0 MiB -14182880.4 MiB      224882                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    101.0 MiB -28403860.1 MiB      450416               if temp_g_score < g_score[neighbor]:
    41    101.0 MiB -3579160.0 MiB       56904                   came_from[neighbor] = current
    42    101.0 MiB -3579160.9 MiB       56904                   g_score[neighbor] = temp_g_score
    43    101.0 MiB -3579162.6 MiB       56904                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    101.0 MiB -3564883.4 MiB       56547           if draw is not None:
    46                                                     draw()
    47                                                     
    48    101.0 MiB -3564884.8 MiB       56547           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.4 MiB      0.0 MiB           1       paths = {}
    53     38.5 MiB      0.0 MiB           8       for goal in goals:
    54     38.5 MiB      1.1 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.5 MiB     98.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.5 MiB   -243.9 MiB         257       for row in grid:
     8     98.5 MiB -62282.5 MiB       65792           for spot in row:
     9     98.5 MiB -62041.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     95.3 MiB     -3.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     95.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     95.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     95.7 MiB      0.0 MiB           1       came_from = {}
    18     98.1 MiB -21428.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.7 MiB     -4.4 MiB           1       g_score[start] = 0
    20                                         
    21     93.8 MiB -4069381.8 MiB       64023       while not open_set.empty():
    22     93.8 MiB -4069405.0 MiB       64023           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.8 MiB -4069409.3 MiB       64023           current = open_set.get()[1]
    28                                         
    29     93.8 MiB -4069414.0 MiB       64023           if current in remaining_goals:
    30     30.4 MiB   -466.8 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.4 MiB    -22.0 MiB           7               if not remaining_goals:
    32     19.5 MiB    -10.9 MiB           1                   break  # All goals found
    33                                         
    34     93.8 MiB -36450189.9 MiB      573584           for neighbor in current.neighbors:
    35     93.8 MiB -32381235.1 MiB      509562               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.8 MiB -32381217.5 MiB      509562               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.8 MiB -16161940.9 MiB      254346                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.8 MiB -32381268.2 MiB      509562               if temp_g_score < g_score[neighbor]:
    41     93.8 MiB -4072854.8 MiB       64171                   came_from[neighbor] = current
    42     93.8 MiB -4072859.0 MiB       64171                   g_score[neighbor] = temp_g_score
    43     93.8 MiB -4072870.6 MiB       64171                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.8 MiB -4069372.8 MiB       64022           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.8 MiB -4069378.1 MiB       64022           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     19.5 MiB      0.0 MiB           1       paths = {}
    53     21.6 MiB      0.0 MiB           8       for goal in goals:
    54     21.6 MiB      2.0 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     21.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.7 MiB     87.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.7 MiB -13782.1 MiB         257       for row in grid:
     8     87.7 MiB -3531490.7 MiB       65792           for spot in row:
     9     87.7 MiB -3517729.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     20.2 MiB    -67.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     20.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     20.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     20.7 MiB      0.0 MiB           1       came_from = {}
    18     32.9 MiB  -4231.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     32.6 MiB     -0.3 MiB           1       g_score[start] = 0
    20                                         
    21     42.6 MiB -758159.6 MiB       64189       while not open_set.empty():
    22     42.6 MiB -758159.8 MiB       64189           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     42.6 MiB -758161.0 MiB       64189           current = open_set.get()[1]
    28                                         
    29     42.6 MiB -758162.4 MiB       64189           if current in remaining_goals:
    30     33.7 MiB   -103.0 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.7 MiB    -57.9 MiB           7               if not remaining_goals:
    32     21.3 MiB    -12.4 MiB           1                   break  # All goals found
    33                                         
    34     42.6 MiB -6785882.3 MiB      575099           for neighbor in current.neighbors:
    35     42.6 MiB -6027785.3 MiB      510911               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     42.6 MiB -6027790.8 MiB      510911               if current.row != neighbor.row and current.col != neighbor.col:
    38     42.6 MiB -3007730.5 MiB      255024                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     42.6 MiB -6027801.8 MiB      510911               if temp_g_score < g_score[neighbor]:
    41     42.6 MiB -754699.1 MiB       64344                   came_from[neighbor] = current
    42     42.6 MiB -754700.4 MiB       64344                   g_score[neighbor] = temp_g_score
    43     42.6 MiB -754701.3 MiB       64344                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     42.6 MiB -758152.6 MiB       64188           if draw is not None:
    46                                                     draw()
    47                                                     
    48     42.6 MiB -758157.8 MiB       64188           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     21.3 MiB      0.0 MiB           1       paths = {}
    53     23.1 MiB      0.0 MiB           8       for goal in goals:
    54     23.1 MiB      1.7 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     23.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.1 MiB     87.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.1 MiB   -678.7 MiB         257       for row in grid:
     8     87.1 MiB -173827.0 MiB       65792           for spot in row:
     9     87.1 MiB -173154.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.5 MiB     -6.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.6 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     80.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     80.8 MiB      0.0 MiB           1       came_from = {}
    18     85.6 MiB -685806.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     28.2 MiB    -57.4 MiB           1       g_score[start] = 0
    20                                         
    21     36.5 MiB -177605.6 MiB       63701       while not open_set.empty():
    22     36.5 MiB -177606.0 MiB       63701           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     36.5 MiB -177608.4 MiB       63701           current = open_set.get()[1]
    28                                         
    29     36.5 MiB -177608.8 MiB       63701           if current in remaining_goals:
    30     36.5 MiB    -28.9 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.5 MiB    -18.1 MiB           7               if not remaining_goals:
    32     24.1 MiB    -12.4 MiB           1                   break  # All goals found
    33                                         
    34     36.5 MiB -1588719.7 MiB      570699           for neighbor in current.neighbors:
    35     36.5 MiB -1411133.7 MiB      506999               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     36.5 MiB -1411126.5 MiB      506999               if current.row != neighbor.row and current.col != neighbor.col:
    38     36.5 MiB -704009.7 MiB      253067                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     36.5 MiB -1411141.4 MiB      506999               if temp_g_score < g_score[neighbor]:
    41     36.5 MiB -177075.4 MiB       63854                   came_from[neighbor] = current
    42     36.5 MiB -177084.0 MiB       63854                   g_score[neighbor] = temp_g_score
    43     36.5 MiB -177084.4 MiB       63854                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     36.5 MiB -177604.3 MiB       63700           if draw is not None:
    46                                                     draw()
    47                                                     
    48     36.5 MiB -177605.2 MiB       63700           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     24.1 MiB      0.0 MiB           1       paths = {}
    53     25.9 MiB      0.1 MiB           8       for goal in goals:
    54     25.9 MiB      1.7 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     25.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.9 MiB     85.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.9 MiB     -8.8 MiB         257       for row in grid:
     8     85.9 MiB  -2234.8 MiB       65792           for spot in row:
     9     85.9 MiB  -2226.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     90.7 MiB  -5607.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.7 MiB -2709621.4 MiB       47063       while not open_set.empty():
    22     90.7 MiB -2709621.6 MiB       47063           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.7 MiB -2709622.7 MiB       47063           current = open_set.get()[1]
    28                                         
    29     90.7 MiB -2709623.0 MiB       47063           if current in remaining_goals:
    30     42.6 MiB   -396.1 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.6 MiB    -22.0 MiB           7               if not remaining_goals:
    32     38.3 MiB     -4.3 MiB           1                   break  # All goals found
    33                                         
    34     90.7 MiB -24297591.3 MiB      422065           for neighbor in current.neighbors:
    35     90.7 MiB -21588314.1 MiB      375003               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.7 MiB -21588302.6 MiB      375003               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.7 MiB -10779468.0 MiB      187253                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.7 MiB -21588308.2 MiB      375003               if temp_g_score < g_score[neighbor]:
    41     90.7 MiB -2728942.8 MiB       47534                   came_from[neighbor] = current
    42     90.7 MiB -2728943.2 MiB       47534                   g_score[neighbor] = temp_g_score
    43     90.7 MiB -2728945.1 MiB       47534                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.7 MiB -2709619.1 MiB       47062           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.7 MiB -2709619.7 MiB       47062           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.3 MiB      0.0 MiB           1       paths = {}
    53     38.6 MiB      0.0 MiB           8       for goal in goals:
    54     38.6 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.9 MiB     84.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.9 MiB    -29.5 MiB         257       for row in grid:
     8     84.9 MiB  -7565.2 MiB       65792           for spot in row:
     9     84.9 MiB  -7535.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.9 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.9 MiB      0.0 MiB           1       came_from = {}
    18     88.7 MiB  -9785.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.7 MiB -3230922.7 MiB       63102       while not open_set.empty():
    22     88.7 MiB -3230923.5 MiB       63102           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.7 MiB -3230924.9 MiB       63102           current = open_set.get()[1]
    28                                         
    29     88.7 MiB -3230925.2 MiB       63102           if current in remaining_goals:
    30     78.5 MiB   -357.6 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     78.5 MiB   -286.2 MiB           7               if not remaining_goals:
    32     28.1 MiB    -50.4 MiB           1                   break  # All goals found
    33                                         
    34     88.7 MiB -28943536.5 MiB      565382           for neighbor in current.neighbors:
    35     88.7 MiB -25712686.6 MiB      502281               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.7 MiB -25712684.5 MiB      502281               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.7 MiB -12834064.5 MiB      250720                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.7 MiB -25712694.8 MiB      502281               if temp_g_score < g_score[neighbor]:
    41     88.7 MiB -3222532.8 MiB       63279                   came_from[neighbor] = current
    42     88.7 MiB -3222533.6 MiB       63279                   g_score[neighbor] = temp_g_score
    43     88.7 MiB -3222575.8 MiB       63279                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.7 MiB -3230920.9 MiB       63101           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.7 MiB -3230921.7 MiB       63101           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     28.1 MiB      0.0 MiB           1       paths = {}
    53     29.1 MiB      0.0 MiB           8       for goal in goals:
    54     29.1 MiB      1.0 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.9 MiB     92.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.9 MiB   -216.7 MiB         257       for row in grid:
     8     92.9 MiB -55050.1 MiB       65792           for spot in row:
     9     92.9 MiB -54838.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.2 MiB     -4.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.2 MiB      0.0 MiB           1       came_from = {}
    18     88.2 MiB -89091.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.4 MiB -2510047.6 MiB       50103       while not open_set.empty():
    22     88.4 MiB -2510048.2 MiB       50103           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.4 MiB -2510050.2 MiB       50103           current = open_set.get()[1]
    28                                         
    29     88.4 MiB -2510050.8 MiB       50103           if current in remaining_goals:
    30     44.7 MiB   -384.3 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.7 MiB     -8.8 MiB           7               if not remaining_goals:
    32     35.9 MiB     -8.8 MiB           1                   break  # All goals found
    33                                         
    34     88.4 MiB -22511368.9 MiB      449285           for neighbor in current.neighbors:
    35     88.4 MiB -20001690.9 MiB      399183               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.4 MiB -20001689.6 MiB      399183               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.4 MiB -9987878.8 MiB      199320                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.4 MiB -20001706.5 MiB      399183               if temp_g_score < g_score[neighbor]:
    41     88.4 MiB -2521408.1 MiB       50534                   came_from[neighbor] = current
    42     88.4 MiB -2521409.3 MiB       50534                   g_score[neighbor] = temp_g_score
    43     88.4 MiB -2521412.4 MiB       50534                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.4 MiB -2510046.0 MiB       50102           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.4 MiB -2510047.0 MiB       50102           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.9 MiB      0.0 MiB           1       paths = {}
    53     36.1 MiB      0.0 MiB           8       for goal in goals:
    54     36.1 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.7 MiB     92.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.7 MiB      0.0 MiB         257       for row in grid:
     8     92.7 MiB      0.0 MiB       65792           for spot in row:
     9     92.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.7 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.7 MiB      0.0 MiB           1       came_from = {}
    18     96.8 MiB -33452.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.1 MiB     -1.8 MiB           1       g_score[start] = 0
    20                                         
    21     95.1 MiB -1622136.7 MiB       29310       while not open_set.empty():
    22     95.1 MiB -1622137.9 MiB       29310           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.1 MiB -1622141.3 MiB       29310           current = open_set.get()[1]
    28                                         
    29     95.1 MiB -1622144.5 MiB       29310           if current in remaining_goals:
    30     95.1 MiB   -238.2 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     95.1 MiB   -238.2 MiB           7               if not remaining_goals:
    32     29.0 MiB    -66.1 MiB           1                   break  # All goals found
    33                                         
    34     95.1 MiB -14554516.8 MiB      262831           for neighbor in current.neighbors:
    35     95.1 MiB -12932397.8 MiB      233522               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.1 MiB -12932404.8 MiB      233522               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.1 MiB -6458889.0 MiB      116603                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.1 MiB -12932422.1 MiB      233522               if temp_g_score < g_score[neighbor]:
    41     95.1 MiB -1638096.2 MiB       29796                   came_from[neighbor] = current
    42     95.1 MiB -1638099.1 MiB       29796                   g_score[neighbor] = temp_g_score
    43     95.1 MiB -1638101.6 MiB       29796                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.1 MiB -1622133.5 MiB       29309           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.1 MiB -1622135.0 MiB       29309           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.0 MiB      0.0 MiB           1       paths = {}
    53     29.1 MiB      0.0 MiB           8       for goal in goals:
    54     29.1 MiB      0.1 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.2 MiB     90.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.2 MiB  -1364.8 MiB         257       for row in grid:
     8     90.2 MiB -349904.3 MiB       65792           for spot in row:
     9     90.2 MiB -348540.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.4 MiB    -10.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.6 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     79.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     79.8 MiB      0.0 MiB           1       came_from = {}
    18     83.3 MiB -41733.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     83.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     84.1 MiB -2030037.5 MiB       42931       while not open_set.empty():
    22     84.1 MiB -2030040.0 MiB       42931           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.1 MiB -2030043.8 MiB       42931           current = open_set.get()[1]
    28                                         
    29     84.1 MiB -2030047.8 MiB       42931           if current in remaining_goals:
    30     37.0 MiB   -368.9 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.0 MiB    -38.1 MiB           7               if not remaining_goals:
    32     28.2 MiB     -8.8 MiB           1                   break  # All goals found
    33                                         
    34     84.1 MiB -18202468.2 MiB      384935           for neighbor in current.neighbors:
    35     84.1 MiB -16172733.9 MiB      342005               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.1 MiB -16172739.9 MiB      342005               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.1 MiB -8075234.0 MiB      170764                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.1 MiB -16172761.2 MiB      342005               if temp_g_score < g_score[neighbor]:
    41     84.1 MiB -2044800.1 MiB       43364                   came_from[neighbor] = current
    42     84.1 MiB -2044802.3 MiB       43364                   g_score[neighbor] = temp_g_score
    43     84.1 MiB -2044805.6 MiB       43364                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.1 MiB -2030033.6 MiB       42930           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.1 MiB -2030035.5 MiB       42930           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     28.2 MiB      0.0 MiB           1       paths = {}
    53     28.8 MiB      0.0 MiB           8       for goal in goals:
    54     28.8 MiB      0.6 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     28.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.9 MiB     88.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.9 MiB  -1313.0 MiB         257       for row in grid:
     8     88.9 MiB -335601.1 MiB       65792           for spot in row:
     9     88.9 MiB -334296.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     76.4 MiB    -12.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     76.6 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     76.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     76.8 MiB      0.0 MiB           1       came_from = {}
    18     78.5 MiB -2619427.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     30.8 MiB    -47.7 MiB           1       g_score[start] = 0
    20                                         
    21     45.0 MiB -240594.3 MiB       56184       while not open_set.empty():
    22     45.0 MiB -240597.4 MiB       56184           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     45.0 MiB -240599.6 MiB       56184           current = open_set.get()[1]
    28                                         
    29     45.0 MiB -240600.1 MiB       56184           if current in remaining_goals:
    30     43.9 MiB    -30.0 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.9 MiB    -23.3 MiB           7               if not remaining_goals:
    32     34.9 MiB     -9.0 MiB           1                   break  # All goals found
    33                                         
    34     45.0 MiB -2155654.8 MiB      503774           for neighbor in current.neighbors:
    35     45.0 MiB -1915085.4 MiB      447591               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     45.0 MiB -1915074.9 MiB      447591               if current.row != neighbor.row and current.col != neighbor.col:
    38     45.0 MiB -955955.9 MiB      223484                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     45.0 MiB -1915082.8 MiB      447591               if temp_g_score < g_score[neighbor]:
    41     45.0 MiB -240503.1 MiB       56561                   came_from[neighbor] = current
    42     45.0 MiB -240505.7 MiB       56561                   g_score[neighbor] = temp_g_score
    43     45.0 MiB -240506.5 MiB       56561                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     45.0 MiB -240591.6 MiB       56183           if draw is not None:
    46                                                     draw()
    47                                                     
    48     45.0 MiB -240591.9 MiB       56183           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.9 MiB      0.0 MiB           1       paths = {}
    53     35.0 MiB      0.0 MiB           8       for goal in goals:
    54     35.0 MiB      0.1 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.0 MiB     88.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.0 MiB    -64.1 MiB         257       for row in grid:
     8     88.0 MiB -16296.7 MiB       65792           for spot in row:
     9     88.0 MiB -16233.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.3 MiB     -1.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.3 MiB      0.0 MiB           1       came_from = {}
    18     89.6 MiB  -7930.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.8 MiB     -0.8 MiB           1       g_score[start] = 0
    20                                         
    21     88.8 MiB -3013365.5 MiB       54311       while not open_set.empty():
    22     88.8 MiB -3013365.9 MiB       54311           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.8 MiB -3013367.1 MiB       54311           current = open_set.get()[1]
    28                                         
    29     88.8 MiB -3013367.4 MiB       54311           if current in remaining_goals:
    30     37.5 MiB   -411.1 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.5 MiB      0.0 MiB           7               if not remaining_goals:
    32     37.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.8 MiB -27018447.0 MiB      487073           for neighbor in current.neighbors:
    35     88.8 MiB -24005446.8 MiB      432763               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.8 MiB -24005433.2 MiB      432763               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.8 MiB -11985977.6 MiB      216096                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.8 MiB -24005447.2 MiB      432763               if temp_g_score < g_score[neighbor]:
    41     88.8 MiB -3026367.8 MiB       54754                   came_from[neighbor] = current
    42     88.8 MiB -3026368.4 MiB       54754                   g_score[neighbor] = temp_g_score
    43     88.8 MiB -3026370.6 MiB       54754                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.8 MiB -3013364.7 MiB       54310           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.8 MiB -3013365.1 MiB       54310           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.5 MiB      0.0 MiB           1       paths = {}
    53     37.8 MiB      0.0 MiB           8       for goal in goals:
    54     37.8 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.5 MiB     87.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.5 MiB    -38.8 MiB         257       for row in grid:
     8     87.5 MiB  -9866.1 MiB       65792           for spot in row:
     9     87.5 MiB  -9828.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.5 MiB     -1.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.5 MiB      0.0 MiB           1       came_from = {}
    18     91.0 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.0 MiB -2658441.6 MiB       52440       while not open_set.empty():
    22     91.0 MiB -2658443.8 MiB       52440           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.0 MiB -2658444.6 MiB       52440           current = open_set.get()[1]
    28                                         
    29     91.0 MiB -2658444.9 MiB       52440           if current in remaining_goals:
    30     89.4 MiB   -374.0 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     89.4 MiB   -362.4 MiB           7               if not remaining_goals:
    32     30.7 MiB    -58.6 MiB           1                   break  # All goals found
    33                                         
    34     91.0 MiB -23852704.9 MiB      470240           for neighbor in current.neighbors:
    35     91.0 MiB -21194315.0 MiB      417801               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.0 MiB -21194313.0 MiB      417801               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.0 MiB -10585093.4 MiB      208616                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.0 MiB -21194336.4 MiB      417801               if temp_g_score < g_score[neighbor]:
    41     91.0 MiB -2671759.8 MiB       52869                   came_from[neighbor] = current
    42     91.0 MiB -2671760.2 MiB       52869                   g_score[neighbor] = temp_g_score
    43     91.0 MiB -2671761.8 MiB       52869                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.0 MiB -2658440.0 MiB       52439           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.0 MiB -2658440.3 MiB       52439           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.7 MiB      0.0 MiB           1       paths = {}
    53     31.8 MiB      0.0 MiB           8       for goal in goals:
    54     31.8 MiB      1.0 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.5 MiB     85.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.5 MiB   -291.1 MiB         257       for row in grid:
     8     85.5 MiB -74275.3 MiB       65792           for spot in row:
     9     85.5 MiB -73985.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.3 MiB     -3.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.3 MiB      0.0 MiB           1       came_from = {}
    18     88.1 MiB     -4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.2 MiB -2910875.9 MiB       59845       while not open_set.empty():
    22     88.2 MiB -2910877.3 MiB       59845           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.2 MiB -2910882.0 MiB       59845           current = open_set.get()[1]
    28                                         
    29     88.2 MiB -2910883.3 MiB       59845           if current in remaining_goals:
    30     86.5 MiB   -322.9 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     86.5 MiB   -311.1 MiB           7               if not remaining_goals:
    32     29.9 MiB    -56.6 MiB           1                   break  # All goals found
    33                                         
    34     88.2 MiB -26092800.3 MiB      536665           for neighbor in current.neighbors:
    35     88.2 MiB -23181953.7 MiB      476821               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.2 MiB -23181954.2 MiB      476821               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.2 MiB -11573556.8 MiB      238089                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.2 MiB -23181973.0 MiB      476821               if temp_g_score < g_score[neighbor]:
    41     88.2 MiB -2911710.3 MiB       60220                   came_from[neighbor] = current
    42     88.2 MiB -2911711.3 MiB       60220                   g_score[neighbor] = temp_g_score
    43     88.2 MiB -2911715.5 MiB       60220                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.2 MiB -2910872.4 MiB       59844           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.2 MiB -2910874.0 MiB       59844           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.9 MiB      0.0 MiB           1       paths = {}
    53     30.8 MiB      0.0 MiB           8       for goal in goals:
    54     30.8 MiB      0.9 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     83.4 MiB     83.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     83.4 MiB  -1211.2 MiB         257       for row in grid:
     8     83.4 MiB -310843.1 MiB       65792           for spot in row:
     9     83.4 MiB -309635.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     77.9 MiB     -5.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     78.1 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     78.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     78.3 MiB      0.0 MiB           1       came_from = {}
    18     83.7 MiB      5.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     83.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     84.2 MiB -2915369.2 MiB       60327       while not open_set.empty():
    22     84.2 MiB -2915369.6 MiB       60327           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.2 MiB -2915370.7 MiB       60327           current = open_set.get()[1]
    28                                         
    29     84.2 MiB -2915371.0 MiB       60327           if current in remaining_goals:
    30     84.2 MiB   -323.6 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     84.2 MiB   -323.3 MiB           7               if not remaining_goals:
    32     25.8 MiB    -58.3 MiB           1                   break  # All goals found
    33                                         
    34     84.2 MiB -26131702.4 MiB      540734           for neighbor in current.neighbors:
    35     84.2 MiB -23216356.3 MiB      480408               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.2 MiB -23216385.9 MiB      480408               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.2 MiB -11590599.2 MiB      239838                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.2 MiB -23216392.4 MiB      480408               if temp_g_score < g_score[neighbor]:
    41     84.2 MiB -2916102.4 MiB       60613                   came_from[neighbor] = current
    42     84.2 MiB -2916105.5 MiB       60613                   g_score[neighbor] = temp_g_score
    43     84.2 MiB -2916106.6 MiB       60613                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.2 MiB -2915367.7 MiB       60326           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.2 MiB -2915368.3 MiB       60326           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     25.8 MiB      0.0 MiB           1       paths = {}
    53     27.0 MiB      0.1 MiB           8       for goal in goals:
    54     27.0 MiB      1.1 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.6 MiB     85.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.6 MiB   -820.7 MiB         257       for row in grid:
     8     85.6 MiB -210332.5 MiB       65792           for spot in row:
     9     85.6 MiB -209516.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.3 MiB     -6.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     79.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     79.7 MiB      0.0 MiB           1       came_from = {}
    18     84.1 MiB  -2282.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     84.2 MiB -2020909.8 MiB       41049       while not open_set.empty():
    22     84.2 MiB -2020910.1 MiB       41049           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.2 MiB -2020911.0 MiB       41049           current = open_set.get()[1]
    28                                         
    29     84.2 MiB -2020911.1 MiB       41049           if current in remaining_goals:
    30     44.5 MiB   -351.5 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.5 MiB    -52.2 MiB           7               if not remaining_goals:
    32     33.9 MiB    -10.6 MiB           1                   break  # All goals found
    33                                         
    34     84.2 MiB -18120561.2 MiB      367967           for neighbor in current.neighbors:
    35     84.2 MiB -16099920.9 MiB      326919               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.2 MiB -16099940.9 MiB      326919               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.2 MiB -8038872.5 MiB      163216                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.2 MiB -16099983.0 MiB      326919               if temp_g_score < g_score[neighbor]:
    41     84.2 MiB -2035514.7 MiB       41446                   came_from[neighbor] = current
    42     84.2 MiB -2035515.3 MiB       41446                   g_score[neighbor] = temp_g_score
    43     84.2 MiB -2035516.0 MiB       41446                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.2 MiB -2020909.2 MiB       41048           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.2 MiB -2020909.4 MiB       41048           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.9 MiB      0.0 MiB           1       paths = {}
    53     34.1 MiB      0.0 MiB           8       for goal in goals:
    54     34.1 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.3 MiB     91.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.3 MiB    -86.0 MiB         257       for row in grid:
     8     91.3 MiB -21846.6 MiB       65792           for spot in row:
     9     91.3 MiB -21761.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.9 MiB     -1.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.9 MiB      0.0 MiB           1       came_from = {}
    18     91.9 MiB -36364.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.4 MiB     -0.5 MiB           1       g_score[start] = 0
    20                                         
    21     91.8 MiB -2726525.1 MiB       53512       while not open_set.empty():
    22     91.8 MiB -2726526.3 MiB       53512           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.8 MiB -2726527.8 MiB       53512           current = open_set.get()[1]
    28                                         
    29     91.8 MiB -2726530.3 MiB       53512           if current in remaining_goals:
    30     83.0 MiB   -367.7 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     83.0 MiB   -306.5 MiB           7               if not remaining_goals:
    32     33.2 MiB    -49.8 MiB           1                   break  # All goals found
    33                                         
    34     91.8 MiB -24438180.8 MiB      479822           for neighbor in current.neighbors:
    35     91.8 MiB -21711741.1 MiB      426311               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.8 MiB -21711739.8 MiB      426311               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.8 MiB -10839274.6 MiB      212860                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.8 MiB -21711758.1 MiB      426311               if temp_g_score < g_score[neighbor]:
    41     91.8 MiB -2727455.4 MiB       53903                   came_from[neighbor] = current
    42     91.8 MiB -2727462.9 MiB       53903                   g_score[neighbor] = temp_g_score
    43     91.8 MiB -2727468.2 MiB       53903                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.8 MiB -2726523.0 MiB       53511           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.8 MiB -2726524.1 MiB       53511           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.2 MiB      0.0 MiB           1       paths = {}
    53     33.4 MiB      0.0 MiB           8       for goal in goals:
    54     33.4 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.7 MiB     90.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.7 MiB   -792.5 MiB         257       for row in grid:
     8     90.7 MiB -203030.5 MiB       65792           for spot in row:
     9     90.7 MiB -202241.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.4 MiB     -5.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     90.9 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.9 MiB -3535887.5 MiB       61657       while not open_set.empty():
    22     90.9 MiB -3535889.4 MiB       61657           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.9 MiB -3535903.4 MiB       61657           current = open_set.get()[1]
    28                                         
    29     90.9 MiB -3535905.5 MiB       61657           if current in remaining_goals:
    30     35.3 MiB   -419.7 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.3 MiB     -6.1 MiB           7               if not remaining_goals:
    32     32.5 MiB     -2.8 MiB           1                   break  # All goals found
    33                                         
    34     90.9 MiB -31696245.8 MiB      552698           for neighbor in current.neighbors:
    35     90.9 MiB -28160734.4 MiB      491042               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.9 MiB -28160741.5 MiB      491042               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.9 MiB -14059427.6 MiB      245154                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.9 MiB -28160765.5 MiB      491042               if temp_g_score < g_score[neighbor]:
    41     90.9 MiB -3541950.1 MiB       61941                   came_from[neighbor] = current
    42     90.9 MiB -3541951.3 MiB       61941                   g_score[neighbor] = temp_g_score
    43     90.9 MiB -3541954.2 MiB       61941                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.9 MiB -3535882.4 MiB       61656           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.9 MiB -3535883.2 MiB       61656           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.5 MiB      0.0 MiB           1       paths = {}
    53     33.1 MiB      0.0 MiB           8       for goal in goals:
    54     33.1 MiB      0.5 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.8 MiB   -647.5 MiB         257       for row in grid:
     8     88.8 MiB -165955.5 MiB       65792           for spot in row:
     9     88.8 MiB -165309.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.2 MiB     -2.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.3 MiB      0.0 MiB           1       came_from = {}
    18     91.5 MiB      5.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.1 MiB -3265757.1 MiB       60279       while not open_set.empty():
    22     92.1 MiB -3265758.2 MiB       60279           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.1 MiB -3265762.1 MiB       60279           current = open_set.get()[1]
    28                                         
    29     92.1 MiB -3265764.8 MiB       60279           if current in remaining_goals:
    30     37.3 MiB   -404.0 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.3 MiB      0.0 MiB           7               if not remaining_goals:
    32     37.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.1 MiB -29280162.6 MiB      540260           for neighbor in current.neighbors:
    35     92.1 MiB -26014774.3 MiB      479982               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.1 MiB -26014770.5 MiB      479982               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.1 MiB -12988977.9 MiB      239618                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.1 MiB -26014787.0 MiB      479982               if temp_g_score < g_score[neighbor]:
    41     92.1 MiB -3267624.5 MiB       60551                   came_from[neighbor] = current
    42     92.1 MiB -3267626.5 MiB       60551                   g_score[neighbor] = temp_g_score
    43     92.1 MiB -3267629.2 MiB       60551                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.1 MiB -3265754.4 MiB       60278           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.1 MiB -3265755.9 MiB       60278           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.3 MiB      0.0 MiB           1       paths = {}
    53     37.6 MiB      0.0 MiB           8       for goal in goals:
    54     37.6 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.1 MiB     87.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.1 MiB   -542.8 MiB         257       for row in grid:
     8     87.1 MiB -138252.5 MiB       65792           for spot in row:
     9     87.1 MiB -137717.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     78.2 MiB     -8.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     78.4 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     78.6 MiB      0.2 MiB           1       open_set.put((0, start))
    17     78.6 MiB      0.0 MiB           1       came_from = {}
    18     83.0 MiB -18645.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     82.2 MiB     -0.8 MiB           1       g_score[start] = 0
    20                                         
    21     82.9 MiB -1873055.0 MiB       53495       while not open_set.empty():
    22     82.9 MiB -1873056.2 MiB       53495           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     82.9 MiB -1873058.9 MiB       53495           current = open_set.get()[1]
    28                                         
    29     82.9 MiB -1873062.6 MiB       53495           if current in remaining_goals:
    30     82.4 MiB   -211.2 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     82.4 MiB   -208.1 MiB           7               if not remaining_goals:
    32     34.0 MiB    -48.4 MiB           1                   break  # All goals found
    33                                         
    34     82.9 MiB -16791215.5 MiB      480019           for neighbor in current.neighbors:
    35     82.9 MiB -14918178.0 MiB      426525               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     82.9 MiB -14918184.3 MiB      426525               if current.row != neighbor.row and current.col != neighbor.col:
    38     82.9 MiB -7448152.1 MiB      213025                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     82.9 MiB -14918198.0 MiB      426525               if temp_g_score < g_score[neighbor]:
    41     82.9 MiB -1872602.2 MiB       54014                   came_from[neighbor] = current
    42     82.9 MiB -1872603.2 MiB       54014                   g_score[neighbor] = temp_g_score
    43     82.9 MiB -1872606.7 MiB       54014                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     82.9 MiB -1873052.6 MiB       53494           if draw is not None:
    46                                                     draw()
    47                                                     
    48     82.9 MiB -1873053.8 MiB       53494           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.0 MiB      0.0 MiB           1       paths = {}
    53     34.2 MiB      0.0 MiB           8       for goal in goals:
    54     34.2 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.9 MiB     86.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.9 MiB   -792.9 MiB         257       for row in grid:
     8     86.9 MiB -203291.8 MiB       65792           for spot in row:
     9     86.9 MiB -202502.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.1 MiB     -7.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     79.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     79.5 MiB      0.0 MiB           1       came_from = {}
    18     80.3 MiB -2583986.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     31.0 MiB    -49.3 MiB           1       g_score[start] = 0
    20                                         
    21     38.6 MiB -240855.1 MiB       49622       while not open_set.empty():
    22     38.6 MiB -240856.2 MiB       49622           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     38.6 MiB -240856.8 MiB       49622           current = open_set.get()[1]
    28                                         
    29     38.6 MiB -240857.2 MiB       49622           if current in remaining_goals:
    30     36.4 MiB    -21.9 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.4 MiB    -11.5 MiB           7               if not remaining_goals:
    32     36.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     38.6 MiB -2158985.8 MiB      444989           for neighbor in current.neighbors:
    35     38.6 MiB -1918744.3 MiB      395368               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     38.6 MiB -1918735.9 MiB      395368               if current.row != neighbor.row and current.col != neighbor.col:
    38     38.6 MiB -958041.2 MiB      197418                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     38.6 MiB -1918754.2 MiB      395368               if temp_g_score < g_score[neighbor]:
    41     38.6 MiB -241776.7 MiB       50054                   came_from[neighbor] = current
    42     38.6 MiB -241171.9 MiB       50054                   g_score[neighbor] = temp_g_score
    43     38.6 MiB -241172.5 MiB       50054                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     38.6 MiB -240853.2 MiB       49621           if draw is not None:
    46                                                     draw()
    47                                                     
    48     38.6 MiB -240854.6 MiB       49621           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.4 MiB      0.0 MiB           1       paths = {}
    53     36.8 MiB      0.0 MiB           8       for goal in goals:
    54     36.8 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.8 MiB     87.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.8 MiB  -1321.6 MiB         257       for row in grid:
     8     87.8 MiB -338271.3 MiB       65792           for spot in row:
     9     87.8 MiB -336958.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     75.9 MiB    -11.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     76.1 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     76.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     76.3 MiB      0.0 MiB           1       came_from = {}
    18     81.4 MiB -36089.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     79.4 MiB     -2.0 MiB           1       g_score[start] = 0
    20                                         
    21     79.6 MiB -2511239.4 MiB       55639       while not open_set.empty():
    22     79.6 MiB -2511240.2 MiB       55639           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     79.6 MiB -2511242.0 MiB       55639           current = open_set.get()[1]
    28                                         
    29     79.6 MiB -2511243.2 MiB       55639           if current in remaining_goals:
    30     45.8 MiB   -272.4 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.8 MiB     -8.1 MiB           7               if not remaining_goals:
    32     38.0 MiB     -7.8 MiB           1                   break  # All goals found
    33                                         
    34     79.6 MiB -22512704.5 MiB      498887           for neighbor in current.neighbors:
    35     79.6 MiB -20001716.8 MiB      443249               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     79.6 MiB -20001716.0 MiB      443249               if current.row != neighbor.row and current.col != neighbor.col:
    38     79.6 MiB -9986290.2 MiB      221316                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     79.6 MiB -20001740.0 MiB      443249               if temp_g_score < g_score[neighbor]:
    41     79.6 MiB -2528002.4 MiB       56040                   came_from[neighbor] = current
    42     79.6 MiB -2528004.7 MiB       56040                   g_score[neighbor] = temp_g_score
    43     79.6 MiB -2528007.4 MiB       56040                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     79.6 MiB -2511235.9 MiB       55638           if draw is not None:
    46                                                     draw()
    47                                                     
    48     79.6 MiB -2511238.2 MiB       55638           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.0 MiB      0.0 MiB           1       paths = {}
    53     38.2 MiB      0.0 MiB           8       for goal in goals:
    54     38.2 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.7 MiB     86.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.7 MiB    -21.9 MiB         257       for row in grid:
     8     86.7 MiB  -5595.2 MiB       65792           for spot in row:
     9     86.7 MiB  -5573.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.4 MiB     -0.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.4 MiB      0.0 MiB           1       came_from = {}
    18     91.7 MiB  -1612.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.9 MiB -2432518.8 MiB       56878       while not open_set.empty():
    22     91.9 MiB -2432520.2 MiB       56878           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.9 MiB -2432524.8 MiB       56878           current = open_set.get()[1]
    28                                         
    29     91.9 MiB -2432526.4 MiB       56878           if current in remaining_goals:
    30     78.5 MiB   -321.1 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     78.5 MiB   -227.0 MiB           7               if not remaining_goals:
    32     33.5 MiB    -45.0 MiB           1                   break  # All goals found
    33                                         
    34     91.9 MiB -21814989.0 MiB      510083           for neighbor in current.neighbors:
    35     91.9 MiB -19382578.2 MiB      453206               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.9 MiB -19382580.4 MiB      453206               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.9 MiB -9678495.2 MiB      226302                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.9 MiB -19382597.3 MiB      453206               if temp_g_score < g_score[neighbor]:
    41     91.9 MiB -2434703.5 MiB       57294                   came_from[neighbor] = current
    42     91.9 MiB -2434704.8 MiB       57294                   g_score[neighbor] = temp_g_score
    43     91.9 MiB -2434707.1 MiB       57294                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.9 MiB -2432512.8 MiB       56877           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.9 MiB -2432515.0 MiB       56877           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.5 MiB      0.0 MiB           1       paths = {}
    53     34.1 MiB      0.0 MiB           8       for goal in goals:
    54     34.1 MiB      0.6 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.1 MiB     86.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.1 MiB   -196.0 MiB         257       for row in grid:
     8     86.1 MiB -50273.5 MiB       65792           for spot in row:
     9     86.1 MiB -50078.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.2 MiB     -0.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.2 MiB      0.0 MiB           1       came_from = {}
    18     90.8 MiB   -520.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.9 MiB -2797214.4 MiB       63744       while not open_set.empty():
    22     90.9 MiB -2797215.4 MiB       63744           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.9 MiB -2797218.0 MiB       63744           current = open_set.get()[1]
    28                                         
    29     90.9 MiB -2797219.3 MiB       63744           if current in remaining_goals:
    30     85.1 MiB   -297.5 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     85.1 MiB   -257.0 MiB           7               if not remaining_goals:
    32     40.2 MiB    -44.9 MiB           1                   break  # All goals found
    33                                         
    34     90.9 MiB -25039964.2 MiB      571106           for neighbor in current.neighbors:
    35     90.9 MiB -22242798.7 MiB      507363               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.9 MiB -22242798.9 MiB      507363               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.9 MiB -11099046.2 MiB      253252                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.9 MiB -22242826.9 MiB      507363               if temp_g_score < g_score[neighbor]:
    41     90.9 MiB -2780355.5 MiB       63903                   came_from[neighbor] = current
    42     90.9 MiB -2780357.1 MiB       63903                   g_score[neighbor] = temp_g_score
    43     90.9 MiB -2780360.1 MiB       63903                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.9 MiB -2797211.7 MiB       63743           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.9 MiB -2797213.2 MiB       63743           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.2 MiB      0.0 MiB           1       paths = {}
    53     40.4 MiB      0.0 MiB           8       for goal in goals:
    54     40.4 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.1 MiB     94.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.1 MiB   -139.0 MiB         257       for row in grid:
     8     94.1 MiB -35589.1 MiB       65792           for spot in row:
     9     94.1 MiB -35451.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.9 MiB     -1.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.9 MiB      0.0 MiB           1       came_from = {}
    18     97.2 MiB   -247.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.2 MiB -2044862.2 MiB       47339       while not open_set.empty():
    22     97.2 MiB -2044862.4 MiB       47339           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.2 MiB -2044863.4 MiB       47339           current = open_set.get()[1]
    28                                         
    29     97.2 MiB -2044863.8 MiB       47339           if current in remaining_goals:
    30     42.9 MiB   -410.3 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.9 MiB    -15.6 MiB           7               if not remaining_goals:
    32     35.5 MiB     -7.4 MiB           1                   break  # All goals found
    33                                         
    34     97.2 MiB -18335965.4 MiB      424825           for neighbor in current.neighbors:
    35     97.2 MiB -16291498.7 MiB      377487               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.2 MiB -16291500.6 MiB      377487               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.2 MiB -8134675.9 MiB      188541                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.2 MiB -16291509.4 MiB      377487               if temp_g_score < g_score[neighbor]:
    41     97.2 MiB -2049542.5 MiB       47888                   came_from[neighbor] = current
    42     97.2 MiB -2049543.0 MiB       47888                   g_score[neighbor] = temp_g_score
    43     97.2 MiB -2049544.7 MiB       47888                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.2 MiB -2044859.9 MiB       47338           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.2 MiB -2044860.2 MiB       47338           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.5 MiB      0.0 MiB           1       paths = {}
    53     35.7 MiB      0.0 MiB           8       for goal in goals:
    54     35.7 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.0 MiB     93.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.0 MiB   -159.0 MiB         257       for row in grid:
     8     93.0 MiB -39798.7 MiB       65792           for spot in row:
     9     93.0 MiB -39643.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.9 MiB     -6.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.0 MiB      0.0 MiB           1       came_from = {}
    18     91.5 MiB  -3449.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.5 MiB -1933409.9 MiB       48770       while not open_set.empty():
    22     91.5 MiB -1933411.6 MiB       48770           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.5 MiB -1933420.1 MiB       48770           current = open_set.get()[1]
    28                                         
    29     91.5 MiB -1933421.3 MiB       48770           if current in remaining_goals:
    30     91.5 MiB   -217.3 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     91.5 MiB   -217.3 MiB           7               if not remaining_goals:
    32     40.4 MiB    -51.1 MiB           1                   break  # All goals found
    33                                         
    34     91.5 MiB -17339555.5 MiB      437662           for neighbor in current.neighbors:
    35     91.5 MiB -15406161.7 MiB      388893               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.5 MiB -15406171.6 MiB      388893               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.5 MiB -7692995.2 MiB      194237                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.5 MiB -15406187.9 MiB      388893               if temp_g_score < g_score[neighbor]:
    41     91.5 MiB -1938892.6 MiB       49319                   came_from[neighbor] = current
    42     91.5 MiB -1938894.0 MiB       49319                   g_score[neighbor] = temp_g_score
    43     91.5 MiB -1938895.8 MiB       49319                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.5 MiB -1933407.5 MiB       48769           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.5 MiB -1933408.6 MiB       48769           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.4 MiB      0.0 MiB           1       paths = {}
    53     40.7 MiB      0.0 MiB           8       for goal in goals:
    54     40.7 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.0 MiB     92.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.0 MiB   -192.5 MiB         257       for row in grid:
     8     92.0 MiB -49283.7 MiB       65792           for spot in row:
     9     92.0 MiB -49093.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.3 MiB     -1.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.3 MiB      0.0 MiB           1       came_from = {}
    18     96.7 MiB  -2314.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.1 MiB     -9.5 MiB           1       g_score[start] = 0
    20                                         
    21     87.1 MiB -3334397.3 MiB       62309       while not open_set.empty():
    22     87.1 MiB -3359713.2 MiB       62309           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.1 MiB -3359715.4 MiB       62309           current = open_set.get()[1]
    28                                         
    29     87.1 MiB -3359727.7 MiB       62309           if current in remaining_goals:
    30     38.9 MiB   -390.4 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.9 MiB     -0.6 MiB           7               if not remaining_goals:
    32     38.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.1 MiB -30017190.3 MiB      558330           for neighbor in current.neighbors:
    35     87.1 MiB -26745053.2 MiB      496022               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.0 MiB -26745047.7 MiB      496022               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.7 MiB -13331175.7 MiB      247605                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.0 MiB -26625061.7 MiB      496022               if temp_g_score < g_score[neighbor]:
    41     86.9 MiB -3355922.4 MiB       62515                   came_from[neighbor] = current
    42     86.9 MiB -3354946.9 MiB       62515                   g_score[neighbor] = temp_g_score
    43     86.9 MiB -3354949.1 MiB       62515                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.7 MiB -3359702.5 MiB       62308           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.7 MiB -3334393.1 MiB       62308           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.9 MiB      0.0 MiB           1       paths = {}
    53     39.1 MiB      0.0 MiB           8       for goal in goals:
    54     39.1 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     39.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.2 MiB     89.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.2 MiB     -6.9 MiB         257       for row in grid:
     8     89.2 MiB  -1777.4 MiB       65792           for spot in row:
     9     89.2 MiB  -1770.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.2 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.2 MiB      0.0 MiB           1       came_from = {}
    18     92.3 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.3 MiB -2973192.0 MiB       63081       while not open_set.empty():
    22     92.3 MiB -2973193.8 MiB       63081           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.3 MiB -2973197.1 MiB       63081           current = open_set.get()[1]
    28                                         
    29     92.3 MiB -2973199.7 MiB       63081           if current in remaining_goals:
    30     43.2 MiB   -373.8 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.2 MiB    -28.5 MiB           7               if not remaining_goals:
    32     37.9 MiB     -5.2 MiB           1                   break  # All goals found
    33                                         
    34     92.3 MiB -26638010.4 MiB      565295           for neighbor in current.neighbors:
    35     92.3 MiB -23665136.2 MiB      502215               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.3 MiB -23665141.2 MiB      502215               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.3 MiB -11812619.1 MiB      250704                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.3 MiB -23665163.9 MiB      502215               if temp_g_score < g_score[neighbor]:
    41     92.3 MiB -2965364.1 MiB       63292                   came_from[neighbor] = current
    42     92.3 MiB -2965366.1 MiB       63292                   g_score[neighbor] = temp_g_score
    43     92.3 MiB -2965368.0 MiB       63292                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.3 MiB -2973187.7 MiB       63080           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.3 MiB -2973189.8 MiB       63080           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.9 MiB      0.0 MiB           1       paths = {}
    53     38.3 MiB      0.0 MiB           8       for goal in goals:
    54     38.3 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.2 MiB     88.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.2 MiB   -179.1 MiB         257       for row in grid:
     8     88.2 MiB -45911.7 MiB       65792           for spot in row:
     9     88.2 MiB -45733.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.8 MiB     -1.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.8 MiB      0.0 MiB           1       came_from = {}
    18     89.1 MiB -129566.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     83.6 MiB     -5.5 MiB           1       g_score[start] = 0
    20                                         
    21     84.2 MiB -1894279.8 MiB       40595       while not open_set.empty():
    22     84.2 MiB -1894280.3 MiB       40595           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.2 MiB -1894284.0 MiB       40595           current = open_set.get()[1]
    28                                         
    29     84.2 MiB -1894285.3 MiB       40595           if current in remaining_goals:
    30     78.1 MiB   -341.4 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     78.1 MiB   -298.5 MiB           7               if not remaining_goals:
    32     36.4 MiB    -41.7 MiB           1                   break  # All goals found
    33                                         
    34     84.2 MiB -17000300.8 MiB      364018           for neighbor in current.neighbors:
    35     84.2 MiB -15106062.6 MiB      323424               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.2 MiB -15106068.3 MiB      323424               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.2 MiB -7545103.2 MiB      161491                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.2 MiB -15106108.7 MiB      323424               if temp_g_score < g_score[neighbor]:
    41     84.2 MiB -1909807.4 MiB       41073                   came_from[neighbor] = current
    42     84.2 MiB -1909808.0 MiB       41073                   g_score[neighbor] = temp_g_score
    43     84.2 MiB -1909808.0 MiB       41073                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.2 MiB -1894279.0 MiB       40594           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.2 MiB -1894279.4 MiB       40594           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.4 MiB      0.0 MiB           1       paths = {}
    53     36.7 MiB      0.0 MiB           8       for goal in goals:
    54     36.7 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.4 MiB    -19.0 MiB         257       for row in grid:
     8     86.4 MiB  -4865.8 MiB       65792           for spot in row:
     9     86.4 MiB  -4847.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.2 MiB     -0.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.2 MiB      0.0 MiB           1       came_from = {}
    18     86.9 MiB -420710.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     73.6 MiB    -13.3 MiB           1       g_score[start] = 0
    20                                         
    21     73.8 MiB -1953813.9 MiB       56987       while not open_set.empty():
    22     73.8 MiB -1953814.8 MiB       56987           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     73.8 MiB -1953823.8 MiB       56987           current = open_set.get()[1]
    28                                         
    29     73.8 MiB -1953824.6 MiB       56987           if current in remaining_goals:
    30     46.9 MiB   -249.6 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     46.9 MiB    -21.9 MiB           7               if not remaining_goals:
    32     38.1 MiB     -8.8 MiB           1                   break  # All goals found
    33                                         
    34     73.8 MiB -17519185.1 MiB      510926           for neighbor in current.neighbors:
    35     73.8 MiB -15565582.0 MiB      453940               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     73.8 MiB -15565578.1 MiB      453940               if current.row != neighbor.row and current.col != neighbor.col:
    38     73.8 MiB -7772081.8 MiB      226646                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     73.8 MiB -15565609.4 MiB      453940               if temp_g_score < g_score[neighbor]:
    41     73.8 MiB -1967725.1 MiB       57343                   came_from[neighbor] = current
    42     73.8 MiB -1967726.2 MiB       57343                   g_score[neighbor] = temp_g_score
    43     73.8 MiB -1967728.5 MiB       57343                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     73.8 MiB -1953811.7 MiB       56986           if draw is not None:
    46                                                     draw()
    47                                                     
    48     73.8 MiB -1953812.2 MiB       56986           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.1 MiB      0.0 MiB           1       paths = {}
    53     38.3 MiB      0.0 MiB           8       for goal in goals:
    54     38.3 MiB      0.1 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.3 MiB     87.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.3 MiB      0.0 MiB         257       for row in grid:
     8     87.3 MiB      0.0 MiB       65792           for spot in row:
     9     87.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.3 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.3 MiB      0.0 MiB           1       came_from = {}
    18     92.5 MiB      5.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.5 MiB -1676088.6 MiB       64433       while not open_set.empty():
    22     92.5 MiB -1676090.9 MiB       64433           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.5 MiB -1676093.5 MiB       64433           current = open_set.get()[1]
    28                                         
    29     92.5 MiB -1676094.7 MiB       64433           if current in remaining_goals:
    30     85.8 MiB   -257.7 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     85.8 MiB   -210.3 MiB           7               if not remaining_goals:
    32     18.0 MiB    -67.8 MiB           1                   break  # All goals found
    33                                         
    34     92.5 MiB -15001739.1 MiB      577128           for neighbor in current.neighbors:
    35     92.5 MiB -13325709.1 MiB      512696               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.5 MiB -13325717.2 MiB      512696               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.5 MiB -6649191.6 MiB      255889                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.5 MiB -13325735.9 MiB      512696               if temp_g_score < g_score[neighbor]:
    41     92.5 MiB -1659690.5 MiB       64533                   came_from[neighbor] = current
    42     92.5 MiB -1659704.2 MiB       64533                   g_score[neighbor] = temp_g_score
    43     92.5 MiB -1659709.3 MiB       64533                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.5 MiB -1676086.2 MiB       64432           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.5 MiB -1676087.6 MiB       64432           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     18.0 MiB      0.0 MiB           1       paths = {}
    53     20.9 MiB      0.0 MiB           8       for goal in goals:
    54     20.9 MiB      2.9 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     20.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.0 MiB     86.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.0 MiB      0.0 MiB         257       for row in grid:
     8     86.0 MiB      0.0 MiB       65792           for spot in row:
     9     86.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.0 MiB      0.0 MiB           1       came_from = {}
    18     90.6 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.6 MiB -3018771.2 MiB       64800       while not open_set.empty():
    22     90.6 MiB -3018771.5 MiB       64800           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.6 MiB -3018773.0 MiB       64800           current = open_set.get()[1]
    28                                         
    29     90.6 MiB -3018773.7 MiB       64800           if current in remaining_goals:
    30     44.9 MiB   -376.7 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.9 MiB    -26.3 MiB           7               if not remaining_goals:
    32     36.3 MiB     -8.5 MiB           1                   break  # All goals found
    33                                         
    34     90.6 MiB -27031886.2 MiB      580371           for neighbor in current.neighbors:
    35     90.6 MiB -24013429.2 MiB      515572               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.6 MiB -24013427.1 MiB      515572               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.6 MiB -11984060.0 MiB      257317                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.6 MiB -24013433.3 MiB      515572               if temp_g_score < g_score[neighbor]:
    41     90.6 MiB -3005929.4 MiB       64880                   came_from[neighbor] = current
    42     90.6 MiB -3005929.8 MiB       64880                   g_score[neighbor] = temp_g_score
    43     90.6 MiB -3005985.2 MiB       64880                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.6 MiB -3018769.5 MiB       64799           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.6 MiB -3018770.2 MiB       64799           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.3 MiB      0.0 MiB           1       paths = {}
    53     36.6 MiB      0.0 MiB           8       for goal in goals:
    54     36.6 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.7 MiB     85.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.7 MiB   -240.2 MiB         257       for row in grid:
     8     85.7 MiB -61434.5 MiB       65792           for spot in row:
     9     85.7 MiB -61195.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.5 MiB     -1.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.5 MiB      0.0 MiB           1       came_from = {}
    18     89.8 MiB      5.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.0 MiB -1168779.6 MiB       44418       while not open_set.empty():
    22     90.0 MiB -1168780.5 MiB       44418           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.0 MiB -1168785.0 MiB       44418           current = open_set.get()[1]
    28                                         
    29     90.0 MiB -1168789.5 MiB       44418           if current in remaining_goals:
    30     90.0 MiB   -184.1 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.0 MiB   -184.1 MiB           7               if not remaining_goals:
    32     44.2 MiB    -45.8 MiB           1                   break  # All goals found
    33                                         
    34     90.0 MiB -10487078.3 MiB      398521           for neighbor in current.neighbors:
    35     90.0 MiB -9318308.7 MiB      354104               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.0 MiB -9318312.1 MiB      354104               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.0 MiB -4653933.3 MiB      176847                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.0 MiB -9318326.7 MiB      354104               if temp_g_score < g_score[neighbor]:
    41     90.0 MiB -1172736.4 MiB       44940                   came_from[neighbor] = current
    42     90.0 MiB -1172737.7 MiB       44940                   g_score[neighbor] = temp_g_score
    43     90.0 MiB -1172739.0 MiB       44940                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.0 MiB -1168778.0 MiB       44417           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.0 MiB -1168778.7 MiB       44417           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.2 MiB      0.0 MiB           1       paths = {}
    53     44.4 MiB      0.0 MiB           8       for goal in goals:
    54     44.4 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     95.0 MiB     95.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     95.0 MiB   -116.5 MiB         257       for row in grid:
     8     95.0 MiB -29897.0 MiB       65792           for spot in row:
     9     95.0 MiB -29781.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.3 MiB     -1.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.3 MiB      0.0 MiB           1       came_from = {}
    18     95.8 MiB -44490.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.7 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     95.9 MiB -1937000.6 MiB       60914       while not open_set.empty():
    22     95.9 MiB -1937001.3 MiB       60914           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.9 MiB -1937003.0 MiB       60914           current = open_set.get()[1]
    28                                         
    29     95.9 MiB -1937003.9 MiB       60914           if current in remaining_goals:
    30     94.0 MiB   -229.2 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     94.0 MiB   -216.2 MiB           7               if not remaining_goals:
    32     46.5 MiB    -47.5 MiB           1                   break  # All goals found
    33                                         
    34     95.9 MiB -17352809.7 MiB      546029           for neighbor in current.neighbors:
    35     95.9 MiB -15415832.4 MiB      485116               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.9 MiB -15415846.5 MiB      485116               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.9 MiB -7694694.6 MiB      242194                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.9 MiB -15415868.6 MiB      485116               if temp_g_score < g_score[neighbor]:
    41     95.9 MiB -1928132.8 MiB       61204                   came_from[neighbor] = current
    42     95.9 MiB -1928133.7 MiB       61204                   g_score[neighbor] = temp_g_score
    43     95.9 MiB -1928135.7 MiB       61204                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.9 MiB -1936998.8 MiB       60913           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.9 MiB -1936999.6 MiB       60913           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.5 MiB      0.0 MiB           1       paths = {}
    53     46.7 MiB      0.0 MiB           8       for goal in goals:
    54     46.7 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.4 MiB     92.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.4 MiB      0.0 MiB         257       for row in grid:
     8     92.4 MiB      0.0 MiB       65792           for spot in row:
     9     92.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.4 MiB      0.0 MiB           1       came_from = {}
    18     96.7 MiB -85622.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.9 MiB     -7.8 MiB           1       g_score[start] = 0
    20                                         
    21     89.4 MiB -2970566.0 MiB       61530       while not open_set.empty():
    22     89.4 MiB -2970567.3 MiB       61530           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.4 MiB -2970574.8 MiB       61530           current = open_set.get()[1]
    28                                         
    29     89.4 MiB -2970576.2 MiB       61530           if current in remaining_goals:
    30     75.3 MiB   -356.4 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     75.3 MiB   -258.1 MiB           7               if not remaining_goals:
    32     31.2 MiB    -44.1 MiB           1                   break  # All goals found
    33                                         
    34     89.4 MiB -26623138.3 MiB      551447           for neighbor in current.neighbors:
    35     89.4 MiB -23652674.4 MiB      489918               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.4 MiB -23652671.5 MiB      489918               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.4 MiB -11807823.6 MiB      244574                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.4 MiB -23652690.9 MiB      489918               if temp_g_score < g_score[neighbor]:
    41     89.4 MiB -2968282.7 MiB       61778                   came_from[neighbor] = current
    42     89.4 MiB -2968284.5 MiB       61778                   g_score[neighbor] = temp_g_score
    43     89.4 MiB -2968289.2 MiB       61778                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.4 MiB -2970560.3 MiB       61529           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.4 MiB -2970561.9 MiB       61529           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.2 MiB      0.0 MiB           1       paths = {}
    53     32.9 MiB      0.0 MiB           8       for goal in goals:
    54     32.9 MiB      1.7 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.0 MiB     90.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.0 MiB   -163.2 MiB         257       for row in grid:
     8     90.0 MiB -41887.4 MiB       65792           for spot in row:
     9     90.0 MiB -41725.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.9 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.9 MiB      0.0 MiB           1       came_from = {}
    18     92.4 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.8 MiB -1122306.7 MiB       46506       while not open_set.empty():
    22     92.8 MiB -1122307.5 MiB       46506           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.8 MiB -1122310.0 MiB       46506           current = open_set.get()[1]
    28                                         
    29     92.8 MiB -1122310.9 MiB       46506           if current in remaining_goals:
    30     88.7 MiB   -244.0 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     88.7 MiB   -214.9 MiB           7               if not remaining_goals:
    32     44.2 MiB    -44.5 MiB           1                   break  # All goals found
    33                                         
    34     92.8 MiB -10054822.8 MiB      416912           for neighbor in current.neighbors:
    35     92.8 MiB -8932553.2 MiB      370407               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.8 MiB -8932560.5 MiB      370407               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.8 MiB -4458726.1 MiB      184932                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.8 MiB -8932578.1 MiB      370407               if temp_g_score < g_score[neighbor]:
    41     92.8 MiB -1117412.3 MiB       46887                   came_from[neighbor] = current
    42     92.8 MiB -1117413.5 MiB       46887                   g_score[neighbor] = temp_g_score
    43     92.8 MiB -1117414.7 MiB       46887                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.8 MiB -1122304.5 MiB       46505           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.8 MiB -1122305.6 MiB       46505           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.2 MiB      0.0 MiB           1       paths = {}
    53     44.5 MiB      0.0 MiB           8       for goal in goals:
    54     44.5 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.4 MiB     91.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.4 MiB     -0.2 MiB         257       for row in grid:
     8     91.4 MiB    -49.3 MiB       65792           for spot in row:
     9     91.4 MiB    -49.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.4 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.4 MiB      0.0 MiB           1       came_from = {}
    18     92.1 MiB -213922.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.2 MiB     -2.9 MiB           1       g_score[start] = 0
    20                                         
    21     89.2 MiB -1843358.5 MiB       61525       while not open_set.empty():
    22     89.2 MiB -1843359.9 MiB       61525           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.2 MiB -1843362.7 MiB       61525           current = open_set.get()[1]
    28                                         
    29     89.2 MiB -1843364.1 MiB       61525           if current in remaining_goals:
    30     88.5 MiB   -207.8 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     88.5 MiB   -203.4 MiB           7               if not remaining_goals:
    32     35.8 MiB    -52.8 MiB           1                   break  # All goals found
    33                                         
    34     89.2 MiB -16510877.2 MiB      551477           for neighbor in current.neighbors:
    35     89.2 MiB -14667540.1 MiB      489953               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.2 MiB -14667545.7 MiB      489953               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.2 MiB -7320668.9 MiB      244604                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.2 MiB -14667563.2 MiB      489953               if temp_g_score < g_score[neighbor]:
    41     89.2 MiB -1833609.0 MiB       61798                   came_from[neighbor] = current
    42     89.2 MiB -1833610.7 MiB       61798                   g_score[neighbor] = temp_g_score
    43     89.2 MiB -1833614.3 MiB       61798                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.2 MiB -1843355.8 MiB       61524           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.2 MiB -1843357.1 MiB       61524           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.8 MiB      0.0 MiB           1       paths = {}
    53     36.1 MiB      0.0 MiB           8       for goal in goals:
    54     36.1 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.9 MiB     87.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.9 MiB     -9.4 MiB         257       for row in grid:
     8     87.9 MiB  -2300.7 MiB       65792           for spot in row:
     9     87.9 MiB  -2292.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.3 MiB     -1.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.3 MiB      0.0 MiB           1       came_from = {}
    18     90.3 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.4 MiB -1173656.1 MiB       42827       while not open_set.empty():
    22     90.4 MiB -1173656.9 MiB       42827           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.4 MiB -1173659.9 MiB       42827           current = open_set.get()[1]
    28                                         
    29     90.4 MiB -1173660.9 MiB       42827           if current in remaining_goals:
    30     77.0 MiB   -294.0 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     77.0 MiB   -200.0 MiB           7               if not remaining_goals:
    32     47.7 MiB    -29.3 MiB           1                   break  # All goals found
    33                                         
    34     90.4 MiB -10556303.4 MiB      385296           for neighbor in current.neighbors:
    35     90.4 MiB -9382740.0 MiB      342470               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.4 MiB -9382741.9 MiB      342470               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.4 MiB -4690357.4 MiB      171212                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.4 MiB -9382753.2 MiB      342470               if temp_g_score < g_score[neighbor]:
    41     90.4 MiB -1187239.6 MiB       43743                   came_from[neighbor] = current
    42     90.4 MiB -1187240.2 MiB       43743                   g_score[neighbor] = temp_g_score
    43     90.4 MiB -1187241.8 MiB       43743                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.4 MiB -1173652.4 MiB       42826           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.4 MiB -1173654.5 MiB       42826           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     47.7 MiB      0.0 MiB           1       paths = {}
    53     47.9 MiB      0.0 MiB           8       for goal in goals:
    54     47.9 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.1 MiB     90.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.1 MiB   -591.5 MiB         257       for row in grid:
     8     90.1 MiB -151416.1 MiB       65792           for spot in row:
     9     90.1 MiB -150828.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.9 MiB     -5.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.9 MiB      0.0 MiB           1       came_from = {}
    18     87.7 MiB -25653.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.8 MiB -2253820.9 MiB       64642       while not open_set.empty():
    22     87.8 MiB -2253822.0 MiB       64642           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.8 MiB -2253824.1 MiB       64642           current = open_set.get()[1]
    28                                         
    29     87.8 MiB -2253824.8 MiB       64642           if current in remaining_goals:
    30     49.5 MiB   -309.9 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     49.5 MiB      0.0 MiB           7               if not remaining_goals:
    32     49.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.8 MiB -20196768.8 MiB      578979           for neighbor in current.neighbors:
    35     87.8 MiB -17943231.2 MiB      514338               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.8 MiB -17943227.5 MiB      514338               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.8 MiB -8957153.9 MiB      256705                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.8 MiB -17943239.5 MiB      514338               if temp_g_score < g_score[neighbor]:
    41     87.8 MiB -2248055.5 MiB       64732                   came_from[neighbor] = current
    42     87.8 MiB -2248057.2 MiB       64732                   g_score[neighbor] = temp_g_score
    43     87.8 MiB -2248059.8 MiB       64732                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.8 MiB -2253818.8 MiB       64641           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.8 MiB -2253819.8 MiB       64641           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     49.5 MiB      0.0 MiB           1       paths = {}
    53     49.7 MiB      0.0 MiB           8       for goal in goals:
    54     49.7 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     49.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.9 MiB     87.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.9 MiB    -79.0 MiB         257       for row in grid:
     8     87.9 MiB -19867.6 MiB       65792           for spot in row:
     9     87.9 MiB -19790.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     90.6 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.0 MiB -482839.6 MiB       56710       while not open_set.empty():
    22     91.0 MiB -482841.0 MiB       56710           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.0 MiB -482845.6 MiB       56710           current = open_set.get()[1]
    28                                         
    29     91.0 MiB -482848.2 MiB       56710           if current in remaining_goals:
    30     85.9 MiB    -81.9 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     85.9 MiB    -39.7 MiB           7               if not remaining_goals:
    32     54.8 MiB    -31.0 MiB           1                   break  # All goals found
    33                                         
    34     91.0 MiB -4326379.4 MiB      508577           for neighbor in current.neighbors:
    35     91.0 MiB -3843587.5 MiB      451868               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.0 MiB -3843592.8 MiB      451868               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.0 MiB -1918663.2 MiB      225634                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.0 MiB -3843603.3 MiB      451868               if temp_g_score < g_score[neighbor]:
    41     91.0 MiB -481796.2 MiB       57126                   came_from[neighbor] = current
    42     91.0 MiB -481797.5 MiB       57126                   g_score[neighbor] = temp_g_score
    43     91.0 MiB -481799.1 MiB       57126                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.0 MiB -482836.7 MiB       56709           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.0 MiB -482838.2 MiB       56709           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     54.8 MiB      0.0 MiB           1       paths = {}
    53     55.0 MiB      0.0 MiB           8       for goal in goals:
    54     55.0 MiB      0.1 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     55.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.2 MiB     88.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.2 MiB   -359.9 MiB         257       for row in grid:
     8     88.2 MiB -91889.0 MiB       65792           for spot in row:
     9     88.2 MiB -91532.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.8 MiB     -4.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.8 MiB      0.0 MiB           1       came_from = {}
    18     87.0 MiB -21062.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.9 MiB -2157266.1 MiB       60945       while not open_set.empty():
    22     87.9 MiB -2157267.2 MiB       60945           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.9 MiB -2157269.9 MiB       60945           current = open_set.get()[1]
    28                                         
    29     87.9 MiB -2157271.4 MiB       60945           if current in remaining_goals:
    30     85.2 MiB   -289.0 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     85.2 MiB   -270.0 MiB           7               if not remaining_goals:
    32     41.0 MiB    -44.2 MiB           1                   break  # All goals found
    33                                         
    34     87.9 MiB -19341092.6 MiB      546158           for neighbor in current.neighbors:
    35     87.9 MiB -17183858.8 MiB      485214               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.9 MiB -17183861.7 MiB      485214               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.9 MiB -8579655.2 MiB      242218                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.9 MiB -17183875.8 MiB      485214               if temp_g_score < g_score[neighbor]:
    41     87.9 MiB -2154300.0 MiB       61185                   came_from[neighbor] = current
    42     87.9 MiB -2154303.2 MiB       61185                   g_score[neighbor] = temp_g_score
    43     87.9 MiB -2154305.4 MiB       61185                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.9 MiB -2157263.8 MiB       60944           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.9 MiB -2157264.8 MiB       60944           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.0 MiB      0.0 MiB           1       paths = {}
    53     41.2 MiB      0.0 MiB           8       for goal in goals:
    54     41.2 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.1 MiB     94.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.1 MiB   -203.2 MiB         257       for row in grid:
     8     94.1 MiB -52032.5 MiB       65792           for spot in row:
     9     94.1 MiB -51830.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.5 MiB     -1.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.5 MiB      0.0 MiB           1       came_from = {}
    18     97.5 MiB   -777.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.4 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     98.5 MiB -100106.1 MiB       56520       while not open_set.empty():
    22     98.5 MiB -100106.4 MiB       56520           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     98.5 MiB -100106.7 MiB       56520           current = open_set.get()[1]
    28                                         
    29     98.5 MiB -100106.9 MiB       56520           if current in remaining_goals:
    30     97.9 MiB    -25.1 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     97.9 MiB    -21.4 MiB           7               if not remaining_goals:
    32     89.6 MiB     -8.2 MiB           1                   break  # All goals found
    33                                         
    34     98.5 MiB -896500.7 MiB      506816           for neighbor in current.neighbors:
    35     98.5 MiB -796400.7 MiB      450297               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     98.5 MiB -796402.6 MiB      450297               if current.row != neighbor.row and current.col != neighbor.col:
    38     98.5 MiB -397473.1 MiB      224840                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     98.5 MiB -796405.6 MiB      450297               if temp_g_score < g_score[neighbor]:
    41     98.5 MiB -99408.9 MiB       56907                   came_from[neighbor] = current
    42     98.5 MiB -99410.4 MiB       56907                   g_score[neighbor] = temp_g_score
    43     98.5 MiB -99410.7 MiB       56907                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     98.5 MiB -100105.5 MiB       56519           if draw is not None:
    46                                                     draw()
    47                                                     
    48     98.5 MiB -100105.8 MiB       56519           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     89.6 MiB      0.0 MiB           1       paths = {}
    53     89.7 MiB      0.0 MiB           8       for goal in goals:
    54     89.7 MiB      0.0 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     89.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.0 MiB     98.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.0 MiB      0.0 MiB         257       for row in grid:
     8     98.0 MiB      0.0 MiB       65792           for spot in row:
     9     98.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     98.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     98.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     98.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     98.0 MiB      0.0 MiB           1       came_from = {}
    18     98.3 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.5 MiB -517760.5 MiB       59601       while not open_set.empty():
    22     99.5 MiB -517761.2 MiB       59601           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.5 MiB -517763.4 MiB       59601           current = open_set.get()[1]
    28                                         
    29     99.5 MiB -517764.5 MiB       59601           if current in remaining_goals:
    30     99.5 MiB    -41.5 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     99.5 MiB    -41.5 MiB           7               if not remaining_goals:
    32     58.6 MiB    -40.9 MiB           1                   break  # All goals found
    33                                         
    34     99.5 MiB -4638259.8 MiB      534317           for neighbor in current.neighbors:
    35     99.5 MiB -4120509.2 MiB      474717               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.5 MiB -4120514.7 MiB      474717               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.5 MiB -2056725.9 MiB      237012                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.5 MiB -4120525.4 MiB      474717               if temp_g_score < g_score[neighbor]:
    41     99.5 MiB -513980.9 MiB       59926                   came_from[neighbor] = current
    42     99.5 MiB -513982.9 MiB       59926                   g_score[neighbor] = temp_g_score
    43     99.5 MiB -513984.9 MiB       59926                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.5 MiB -517758.7 MiB       59600           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.5 MiB -517759.6 MiB       59600           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     58.6 MiB      0.0 MiB           1       paths = {}
    53     58.9 MiB      0.0 MiB           8       for goal in goals:
    54     58.9 MiB      0.3 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     58.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.1 MiB     97.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.1 MiB      0.0 MiB         257       for row in grid:
     8     97.1 MiB      0.0 MiB       65792           for spot in row:
     9     97.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.1 MiB      0.0 MiB           1       came_from = {}
    18    102.3 MiB      5.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    102.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    102.3 MiB -1748397.0 MiB       65157       while not open_set.empty():
    22    102.3 MiB -1748398.5 MiB       65157           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    102.3 MiB -1748404.8 MiB       65157           current = open_set.get()[1]
    28                                         
    29    102.3 MiB -1748406.3 MiB       65157           if current in remaining_goals:
    30     98.0 MiB   -221.6 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     98.0 MiB   -192.1 MiB           7               if not remaining_goals:
    32     43.6 MiB    -54.5 MiB           1                   break  # All goals found
    33                                         
    34    102.3 MiB -15629251.0 MiB      583512           for neighbor in current.neighbors:
    35    102.3 MiB -13880894.4 MiB      518356               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    102.3 MiB -13880901.2 MiB      518356               if current.row != neighbor.row and current.col != neighbor.col:
    38    102.3 MiB -6922867.4 MiB      258697                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    102.3 MiB -13880918.6 MiB      518356               if temp_g_score < g_score[neighbor]:
    41    102.3 MiB -1724510.9 MiB       65213                   came_from[neighbor] = current
    42    102.3 MiB -1724512.3 MiB       65213                   g_score[neighbor] = temp_g_score
    43    102.3 MiB -1724514.5 MiB       65213                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    102.3 MiB -1748394.5 MiB       65156           if draw is not None:
    46                                                     draw()
    47                                                     
    48    102.3 MiB -1748395.6 MiB       65156           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.6 MiB      0.0 MiB           1       paths = {}
    53     43.8 MiB      0.0 MiB           8       for goal in goals:
    54     43.8 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.1 MiB     91.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.1 MiB  -1645.0 MiB         257       for row in grid:
     8     91.1 MiB -419790.9 MiB       65792           for spot in row:
     9     91.1 MiB -418159.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     70.8 MiB    -20.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     71.0 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     71.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     71.2 MiB      0.0 MiB           1       came_from = {}
    18     75.8 MiB -11247.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     75.4 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     85.3 MiB -179805.7 MiB       52199       while not open_set.empty():
    22     85.3 MiB -179806.6 MiB       52199           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.3 MiB -179808.4 MiB       52199           current = open_set.get()[1]
    28                                         
    29     85.3 MiB -179809.4 MiB       52199           if current in remaining_goals:
    30     82.7 MiB    -45.2 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     82.7 MiB    -42.4 MiB           7               if not remaining_goals:
    32     40.3 MiB    -42.4 MiB           1                   break  # All goals found
    33                                         
    34     85.3 MiB -1608965.8 MiB      468202           for neighbor in current.neighbors:
    35     85.3 MiB -1429174.0 MiB      416004               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.3 MiB -1429178.6 MiB      416004               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.3 MiB -713122.0 MiB      207739                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.3 MiB -1429193.9 MiB      416004               if temp_g_score < g_score[neighbor]:
    41     85.3 MiB -177900.4 MiB       52679                   came_from[neighbor] = current
    42     85.3 MiB -177906.4 MiB       52679                   g_score[neighbor] = temp_g_score
    43     85.3 MiB -177907.9 MiB       52679                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.3 MiB -179803.6 MiB       52198           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.3 MiB -179804.7 MiB       52198           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.3 MiB      0.0 MiB           1       paths = {}
    53     40.6 MiB      0.0 MiB           8       for goal in goals:
    54     40.6 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.2 MiB     90.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.2 MiB    -35.6 MiB         257       for row in grid:
     8     90.2 MiB  -9109.9 MiB       65792           for spot in row:
     9     90.2 MiB  -9074.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.9 MiB     -0.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.9 MiB      0.0 MiB           1       came_from = {}
    18     93.5 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.8 MiB -294304.8 MiB       57007       while not open_set.empty():
    22     93.8 MiB -294305.9 MiB       57007           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.8 MiB -294307.3 MiB       57007           current = open_set.get()[1]
    28                                         
    29     93.8 MiB -294308.1 MiB       57007           if current in remaining_goals:
    30     93.0 MiB    -55.0 MiB           7               remaining_goals.remove(current)  # Remove this goal from the list
    31     93.0 MiB    -49.9 MiB           7               if not remaining_goals:
    32     56.7 MiB    -36.3 MiB           1                   break  # All goals found
    33                                         
    34     93.8 MiB -2634007.8 MiB      510999           for neighbor in current.neighbors:
    35     93.8 MiB -2339717.6 MiB      453993               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.8 MiB -2339723.9 MiB      453993               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.8 MiB -1167481.9 MiB      226655                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.8 MiB -2339734.0 MiB      453993               if temp_g_score < g_score[neighbor]:
    41     93.8 MiB -291724.5 MiB       57342                   came_from[neighbor] = current
    42     93.8 MiB -291725.6 MiB       57342                   g_score[neighbor] = temp_g_score
    43     93.8 MiB -291727.3 MiB       57342                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.8 MiB -294302.2 MiB       57006           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.8 MiB -294303.5 MiB       57006           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     56.7 MiB      0.0 MiB           1       paths = {}
    53     56.9 MiB      0.0 MiB           8       for goal in goals:
    54     56.9 MiB      0.2 MiB           7           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     56.9 MiB      0.0 MiB           1       return paths


