Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.4 MiB     67.4 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     70.3 MiB   -292.5 MiB         257       for row in grid:
     8     70.3 MiB -74449.4 MiB       65792           for spot in row:
     9     70.3 MiB -74157.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     66.2 MiB     -4.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     66.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     66.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     66.3 MiB      0.0 MiB           1       came_from = {}
    18     73.2 MiB      7.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     73.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     73.2 MiB -1265840.0 MiB       61404       while not open_set.empty():
    22     73.2 MiB -1265840.8 MiB       61404           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     73.2 MiB -1265845.2 MiB       61404           current = open_set.get()[1]
    28                                         
    29     73.2 MiB -1265847.1 MiB       61404           if current in remaining_goals:
    30     69.2 MiB   -137.4 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     69.2 MiB    -97.6 MiB          10               if not remaining_goals:
    32     43.0 MiB    -26.3 MiB           1                   break  # All goals found
    33                                         
    34     73.2 MiB -11345906.4 MiB      550272           for neighbor in current.neighbors:
    35     73.2 MiB -10080119.0 MiB      488869               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     73.2 MiB -10080115.7 MiB      488869               if current.row != neighbor.row and current.col != neighbor.col:
    38     73.2 MiB -5032343.9 MiB      244043                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     73.2 MiB -10080122.0 MiB      488869               if temp_g_score < g_score[neighbor]:
    41     73.2 MiB -1263541.9 MiB       61639                   came_from[neighbor] = current
    42     73.2 MiB -1263542.3 MiB       61639                   g_score[neighbor] = temp_g_score
    43     73.2 MiB -1263542.8 MiB       61639                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     73.2 MiB -1265835.1 MiB       61403           if draw is not None:
    46                                                     draw()
    47                                                     
    48     73.2 MiB -1265837.9 MiB       61403           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.0 MiB      0.0 MiB           1       paths = {}
    53     43.1 MiB      0.0 MiB          11       for goal in goals:
    54     43.1 MiB      0.1 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.2 MiB     89.2 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.2 MiB     -0.2 MiB         257       for row in grid:
     8     93.2 MiB    -49.1 MiB       65792           for spot in row:
     9     93.2 MiB    -45.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.2 MiB      0.0 MiB           1       came_from = {}
    18     97.0 MiB -105394.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.7 MiB     -4.2 MiB           1       g_score[start] = 0
    20                                         
    21     93.6 MiB -2415065.4 MiB       57134       while not open_set.empty():
    22     93.6 MiB -2415066.0 MiB       57134           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.6 MiB -2415069.8 MiB       57134           current = open_set.get()[1]
    28                                         
    29     93.6 MiB -2415071.3 MiB       57134           if current in remaining_goals:
    30     90.5 MiB   -422.0 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.5 MiB   -390.1 MiB          10               if not remaining_goals:
    32     45.7 MiB    -44.7 MiB           1                   break  # All goals found
    33                                         
    34     93.6 MiB -21643013.0 MiB      512291           for neighbor in current.neighbors:
    35     93.6 MiB -19227996.7 MiB      455158               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.6 MiB -19227998.0 MiB      455158               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.6 MiB -9598685.8 MiB      227262                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.6 MiB -19228018.8 MiB      455158               if temp_g_score < g_score[neighbor]:
    41     93.6 MiB -2413781.0 MiB       57506                   came_from[neighbor] = current
    42     93.6 MiB -2413783.2 MiB       57506                   g_score[neighbor] = temp_g_score
    43     93.6 MiB -2413784.0 MiB       57506                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.6 MiB -2415053.8 MiB       57133           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.6 MiB -2415062.1 MiB       57133           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.7 MiB      0.0 MiB           1       paths = {}
    53     46.0 MiB      0.0 MiB          11       for goal in goals:
    54     46.0 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.0 MiB     94.0 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.0 MiB   -673.7 MiB         257       for row in grid:
     8     94.0 MiB -172537.8 MiB       65792           for spot in row:
     9     94.0 MiB -171867.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.8 MiB     -5.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.8 MiB      0.0 MiB           1       came_from = {}
    18     94.1 MiB -13275.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.7 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     93.7 MiB -2767413.3 MiB       61849       while not open_set.empty():
    22     93.7 MiB -2767415.1 MiB       61849           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.7 MiB -2767417.8 MiB       61849           current = open_set.get()[1]
    28                                         
    29     93.7 MiB -2767419.5 MiB       61849           if current in remaining_goals:
    30     93.2 MiB   -439.1 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     93.2 MiB   -433.6 MiB          10               if not remaining_goals:
    32     44.6 MiB    -48.6 MiB           1                   break  # All goals found
    33                                         
    34     93.7 MiB -24806583.7 MiB      554199           for neighbor in current.neighbors:
    35     93.7 MiB -22039183.6 MiB      492351               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.7 MiB -22039193.2 MiB      492351               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.7 MiB -11003036.4 MiB      245771                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.7 MiB -22039215.2 MiB      492351               if temp_g_score < g_score[neighbor]:
    41     93.7 MiB -2766188.7 MiB       62058                   came_from[neighbor] = current
    42     93.7 MiB -2766189.5 MiB       62058                   g_score[neighbor] = temp_g_score
    43     93.7 MiB -2766192.5 MiB       62058                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.7 MiB -2767411.3 MiB       61848           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.7 MiB -2767412.5 MiB       61848           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.6 MiB      0.0 MiB           1       paths = {}
    53     45.0 MiB      0.0 MiB          11       for goal in goals:
    54     45.0 MiB      0.4 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.3 MiB     99.3 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.3 MiB     -0.6 MiB         257       for row in grid:
     8     99.3 MiB   -149.5 MiB       65792           for spot in row:
     9     99.3 MiB   -148.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     99.3 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     99.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     99.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     99.3 MiB      0.0 MiB           1       came_from = {}
    18    104.3 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    104.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    104.5 MiB -2405039.9 MiB       59482       while not open_set.empty():
    22    104.5 MiB -2405042.8 MiB       59482           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    104.5 MiB -2405046.0 MiB       59482           current = open_set.get()[1]
    28                                         
    29    104.5 MiB -2405046.4 MiB       59482           if current in remaining_goals:
    30    104.3 MiB   -246.1 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31    104.3 MiB   -245.0 MiB          10               if not remaining_goals:
    32     46.5 MiB    -57.8 MiB           1                   break  # All goals found
    33                                         
    34    104.5 MiB -21550228.6 MiB      533321           for neighbor in current.neighbors:
    35    104.5 MiB -19145202.2 MiB      473840               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    104.5 MiB -19145218.5 MiB      473840               if current.row != neighbor.row and current.col != neighbor.col:
    38    104.5 MiB -9556899.5 MiB      236586                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    104.5 MiB -19145231.4 MiB      473840               if temp_g_score < g_score[neighbor]:
    41    104.5 MiB -2397927.7 MiB       59832                   came_from[neighbor] = current
    42    104.5 MiB -2397928.8 MiB       59832                   g_score[neighbor] = temp_g_score
    43    104.5 MiB -2397941.3 MiB       59832                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    104.5 MiB -2405037.8 MiB       59481           if draw is not None:
    46                                                     draw()
    47                                                     
    48    104.5 MiB -2405038.1 MiB       59481           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.5 MiB      0.0 MiB           1       paths = {}
    53     46.7 MiB      0.0 MiB          11       for goal in goals:
    54     46.7 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.8 MiB    100.8 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.8 MiB   -110.3 MiB         257       for row in grid:
     8    100.8 MiB -28040.9 MiB       65792           for spot in row:
     9    100.8 MiB -27932.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.6 MiB     -3.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.6 MiB      0.0 MiB           1       came_from = {}
    18     99.6 MiB -30825.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     99.2 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     99.2 MiB -3144023.0 MiB       62174       while not open_set.empty():
    22     99.2 MiB -3144023.7 MiB       62174           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.2 MiB -3144027.6 MiB       62174           current = open_set.get()[1]
    28                                         
    29     99.2 MiB -3144028.6 MiB       62174           if current in remaining_goals:
    30     43.7 MiB   -576.6 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.7 MiB     -0.7 MiB          10               if not remaining_goals:
    32     43.4 MiB     -0.3 MiB           1                   break  # All goals found
    33                                         
    34     99.2 MiB -28162383.0 MiB      557249           for neighbor in current.neighbors:
    35     99.2 MiB -25018890.1 MiB      495076               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.2 MiB -25018911.9 MiB      495076               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.2 MiB -12487392.9 MiB      247154                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.2 MiB -25018930.4 MiB      495076               if temp_g_score < g_score[neighbor]:
    41     99.2 MiB -3135334.0 MiB       62424                   came_from[neighbor] = current
    42     99.2 MiB -3135334.5 MiB       62424                   g_score[neighbor] = temp_g_score
    43     99.2 MiB -3135335.5 MiB       62424                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.2 MiB -3144019.9 MiB       62173           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.2 MiB -3144021.7 MiB       62173           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.4 MiB      0.0 MiB           1       paths = {}
    53     43.5 MiB      0.0 MiB          11       for goal in goals:
    54     43.5 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.4 MiB     99.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.4 MiB   -473.4 MiB         257       for row in grid:
     8     99.4 MiB -121049.8 MiB       65792           for spot in row:
     9     99.4 MiB -120577.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     95.4 MiB     -4.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     95.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     95.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     95.4 MiB      0.0 MiB           1       came_from = {}
    18     98.9 MiB -32165.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.9 MiB     -1.0 MiB           1       g_score[start] = 0
    20                                         
    21     98.0 MiB -3929263.1 MiB       65095       while not open_set.empty():
    22     98.0 MiB -3929270.4 MiB       65095           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     98.0 MiB -3929272.4 MiB       65095           current = open_set.get()[1]
    28                                         
    29     98.0 MiB -3929276.4 MiB       65095           if current in remaining_goals:
    30     39.6 MiB   -645.3 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     39.6 MiB    -52.5 MiB          10               if not remaining_goals:
    32     28.5 MiB    -11.1 MiB           1                   break  # All goals found
    33                                         
    34     98.0 MiB -35176550.5 MiB      583005           for neighbor in current.neighbors:
    35     98.0 MiB -31247883.3 MiB      517911               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     98.0 MiB -31247862.1 MiB      517911               if current.row != neighbor.row and current.col != neighbor.col:
    38     98.0 MiB -15593270.9 MiB      258483                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     98.0 MiB -31247944.9 MiB      517911               if temp_g_score < g_score[neighbor]:
    41     98.0 MiB -3918359.1 MiB       65168                   came_from[neighbor] = current
    42     98.0 MiB -3918361.8 MiB       65168                   g_score[neighbor] = temp_g_score
    43     98.0 MiB -3918368.4 MiB       65168                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     98.0 MiB -3929252.7 MiB       65094           if draw is not None:
    46                                                     draw()
    47                                                     
    48     98.0 MiB -3929258.2 MiB       65094           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     28.5 MiB      0.0 MiB           1       paths = {}
    53     30.0 MiB      0.0 MiB          11       for goal in goals:
    54     30.0 MiB      1.5 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.4 MiB     89.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.4 MiB -11441.3 MiB         257       for row in grid:
     8     89.4 MiB -2933939.0 MiB       65792           for spot in row:
     9     89.4 MiB -2922537.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     31.2 MiB    -58.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     31.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     31.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     31.7 MiB      0.0 MiB           1       came_from = {}
    18     40.6 MiB -33963.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     38.9 MiB     -1.7 MiB           1       g_score[start] = 0
    20                                         
    21     40.8 MiB -686692.9 MiB       63732       while not open_set.empty():
    22     40.8 MiB -686695.3 MiB       63732           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     40.8 MiB -686697.6 MiB       63732           current = open_set.get()[1]
    28                                         
    29     40.8 MiB -686699.1 MiB       63732           if current in remaining_goals:
    30     33.8 MiB    -91.4 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.8 MiB     -6.6 MiB          10               if not remaining_goals:
    32     29.4 MiB     -4.4 MiB           1                   break  # All goals found
    33                                         
    34     40.8 MiB -6154477.2 MiB      571031           for neighbor in current.neighbors:
    35     40.8 MiB -5467879.9 MiB      507300               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     40.8 MiB -5467880.1 MiB      507300               if current.row != neighbor.row and current.col != neighbor.col:
    38     40.8 MiB -2729746.5 MiB      253226                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     40.8 MiB -5467899.6 MiB      507300               if temp_g_score < g_score[neighbor]:
    41     40.8 MiB -689025.0 MiB       63902                   came_from[neighbor] = current
    42     40.8 MiB -689026.5 MiB       63902                   g_score[neighbor] = temp_g_score
    43     40.8 MiB -689027.5 MiB       63902                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     40.8 MiB -686689.9 MiB       63731           if draw is not None:
    46                                                     draw()
    47                                                     
    48     40.8 MiB -686690.4 MiB       63731           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.4 MiB      0.0 MiB           1       paths = {}
    53     30.7 MiB      0.0 MiB          11       for goal in goals:
    54     30.7 MiB      1.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.9 MiB     87.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.9 MiB   -565.7 MiB         257       for row in grid:
     8     87.9 MiB -144882.7 MiB       65792           for spot in row:
     9     87.9 MiB -144322.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.0 MiB     -5.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.0 MiB      0.0 MiB           1       came_from = {}
    18     84.6 MiB -40823.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.2 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     84.2 MiB -3326621.7 MiB       60520       while not open_set.empty():
    22     84.2 MiB -3326631.0 MiB       60520           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.2 MiB -3326631.5 MiB       60520           current = open_set.get()[1]
    28                                         
    29     84.2 MiB -3326634.7 MiB       60520           if current in remaining_goals:
    30     34.8 MiB   -553.1 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.8 MiB    -25.3 MiB          10               if not remaining_goals:
    32     26.8 MiB     -8.0 MiB           1                   break  # All goals found
    33                                         
    34     84.2 MiB -29809960.8 MiB      542388           for neighbor in current.neighbors:
    35     84.2 MiB -26483828.9 MiB      481869               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.2 MiB -26483833.5 MiB      481869               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.2 MiB -13220573.8 MiB      240555                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.2 MiB -26483874.2 MiB      481869               if temp_g_score < g_score[neighbor]:
    41     84.2 MiB -3334961.3 MiB       60779                   came_from[neighbor] = current
    42     84.2 MiB -3334962.1 MiB       60779                   g_score[neighbor] = temp_g_score
    43     84.2 MiB -3334962.4 MiB       60779                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.2 MiB -3326618.8 MiB       60519           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.2 MiB -3326620.1 MiB       60519           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     26.8 MiB      0.0 MiB           1       paths = {}
    53     27.8 MiB      0.0 MiB          11       for goal in goals:
    54     27.8 MiB      1.1 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.6 MiB   -675.9 MiB         257       for row in grid:
     8     86.6 MiB -172965.7 MiB       65792           for spot in row:
     9     86.6 MiB -172292.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.1 MiB     -5.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     81.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     81.5 MiB      0.0 MiB           1       came_from = {}
    18     84.9 MiB -17959.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.2 MiB     -0.7 MiB           1       g_score[start] = 0
    20                                         
    21     84.3 MiB -2042535.8 MiB       40121       while not open_set.empty():
    22     84.3 MiB -2042536.2 MiB       40121           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.3 MiB -2042536.9 MiB       40121           current = open_set.get()[1]
    28                                         
    29     84.3 MiB -2042537.2 MiB       40121           if current in remaining_goals:
    30     84.0 MiB   -475.5 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     84.0 MiB   -472.6 MiB          10               if not remaining_goals:
    32     30.3 MiB    -53.7 MiB           1                   break  # All goals found
    33                                         
    34     84.3 MiB -18335406.7 MiB      360210           for neighbor in current.neighbors:
    35     84.3 MiB -16292909.3 MiB      320090               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.3 MiB -16292925.5 MiB      320090               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.3 MiB -8138667.1 MiB      159900                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.3 MiB -16292936.2 MiB      320090               if temp_g_score < g_score[neighbor]:
    41     84.3 MiB -2063429.5 MiB       40723                   came_from[neighbor] = current
    42     84.3 MiB -2063432.1 MiB       40723                   g_score[neighbor] = temp_g_score
    43     84.3 MiB -2063432.4 MiB       40723                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.3 MiB -2042534.4 MiB       40120           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.3 MiB -2042535.3 MiB       40120           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.3 MiB      0.0 MiB           1       paths = {}
    53     30.4 MiB      0.0 MiB          11       for goal in goals:
    54     30.4 MiB      0.1 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.1 MiB     85.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.1 MiB   -242.0 MiB         257       for row in grid:
     8     85.1 MiB -62151.6 MiB       65792           for spot in row:
     9     85.1 MiB -61911.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.3 MiB     -1.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.3 MiB      0.0 MiB           1       came_from = {}
    18     88.0 MiB -51222.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.2 MiB     -2.8 MiB           1       g_score[start] = 0
    20                                         
    21     85.2 MiB -3074811.7 MiB       60543       while not open_set.empty():
    22     85.2 MiB -3074812.6 MiB       60543           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.2 MiB -3074814.4 MiB       60543           current = open_set.get()[1]
    28                                         
    29     85.2 MiB -3074815.7 MiB       60543           if current in remaining_goals:
    30     84.6 MiB   -364.2 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     84.6 MiB   -357.4 MiB          10               if not remaining_goals:
    32     38.4 MiB    -46.1 MiB           1                   break  # All goals found
    33                                         
    34     85.2 MiB -27570029.3 MiB      542595           for neighbor in current.neighbors:
    35     85.2 MiB -24495245.0 MiB      482053               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.2 MiB -24495241.8 MiB      482053               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.2 MiB -12230536.8 MiB      240647                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.2 MiB -24495263.8 MiB      482053               if temp_g_score < g_score[neighbor]:
    41     85.2 MiB -3083231.6 MiB       60802                   came_from[neighbor] = current
    42     85.2 MiB -3083233.0 MiB       60802                   g_score[neighbor] = temp_g_score
    43     85.2 MiB -3083235.3 MiB       60802                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.2 MiB -3074804.1 MiB       60542           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.2 MiB -3074805.6 MiB       60542           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.4 MiB      0.0 MiB           1       paths = {}
    53     38.9 MiB      0.0 MiB          11       for goal in goals:
    54     38.9 MiB      0.4 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.9 MiB     85.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.9 MiB  -2203.6 MiB         257       for row in grid:
     8     85.9 MiB -564802.3 MiB       65792           for spot in row:
     9     85.9 MiB -562609.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     71.4 MiB    -14.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     71.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     71.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     71.4 MiB      0.0 MiB           1       came_from = {}
    18     77.2 MiB   -341.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     77.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     77.3 MiB -2085557.2 MiB       53971       while not open_set.empty():
    22     77.3 MiB -2085560.7 MiB       53971           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     77.3 MiB -2085564.5 MiB       53971           current = open_set.get()[1]
    28                                         
    29     77.3 MiB -2085565.7 MiB       53971           if current in remaining_goals:
    30     38.8 MiB   -421.9 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.8 MiB    -36.4 MiB          10               if not remaining_goals:
    32     35.1 MiB     -3.7 MiB           1                   break  # All goals found
    33                                         
    34     77.3 MiB -18700734.9 MiB      484126           for neighbor in current.neighbors:
    35     77.3 MiB -16615550.0 MiB      430156               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     77.3 MiB -16615548.7 MiB      430156               if current.row != neighbor.row and current.col != neighbor.col:
    38     77.3 MiB -8296381.9 MiB      214811                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     77.3 MiB -16615567.8 MiB      430156               if temp_g_score < g_score[neighbor]:
    41     77.3 MiB -2091277.1 MiB       54423                   came_from[neighbor] = current
    42     77.3 MiB -2091278.1 MiB       54423                   g_score[neighbor] = temp_g_score
    43     77.3 MiB -2091279.9 MiB       54423                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     77.3 MiB -2085554.0 MiB       53970           if draw is not None:
    46                                                     draw()
    47                                                     
    48     77.3 MiB -2085555.7 MiB       53970           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.1 MiB      0.0 MiB           1       paths = {}
    53     35.3 MiB      0.0 MiB          11       for goal in goals:
    54     35.3 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.1 MiB     91.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.1 MiB   -268.5 MiB         257       for row in grid:
     8     91.1 MiB -68814.6 MiB       65792           for spot in row:
     9     91.1 MiB -68545.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.1 MiB     -1.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.1 MiB      0.0 MiB           1       came_from = {}
    18     95.1 MiB   -690.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.1 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.1 MiB -3341667.5 MiB       60634       while not open_set.empty():
    22     95.1 MiB -3341668.0 MiB       60634           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.1 MiB -3341669.9 MiB       60634           current = open_set.get()[1]
    28                                         
    29     95.1 MiB -3341670.4 MiB       60634           if current in remaining_goals:
    30     37.6 MiB   -619.5 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.6 MiB     -0.4 MiB          10               if not remaining_goals:
    32     37.2 MiB     -0.4 MiB           1                   break  # All goals found
    33                                         
    34     95.1 MiB -29949622.9 MiB      543524           for neighbor in current.neighbors:
    35     95.1 MiB -26608530.4 MiB      482891               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.1 MiB -26608552.4 MiB      482891               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.1 MiB -13283640.8 MiB      241084                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.1 MiB -26608572.0 MiB      482891               if temp_g_score < g_score[neighbor]:
    41     95.1 MiB -3341074.4 MiB       60929                   came_from[neighbor] = current
    42     95.1 MiB -3341075.5 MiB       60929                   g_score[neighbor] = temp_g_score
    43     95.1 MiB -3341078.7 MiB       60929                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.1 MiB -3341664.5 MiB       60633           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.1 MiB -3341666.2 MiB       60633           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.2 MiB      0.0 MiB           1       paths = {}
    53     37.5 MiB      0.0 MiB          11       for goal in goals:
    54     37.5 MiB      0.3 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.4 MiB     91.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.4 MiB  -2846.2 MiB         257       for row in grid:
     8     91.4 MiB -721706.1 MiB       65792           for spot in row:
     9     91.4 MiB -718913.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     27.9 MiB    -63.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     28.0 MiB      0.1 MiB           1       open_set = PriorityQueue()
    16     28.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     28.0 MiB      0.0 MiB           1       came_from = {}
    18     40.2 MiB   -200.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     40.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     45.1 MiB -548594.1 MiB       54040       while not open_set.empty():
    22     45.1 MiB -548594.4 MiB       54040           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     45.1 MiB -548596.0 MiB       54040           current = open_set.get()[1]
    28                                         
    29     45.1 MiB -548596.2 MiB       54040           if current in remaining_goals:
    30     34.0 MiB   -126.0 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.0 MiB    -24.7 MiB          10               if not remaining_goals:
    32     32.6 MiB     -1.5 MiB           1                   break  # All goals found
    33                                         
    34     45.1 MiB -4935725.8 MiB      484705           for neighbor in current.neighbors:
    35     45.1 MiB -4387242.6 MiB      430666               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     45.1 MiB -4387247.2 MiB      430666               if current.row != neighbor.row and current.col != neighbor.col:
    38     45.1 MiB -2190842.9 MiB      215059                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     45.1 MiB -4387254.5 MiB      430666               if temp_g_score < g_score[neighbor]:
    41     45.1 MiB -552559.3 MiB       54504                   came_from[neighbor] = current
    42     45.1 MiB -552559.9 MiB       54504                   g_score[neighbor] = temp_g_score
    43     45.1 MiB -552560.4 MiB       54504                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     45.1 MiB -550498.7 MiB       54039           if draw is not None:
    46                                                     draw()
    47                                                     
    48     45.1 MiB -548593.7 MiB       54039           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.6 MiB      0.0 MiB           1       paths = {}
    53     33.1 MiB      0.0 MiB          11       for goal in goals:
    54     33.1 MiB      0.5 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.5 MiB     90.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.5 MiB   -232.0 MiB         257       for row in grid:
     8     90.5 MiB -58938.6 MiB       65792           for spot in row:
     9     90.5 MiB -58707.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.2 MiB     -3.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.2 MiB      0.0 MiB           1       came_from = {}
    18     91.0 MiB -13633.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.9 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     90.9 MiB -2735856.6 MiB       55240       while not open_set.empty():
    22     90.9 MiB -2735857.5 MiB       55240           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.9 MiB -2735859.2 MiB       55240           current = open_set.get()[1]
    28                                         
    29     90.9 MiB -2735860.5 MiB       55240           if current in remaining_goals:
    30     34.8 MiB   -592.8 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.8 MiB    -11.0 MiB          10               if not remaining_goals:
    32     32.3 MiB     -2.5 MiB           1                   break  # All goals found
    33                                         
    34     90.9 MiB -24542957.2 MiB      495251           for neighbor in current.neighbors:
    35     90.9 MiB -21807639.8 MiB      440012               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.9 MiB -21807628.0 MiB      440012               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.9 MiB -10890772.5 MiB      219690                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.9 MiB -21807685.1 MiB      440012               if temp_g_score < g_score[neighbor]:
    41     90.9 MiB -2745658.4 MiB       55626                   came_from[neighbor] = current
    42     90.9 MiB -2745658.7 MiB       55626                   g_score[neighbor] = temp_g_score
    43     90.9 MiB -2745659.3 MiB       55626                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.9 MiB -2735854.4 MiB       55239           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.9 MiB -2735856.2 MiB       55239           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.3 MiB      0.0 MiB           1       paths = {}
    53     32.7 MiB      0.0 MiB          11       for goal in goals:
    54     32.7 MiB      0.4 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.4 MiB     89.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.4 MiB   -100.6 MiB         257       for row in grid:
     8     89.4 MiB -25543.5 MiB       65792           for spot in row:
     9     89.4 MiB -25444.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.2 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.4 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     87.6 MiB      0.2 MiB           1       open_set.put((0, start))
    17     87.6 MiB      0.0 MiB           1       came_from = {}
    18     91.3 MiB  -8388.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.6 MiB -3000569.0 MiB       55291       while not open_set.empty():
    22     91.6 MiB -3000586.2 MiB       55291           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.6 MiB -3000587.4 MiB       55291           current = open_set.get()[1]
    28                                         
    29     91.6 MiB -3000587.8 MiB       55291           if current in remaining_goals:
    30     41.6 MiB   -581.4 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.6 MiB    -22.0 MiB          10               if not remaining_goals:
    32     39.1 MiB     -2.5 MiB           1                   break  # All goals found
    33                                         
    34     91.6 MiB -26907888.6 MiB      495833           for neighbor in current.neighbors:
    35     91.6 MiB -23907873.5 MiB      440543               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.6 MiB -23907866.2 MiB      440543               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.6 MiB -11937936.6 MiB      219976                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.6 MiB -23907876.9 MiB      440543               if temp_g_score < g_score[neighbor]:
    41     91.6 MiB -3011117.4 MiB       55718                   came_from[neighbor] = current
    42     91.6 MiB -3011118.2 MiB       55718                   g_score[neighbor] = temp_g_score
    43     91.6 MiB -3011119.1 MiB       55718                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.6 MiB -3000535.1 MiB       55290           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.6 MiB -3000537.5 MiB       55290           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.1 MiB      0.0 MiB           1       paths = {}
    53     39.4 MiB      0.0 MiB          11       for goal in goals:
    54     39.4 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     39.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.1 MiB     89.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.1 MiB  -3076.7 MiB         257       for row in grid:
     8     89.1 MiB -788466.2 MiB       65792           for spot in row:
     9     89.1 MiB -785396.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     75.0 MiB    -14.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     75.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     75.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     75.0 MiB      0.0 MiB           1       came_from = {}
    18     80.8 MiB  -2169.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     80.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     80.9 MiB -2869479.4 MiB       61456       while not open_set.empty():
    22     80.9 MiB -2869480.0 MiB       61456           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     80.9 MiB -2869482.0 MiB       61456           current = open_set.get()[1]
    28                                         
    29     80.9 MiB -2869483.7 MiB       61456           if current in remaining_goals:
    30     79.1 MiB   -471.2 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     79.1 MiB   -452.9 MiB          10               if not remaining_goals:
    32     24.6 MiB    -54.5 MiB           1                   break  # All goals found
    33                                         
    34     80.9 MiB -25717783.8 MiB      550847           for neighbor in current.neighbors:
    35     80.9 MiB -22848354.0 MiB      489392               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     80.9 MiB -22848363.2 MiB      489392               if current.row != neighbor.row and current.col != neighbor.col:
    38     80.9 MiB -11406355.2 MiB      244322                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     80.9 MiB -22848377.1 MiB      489392               if temp_g_score < g_score[neighbor]:
    41     80.9 MiB -2872632.6 MiB       61726                   came_from[neighbor] = current
    42     80.9 MiB -2872633.0 MiB       61726                   g_score[neighbor] = temp_g_score
    43     80.9 MiB -2872634.0 MiB       61726                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     80.9 MiB -2869478.1 MiB       61455           if draw is not None:
    46                                                     draw()
    47                                                     
    48     80.9 MiB -2869478.7 MiB       61455           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     24.6 MiB      0.0 MiB           1       paths = {}
    53     26.6 MiB      0.1 MiB          11       for goal in goals:
    54     26.6 MiB      1.9 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     26.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.1 MiB     87.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.1 MiB   -376.7 MiB         257       for row in grid:
     8     87.1 MiB -96489.7 MiB       65792           for spot in row:
     9     87.1 MiB -96117.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.7 MiB     -5.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     81.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     81.7 MiB      0.0 MiB           1       came_from = {}
    18     85.3 MiB -26872.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.0 MiB     -0.3 MiB           1       g_score[start] = 0
    20                                         
    21     85.1 MiB -3304359.6 MiB       64907       while not open_set.empty():
    22     85.1 MiB -3304362.5 MiB       64907           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.1 MiB -3304365.0 MiB       64907           current = open_set.get()[1]
    28                                         
    29     85.1 MiB -3304366.5 MiB       64907           if current in remaining_goals:
    30     84.8 MiB   -426.3 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     84.8 MiB   -422.5 MiB          10               if not remaining_goals:
    32     30.0 MiB    -54.8 MiB           1                   break  # All goals found
    33                                         
    34     85.1 MiB -29591608.6 MiB      581325           for neighbor in current.neighbors:
    35     85.1 MiB -26287302.5 MiB      516419               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.1 MiB -26287297.1 MiB      516419               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.1 MiB -13119205.5 MiB      257739                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.1 MiB -26287304.9 MiB      516419               if temp_g_score < g_score[neighbor]:
    41     85.1 MiB -3296854.5 MiB       64984                   came_from[neighbor] = current
    42     85.1 MiB -3296854.8 MiB       64984                   g_score[neighbor] = temp_g_score
    43     85.1 MiB -3296856.3 MiB       64984                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.1 MiB -3304357.0 MiB       64906           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.1 MiB -3304358.2 MiB       64906           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.0 MiB      0.0 MiB           1       paths = {}
    53     31.0 MiB      0.0 MiB          11       for goal in goals:
    54     31.0 MiB      1.0 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.6 MiB     85.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.6 MiB    -20.0 MiB         257       for row in grid:
     8     85.6 MiB  -5128.7 MiB       65792           for spot in row:
     9     85.6 MiB  -5108.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.4 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.4 MiB      0.0 MiB           1       came_from = {}
    18     87.4 MiB -44629.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.7 MiB -2455931.9 MiB       60329       while not open_set.empty():
    22     87.7 MiB -2455932.2 MiB       60329           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.7 MiB -2455932.9 MiB       60329           current = open_set.get()[1]
    28                                         
    29     87.7 MiB -2455933.1 MiB       60329           if current in remaining_goals:
    30     86.9 MiB   -381.9 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     86.9 MiB   -373.8 MiB          10               if not remaining_goals:
    32     34.8 MiB    -52.1 MiB           1                   break  # All goals found
    33                                         
    34     87.7 MiB -22017898.2 MiB      540806           for neighbor in current.neighbors:
    35     87.7 MiB -19562025.0 MiB      480478               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.7 MiB -19562016.3 MiB      480478               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.7 MiB -9766912.2 MiB      239882                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.7 MiB -19562026.8 MiB      480478               if temp_g_score < g_score[neighbor]:
    41     87.7 MiB -2450569.9 MiB       60633                   came_from[neighbor] = current
    42     87.7 MiB -2450570.7 MiB       60633                   g_score[neighbor] = temp_g_score
    43     87.7 MiB -2450572.1 MiB       60633                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.7 MiB -2455929.3 MiB       60328           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.7 MiB -2455931.0 MiB       60328           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.8 MiB      0.0 MiB           1       paths = {}
    53     35.1 MiB      0.0 MiB          11       for goal in goals:
    54     35.1 MiB      0.3 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.1 MiB     84.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.1 MiB  -6361.5 MiB         257       for row in grid:
     8     84.1 MiB -1627376.8 MiB       65792           for spot in row:
     9     84.1 MiB -1621045.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     22.1 MiB    -62.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     22.4 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     22.6 MiB      0.2 MiB           1       open_set.put((0, start))
    17     22.6 MiB      0.0 MiB           1       came_from = {}
    18     32.9 MiB  -2797.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     32.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     33.4 MiB -528212.5 MiB       61967       while not open_set.empty():
    22     33.4 MiB -528213.1 MiB       61967           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     33.4 MiB -528215.0 MiB       61967           current = open_set.get()[1]
    28                                         
    29     33.4 MiB -528216.4 MiB       61967           if current in remaining_goals:
    30     29.4 MiB    -92.5 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.4 MiB    -35.6 MiB          10               if not remaining_goals:
    32     21.6 MiB     -7.8 MiB           1                   break  # All goals found
    33                                         
    34     33.4 MiB -4734508.8 MiB      555410           for neighbor in current.neighbors:
    35     33.4 MiB -4206360.4 MiB      493444               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     33.4 MiB -4206359.2 MiB      493444               if current.row != neighbor.row and current.col != neighbor.col:
    38     33.4 MiB -2099991.4 MiB      246342                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     33.4 MiB -4206366.4 MiB      493444               if temp_g_score < g_score[neighbor]:
    41     33.4 MiB -529237.9 MiB       62225                   came_from[neighbor] = current
    42     33.4 MiB -529238.6 MiB       62225                   g_score[neighbor] = temp_g_score
    43     33.4 MiB -529239.3 MiB       62225                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     33.4 MiB -528210.8 MiB       61966           if draw is not None:
    46                                                     draw()
    47                                                     
    48     33.4 MiB -528211.9 MiB       61966           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     21.6 MiB      0.0 MiB           1       paths = {}
    53     24.0 MiB      0.0 MiB          11       for goal in goals:
    54     24.0 MiB      2.5 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     24.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.7 MiB     85.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.7 MiB   -349.3 MiB         257       for row in grid:
     8     85.7 MiB -89367.1 MiB       65792           for spot in row:
     9     85.7 MiB -89019.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.8 MiB     -3.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.8 MiB      0.0 MiB           1       came_from = {}
    18     86.7 MiB -34882.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.0 MiB     -2.6 MiB           1       g_score[start] = 0
    20                                         
    21     84.6 MiB -3173088.6 MiB       59420       while not open_set.empty():
    22     84.6 MiB -3173107.5 MiB       59420           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.6 MiB -3173109.0 MiB       59420           current = open_set.get()[1]
    28                                         
    29     84.6 MiB -3173110.1 MiB       59420           if current in remaining_goals:
    30     36.8 MiB   -536.8 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.8 MiB      0.0 MiB          10               if not remaining_goals:
    32     36.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.6 MiB -28446536.9 MiB      532724           for neighbor in current.neighbors:
    35     84.6 MiB -25273970.5 MiB      473305               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.6 MiB -25273953.2 MiB      473305               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.6 MiB -12618601.2 MiB      236312                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.6 MiB -25273958.6 MiB      473305               if temp_g_score < g_score[neighbor]:
    41     84.6 MiB -3189373.3 MiB       59757                   came_from[neighbor] = current
    42     84.6 MiB -3189373.8 MiB       59757                   g_score[neighbor] = temp_g_score
    43     84.6 MiB -3189376.9 MiB       59757                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.6 MiB -3173060.2 MiB       59419           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.6 MiB -3173061.4 MiB       59419           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.8 MiB      0.0 MiB           1       paths = {}
    53     36.9 MiB      0.0 MiB          11       for goal in goals:
    54     36.9 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.9 MiB     91.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.9 MiB  -1037.4 MiB         257       for row in grid:
     8     91.9 MiB -265793.5 MiB       65792           for spot in row:
     9     91.9 MiB -264759.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.9 MiB     -7.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.9 MiB      0.0 MiB           1       came_from = {}
    18     89.8 MiB  -2745.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.8 MiB -3449877.5 MiB       64117       while not open_set.empty():
    22     90.8 MiB -3449878.0 MiB       64117           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.8 MiB -3449878.7 MiB       64117           current = open_set.get()[1]
    28                                         
    29     90.8 MiB -3449879.1 MiB       64117           if current in remaining_goals:
    30     90.1 MiB   -556.0 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.1 MiB   -549.0 MiB          10               if not remaining_goals:
    32     23.2 MiB    -66.8 MiB           1                   break  # All goals found
    33                                         
    34     90.8 MiB -30901009.8 MiB      574323           for neighbor in current.neighbors:
    35     90.8 MiB -27451149.2 MiB      510207               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.8 MiB -27451199.1 MiB      510207               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.8 MiB -13701235.6 MiB      254651                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.8 MiB -27451211.9 MiB      510207               if temp_g_score < g_score[neighbor]:
    41     90.8 MiB -3435606.2 MiB       64230                   came_from[neighbor] = current
    42     90.8 MiB -3435607.3 MiB       64230                   g_score[neighbor] = temp_g_score
    43     90.8 MiB -3435608.9 MiB       64230                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.8 MiB -3449876.0 MiB       64116           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.8 MiB -3449876.3 MiB       64116           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     23.2 MiB      0.0 MiB           1       paths = {}
    53     25.6 MiB      0.1 MiB          11       for goal in goals:
    54     25.6 MiB      2.3 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     25.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.8 MiB     89.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.8 MiB   -555.5 MiB         257       for row in grid:
     8     89.8 MiB -142317.5 MiB       65792           for spot in row:
     9     89.8 MiB -141764.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.5 MiB     -3.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     86.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     86.9 MiB      0.0 MiB           1       came_from = {}
    18     91.0 MiB  -9144.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.0 MiB -3570271.4 MiB       64373       while not open_set.empty():
    22     91.0 MiB -3570272.0 MiB       64373           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.0 MiB -3570274.2 MiB       64373           current = open_set.get()[1]
    28                                         
    29     91.0 MiB -3570275.2 MiB       64373           if current in remaining_goals:
    30     90.5 MiB   -547.8 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.5 MiB   -541.9 MiB          10               if not remaining_goals:
    32     25.3 MiB    -65.1 MiB           1                   break  # All goals found
    33                                         
    34     91.0 MiB -31984718.5 MiB      576594           for neighbor in current.neighbors:
    35     91.0 MiB -28414470.1 MiB      512222               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.0 MiB -28414476.8 MiB      512222               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.0 MiB -14182821.0 MiB      255653                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.0 MiB -28414498.1 MiB      512222               if temp_g_score < g_score[neighbor]:
    41     91.0 MiB -3562362.4 MiB       64475                   came_from[neighbor] = current
    42     91.0 MiB -3562363.8 MiB       64475                   g_score[neighbor] = temp_g_score
    43     91.0 MiB -3562366.0 MiB       64475                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.0 MiB -3570266.7 MiB       64372           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.0 MiB -3570268.0 MiB       64372           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     25.3 MiB      0.0 MiB           1       paths = {}
    53     27.5 MiB      0.1 MiB          11       for goal in goals:
    54     27.5 MiB      2.1 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.1 MiB     90.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.1 MiB  -1122.9 MiB         257       for row in grid:
     8     90.1 MiB -286497.9 MiB       65792           for spot in row:
     9     90.1 MiB -285400.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     61.7 MiB    -28.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     62.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     62.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     62.2 MiB      0.0 MiB           1       came_from = {}
    18     64.4 MiB -1834521.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     31.0 MiB    -33.4 MiB           1       g_score[start] = 0
    20                                         
    21     44.8 MiB -511215.1 MiB       59689       while not open_set.empty():
    22     44.8 MiB -511221.5 MiB       59689           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     44.8 MiB -511222.3 MiB       59689           current = open_set.get()[1]
    28                                         
    29     44.8 MiB -511223.3 MiB       59689           if current in remaining_goals:
    30     35.8 MiB    -81.3 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.8 MiB    -16.7 MiB          10               if not remaining_goals:
    32     32.1 MiB     -3.7 MiB           1                   break  # All goals found
    33                                         
    34     44.8 MiB -4582603.8 MiB      535333           for neighbor in current.neighbors:
    35     44.8 MiB -4071460.9 MiB      475645               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     44.8 MiB -4071451.2 MiB      475645               if current.row != neighbor.row and current.col != neighbor.col:
    38     44.8 MiB -2032705.0 MiB      237513                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     44.8 MiB -4071463.4 MiB      475645               if temp_g_score < g_score[neighbor]:
    41     44.8 MiB -510847.0 MiB       60088                   came_from[neighbor] = current
    42     44.8 MiB -510847.6 MiB       60088                   g_score[neighbor] = temp_g_score
    43     44.8 MiB -510848.0 MiB       60088                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     44.8 MiB -511214.8 MiB       59688           if draw is not None:
    46                                                     draw()
    47                                                     
    48     44.8 MiB -511214.8 MiB       59688           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.1 MiB      0.0 MiB           1       paths = {}
    53     32.8 MiB      0.0 MiB          11       for goal in goals:
    54     32.8 MiB      0.6 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.1 MiB     87.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.1 MiB  -8981.0 MiB         257       for row in grid:
     8     87.1 MiB -2301535.1 MiB       65792           for spot in row:
     9     87.1 MiB -2292599.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     20.0 MiB    -67.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     20.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     20.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     20.5 MiB      0.0 MiB           1       came_from = {}
    18     31.0 MiB  -5989.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     31.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     40.2 MiB -191917.3 MiB       52278       while not open_set.empty():
    22     40.2 MiB -191917.8 MiB       52278           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     40.2 MiB -191919.0 MiB       52278           current = open_set.get()[1]
    28                                         
    29     40.2 MiB -191919.7 MiB       52278           if current in remaining_goals:
    30     38.8 MiB    -45.8 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.8 MiB    -43.1 MiB          10               if not remaining_goals:
    32     38.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     40.2 MiB -1724173.3 MiB      469165           for neighbor in current.neighbors:
    35     40.2 MiB -1532266.7 MiB      416888               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     40.2 MiB -1532256.5 MiB      416888               if current.row != neighbor.row and current.col != neighbor.col:
    38     40.2 MiB -765645.1 MiB      208223                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     40.2 MiB -1532264.4 MiB      416888               if temp_g_score < g_score[neighbor]:
    41     40.2 MiB -195680.7 MiB       52842                   came_from[neighbor] = current
    42     40.2 MiB -195684.5 MiB       52842                   g_score[neighbor] = temp_g_score
    43     40.2 MiB -195685.7 MiB       52842                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     40.2 MiB -191915.8 MiB       52277           if draw is not None:
    46                                                     draw()
    47                                                     
    48     40.2 MiB -191916.0 MiB       52277           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.8 MiB      0.0 MiB           1       paths = {}
    53     47.1 MiB      0.0 MiB          11       for goal in goals:
    54     47.1 MiB      8.3 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.6 MiB     88.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.6 MiB    -12.8 MiB         257       for row in grid:
     8     88.6 MiB  -3272.2 MiB       65792           for spot in row:
     9     88.6 MiB  -3259.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.5 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.5 MiB      0.0 MiB           1       came_from = {}
    18     93.4 MiB   -158.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.4 MiB -2976840.5 MiB       63826       while not open_set.empty():
    22     93.4 MiB -2976842.8 MiB       63826           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.4 MiB -2976844.1 MiB       63826           current = open_set.get()[1]
    28                                         
    29     93.4 MiB -2976844.9 MiB       63826           if current in remaining_goals:
    30     82.7 MiB   -495.7 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     82.7 MiB   -388.7 MiB          10               if not remaining_goals:
    32     35.7 MiB    -47.0 MiB           1                   break  # All goals found
    33                                         
    34     93.4 MiB -26646274.5 MiB      571883           for neighbor in current.neighbors:
    35     93.4 MiB -23669571.6 MiB      508058               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.4 MiB -23669570.8 MiB      508058               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.4 MiB -11810764.6 MiB      253606                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.4 MiB -23669581.4 MiB      508058               if temp_g_score < g_score[neighbor]:
    41     93.4 MiB -2958429.7 MiB       63998                   came_from[neighbor] = current
    42     93.4 MiB -2958430.9 MiB       63998                   g_score[neighbor] = temp_g_score
    43     93.4 MiB -2958442.7 MiB       63998                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.4 MiB -2976837.6 MiB       63825           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.4 MiB -2976838.6 MiB       63825           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.7 MiB      0.0 MiB           1       paths = {}
    53     35.8 MiB      0.0 MiB          11       for goal in goals:
    54     35.8 MiB      0.1 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.4 MiB     -0.6 MiB         257       for row in grid:
     8     86.4 MiB   -164.6 MiB       65792           for spot in row:
     9     86.4 MiB   -164.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.4 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.4 MiB      0.0 MiB           1       came_from = {}
    18     91.9 MiB -24414.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.9 MiB     -2.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.9 MiB -3324383.9 MiB       64439       while not open_set.empty():
    22     89.9 MiB -3324384.4 MiB       64439           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.9 MiB -3324385.3 MiB       64439           current = open_set.get()[1]
    28                                         
    29     89.9 MiB -3324386.1 MiB       64439           if current in remaining_goals:
    30     44.4 MiB   -497.4 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.4 MiB    -24.3 MiB          10               if not remaining_goals:
    32     36.6 MiB     -7.8 MiB           1                   break  # All goals found
    33                                         
    34     89.9 MiB -29783457.0 MiB      577360           for neighbor in current.neighbors:
    35     89.9 MiB -26459514.6 MiB      512922               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.9 MiB -26459512.0 MiB      512922               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.9 MiB -13207318.5 MiB      256031                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.9 MiB -26459566.8 MiB      512922               if temp_g_score < g_score[neighbor]:
    41     89.9 MiB -3325765.4 MiB       64597                   came_from[neighbor] = current
    42     89.9 MiB -3325766.0 MiB       64597                   g_score[neighbor] = temp_g_score
    43     89.9 MiB -3325767.6 MiB       64597                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.9 MiB -3324381.7 MiB       64438           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.9 MiB -3324383.2 MiB       64438           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.6 MiB      0.0 MiB           1       paths = {}
    53     36.8 MiB      0.0 MiB          11       for goal in goals:
    54     36.8 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.9 MiB     84.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.9 MiB    -33.2 MiB         257       for row in grid:
     8     84.9 MiB  -8399.1 MiB       65792           for spot in row:
     9     84.9 MiB  -8366.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.1 MiB     -0.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.1 MiB      0.0 MiB           1       came_from = {}
    18     86.7 MiB -70073.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.6 MiB     -1.1 MiB           1       g_score[start] = 0
    20                                         
    21     85.7 MiB -2315960.4 MiB       64593       while not open_set.empty():
    22     85.7 MiB -2315961.0 MiB       64593           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.7 MiB -2315961.9 MiB       64593           current = open_set.get()[1]
    28                                         
    29     85.7 MiB -2315962.4 MiB       64593           if current in remaining_goals:
    30     77.2 MiB   -374.2 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     77.2 MiB   -288.9 MiB          10               if not remaining_goals:
    32     34.1 MiB    -43.0 MiB           1                   break  # All goals found
    33                                         
    34     85.7 MiB -20708232.8 MiB      578657           for neighbor in current.neighbors:
    35     85.7 MiB -18392370.8 MiB      514065               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.7 MiB -18392370.7 MiB      514065               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.7 MiB -9173786.6 MiB      256588                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.7 MiB -18392393.6 MiB      514065               if temp_g_score < g_score[neighbor]:
    41     85.7 MiB -2290213.0 MiB       64722                   came_from[neighbor] = current
    42     85.7 MiB -2290216.5 MiB       64722                   g_score[neighbor] = temp_g_score
    43     85.7 MiB -2290220.3 MiB       64722                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.7 MiB -2315957.8 MiB       64592           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.7 MiB -2315959.7 MiB       64592           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.1 MiB      0.0 MiB           1       paths = {}
    53     35.0 MiB      0.0 MiB          11       for goal in goals:
    54     35.0 MiB      0.8 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.6 MiB     85.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.6 MiB    -66.5 MiB         257       for row in grid:
     8     85.6 MiB -16986.9 MiB       65792           for spot in row:
     9     85.6 MiB -16921.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.7 MiB     -0.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.7 MiB      0.0 MiB           1       came_from = {}
    18     90.4 MiB     -9.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.1 MiB -2026470.7 MiB       57437       while not open_set.empty():
    22     91.1 MiB -2026473.1 MiB       57437           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.1 MiB -2026474.5 MiB       57437           current = open_set.get()[1]
    28                                         
    29     91.1 MiB -2026475.4 MiB       57437           if current in remaining_goals:
    30     91.0 MiB   -346.6 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     91.0 MiB   -345.3 MiB          10               if not remaining_goals:
    32     40.4 MiB    -50.6 MiB           1                   break  # All goals found
    33                                         
    34     91.1 MiB -18181296.2 MiB      515030           for neighbor in current.neighbors:
    35     91.1 MiB -16154850.2 MiB      457594               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.1 MiB -16154847.4 MiB      457594               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.1 MiB -8068046.0 MiB      228482                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.1 MiB -16154859.4 MiB      457594               if temp_g_score < g_score[neighbor]:
    41     91.1 MiB -2028691.1 MiB       57825                   came_from[neighbor] = current
    42     91.1 MiB -2028693.3 MiB       57825                   g_score[neighbor] = temp_g_score
    43     91.1 MiB -2028704.0 MiB       57825                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.1 MiB -2026457.7 MiB       57436           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.1 MiB -2026460.6 MiB       57436           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.4 MiB      0.0 MiB           1       paths = {}
    53     40.8 MiB      0.0 MiB          11       for goal in goals:
    54     40.8 MiB      0.4 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.4 MiB     93.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.4 MiB   -370.9 MiB         257       for row in grid:
     8     93.4 MiB -94856.2 MiB       65792           for spot in row:
     9     93.4 MiB -94487.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.1 MiB     -3.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     90.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     90.5 MiB      0.0 MiB           1       came_from = {}
    18     93.7 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.0 MiB -2665454.8 MiB       55242       while not open_set.empty():
    22     94.0 MiB -2665456.0 MiB       55242           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.0 MiB -2665457.2 MiB       55242           current = open_set.get()[1]
    28                                         
    29     94.0 MiB -2665458.3 MiB       55242           if current in remaining_goals:
    30     80.8 MiB   -535.2 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     80.8 MiB   -402.9 MiB          10               if not remaining_goals:
    32     38.2 MiB    -42.5 MiB           1                   break  # All goals found
    33                                         
    34     94.0 MiB -23911772.8 MiB      495383           for neighbor in current.neighbors:
    35     94.0 MiB -21246448.3 MiB      440142               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.0 MiB -21246480.7 MiB      440142               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.0 MiB -10610508.4 MiB      219774                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.0 MiB -21246495.1 MiB      440142               if temp_g_score < g_score[neighbor]:
    41     94.0 MiB -2674633.0 MiB       55666                   came_from[neighbor] = current
    42     94.0 MiB -2674634.1 MiB       55666                   g_score[neighbor] = temp_g_score
    43     94.0 MiB -2674637.0 MiB       55666                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.0 MiB -2665450.6 MiB       55241           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.0 MiB -2665453.3 MiB       55241           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.2 MiB      0.0 MiB           1       paths = {}
    53     38.5 MiB      0.0 MiB          11       for goal in goals:
    54     38.5 MiB      0.3 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.3 MiB     91.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.3 MiB    -17.8 MiB         257       for row in grid:
     8     91.3 MiB  -4535.6 MiB       65792           for spot in row:
     9     91.3 MiB  -4517.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.1 MiB     -0.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.1 MiB      0.0 MiB           1       came_from = {}
    18     95.9 MiB    -29.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.9 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.0 MiB -2993694.1 MiB       52933       while not open_set.empty():
    22     96.0 MiB -2993695.7 MiB       52933           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.0 MiB -2993699.2 MiB       52933           current = open_set.get()[1]
    28                                         
    29     96.0 MiB -2993703.7 MiB       52933           if current in remaining_goals:
    30     96.0 MiB   -557.4 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.0 MiB   -557.4 MiB          10               if not remaining_goals:
    32     27.0 MiB    -69.0 MiB           1                   break  # All goals found
    33                                         
    34     96.0 MiB -26855260.4 MiB      474593           for neighbor in current.neighbors:
    35     96.0 MiB -23861588.7 MiB      421661               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.0 MiB -23861592.2 MiB      421661               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.0 MiB -11916267.6 MiB      210532                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.0 MiB -23861617.8 MiB      421661               if temp_g_score < g_score[neighbor]:
    41     96.0 MiB -3000637.1 MiB       53320                   came_from[neighbor] = current
    42     96.0 MiB -3000639.2 MiB       53320                   g_score[neighbor] = temp_g_score
    43     96.0 MiB -3000641.9 MiB       53320                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.0 MiB -2993690.3 MiB       52932           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.0 MiB -2993692.1 MiB       52932           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.0 MiB      0.0 MiB           1       paths = {}
    53     28.2 MiB      0.1 MiB          11       for goal in goals:
    54     28.2 MiB      1.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     28.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.1 MiB     89.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.1 MiB  -7032.0 MiB         257       for row in grid:
     8     89.1 MiB -1797518.2 MiB       65792           for spot in row:
     9     89.1 MiB -1790523.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     21.5 MiB    -67.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     21.8 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     22.1 MiB      0.2 MiB           1       open_set.put((0, start))
    17     22.1 MiB      0.0 MiB           1       came_from = {}
    18     34.3 MiB     12.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     34.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     44.5 MiB -399361.3 MiB       58340       while not open_set.empty():
    22     44.5 MiB -399361.5 MiB       58340           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     44.5 MiB -399362.3 MiB       58340           current = open_set.get()[1]
    28                                         
    29     44.5 MiB -399362.7 MiB       58340           if current in remaining_goals:
    30     37.1 MiB    -73.5 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.1 MiB    -17.1 MiB          10               if not remaining_goals:
    32     33.1 MiB     -4.0 MiB           1                   break  # All goals found
    33                                         
    34     44.5 MiB -3580032.8 MiB      523064           for neighbor in current.neighbors:
    35     44.5 MiB -3180737.5 MiB      464725               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     44.5 MiB -3180734.1 MiB      464725               if current.row != neighbor.row and current.col != neighbor.col:
    38     44.5 MiB -1588044.3 MiB      232032                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     44.5 MiB -3180740.9 MiB      464725               if temp_g_score < g_score[neighbor]:
    41     44.5 MiB -398254.0 MiB       58695                   came_from[neighbor] = current
    42     44.5 MiB -398255.8 MiB       58695                   g_score[neighbor] = temp_g_score
    43     44.5 MiB -398256.0 MiB       58695                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     44.5 MiB -399360.8 MiB       58339           if draw is not None:
    46                                                     draw()
    47                                                     
    48     44.5 MiB -399361.1 MiB       58339           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.1 MiB      0.0 MiB           1       paths = {}
    53     34.1 MiB      0.0 MiB          11       for goal in goals:
    54     34.1 MiB      1.0 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.4 MiB     90.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.4 MiB      0.0 MiB         257       for row in grid:
     8     90.4 MiB      0.0 MiB       65792           for spot in row:
     9     90.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.4 MiB      0.0 MiB           1       came_from = {}
    18     91.8 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.4 MiB -1229837.8 MiB       58459       while not open_set.empty():
    22     92.4 MiB -1229839.7 MiB       58459           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.4 MiB -1229842.6 MiB       58459           current = open_set.get()[1]
    28                                         
    29     92.4 MiB -1229843.3 MiB       58459           if current in remaining_goals:
    30     92.0 MiB   -140.2 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     92.0 MiB   -135.8 MiB          10               if not remaining_goals:
    32     43.8 MiB    -48.1 MiB           1                   break  # All goals found
    33                                         
    34     92.4 MiB -11028842.1 MiB      524135           for neighbor in current.neighbors:
    35     92.4 MiB -9799019.9 MiB      465677               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.4 MiB -9799027.6 MiB      465677               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.4 MiB -4892989.6 MiB      232508                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.4 MiB -9799041.3 MiB      465677               if temp_g_score < g_score[neighbor]:
    41     92.4 MiB -1227410.2 MiB       58816                   came_from[neighbor] = current
    42     92.4 MiB -1227412.9 MiB       58816                   g_score[neighbor] = temp_g_score
    43     92.4 MiB -1227414.8 MiB       58816                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.4 MiB -1229834.9 MiB       58458           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.4 MiB -1229836.1 MiB       58458           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.8 MiB      0.0 MiB           1       paths = {}
    53     44.2 MiB      0.0 MiB          11       for goal in goals:
    54     44.2 MiB      0.4 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.0 MiB     90.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.0 MiB      0.0 MiB         257       for row in grid:
     8     90.0 MiB      0.0 MiB       65792           for spot in row:
     9     90.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.0 MiB      0.0 MiB           1       came_from = {}
    18     95.1 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.7 MiB -2540148.6 MiB       57207       while not open_set.empty():
    22     95.7 MiB -2540160.6 MiB       57207           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.7 MiB -2540165.4 MiB       57207           current = open_set.get()[1]
    28                                         
    29     95.7 MiB -2540166.1 MiB       57207           if current in remaining_goals:
    30     95.2 MiB   -487.9 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     95.2 MiB   -483.6 MiB          10               if not remaining_goals:
    32     36.0 MiB    -59.2 MiB           1                   break  # All goals found
    33                                         
    34     95.7 MiB -22768037.2 MiB      513130           for neighbor in current.neighbors:
    35     95.7 MiB -20227910.6 MiB      455924               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.7 MiB -20227915.9 MiB      455924               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.7 MiB -10098513.3 MiB      227675                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.7 MiB -20227924.7 MiB      455924               if temp_g_score < g_score[neighbor]:
    41     95.7 MiB -2536505.1 MiB       57651                   came_from[neighbor] = current
    42     95.7 MiB -2536506.9 MiB       57651                   g_score[neighbor] = temp_g_score
    43     95.7 MiB -2536511.5 MiB       57651                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.7 MiB -2540138.6 MiB       57206           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.7 MiB -2540139.9 MiB       57206           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.0 MiB      0.0 MiB           1       paths = {}
    53     36.3 MiB      0.0 MiB          11       for goal in goals:
    54     36.3 MiB      0.3 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.8 MiB     86.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.8 MiB      0.0 MiB         257       for row in grid:
     8     86.8 MiB      0.0 MiB       65792           for spot in row:
     9     86.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.8 MiB      0.0 MiB           1       came_from = {}
    18     92.3 MiB   -478.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.3 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.5 MiB -3236958.8 MiB       64856       while not open_set.empty():
    22     92.5 MiB -3236959.6 MiB       64856           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.5 MiB -3236962.2 MiB       64856           current = open_set.get()[1]
    28                                         
    29     92.5 MiB -3236963.3 MiB       64856           if current in remaining_goals:
    30     41.7 MiB   -550.0 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.7 MiB     -5.1 MiB          10               if not remaining_goals:
    32     41.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.5 MiB -28995791.0 MiB      580866           for neighbor in current.neighbors:
    35     92.5 MiB -25759354.9 MiB      516011               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.5 MiB -25759355.4 MiB      516011               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.5 MiB -12857103.8 MiB      257535                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.5 MiB -25759368.5 MiB      516011               if temp_g_score < g_score[neighbor]:
    41     92.5 MiB -3228025.3 MiB       64933                   came_from[neighbor] = current
    42     92.5 MiB -3228026.1 MiB       64933                   g_score[neighbor] = temp_g_score
    43     92.5 MiB -3228028.0 MiB       64933                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.5 MiB -3236942.5 MiB       64855           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.5 MiB -3236956.8 MiB       64855           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.7 MiB      0.0 MiB           1       paths = {}
    53     42.2 MiB      0.0 MiB          11       for goal in goals:
    54     42.2 MiB      0.5 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.2 MiB     86.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.2 MiB      0.0 MiB         257       for row in grid:
     8     86.2 MiB      0.0 MiB       65792           for spot in row:
     9     86.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.2 MiB      0.0 MiB           1       came_from = {}
    18     91.2 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.3 MiB -1942108.7 MiB       62892       while not open_set.empty():
    22     91.3 MiB -1942109.5 MiB       62892           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.3 MiB -1942113.0 MiB       62892           current = open_set.get()[1]
    28                                         
    29     91.3 MiB -1942114.2 MiB       62892           if current in remaining_goals:
    30     91.2 MiB   -305.0 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     91.2 MiB   -304.1 MiB          10               if not remaining_goals:
    32     44.3 MiB    -46.9 MiB           1                   break  # All goals found
    33                                         
    34     91.3 MiB -17384821.9 MiB      563618           for neighbor in current.neighbors:
    35     91.3 MiB -15442733.7 MiB      500727               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.3 MiB -15442736.8 MiB      500727               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.3 MiB -7705788.7 MiB      249964                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.3 MiB -15442750.4 MiB      500727               if temp_g_score < g_score[neighbor]:
    41     91.3 MiB -1927478.2 MiB       63111                   came_from[neighbor] = current
    42     91.3 MiB -1927479.4 MiB       63111                   g_score[neighbor] = temp_g_score
    43     91.3 MiB -1927482.5 MiB       63111                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.3 MiB -1942105.9 MiB       62891           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.3 MiB -1942107.4 MiB       62891           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.3 MiB      0.0 MiB           1       paths = {}
    53     44.7 MiB      0.0 MiB          11       for goal in goals:
    54     44.7 MiB      0.3 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.5 MiB     87.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.5 MiB      0.0 MiB         257       for row in grid:
     8     87.5 MiB      0.0 MiB       65792           for spot in row:
     9     87.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.5 MiB      0.0 MiB           1       came_from = {}
    18     92.0 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.2 MiB -2586117.5 MiB       63625       while not open_set.empty():
    22     92.2 MiB -2586119.1 MiB       63625           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.2 MiB -2586121.1 MiB       63625           current = open_set.get()[1]
    28                                         
    29     92.2 MiB -2586122.1 MiB       63625           if current in remaining_goals:
    30     69.5 MiB   -472.2 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     69.5 MiB   -243.6 MiB          10               if not remaining_goals:
    32     42.8 MiB    -26.7 MiB           1                   break  # All goals found
    33                                         
    34     92.2 MiB -23175749.1 MiB      569952           for neighbor in current.neighbors:
    35     92.2 MiB -20589852.3 MiB      506328               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.2 MiB -20589855.4 MiB      506328               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.2 MiB -10278543.5 MiB      252721                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.2 MiB -20589877.4 MiB      506328               if temp_g_score < g_score[neighbor]:
    41     92.2 MiB -2576864.4 MiB       63757                   came_from[neighbor] = current
    42     92.2 MiB -2576866.0 MiB       63757                   g_score[neighbor] = temp_g_score
    43     92.2 MiB -2576868.1 MiB       63757                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.2 MiB -2586112.7 MiB       63624           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.2 MiB -2586113.8 MiB       63624           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.8 MiB      0.0 MiB           1       paths = {}
    53     42.9 MiB      0.0 MiB          11       for goal in goals:
    54     42.9 MiB      0.1 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.7 MiB     86.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.7 MiB   -189.9 MiB         257       for row in grid:
     8     86.7 MiB -48778.8 MiB       65792           for spot in row:
     9     86.7 MiB -48589.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.0 MiB     -0.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.0 MiB      0.0 MiB           1       came_from = {}
    18     91.1 MiB      5.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.1 MiB -1736129.4 MiB       47065       while not open_set.empty():
    22     91.1 MiB -1736130.8 MiB       47065           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.1 MiB -1736134.8 MiB       47065           current = open_set.get()[1]
    28                                         
    29     91.1 MiB -1736135.8 MiB       47065           if current in remaining_goals:
    30     77.9 MiB   -425.5 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     77.9 MiB   -293.3 MiB          10               if not remaining_goals:
    32     46.2 MiB    -31.7 MiB           1                   break  # All goals found
    33                                         
    34     91.1 MiB -15576781.1 MiB      422131           for neighbor in current.neighbors:
    35     91.1 MiB -13840786.7 MiB      375067               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.1 MiB -13840791.8 MiB      375067               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.1 MiB -6912442.2 MiB      187293                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.1 MiB -13840812.3 MiB      375067               if temp_g_score < g_score[neighbor]:
    41     91.1 MiB -1744318.5 MiB       47538                   came_from[neighbor] = current
    42     91.1 MiB -1744320.0 MiB       47538                   g_score[neighbor] = temp_g_score
    43     91.1 MiB -1744322.2 MiB       47538                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.1 MiB -1736126.3 MiB       47064           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.1 MiB -1736128.1 MiB       47064           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.2 MiB      0.0 MiB           1       paths = {}
    53     46.6 MiB      0.0 MiB          11       for goal in goals:
    54     46.6 MiB      0.4 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.4 MiB     94.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.4 MiB   -135.2 MiB         257       for row in grid:
     8     94.4 MiB -34622.1 MiB       65792           for spot in row:
     9     94.4 MiB -34488.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.7 MiB     -1.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.7 MiB      0.0 MiB           1       came_from = {}
    18     94.5 MiB -51353.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.3 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     94.3 MiB -1736402.5 MiB       49205       while not open_set.empty():
    22     94.3 MiB -1736403.2 MiB       49205           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.3 MiB -1736405.1 MiB       49205           current = open_set.get()[1]
    28                                         
    29     94.3 MiB -1736406.1 MiB       49205           if current in remaining_goals:
    30     81.0 MiB   -438.2 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     81.0 MiB   -304.4 MiB          10               if not remaining_goals:
    32     46.9 MiB    -34.1 MiB           1                   break  # All goals found
    33                                         
    34     94.3 MiB -15559429.1 MiB      441194           for neighbor in current.neighbors:
    35     94.3 MiB -13823162.1 MiB      391990               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.3 MiB -13823169.3 MiB      391990               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.3 MiB -6900362.9 MiB      195722                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.3 MiB -13823186.4 MiB      391990               if temp_g_score < g_score[neighbor]:
    41     94.3 MiB -1734194.3 MiB       49605                   came_from[neighbor] = current
    42     94.3 MiB -1734196.1 MiB       49605                   g_score[neighbor] = temp_g_score
    43     94.3 MiB -1734199.2 MiB       49605                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.3 MiB -1736400.8 MiB       49204           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.3 MiB -1736401.6 MiB       49204           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.9 MiB      0.0 MiB           1       paths = {}
    53     47.1 MiB      0.0 MiB          11       for goal in goals:
    54     47.1 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.0 MiB     93.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.0 MiB   -188.3 MiB         257       for row in grid:
     8     93.0 MiB -47854.1 MiB       65792           for spot in row:
     9     93.0 MiB -47667.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.2 MiB     -2.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.2 MiB      0.0 MiB           1       came_from = {}
    18     91.3 MiB -429046.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.0 MiB     -7.2 MiB           1       g_score[start] = 0
    20                                         
    21     84.1 MiB -2106600.4 MiB       57034       while not open_set.empty():
    22     84.1 MiB -2106602.1 MiB       57034           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.1 MiB -2106611.0 MiB       57034           current = open_set.get()[1]
    28                                         
    29     84.1 MiB -2106615.5 MiB       57034           if current in remaining_goals:
    30     83.2 MiB   -358.7 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     83.2 MiB   -349.5 MiB          10               if not remaining_goals:
    32     39.4 MiB    -43.8 MiB           1                   break  # All goals found
    33                                         
    34     84.1 MiB -18892683.4 MiB      511717           for neighbor in current.neighbors:
    35     84.1 MiB -16786111.3 MiB      454684               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.1 MiB -16786112.6 MiB      454684               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.1 MiB -8382038.0 MiB      227079                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.1 MiB -16786128.2 MiB      454684               if temp_g_score < g_score[neighbor]:
    41     84.1 MiB -2109991.2 MiB       57526                   came_from[neighbor] = current
    42     84.1 MiB -2109992.3 MiB       57526                   g_score[neighbor] = temp_g_score
    43     84.1 MiB -2109994.0 MiB       57526                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.1 MiB -2106596.2 MiB       57033           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.1 MiB -2106598.1 MiB       57033           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.4 MiB      0.0 MiB           1       paths = {}
    53     39.7 MiB      0.0 MiB          11       for goal in goals:
    54     39.7 MiB      0.3 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     39.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.4 MiB     90.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.4 MiB      0.0 MiB         257       for row in grid:
     8     90.4 MiB      0.0 MiB       65792           for spot in row:
     9     90.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.4 MiB      0.0 MiB           1       came_from = {}
    18     95.2 MiB      4.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.6 MiB -2890155.0 MiB       64205       while not open_set.empty():
    22     95.6 MiB -2890156.2 MiB       64205           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.6 MiB -2890158.5 MiB       64205           current = open_set.get()[1]
    28                                         
    29     95.6 MiB -2890160.2 MiB       64205           if current in remaining_goals:
    30     95.3 MiB   -426.4 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     95.3 MiB   -424.3 MiB          10               if not remaining_goals:
    32     39.7 MiB    -55.6 MiB           1                   break  # All goals found
    33                                         
    34     95.6 MiB -25875647.9 MiB      575192           for neighbor in current.neighbors:
    35     95.6 MiB -22985510.0 MiB      510988               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.6 MiB -22985518.3 MiB      510988               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.6 MiB -11470287.1 MiB      255054                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.6 MiB -22985538.4 MiB      510988               if temp_g_score < g_score[neighbor]:
    41     95.6 MiB -2873336.9 MiB       64343                   came_from[neighbor] = current
    42     95.6 MiB -2873339.1 MiB       64343                   g_score[neighbor] = temp_g_score
    43     95.6 MiB -2873342.4 MiB       64343                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.6 MiB -2890152.9 MiB       64204           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.6 MiB -2890154.0 MiB       64204           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.7 MiB      0.0 MiB           1       paths = {}
    53     40.5 MiB      0.0 MiB          11       for goal in goals:
    54     40.5 MiB      0.8 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.2 MiB     90.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.2 MiB      0.0 MiB         257       for row in grid:
     8     90.2 MiB      0.0 MiB       65792           for spot in row:
     9     90.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.2 MiB      0.0 MiB           1       came_from = {}
    18     94.0 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.8 MiB -289372.1 MiB       53939       while not open_set.empty():
    22     94.8 MiB -289372.4 MiB       53939           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.8 MiB -289372.8 MiB       53939           current = open_set.get()[1]
    28                                         
    29     94.8 MiB -289373.0 MiB       53939           if current in remaining_goals:
    30     94.3 MiB    -80.2 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     94.3 MiB    -75.7 MiB          10               if not remaining_goals:
    32     84.9 MiB     -9.5 MiB           1                   break  # All goals found
    33                                         
    34     94.8 MiB -2595763.3 MiB      483656           for neighbor in current.neighbors:
    35     94.8 MiB -2306401.0 MiB      429718               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.8 MiB -2306403.8 MiB      429718               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.8 MiB -1151790.3 MiB      214562                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.8 MiB -2306407.3 MiB      429718               if temp_g_score < g_score[neighbor]:
    41     94.8 MiB -289648.5 MiB       54339                   came_from[neighbor] = current
    42     94.8 MiB -289649.7 MiB       54339                   g_score[neighbor] = temp_g_score
    43     94.8 MiB -289650.0 MiB       54339                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.8 MiB -289371.1 MiB       53938           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.8 MiB -289371.4 MiB       53938           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     84.9 MiB      0.0 MiB           1       paths = {}
    53     85.0 MiB      0.0 MiB          11       for goal in goals:
    54     85.0 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     85.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.0 MiB     94.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.0 MiB   -201.7 MiB         257       for row in grid:
     8     94.0 MiB -50956.4 MiB       65792           for spot in row:
     9     94.0 MiB -50756.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.1 MiB     -3.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.1 MiB      0.0 MiB           1       came_from = {}
    18     91.7 MiB -60667.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.8 MiB -1797284.7 MiB       56962       while not open_set.empty():
    22     91.8 MiB -1797285.7 MiB       56962           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.8 MiB -1797287.8 MiB       56962           current = open_set.get()[1]
    28                                         
    29     91.8 MiB -1797289.0 MiB       56962           if current in remaining_goals:
    30     86.5 MiB   -383.9 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     86.5 MiB   -331.0 MiB          10               if not remaining_goals:
    32     45.0 MiB    -41.5 MiB           1                   break  # All goals found
    33                                         
    34     91.8 MiB -16113957.0 MiB      510692           for neighbor in current.neighbors:
    35     91.8 MiB -14316735.6 MiB      453731               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.8 MiB -14316738.1 MiB      453731               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.8 MiB -7148216.2 MiB      226540                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.8 MiB -14316754.6 MiB      453731               if temp_g_score < g_score[neighbor]:
    41     91.8 MiB -1794426.5 MiB       57317                   came_from[neighbor] = current
    42     91.8 MiB -1794427.8 MiB       57317                   g_score[neighbor] = temp_g_score
    43     91.8 MiB -1794430.8 MiB       57317                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.8 MiB -1797281.1 MiB       56961           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.8 MiB -1797282.7 MiB       56961           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.0 MiB      0.0 MiB           1       paths = {}
    53     45.3 MiB      0.0 MiB          11       for goal in goals:
    54     45.3 MiB      0.3 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.2 MiB     88.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.2 MiB     -0.2 MiB         257       for row in grid:
     8     88.2 MiB    -35.0 MiB       65792           for spot in row:
     9     88.2 MiB    -34.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.2 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.2 MiB      0.0 MiB           1       came_from = {}
    18     91.6 MiB  -5397.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.6 MiB -558873.1 MiB       39863       while not open_set.empty():
    22     91.6 MiB -558874.0 MiB       39863           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.6 MiB -558875.9 MiB       39863           current = open_set.get()[1]
    28                                         
    29     91.6 MiB -558876.6 MiB       39863           if current in remaining_goals:
    30     86.2 MiB   -228.0 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     86.2 MiB   -171.5 MiB          10               if not remaining_goals:
    32     57.8 MiB    -28.3 MiB           1                   break  # All goals found
    33                                         
    34     91.6 MiB -5009207.3 MiB      357658           for neighbor in current.neighbors:
    35     91.6 MiB -4450396.1 MiB      317796               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.6 MiB -4450403.0 MiB      317796               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.6 MiB -2221832.4 MiB      158715                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.6 MiB -4450412.9 MiB      317796               if temp_g_score < g_score[neighbor]:
    41     91.6 MiB -559965.7 MiB       40381                   came_from[neighbor] = current
    42     91.6 MiB -559966.3 MiB       40381                   g_score[neighbor] = temp_g_score
    43     91.6 MiB -559967.3 MiB       40381                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.6 MiB -558870.5 MiB       39862           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.6 MiB -558872.0 MiB       39862           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     57.8 MiB      0.0 MiB           1       paths = {}
    53     58.1 MiB      0.0 MiB          11       for goal in goals:
    54     58.1 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     58.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.0 MiB     88.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.0 MiB      0.0 MiB         257       for row in grid:
     8     88.0 MiB      0.0 MiB       65792           for spot in row:
     9     88.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.0 MiB      0.0 MiB           1       came_from = {}
    18     91.1 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.5 MiB -41314.7 MiB       65358       while not open_set.empty():
    22     93.5 MiB -41314.7 MiB       65358           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.5 MiB -41314.8 MiB       65358           current = open_set.get()[1]
    28                                         
    29     93.5 MiB -41314.8 MiB       65358           if current in remaining_goals:
    30     93.5 MiB     -9.1 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     93.5 MiB     -5.1 MiB          10               if not remaining_goals:
    32     93.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.5 MiB -370596.2 MiB      585279           for neighbor in current.neighbors:
    35     93.5 MiB -329285.8 MiB      519922               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.5 MiB -329286.2 MiB      519922               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.5 MiB -164438.8 MiB      259473                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.5 MiB -329286.8 MiB      519922               if temp_g_score < g_score[neighbor]:
    41     93.5 MiB -41474.4 MiB       65400                   came_from[neighbor] = current
    42     93.5 MiB -41476.9 MiB       65400                   g_score[neighbor] = temp_g_score
    43     93.5 MiB -41477.2 MiB       65400                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.5 MiB -41314.7 MiB       65357           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.5 MiB -41314.7 MiB       65357           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     93.5 MiB      0.0 MiB           1       paths = {}
    53     93.5 MiB      0.0 MiB          11       for goal in goals:
    54     93.5 MiB      0.0 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     93.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.2 MiB     94.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.2 MiB   -184.5 MiB         257       for row in grid:
     8     94.2 MiB -47237.2 MiB       65792           for spot in row:
     9     94.2 MiB -47054.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.3 MiB     -1.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.3 MiB      0.0 MiB           1       came_from = {}
    18     93.9 MiB -31734.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.9 MiB -1752226.8 MiB       64408       while not open_set.empty():
    22     93.9 MiB -1752228.1 MiB       64408           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.9 MiB -1752230.5 MiB       64408           current = open_set.get()[1]
    28                                         
    29     93.9 MiB -1752232.2 MiB       64408           if current in remaining_goals:
    30     90.3 MiB   -389.1 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.3 MiB   -351.9 MiB          10               if not remaining_goals:
    32     45.7 MiB    -44.6 MiB           1                   break  # All goals found
    33                                         
    34     93.9 MiB -15679291.4 MiB      576948           for neighbor in current.neighbors:
    35     93.9 MiB -13927114.5 MiB      512541               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.9 MiB -13927117.4 MiB      512541               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.9 MiB -6948565.9 MiB      255819                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.9 MiB -13927133.4 MiB      512541               if temp_g_score < g_score[neighbor]:
    41     93.9 MiB -1736959.3 MiB       64523                   came_from[neighbor] = current
    42     93.9 MiB -1736961.0 MiB       64523                   g_score[neighbor] = temp_g_score
    43     93.9 MiB -1736963.1 MiB       64523                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.9 MiB -1752223.0 MiB       64407           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.9 MiB -1752224.8 MiB       64407           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.7 MiB      0.0 MiB           1       paths = {}
    53     45.9 MiB      0.0 MiB          11       for goal in goals:
    54     45.9 MiB      0.1 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.6 MiB     93.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.6 MiB     -5.0 MiB         257       for row in grid:
     8     93.6 MiB  -1247.6 MiB       65792           for spot in row:
     9     93.6 MiB  -1242.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.5 MiB     -0.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.5 MiB      0.0 MiB           1       came_from = {}
    18     96.5 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.0 MiB -2442446.0 MiB       63606       while not open_set.empty():
    22     97.0 MiB -2442446.5 MiB       63606           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.0 MiB -2442448.4 MiB       63606           current = open_set.get()[1]
    28                                         
    29     97.0 MiB -2442449.7 MiB       63606           if current in remaining_goals:
    30     96.8 MiB   -398.6 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.8 MiB   -396.0 MiB          10               if not remaining_goals:
    32     44.4 MiB    -52.3 MiB           1                   break  # All goals found
    33                                         
    34     97.0 MiB -21847302.6 MiB      569906           for neighbor in current.neighbors:
    35     97.0 MiB -19404874.4 MiB      506301               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.0 MiB -19404882.9 MiB      506301               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.0 MiB -9680127.6 MiB      252728                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.0 MiB -19404898.8 MiB      506301               if temp_g_score < g_score[neighbor]:
    41     97.0 MiB -2418713.5 MiB       63779                   came_from[neighbor] = current
    42     97.0 MiB -2418715.0 MiB       63779                   g_score[neighbor] = temp_g_score
    43     97.0 MiB -2418717.3 MiB       63779                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.0 MiB -2442444.5 MiB       63605           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.0 MiB -2442445.4 MiB       63605           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.4 MiB      0.0 MiB           1       paths = {}
    53     44.6 MiB      0.0 MiB          11       for goal in goals:
    54     44.6 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.5 MiB     93.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.5 MiB      0.0 MiB         257       for row in grid:
     8     93.5 MiB      0.0 MiB       65792           for spot in row:
     9     93.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.5 MiB      0.0 MiB           1       came_from = {}
    18     98.8 MiB      5.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.1 MiB -3013696.5 MiB       55474       while not open_set.empty():
    22     99.1 MiB -3013697.7 MiB       55474           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.1 MiB -3013700.3 MiB       55474           current = open_set.get()[1]
    28                                         
    29     99.1 MiB -3013701.6 MiB       55474           if current in remaining_goals:
    30     71.7 MiB   -594.9 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     71.7 MiB   -321.2 MiB          10               if not remaining_goals:
    32     44.5 MiB    -27.2 MiB           1                   break  # All goals found
    33                                         
    34     99.1 MiB -27017470.7 MiB      497557           for neighbor in current.neighbors:
    35     99.1 MiB -24004035.9 MiB      442084               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.1 MiB -24004042.7 MiB      442084               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.1 MiB -11984552.2 MiB      220759                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.1 MiB -24004061.1 MiB      442084               if temp_g_score < g_score[neighbor]:
    41     99.1 MiB -3017497.2 MiB       55916                   came_from[neighbor] = current
    42     99.1 MiB -3017498.8 MiB       55916                   g_score[neighbor] = temp_g_score
    43     99.1 MiB -3017501.4 MiB       55916                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.1 MiB -3013693.9 MiB       55473           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.1 MiB -3013695.1 MiB       55473           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.5 MiB      0.0 MiB           1       paths = {}
    53     44.7 MiB      0.0 MiB          11       for goal in goals:
    54     44.7 MiB      0.2 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.0 MiB     93.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.0 MiB      0.0 MiB         257       for row in grid:
     8     93.0 MiB      0.0 MiB       65792           for spot in row:
     9     93.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.0 MiB      0.0 MiB           1       came_from = {}
    18     96.0 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.2 MiB -638962.7 MiB       62327       while not open_set.empty():
    22     96.2 MiB -638963.2 MiB       62327           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.2 MiB -638964.0 MiB       62327           current = open_set.get()[1]
    28                                         
    29     96.2 MiB -638964.4 MiB       62327           if current in remaining_goals:
    30     93.9 MiB   -111.8 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     93.9 MiB    -88.8 MiB          10               if not remaining_goals:
    32     82.5 MiB    -11.4 MiB           1                   break  # All goals found
    33                                         
    34     96.2 MiB -5720730.2 MiB      558611           for neighbor in current.neighbors:
    35     96.2 MiB -5081792.3 MiB      496285               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.2 MiB -5081794.4 MiB      496285               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.2 MiB -2535941.5 MiB      247756                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.2 MiB -5081799.3 MiB      496285               if temp_g_score < g_score[neighbor]:
    41     96.2 MiB -635448.2 MiB       62572                   came_from[neighbor] = current
    42     96.2 MiB -635448.7 MiB       62572                   g_score[neighbor] = temp_g_score
    43     96.2 MiB -635449.1 MiB       62572                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.2 MiB -638961.8 MiB       62326           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.2 MiB -638962.2 MiB       62326           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     82.5 MiB      0.0 MiB           1       paths = {}
    53     82.6 MiB      0.0 MiB          11       for goal in goals:
    54     82.6 MiB      0.1 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     82.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.5 MiB     94.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.5 MiB      0.0 MiB         257       for row in grid:
     8     94.5 MiB      0.0 MiB       65792           for spot in row:
     9     94.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     94.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     94.5 MiB      0.0 MiB           1       came_from = {}
    18     95.9 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.4 MiB -274838.3 MiB       63617       while not open_set.empty():
    22     96.4 MiB -274838.4 MiB       63617           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.4 MiB -274838.8 MiB       63617           current = open_set.get()[1]
    28                                         
    29     96.4 MiB -274839.0 MiB       63617           if current in remaining_goals:
    30     95.9 MiB    -34.3 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     95.9 MiB    -29.5 MiB          10               if not remaining_goals:
    32     93.6 MiB     -2.2 MiB           1                   break  # All goals found
    33                                         
    34     96.4 MiB -2463701.5 MiB      570041           for neighbor in current.neighbors:
    35     96.4 MiB -2188869.7 MiB      506425               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.4 MiB -2188870.3 MiB      506425               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.4 MiB -1092800.3 MiB      252796                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.4 MiB -2188872.0 MiB      506425               if temp_g_score < g_score[neighbor]:
    41     96.4 MiB -275068.6 MiB       63802                   came_from[neighbor] = current
    42     96.4 MiB -275069.2 MiB       63802                   g_score[neighbor] = temp_g_score
    43     96.4 MiB -275069.6 MiB       63802                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.4 MiB -274837.9 MiB       63616           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.4 MiB -274838.0 MiB       63616           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     93.6 MiB      0.0 MiB           1       paths = {}
    53     93.6 MiB      0.0 MiB          11       for goal in goals:
    54     93.6 MiB      0.0 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     93.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     96.6 MiB     96.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     96.6 MiB      0.0 MiB         257       for row in grid:
     8     96.6 MiB      0.0 MiB       65792           for spot in row:
     9     96.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     96.6 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     96.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     96.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     96.6 MiB      0.0 MiB           1       came_from = {}
    18     96.8 MiB      0.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.9 MiB   -110.1 MiB       54552       while not open_set.empty():
    22     97.9 MiB   -110.1 MiB       54552           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.9 MiB   -110.1 MiB       54552           current = open_set.get()[1]
    28                                         
    29     97.9 MiB   -110.1 MiB       54552           if current in remaining_goals:
    30     97.9 MiB     -0.0 MiB          10               remaining_goals.remove(current)  # Remove this goal from the list
    31     97.9 MiB     -0.0 MiB          10               if not remaining_goals:
    32     97.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     97.9 MiB   -989.2 MiB      489469           for neighbor in current.neighbors:
    35     97.9 MiB   -879.1 MiB      434918               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.9 MiB   -879.1 MiB      434918               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.9 MiB   -439.3 MiB      217211                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.9 MiB   -879.1 MiB      434918               if temp_g_score < g_score[neighbor]:
    41     97.9 MiB   -109.7 MiB       55074                   came_from[neighbor] = current
    42     97.9 MiB   -110.7 MiB       55074                   g_score[neighbor] = temp_g_score
    43     97.9 MiB   -110.7 MiB       55074                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.9 MiB   -110.1 MiB       54551           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.9 MiB   -110.1 MiB       54551           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     97.9 MiB      0.0 MiB           1       paths = {}
    53     97.9 MiB      0.0 MiB          11       for goal in goals:
    54     97.9 MiB      0.0 MiB          10           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     97.9 MiB      0.0 MiB           1       return paths


