Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.7 MiB     67.7 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/1.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     70.0 MiB  -2188.4 MiB         257       for row in grid:
     8     70.0 MiB -561774.1 MiB       65792           for spot in row:
     9     70.0 MiB -559595.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     51.4 MiB    -18.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     51.5 MiB      0.1 MiB           1       open_set = PriorityQueue()
    16     51.6 MiB      0.1 MiB           1       open_set.put((0, start))
    17     51.6 MiB      0.0 MiB           1       came_from = {}
    18     58.4 MiB      6.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     58.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     60.4 MiB -335592.5 MiB       35386       while not open_set.empty():
    22     60.4 MiB -335592.8 MiB       35386           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     60.4 MiB -335593.3 MiB       35386           current = open_set.get()[1]
    28                                         
    29     60.4 MiB -335593.6 MiB       35386           if current in remaining_goals:
    30     45.9 MiB    -14.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     45.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     60.4 MiB -3020266.4 MiB      318465           for neighbor in current.neighbors:
    35     60.4 MiB -2684681.4 MiB      283080               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     60.4 MiB -2684684.6 MiB      283080               if current.row != neighbor.row and current.col != neighbor.col:
    38     60.4 MiB -1342358.5 MiB      141540                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     60.4 MiB -2684687.9 MiB      283080               if temp_g_score < g_score[neighbor]:
    41     60.4 MiB -340871.8 MiB       36280                   came_from[neighbor] = current
    42     60.4 MiB -340872.3 MiB       36280                   g_score[neighbor] = temp_g_score
    43     60.4 MiB -340873.0 MiB       36280                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     60.4 MiB -335592.0 MiB       35385           if draw is not None:
    46                                                     draw()
    47                                                     
    48     60.4 MiB -335592.4 MiB       35385           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.9 MiB      0.0 MiB           1       paths = {}
    53     46.0 MiB      0.0 MiB           2       for goal in goals:
    54     46.0 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.5 MiB     89.5 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/1.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.5 MiB      0.0 MiB         257       for row in grid:
     8     93.5 MiB      0.0 MiB       65792           for spot in row:
     9     93.5 MiB      4.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.5 MiB      0.0 MiB           1       came_from = {}
    18     99.3 MiB   -473.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     99.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.3 MiB -2171502.9 MiB       46507       while not open_set.empty():
    22     99.3 MiB -2171504.0 MiB       46507           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.3 MiB -2171506.7 MiB       46507           current = open_set.get()[1]
    28                                         
    29     99.3 MiB -2171507.6 MiB       46507           if current in remaining_goals:
    30     51.9 MiB    -47.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     51.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     51.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     99.3 MiB -19477981.0 MiB      417253           for neighbor in current.neighbors:
    35     99.3 MiB -17306489.5 MiB      370747               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.3 MiB -17306504.0 MiB      370747               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.3 MiB -8642467.9 MiB      185157                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.3 MiB -17306518.5 MiB      370747               if temp_g_score < g_score[neighbor]:
    41     99.3 MiB -2181757.7 MiB       47032                   came_from[neighbor] = current
    42     99.3 MiB -2181758.6 MiB       47032                   g_score[neighbor] = temp_g_score
    43     99.3 MiB -2181760.1 MiB       47032                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.3 MiB -2171500.5 MiB       46506           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.3 MiB -2171501.7 MiB       46506           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     51.9 MiB      0.0 MiB           1       paths = {}
    53     52.1 MiB      0.0 MiB           2       for goal in goals:
    54     52.1 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     52.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     96.8 MiB     96.8 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/1.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.1 MiB      0.0 MiB         257       for row in grid:
     8     97.1 MiB      0.0 MiB       65792           for spot in row:
     9     97.1 MiB      0.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.1 MiB      0.0 MiB           1       came_from = {}
    18    101.5 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    101.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    101.6 MiB  -9623.9 MiB        6326       while not open_set.empty():
    22    101.6 MiB  -9623.9 MiB        6326           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    101.6 MiB  -9623.9 MiB        6326           current = open_set.get()[1]
    28                                         
    29    101.6 MiB  -9623.9 MiB        6326           if current in remaining_goals:
    30     98.7 MiB     -2.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     98.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     98.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    101.6 MiB -86062.3 MiB       56377           for neighbor in current.neighbors:
    35    101.6 MiB -76439.3 MiB       50052               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    101.6 MiB -76439.8 MiB       50052               if current.row != neighbor.row and current.col != neighbor.col:
    38    101.6 MiB -38133.2 MiB       24935                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    101.6 MiB -76440.6 MiB       50052               if temp_g_score < g_score[neighbor]:
    41    101.6 MiB  -9788.0 MiB        6512                   came_from[neighbor] = current
    42    101.6 MiB  -9788.1 MiB        6512                   g_score[neighbor] = temp_g_score
    43    101.6 MiB  -9788.1 MiB        6512                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    101.6 MiB  -9623.8 MiB        6325           if draw is not None:
    46                                                     draw()
    47                                                     
    48    101.6 MiB  -9623.9 MiB        6325           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     98.7 MiB      0.0 MiB           1       paths = {}
    53     98.7 MiB      0.0 MiB           2       for goal in goals:
    54     98.7 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     98.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    103.8 MiB    103.8 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/1.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    103.8 MiB   -972.6 MiB         257       for row in grid:
     8    103.8 MiB -249312.7 MiB       65792           for spot in row:
     9    103.8 MiB -248343.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.4 MiB     -6.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.4 MiB      0.0 MiB           1       came_from = {}
    18    101.4 MiB -16225.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.9 MiB     -0.5 MiB           1       g_score[start] = 0
    20                                         
    21    101.1 MiB -48497.4 MiB       31669       while not open_set.empty():
    22    101.1 MiB -48497.4 MiB       31669           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    101.1 MiB -48497.5 MiB       31669           current = open_set.get()[1]
    28                                         
    29    101.1 MiB -48497.5 MiB       31669           if current in remaining_goals:
    30     96.8 MiB     -4.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     96.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    101.1 MiB -435225.7 MiB      284583           for neighbor in current.neighbors:
    35    101.1 MiB -386729.7 MiB      252915               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    101.1 MiB -386730.5 MiB      252915               if current.row != neighbor.row and current.col != neighbor.col:
    38    101.1 MiB -193165.8 MiB      126386                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    101.1 MiB -386731.9 MiB      252915               if temp_g_score < g_score[neighbor]:
    41    101.1 MiB -48820.1 MiB       32338                   came_from[neighbor] = current
    42    101.1 MiB -48820.3 MiB       32338                   g_score[neighbor] = temp_g_score
    43    101.1 MiB -48820.7 MiB       32338                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    101.1 MiB -48497.2 MiB       31668           if draw is not None:
    46                                                     draw()
    47                                                     
    48    101.1 MiB -48497.3 MiB       31668           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     96.8 MiB      0.0 MiB           1       paths = {}
    53     96.8 MiB      0.0 MiB           2       for goal in goals:
    54     96.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     96.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    103.6 MiB    103.6 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/2.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    103.6 MiB   -194.8 MiB         257       for row in grid:
     8    103.6 MiB -49984.8 MiB       65792           for spot in row:
     9    103.6 MiB -49790.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    102.8 MiB     -0.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    102.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    102.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17    102.8 MiB      0.0 MiB           1       came_from = {}
    18    106.7 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    106.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    106.7 MiB -1740901.7 MiB       53912       while not open_set.empty():
    22    106.7 MiB -1740902.5 MiB       53912           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    106.7 MiB -1740905.5 MiB       53912           current = open_set.get()[1]
    28                                         
    29    106.7 MiB -1740906.8 MiB       53912           if current in remaining_goals:
    30     50.5 MiB    -56.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     50.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     50.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    106.7 MiB -15584772.7 MiB      483419           for neighbor in current.neighbors:
    35    106.7 MiB -13843887.0 MiB      429508               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    106.7 MiB -13843896.7 MiB      429508               if current.row != neighbor.row and current.col != neighbor.col:
    38    106.7 MiB -6908205.6 MiB      214458                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    106.7 MiB -13843913.7 MiB      429508               if temp_g_score < g_score[neighbor]:
    41    106.7 MiB -1730531.9 MiB       54302                   came_from[neighbor] = current
    42    106.7 MiB -1730533.5 MiB       54302                   g_score[neighbor] = temp_g_score
    43    106.7 MiB -1730535.7 MiB       54302                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    106.7 MiB -1740898.3 MiB       53911           if draw is not None:
    46                                                     draw()
    47                                                     
    48    106.7 MiB -1740899.3 MiB       53911           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     50.5 MiB      0.0 MiB           1       paths = {}
    53     50.8 MiB      0.0 MiB           2       for goal in goals:
    54     50.8 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     50.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    101.0 MiB    101.0 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/5.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    101.0 MiB   -188.5 MiB         257       for row in grid:
     8    101.0 MiB -48121.1 MiB       65792           for spot in row:
     9    101.0 MiB -47934.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     99.0 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     99.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     99.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     99.0 MiB      0.0 MiB           1       came_from = {}
    18    103.5 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    103.7 MiB -1257160.7 MiB       27368       while not open_set.empty():
    22    103.7 MiB -1257161.6 MiB       27368           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.7 MiB -1257164.3 MiB       27368           current = open_set.get()[1]
    28                                         
    29    103.7 MiB -1257165.3 MiB       27368           if current in remaining_goals:
    30     41.4 MiB    -62.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     41.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.7 MiB -11276877.2 MiB      245275           for neighbor in current.neighbors:
    35    103.7 MiB -10019730.1 MiB      217908               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.7 MiB -10019739.8 MiB      217908               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.7 MiB -5003720.2 MiB      108783                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.7 MiB -10019771.0 MiB      217908               if temp_g_score < g_score[neighbor]:
    41    103.7 MiB -1267295.9 MiB       27770                   came_from[neighbor] = current
    42    103.7 MiB -1267296.2 MiB       27770                   g_score[neighbor] = temp_g_score
    43    103.7 MiB -1267296.6 MiB       27770                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.7 MiB -1257155.6 MiB       27367           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.7 MiB -1257156.1 MiB       27367           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.4 MiB      0.0 MiB           1       paths = {}
    53     41.6 MiB      0.0 MiB           2       for goal in goals:
    54     41.6 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.8 MiB     98.8 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/7.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.8 MiB      0.0 MiB         257       for row in grid:
     8     98.8 MiB      0.0 MiB       65792           for spot in row:
     9     98.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     98.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     98.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     98.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     98.8 MiB      0.0 MiB           1       came_from = {}
    18    102.9 MiB  -4095.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    102.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    103.0 MiB -320967.1 MiB       21099       while not open_set.empty():
    22    103.0 MiB -320967.8 MiB       21099           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.0 MiB -320968.4 MiB       21099           current = open_set.get()[1]
    28                                         
    29    103.0 MiB -320968.7 MiB       21099           if current in remaining_goals:
    30     56.4 MiB    -46.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     56.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     56.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.0 MiB -2881556.8 MiB      189447           for neighbor in current.neighbors:
    35    103.0 MiB -2560608.6 MiB      168349               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.0 MiB -2560612.9 MiB      168349               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.0 MiB -1279196.8 MiB       84102                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.0 MiB -2560621.6 MiB      168349               if temp_g_score < g_score[neighbor]:
    41    103.0 MiB -324791.6 MiB       21620                   came_from[neighbor] = current
    42    103.0 MiB -324792.2 MiB       21620                   g_score[neighbor] = temp_g_score
    43    103.0 MiB -324793.8 MiB       21620                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.0 MiB -320964.5 MiB       21098           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.0 MiB -320965.6 MiB       21098           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     56.4 MiB      0.0 MiB           1       paths = {}
    53     56.5 MiB      0.0 MiB           2       for goal in goals:
    54     56.5 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     56.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.4 MiB     97.4 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.4 MiB     -2.1 MiB         257       for row in grid:
     8     97.4 MiB   -529.2 MiB       65792           for spot in row:
     9     97.4 MiB   -527.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.3 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.3 MiB      0.0 MiB           1       came_from = {}
    18    102.3 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    102.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    102.4 MiB -1356375.9 MiB       42869       while not open_set.empty():
    22    102.4 MiB -1356376.3 MiB       42869           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    102.4 MiB -1356377.2 MiB       42869           current = open_set.get()[1]
    28                                         
    29    102.4 MiB -1356377.9 MiB       42869           if current in remaining_goals:
    30     49.3 MiB    -53.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     49.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     49.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    102.4 MiB -12178917.4 MiB      384385           for neighbor in current.neighbors:
    35    102.4 MiB -10822568.2 MiB      341517               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    102.4 MiB -10822575.0 MiB      341517               if current.row != neighbor.row and current.col != neighbor.col:
    38    102.4 MiB -5406645.0 MiB      170521                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    102.4 MiB -10822581.8 MiB      341517               if temp_g_score < g_score[neighbor]:
    41    102.4 MiB -1365814.0 MiB       43358                   came_from[neighbor] = current
    42    102.4 MiB -1365814.8 MiB       43358                   g_score[neighbor] = temp_g_score
    43    102.4 MiB -1365815.7 MiB       43358                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    102.4 MiB -1356373.7 MiB       42868           if draw is not None:
    46                                                     draw()
    47                                                     
    48    102.4 MiB -1356375.2 MiB       42868           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     49.3 MiB      0.0 MiB           1       paths = {}
    53     49.6 MiB      0.0 MiB           2       for goal in goals:
    54     49.6 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     49.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     95.9 MiB     95.9 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     95.9 MiB      0.0 MiB         257       for row in grid:
     8     95.9 MiB      0.0 MiB       65792           for spot in row:
     9     95.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     95.9 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     95.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     95.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     95.9 MiB      0.0 MiB           1       came_from = {}
    18    100.2 MiB  -2255.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    100.2 MiB -2823093.4 MiB       63490       while not open_set.empty():
    22    100.2 MiB -2823094.4 MiB       63490           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.2 MiB -2823096.3 MiB       63490           current = open_set.get()[1]
    28                                         
    29    100.2 MiB -2823098.0 MiB       63490           if current in remaining_goals:
    30     34.5 MiB    -65.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.2 MiB -25277685.1 MiB      568922           for neighbor in current.neighbors:
    35    100.2 MiB -22454604.3 MiB      505433               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.2 MiB -22454627.4 MiB      505433               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.2 MiB -11205784.9 MiB      252304                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.2 MiB -22454651.2 MiB      505433               if temp_g_score < g_score[neighbor]:
    41    100.2 MiB -2807107.5 MiB       63683                   came_from[neighbor] = current
    42    100.2 MiB -2807109.1 MiB       63683                   g_score[neighbor] = temp_g_score
    43    100.2 MiB -2807111.3 MiB       63683                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.2 MiB -2823092.0 MiB       63489           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.2 MiB -2823092.6 MiB       63489           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.5 MiB      0.0 MiB           1       paths = {}
    53     35.9 MiB      0.0 MiB           2       for goal in goals:
    54     35.9 MiB      1.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     95.4 MiB     95.4 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     95.4 MiB    -78.4 MiB         257       for row in grid:
     8     95.4 MiB -20081.3 MiB       65792           for spot in row:
     9     95.4 MiB -20002.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.4 MiB     -1.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.5 MiB      0.1 MiB           1       open_set = PriorityQueue()
    16     94.6 MiB      0.1 MiB           1       open_set.put((0, start))
    17     94.6 MiB      0.0 MiB           1       came_from = {}
    18     96.3 MiB  -5693.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.0 MiB     -0.3 MiB           1       g_score[start] = 0
    20                                         
    21     96.1 MiB -3207404.9 MiB       65189       while not open_set.empty():
    22     96.1 MiB -3207406.2 MiB       65189           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.1 MiB -3207413.9 MiB       65189           current = open_set.get()[1]
    28                                         
    29     96.1 MiB -3207415.1 MiB       65189           if current in remaining_goals:
    30     36.8 MiB    -59.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     36.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.1 MiB -28713866.1 MiB      583791           for neighbor in current.neighbors:
    35     96.1 MiB -25506478.0 MiB      518603               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.1 MiB -25506485.7 MiB      518603               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.1 MiB -12727932.7 MiB      258819                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.1 MiB -25506504.8 MiB      518603               if temp_g_score < g_score[neighbor]:
    41     96.1 MiB -3194125.9 MiB       65242                   came_from[neighbor] = current
    42     96.1 MiB -3194126.4 MiB       65242                   g_score[neighbor] = temp_g_score
    43     96.1 MiB -3194128.7 MiB       65242                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.1 MiB -3207400.9 MiB       65188           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.1 MiB -3207402.1 MiB       65188           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.8 MiB      0.0 MiB           1       paths = {}
    53     37.8 MiB      0.0 MiB           2       for goal in goals:
    54     37.8 MiB      1.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     95.1 MiB     95.1 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     95.1 MiB  -1151.4 MiB         257       for row in grid:
     8     95.1 MiB -294740.3 MiB       65792           for spot in row:
     9     95.1 MiB -293592.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.7 MiB     -6.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.8 MiB      0.0 MiB           1       came_from = {}
    18     93.1 MiB  -3611.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.2 MiB -1259285.4 MiB       36027       while not open_set.empty():
    22     93.2 MiB -1259286.3 MiB       36027           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.2 MiB -1259289.5 MiB       36027           current = open_set.get()[1]
    28                                         
    29     93.2 MiB -1259290.6 MiB       36027           if current in remaining_goals:
    30     48.3 MiB    -44.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     48.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     48.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.2 MiB -11301842.4 MiB      323008           for neighbor in current.neighbors:
    35     93.2 MiB -10042570.9 MiB      286982               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.2 MiB -10042574.4 MiB      286982               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.2 MiB -5016084.5 MiB      143287                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.2 MiB -10042597.7 MiB      286982               if temp_g_score < g_score[neighbor]:
    41     93.2 MiB -1269690.9 MiB       36481                   came_from[neighbor] = current
    42     93.2 MiB -1269692.3 MiB       36481                   g_score[neighbor] = temp_g_score
    43     93.2 MiB -1269694.4 MiB       36481                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.2 MiB -1259282.2 MiB       36026           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.2 MiB -1259284.7 MiB       36026           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     48.3 MiB      0.0 MiB           1       paths = {}
    53     48.5 MiB      0.0 MiB           2       for goal in goals:
    54     48.5 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     48.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    102.4 MiB    102.4 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    102.4 MiB    -45.1 MiB         257       for row in grid:
     8    102.4 MiB -11477.5 MiB       65792           for spot in row:
     9    102.4 MiB -11433.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    101.7 MiB     -0.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    101.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    101.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17    101.7 MiB      0.0 MiB           1       came_from = {}
    18    106.7 MiB  -9229.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    105.5 MiB     -1.2 MiB           1       g_score[start] = 0
    20                                         
    21    105.5 MiB -15660.7 MiB        2762       while not open_set.empty():
    22    105.5 MiB -15660.7 MiB        2762           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    105.5 MiB -15660.9 MiB        2762           current = open_set.get()[1]
    28                                         
    29    105.5 MiB -15661.0 MiB        2762           if current in remaining_goals:
    30     98.8 MiB     -6.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     98.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     98.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    105.5 MiB -139658.4 MiB       24571           for neighbor in current.neighbors:
    35    105.5 MiB -123999.5 MiB       21810               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    105.5 MiB -124000.9 MiB       21810               if current.row != neighbor.row and current.col != neighbor.col:
    38    105.5 MiB -61801.0 MiB       10859                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    105.5 MiB -124003.0 MiB       21810               if temp_g_score < g_score[neighbor]:
    41    105.5 MiB -16250.8 MiB        2920                   came_from[neighbor] = current
    42    105.5 MiB -16250.9 MiB        2920                   g_score[neighbor] = temp_g_score
    43    105.5 MiB -16251.2 MiB        2920                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    105.5 MiB -15660.5 MiB        2761           if draw is not None:
    46                                                     draw()
    47                                                     
    48    105.5 MiB -15660.6 MiB        2761           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     98.8 MiB      0.0 MiB           1       paths = {}
    53     98.8 MiB      0.0 MiB           2       for goal in goals:
    54     98.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     98.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    107.3 MiB    107.3 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    107.3 MiB   -661.0 MiB         257       for row in grid:
     8    107.3 MiB -169354.2 MiB       65792           for spot in row:
     9    107.3 MiB -168694.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    102.8 MiB     -4.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    102.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    102.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17    102.9 MiB      0.0 MiB           1       came_from = {}
    18    105.9 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    105.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    106.1 MiB -564805.4 MiB       17013       while not open_set.empty():
    22    106.1 MiB -564806.2 MiB       17013           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    106.1 MiB -564808.8 MiB       17013           current = open_set.get()[1]
    28                                         
    29    106.1 MiB -564810.5 MiB       17013           if current in remaining_goals:
    30     38.6 MiB    -67.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     38.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    106.1 MiB -5069194.2 MiB      152877           for neighbor in current.neighbors:
    35    106.1 MiB -4504406.5 MiB      135865               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    106.1 MiB -4504411.1 MiB      135865               if current.row != neighbor.row and current.col != neighbor.col:
    38    106.1 MiB -2249976.1 MiB       67894                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    106.1 MiB -4504423.6 MiB      135865               if temp_g_score < g_score[neighbor]:
    41    106.1 MiB -571562.8 MiB       17534                   came_from[neighbor] = current
    42    106.1 MiB -571565.7 MiB       17534                   g_score[neighbor] = temp_g_score
    43    106.1 MiB -571573.4 MiB       17534                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    106.1 MiB -564798.5 MiB       17012           if draw is not None:
    46                                                     draw()
    47                                                     
    48    106.1 MiB -564804.4 MiB       17012           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.6 MiB      0.0 MiB           1       paths = {}
    53     38.7 MiB      0.0 MiB           2       for goal in goals:
    54     38.7 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.5 MiB     99.5 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.5 MiB    -53.3 MiB         257       for row in grid:
     8     99.5 MiB -13557.8 MiB       65792           for spot in row:
     9     99.5 MiB -13504.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     98.8 MiB     -0.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     98.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     98.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     98.9 MiB      0.0 MiB           1       came_from = {}
    18    101.8 MiB -30131.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    101.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    101.9 MiB -1099654.4 MiB       27722       while not open_set.empty():
    22    101.9 MiB -1099654.9 MiB       27722           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    101.9 MiB -1099655.8 MiB       27722           current = open_set.get()[1]
    28                                         
    29    101.9 MiB -1099657.0 MiB       27722           if current in remaining_goals:
    30     40.1 MiB    -61.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     40.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    101.9 MiB -9871944.8 MiB      249000           for neighbor in current.neighbors:
    35    101.9 MiB -8772308.5 MiB      221279               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    101.9 MiB -8772323.9 MiB      221279               if current.row != neighbor.row and current.col != neighbor.col:
    38    101.9 MiB -4382108.4 MiB      110558                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    101.9 MiB -8772335.3 MiB      221279               if temp_g_score < g_score[neighbor]:
    41    101.9 MiB -1111877.3 MiB       28321                   came_from[neighbor] = current
    42    101.9 MiB -1111877.8 MiB       28321                   g_score[neighbor] = temp_g_score
    43    101.9 MiB -1111879.2 MiB       28321                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    101.9 MiB -1099649.0 MiB       27721           if draw is not None:
    46                                                     draw()
    47                                                     
    48    101.9 MiB -1099650.1 MiB       27721           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.1 MiB      0.0 MiB           1       paths = {}
    53     40.2 MiB      0.0 MiB           2       for goal in goals:
    54     40.2 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.7 MiB     98.7 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.7 MiB   -370.8 MiB         257       for row in grid:
     8     98.7 MiB -94788.5 MiB       65792           for spot in row:
     9     98.7 MiB -94420.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.9 MiB     -3.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     95.0 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     95.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     95.2 MiB      0.0 MiB           1       came_from = {}
    18     98.6 MiB -41627.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.5 MiB     -5.1 MiB           1       g_score[start] = 0
    20                                         
    21     93.7 MiB -2392393.0 MiB       51222       while not open_set.empty():
    22     93.7 MiB -2392393.6 MiB       51222           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.7 MiB -2392395.0 MiB       51222           current = open_set.get()[1]
    28                                         
    29     93.7 MiB -2392396.2 MiB       51222           if current in remaining_goals:
    30     45.9 MiB    -47.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     45.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.7 MiB -21464863.3 MiB      459630           for neighbor in current.neighbors:
    35     93.7 MiB -19072499.3 MiB      408409               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.7 MiB -19072492.7 MiB      408409               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.7 MiB -9525231.3 MiB      203978                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.7 MiB -19069377.2 MiB      408409               if temp_g_score < g_score[neighbor]:
    41     93.7 MiB -2407546.1 MiB       51739                   came_from[neighbor] = current
    42     93.7 MiB -2407546.8 MiB       51739                   g_score[neighbor] = temp_g_score
    43     93.7 MiB -2407548.6 MiB       51739                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.7 MiB -2392390.4 MiB       51221           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.7 MiB -2392392.3 MiB       51221           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.9 MiB      0.0 MiB           1       paths = {}
    53     46.1 MiB      0.0 MiB           2       for goal in goals:
    54     46.1 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.2 MiB     98.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.2 MiB    -54.4 MiB         257       for row in grid:
     8     98.2 MiB -13490.5 MiB       65792           for spot in row:
     9     98.2 MiB -13438.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     95.1 MiB     -3.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     95.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     95.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     95.1 MiB      0.0 MiB           1       came_from = {}
    18     98.0 MiB -27735.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.2 MiB     -0.8 MiB           1       g_score[start] = 0
    20                                         
    21     97.2 MiB -2280040.0 MiB       35185       while not open_set.empty():
    22     97.2 MiB -2280042.7 MiB       35185           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.2 MiB -2280049.6 MiB       35185           current = open_set.get()[1]
    28                                         
    29     97.2 MiB -2280050.7 MiB       35185           if current in remaining_goals:
    30     30.4 MiB    -66.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     30.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     97.2 MiB -20441406.5 MiB      315484           for neighbor in current.neighbors:
    35     97.2 MiB -18161388.9 MiB      280300               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.2 MiB -18161380.7 MiB      280300               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.2 MiB -9067788.8 MiB      139955                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.2 MiB -18161448.1 MiB      280300               if temp_g_score < g_score[neighbor]:
    41     97.2 MiB -2299085.8 MiB       35637                   came_from[neighbor] = current
    42     97.2 MiB -2299088.6 MiB       35637                   g_score[neighbor] = temp_g_score
    43     97.2 MiB -2299090.9 MiB       35637                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.2 MiB -2280037.2 MiB       35184           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.2 MiB -2280038.4 MiB       35184           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.4 MiB      0.0 MiB           1       paths = {}
    53     30.7 MiB      0.0 MiB           2       for goal in goals:
    54     30.7 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.4 MiB     87.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.4 MiB  -9835.1 MiB         257       for row in grid:
     8     87.4 MiB -2516744.6 MiB       65792           for spot in row:
     9     87.4 MiB -2506952.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     31.0 MiB    -56.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     31.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     31.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     31.5 MiB      0.0 MiB           1       came_from = {}
    18     36.0 MiB -83357.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     36.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     48.8 MiB -549022.4 MiB       56169       while not open_set.empty():
    22     48.8 MiB -549023.8 MiB       56169           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     48.8 MiB -549026.7 MiB       56169           current = open_set.get()[1]
    28                                         
    29     48.8 MiB -549029.4 MiB       56169           if current in remaining_goals:
    30     30.2 MiB    -18.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     30.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     48.8 MiB -4919349.6 MiB      503520           for neighbor in current.neighbors:
    35     48.8 MiB -4370354.2 MiB      447352               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     48.8 MiB -4370346.1 MiB      447352               if current.row != neighbor.row and current.col != neighbor.col:
    38     48.8 MiB -2181600.0 MiB      223345                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     48.8 MiB -4370361.7 MiB      447352               if temp_g_score < g_score[neighbor]:
    41     48.8 MiB -550135.4 MiB       56525                   came_from[neighbor] = current
    42     48.8 MiB -550138.4 MiB       56525                   g_score[neighbor] = temp_g_score
    43     48.8 MiB -550141.2 MiB       56525                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     48.8 MiB -549020.5 MiB       56168           if draw is not None:
    46                                                     draw()
    47                                                     
    48     48.8 MiB -549021.0 MiB       56168           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.2 MiB      0.0 MiB           1       paths = {}
    53     30.7 MiB      0.0 MiB           2       for goal in goals:
    54     30.7 MiB      0.5 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.6 MiB  -1355.1 MiB         257       for row in grid:
     8     86.6 MiB -346612.9 MiB       65792           for spot in row:
     9     86.6 MiB -345266.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     77.3 MiB     -9.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     77.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     77.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     77.7 MiB      0.0 MiB           1       came_from = {}
    18     83.0 MiB -683596.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     45.1 MiB    -37.9 MiB           1       g_score[start] = 0
    20                                         
    21     45.8 MiB -988068.4 MiB       65484       while not open_set.empty():
    22     45.8 MiB -988069.3 MiB       65484           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     45.8 MiB -988069.8 MiB       65484           current = open_set.get()[1]
    28                                         
    29     45.8 MiB -988070.6 MiB       65484           if current in remaining_goals:
    30     25.2 MiB    -20.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     25.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     25.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     45.8 MiB -8845930.6 MiB      586341           for neighbor in current.neighbors:
    35     45.8 MiB -7857885.9 MiB      520858               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     45.8 MiB -7857870.8 MiB      520858               if current.row != neighbor.row and current.col != neighbor.col:
    38     45.8 MiB -3921259.2 MiB      259929                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     45.8 MiB -7857887.4 MiB      520858               if temp_g_score < g_score[neighbor]:
    41     45.8 MiB -988450.0 MiB       65502                   came_from[neighbor] = current
    42     45.8 MiB -988450.6 MiB       65502                   g_score[neighbor] = temp_g_score
    43     45.8 MiB -988454.2 MiB       65502                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     45.8 MiB -988066.4 MiB       65483           if draw is not None:
    46                                                     draw()
    47                                                     
    48     45.8 MiB -988067.3 MiB       65483           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     25.2 MiB      0.0 MiB           1       paths = {}
    53     26.3 MiB      0.0 MiB           2       for goal in goals:
    54     26.3 MiB      1.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     26.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.7 MiB     86.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.7 MiB -12846.8 MiB         257       for row in grid:
     8     86.7 MiB -3287422.1 MiB       65792           for spot in row:
     9     86.7 MiB -3274631.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     21.6 MiB    -65.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     22.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     22.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     22.2 MiB      0.0 MiB           1       came_from = {}
    18     34.7 MiB   -885.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     34.5 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     35.8 MiB -54985.1 MiB        3577       while not open_set.empty():
    22     35.8 MiB -54985.2 MiB        3577           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     35.8 MiB -54985.2 MiB        3577           current = open_set.get()[1]
    28                                         
    29     35.8 MiB -54985.3 MiB        3577           if current in remaining_goals:
    30     18.7 MiB    -17.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     18.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     18.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     35.8 MiB -494781.8 MiB       32184           for neighbor in current.neighbors:
    35     35.8 MiB -439803.6 MiB       28608               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     35.8 MiB -439806.7 MiB       28608               if current.row != neighbor.row and current.col != neighbor.col:
    38     35.8 MiB -219915.6 MiB       14304                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     35.8 MiB -439811.4 MiB       28608               if temp_g_score < g_score[neighbor]:
    41     35.8 MiB -58206.2 MiB        3863                   came_from[neighbor] = current
    42     35.8 MiB -58206.3 MiB        3863                   g_score[neighbor] = temp_g_score
    43     35.8 MiB -58206.2 MiB        3863                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     35.8 MiB -54980.7 MiB        3576           if draw is not None:
    46                                                     draw()
    47                                                     
    48     35.8 MiB -54982.3 MiB        3576           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     18.7 MiB      0.0 MiB           1       paths = {}
    53     18.8 MiB      0.0 MiB           2       for goal in goals:
    54     18.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     18.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.0 MiB     84.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.0 MiB   -309.5 MiB         257       for row in grid:
     8     84.0 MiB -79390.5 MiB       65792           for spot in row:
     9     84.0 MiB -79082.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.5 MiB     -2.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     81.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     81.9 MiB      0.0 MiB           1       came_from = {}
    18     86.2 MiB -13375.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.0 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     86.0 MiB -2305060.3 MiB       42743       while not open_set.empty():
    22     86.0 MiB -2305061.6 MiB       42743           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.0 MiB -2305063.0 MiB       42743           current = open_set.get()[1]
    28                                         
    29     86.0 MiB -2305066.5 MiB       42743           if current in remaining_goals:
    30     31.3 MiB    -54.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     31.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     31.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.0 MiB -20673100.7 MiB      383437           for neighbor in current.neighbors:
    35     86.0 MiB -18368055.3 MiB      340695               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.0 MiB -18368056.3 MiB      340695               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.0 MiB -9172099.7 MiB      170141                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.0 MiB -18368097.0 MiB      340695               if temp_g_score < g_score[neighbor]:
    41     86.0 MiB -2322562.8 MiB       43248                   came_from[neighbor] = current
    42     86.0 MiB -2322563.8 MiB       43248                   g_score[neighbor] = temp_g_score
    43     86.0 MiB -2322566.9 MiB       43248                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.0 MiB -2305059.1 MiB       42742           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.0 MiB -2305059.6 MiB       42742           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.3 MiB      0.0 MiB           1       paths = {}
    53     31.6 MiB      0.0 MiB           2       for goal in goals:
    54     31.6 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.7 MiB     91.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.7 MiB   -110.5 MiB         257       for row in grid:
     8     91.7 MiB -28032.0 MiB       65792           for spot in row:
     9     91.7 MiB -27921.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.9 MiB     -1.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.9 MiB      0.0 MiB           1       came_from = {}
    18     94.5 MiB  -1227.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.5 MiB -2180604.7 MiB       35497       while not open_set.empty():
    22     94.5 MiB -2180606.1 MiB       35497           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.5 MiB -2180607.4 MiB       35497           current = open_set.get()[1]
    28                                         
    29     94.5 MiB -2180608.0 MiB       35497           if current in remaining_goals:
    30     33.9 MiB    -60.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     33.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.5 MiB -19550902.8 MiB      318325           for neighbor in current.neighbors:
    35     94.5 MiB -17370360.5 MiB      282829               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.5 MiB -17370353.1 MiB      282829               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.5 MiB -8672902.0 MiB      141225                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.5 MiB -17370359.4 MiB      282829               if temp_g_score < g_score[neighbor]:
    41     94.5 MiB -2197877.6 MiB       35964                   came_from[neighbor] = current
    42     94.5 MiB -2197878.5 MiB       35964                   g_score[neighbor] = temp_g_score
    43     94.5 MiB -2197878.8 MiB       35964                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.5 MiB -2180604.0 MiB       35496           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.5 MiB -2180604.2 MiB       35496           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.9 MiB      0.0 MiB           1       paths = {}
    53     34.2 MiB      0.0 MiB           2       for goal in goals:
    54     34.2 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.6 MiB     90.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.6 MiB    -27.0 MiB         257       for row in grid:
     8     90.6 MiB  -6700.9 MiB       65792           for spot in row:
     9     90.6 MiB  -6675.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.6 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.6 MiB      0.0 MiB           1       came_from = {}
    18     89.8 MiB -39591.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.4 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     89.5 MiB -1230948.4 MiB       32932       while not open_set.empty():
    22     89.5 MiB -1230948.7 MiB       32932           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.5 MiB -1230949.7 MiB       32932           current = open_set.get()[1]
    28                                         
    29     89.5 MiB -1230950.2 MiB       32932           if current in remaining_goals:
    30     35.8 MiB    -53.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.5 MiB -11055724.6 MiB      295971           for neighbor in current.neighbors:
    35     89.5 MiB -9824798.1 MiB      263040               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.5 MiB -9824805.2 MiB      263040               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.5 MiB -4908697.8 MiB      131452                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.5 MiB -9824818.9 MiB      263040               if temp_g_score < g_score[neighbor]:
    41     89.5 MiB -1242903.8 MiB       33626                   came_from[neighbor] = current
    42     89.5 MiB -1242904.0 MiB       33626                   g_score[neighbor] = temp_g_score
    43     89.5 MiB -1242904.2 MiB       33626                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.5 MiB -1230947.9 MiB       32931           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.5 MiB -1230947.9 MiB       32931           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.8 MiB      0.0 MiB           1       paths = {}
    53     35.9 MiB      0.0 MiB           2       for goal in goals:
    54     35.9 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.4 MiB     89.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.4 MiB      0.0 MiB         257       for row in grid:
     8     89.4 MiB      0.0 MiB       65792           for spot in row:
     9     89.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.4 MiB      0.0 MiB           1       came_from = {}
    18     93.5 MiB -217971.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     80.0 MiB    -13.6 MiB           1       g_score[start] = 0
    20                                         
    21     80.1 MiB -549488.6 MiB       17345       while not open_set.empty():
    22     80.1 MiB -549489.5 MiB       17345           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     80.1 MiB -549490.9 MiB       17345           current = open_set.get()[1]
    28                                         
    29     80.1 MiB -549491.7 MiB       17345           if current in remaining_goals:
    30     26.9 MiB    -53.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     26.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     26.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     80.1 MiB -4911382.8 MiB      155359           for neighbor in current.neighbors:
    35     80.1 MiB -4361911.7 MiB      138015               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     80.1 MiB -4361915.9 MiB      138015               if current.row != neighbor.row and current.col != neighbor.col:
    38     80.1 MiB -2175393.4 MiB       68885                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     80.1 MiB -4361927.8 MiB      138015               if temp_g_score < g_score[neighbor]:
    41     80.1 MiB -548811.3 MiB       17676                   came_from[neighbor] = current
    42     80.1 MiB -548812.1 MiB       17676                   g_score[neighbor] = temp_g_score
    43     80.1 MiB -548813.6 MiB       17676                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     80.1 MiB -549486.1 MiB       17344           if draw is not None:
    46                                                     draw()
    47                                                     
    48     80.1 MiB -549487.1 MiB       17344           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     26.9 MiB      0.0 MiB           1       paths = {}
    53     27.1 MiB      0.0 MiB           2       for goal in goals:
    54     27.1 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.8 MiB     85.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.8 MiB   -995.2 MiB         257       for row in grid:
     8     85.8 MiB -255061.0 MiB       65792           for spot in row:
     9     85.8 MiB -254068.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.7 MiB     -5.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     80.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     80.7 MiB      0.0 MiB           1       came_from = {}
    18     86.0 MiB  -1185.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     86.1 MiB -28944.9 MiB        2060       while not open_set.empty():
    22     86.1 MiB -28945.8 MiB        2060           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.1 MiB -28947.1 MiB        2060           current = open_set.get()[1]
    28                                         
    29     86.1 MiB -28947.7 MiB        2060           if current in remaining_goals:
    30     26.4 MiB    -59.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     26.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     26.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.1 MiB -260124.6 MiB       18531           for neighbor in current.neighbors:
    35     86.1 MiB -231199.2 MiB       16472               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.1 MiB -231203.4 MiB       16472               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.1 MiB -115651.8 MiB        8236                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.1 MiB -231227.5 MiB       16472               if temp_g_score < g_score[neighbor]:
    41     86.1 MiB -30315.6 MiB        2274                   came_from[neighbor] = current
    42     86.1 MiB -30316.4 MiB        2274                   g_score[neighbor] = temp_g_score
    43     86.1 MiB -30317.4 MiB        2274                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.1 MiB -28930.0 MiB        2059           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.1 MiB -28936.2 MiB        2059           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     26.4 MiB      0.0 MiB           1       paths = {}
    53     26.5 MiB      0.0 MiB           2       for goal in goals:
    54     26.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     26.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.3 MiB     88.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.3 MiB   -228.3 MiB         257       for row in grid:
     8     88.3 MiB -57967.8 MiB       65792           for spot in row:
     9     88.3 MiB -57742.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.4 MiB     -3.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.5 MiB      0.0 MiB           1       came_from = {}
    18     89.2 MiB  -9280.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.1 MiB     -2.1 MiB           1       g_score[start] = 0
    20                                         
    21     87.4 MiB -1986220.7 MiB       37727       while not open_set.empty():
    22     87.4 MiB -1986221.6 MiB       37727           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.4 MiB -1986223.9 MiB       37727           current = open_set.get()[1]
    28                                         
    29     87.4 MiB -1986224.8 MiB       37727           if current in remaining_goals:
    30     43.3 MiB    -44.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     43.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.4 MiB -17822896.1 MiB      338535           for neighbor in current.neighbors:
    35     87.4 MiB -15836720.2 MiB      300809               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.4 MiB -15836715.0 MiB      300809               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.4 MiB -7909626.6 MiB      150238                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.4 MiB -15836724.5 MiB      300809               if temp_g_score < g_score[neighbor]:
    41     87.4 MiB -2007913.8 MiB       38264                   came_from[neighbor] = current
    42     87.4 MiB -2007915.2 MiB       38264                   g_score[neighbor] = temp_g_score
    43     87.4 MiB -2007917.1 MiB       38264                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.4 MiB -1986217.8 MiB       37726           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.4 MiB -1986219.5 MiB       37726           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.3 MiB      0.0 MiB           1       paths = {}
    53     43.4 MiB      0.0 MiB           2       for goal in goals:
    54     43.4 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.0 MiB     86.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.0 MiB    -22.8 MiB         257       for row in grid:
     8     86.0 MiB  -5852.4 MiB       65792           for spot in row:
     9     86.0 MiB  -5829.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.9 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.9 MiB      0.0 MiB           1       came_from = {}
    18     91.2 MiB      5.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.4 MiB -3391243.2 MiB       65418       while not open_set.empty():
    22     91.4 MiB -3391244.6 MiB       65418           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.4 MiB -3391250.3 MiB       65418           current = open_set.get()[1]
    28                                         
    29     91.4 MiB -3391252.2 MiB       65418           if current in remaining_goals:
    30     23.1 MiB    -68.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     23.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     23.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.4 MiB -30349788.5 MiB      585780           for neighbor in current.neighbors:
    35     91.4 MiB -26958569.5 MiB      520363               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.4 MiB -26958568.3 MiB      520363               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.4 MiB -13450904.0 MiB      259687                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.4 MiB -26958591.3 MiB      520363               if temp_g_score < g_score[neighbor]:
    41     91.4 MiB -3371106.2 MiB       65447                   came_from[neighbor] = current
    42     91.4 MiB -3371107.7 MiB       65447                   g_score[neighbor] = temp_g_score
    43     91.4 MiB -3371113.5 MiB       65447                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.4 MiB -3391236.3 MiB       65417           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.4 MiB -3391238.9 MiB       65417           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     23.1 MiB      0.0 MiB           1       paths = {}
    53     24.4 MiB      0.0 MiB           2       for goal in goals:
    54     24.4 MiB      1.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     24.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.7 MiB     85.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.7 MiB -12046.8 MiB         257       for row in grid:
     8     85.7 MiB -3088810.2 MiB       65792           for spot in row:
     9     85.7 MiB -3076791.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     35.2 MiB    -50.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     35.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     35.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     35.8 MiB      0.0 MiB           1       came_from = {}
    18     44.7 MiB      8.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     44.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     45.2 MiB -851496.0 MiB       64482       while not open_set.empty():
    22     45.2 MiB -851515.0 MiB       64482           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     45.2 MiB -851515.9 MiB       64482           current = open_set.get()[1]
    28                                         
    29     45.2 MiB -851516.1 MiB       64482           if current in remaining_goals:
    30     24.6 MiB    -20.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     24.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     24.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     45.2 MiB -7624560.8 MiB      577586           for neighbor in current.neighbors:
    35     45.2 MiB -6773079.3 MiB      513105               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     45.2 MiB -6773079.7 MiB      513105               if current.row != neighbor.row and current.col != neighbor.col:
    38     45.2 MiB -3380123.5 MiB      256096                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     45.2 MiB -6773087.2 MiB      513105               if temp_g_score < g_score[neighbor]:
    41     45.2 MiB -848185.1 MiB       64587                   came_from[neighbor] = current
    42     45.2 MiB -848187.4 MiB       64587                   g_score[neighbor] = temp_g_score
    43     45.2 MiB -848188.3 MiB       64587                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     45.2 MiB -851494.4 MiB       64481           if draw is not None:
    46                                                     draw()
    47                                                     
    48     45.2 MiB -851495.1 MiB       64481           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     24.6 MiB      0.0 MiB           1       paths = {}
    53     26.6 MiB      0.0 MiB           2       for goal in goals:
    54     26.6 MiB      2.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     26.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.9 MiB     85.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.9 MiB   -300.0 MiB         257       for row in grid:
     8     85.9 MiB -76542.1 MiB       65792           for spot in row:
     9     85.9 MiB -76243.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.4 MiB     -3.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.4 MiB      0.0 MiB           1       came_from = {}
    18     87.6 MiB  -1401.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.6 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.6 MiB -895286.1 MiB       19738       while not open_set.empty():
    22     87.6 MiB -895286.2 MiB       19738           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.6 MiB -895288.3 MiB       19738           current = open_set.get()[1]
    28                                         
    29     87.6 MiB -895289.1 MiB       19738           if current in remaining_goals:
    30     32.0 MiB    -55.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.6 MiB -8035801.3 MiB      177054           for neighbor in current.neighbors:
    35     87.6 MiB -7140546.8 MiB      157317               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.6 MiB -7140543.8 MiB      157317               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.6 MiB -3566739.8 MiB       78562                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.6 MiB -7140551.5 MiB      157317               if temp_g_score < g_score[neighbor]:
    41     87.6 MiB -909398.2 MiB       20213                   came_from[neighbor] = current
    42     87.6 MiB -909400.6 MiB       20213                   g_score[neighbor] = temp_g_score
    43     87.6 MiB -909402.2 MiB       20213                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.6 MiB -895283.9 MiB       19737           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.6 MiB -895285.9 MiB       19737           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.0 MiB      0.0 MiB           1       paths = {}
    53     32.1 MiB      0.0 MiB           2       for goal in goals:
    54     32.1 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.7 MiB     84.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.7 MiB    -32.8 MiB         257       for row in grid:
     8     84.7 MiB  -8297.0 MiB       65792           for spot in row:
     9     84.7 MiB  -8265.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.7 MiB     -1.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.7 MiB      0.0 MiB           1       came_from = {}
    18     88.9 MiB   -237.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.0 MiB -3375249.7 MiB       60376       while not open_set.empty():
    22     89.0 MiB -3375252.2 MiB       60376           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.0 MiB -3375256.3 MiB       60376           current = open_set.get()[1]
    28                                         
    29     89.0 MiB -3375257.2 MiB       60376           if current in remaining_goals:
    30     21.2 MiB    -67.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     21.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     21.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.0 MiB -30264602.8 MiB      541232           for neighbor in current.neighbors:
    35     89.0 MiB -26889402.7 MiB      480857               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.0 MiB -26889404.4 MiB      480857               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.0 MiB -13426072.0 MiB      240072                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.0 MiB -26889419.0 MiB      480857               if temp_g_score < g_score[neighbor]:
    41     89.0 MiB -3380774.3 MiB       60681                   came_from[neighbor] = current
    42     89.0 MiB -3380776.1 MiB       60681                   g_score[neighbor] = temp_g_score
    43     89.0 MiB -3380780.0 MiB       60681                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.0 MiB -3375221.0 MiB       60375           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.0 MiB -3375248.5 MiB       60375           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     21.2 MiB      0.0 MiB           1       paths = {}
    53     23.5 MiB      0.0 MiB           2       for goal in goals:
    54     23.5 MiB      2.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     23.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.1 MiB     92.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.1 MiB   -860.1 MiB         257       for row in grid:
     8     92.1 MiB -220840.8 MiB       65792           for spot in row:
     9     92.1 MiB -219983.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.5 MiB     -3.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     88.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     88.9 MiB      0.0 MiB           1       came_from = {}
    18     94.0 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.6 MiB -2553709.4 MiB       50579       while not open_set.empty():
    22     94.6 MiB -2553711.1 MiB       50579           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.6 MiB -2553712.3 MiB       50579           current = open_set.get()[1]
    28                                         
    29     94.6 MiB -2553713.8 MiB       50579           if current in remaining_goals:
    30     35.4 MiB    -59.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.6 MiB -22901274.0 MiB      453542           for neighbor in current.neighbors:
    35     94.6 MiB -20347572.7 MiB      402964               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.6 MiB -20347566.2 MiB      402964               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.6 MiB -10160298.3 MiB      201206                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.6 MiB -20347623.4 MiB      402964               if temp_g_score < g_score[neighbor]:
    41     94.6 MiB -2559605.0 MiB       50995                   came_from[neighbor] = current
    42     94.6 MiB -2559606.1 MiB       50995                   g_score[neighbor] = temp_g_score
    43     94.6 MiB -2559607.3 MiB       50995                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.6 MiB -2553707.9 MiB       50578           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.6 MiB -2553709.0 MiB       50578           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.4 MiB      0.0 MiB           1       paths = {}
    53     35.7 MiB      0.0 MiB           2       for goal in goals:
    54     35.7 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.7 MiB     90.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.7 MiB   -176.6 MiB         257       for row in grid:
     8     90.7 MiB -45104.5 MiB       65792           for spot in row:
     9     90.7 MiB -44929.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.2 MiB     -2.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.2 MiB      0.0 MiB           1       came_from = {}
    18     91.9 MiB -10012.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.0 MiB -2974494.4 MiB       59219       while not open_set.empty():
    22     92.0 MiB -2974495.1 MiB       59219           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.0 MiB -2974497.6 MiB       59219           current = open_set.get()[1]
    28                                         
    29     92.0 MiB -2974498.1 MiB       59219           if current in remaining_goals:
    30     37.7 MiB    -54.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     37.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.0 MiB -26661948.1 MiB      530977           for neighbor in current.neighbors:
    35     92.0 MiB -23687485.2 MiB      471759               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.0 MiB -23687496.1 MiB      471759               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.0 MiB -11825746.3 MiB      235549                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.0 MiB -23687506.8 MiB      471759               if temp_g_score < g_score[neighbor]:
    41     92.0 MiB -2974699.9 MiB       59576                   came_from[neighbor] = current
    42     92.0 MiB -2974700.6 MiB       59576                   g_score[neighbor] = temp_g_score
    43     92.0 MiB -2974703.4 MiB       59576                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.0 MiB -2974470.1 MiB       59218           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.0 MiB -2974470.6 MiB       59218           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.7 MiB      0.0 MiB           1       paths = {}
    53     37.9 MiB      0.0 MiB           2       for goal in goals:
    54     37.9 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.5 MiB     89.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.5 MiB   -285.9 MiB         257       for row in grid:
     8     89.5 MiB -73049.1 MiB       65792           for spot in row:
     9     89.5 MiB -72765.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.6 MiB     -1.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.6 MiB      0.0 MiB           1       came_from = {}
    18     92.5 MiB  -2063.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.9 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21     91.9 MiB  -3219.7 MiB        5488       while not open_set.empty():
    22     91.9 MiB  -3219.7 MiB        5488           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.9 MiB  -3219.7 MiB        5488           current = open_set.get()[1]
    28                                         
    29     91.9 MiB  -3219.7 MiB        5488           if current in remaining_goals:
    30     87.8 MiB     -4.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     87.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     87.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.9 MiB -28945.6 MiB       49383           for neighbor in current.neighbors:
    35     91.9 MiB -25726.0 MiB       43896               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.9 MiB -25726.2 MiB       43896               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.9 MiB -12863.3 MiB       21948                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.9 MiB -25730.5 MiB       43896               if temp_g_score < g_score[neighbor]:
    41     91.9 MiB  -3367.1 MiB        5838                   came_from[neighbor] = current
    42     91.9 MiB  -3367.1 MiB        5838                   g_score[neighbor] = temp_g_score
    43     91.9 MiB  -3367.1 MiB        5838                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.9 MiB  -3219.7 MiB        5487           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.9 MiB  -3219.7 MiB        5487           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     87.8 MiB      0.0 MiB           1       paths = {}
    53     87.8 MiB      0.0 MiB           2       for goal in goals:
    54     87.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     87.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.4 MiB     92.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.4 MiB      0.0 MiB         257       for row in grid:
     8     92.4 MiB      0.0 MiB       65792           for spot in row:
     9     92.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.4 MiB      0.0 MiB           1       came_from = {}
    18     96.9 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.9 MiB -83881.0 MiB        5875       while not open_set.empty():
    22     96.9 MiB -83881.3 MiB        5875           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.9 MiB -83881.4 MiB        5875           current = open_set.get()[1]
    28                                         
    29     96.9 MiB -83881.5 MiB        5875           if current in remaining_goals:
    30     32.6 MiB    -64.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.9 MiB -754832.0 MiB       52866           for neighbor in current.neighbors:
    35     96.9 MiB -670954.8 MiB       46992               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.9 MiB -670997.0 MiB       46992               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.9 MiB -335512.9 MiB       23496                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.9 MiB -671014.3 MiB       46992               if temp_g_score < g_score[neighbor]:
    41     96.9 MiB -86949.2 MiB        6241                   came_from[neighbor] = current
    42     96.9 MiB -86949.3 MiB        6241                   g_score[neighbor] = temp_g_score
    43     96.9 MiB -86949.5 MiB        6241                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.9 MiB -83879.7 MiB        5874           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.9 MiB -83879.7 MiB        5874           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.6 MiB      0.0 MiB           1       paths = {}
    53     32.7 MiB      0.0 MiB           2       for goal in goals:
    54     32.7 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.5 MiB     90.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.5 MiB      0.0 MiB         257       for row in grid:
     8     90.5 MiB      0.0 MiB       65792           for spot in row:
     9     90.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.5 MiB      0.0 MiB           1       came_from = {}
    18     94.1 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.3 MiB -197303.7 MiB        7461       while not open_set.empty():
    22     94.3 MiB -197303.7 MiB        7461           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.3 MiB -197304.0 MiB        7461           current = open_set.get()[1]
    28                                         
    29     94.3 MiB -197304.2 MiB        7461           if current in remaining_goals:
    30     21.1 MiB    -73.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     21.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     21.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.3 MiB -1769091.4 MiB       66765           for neighbor in current.neighbors:
    35     94.3 MiB -1571799.5 MiB       59305               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.3 MiB -1571816.5 MiB       59305               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.3 MiB -784953.7 MiB       29590                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.3 MiB -1571837.9 MiB       59305               if temp_g_score < g_score[neighbor]:
    41     94.3 MiB -201773.7 MiB        7754                   came_from[neighbor] = current
    42     94.3 MiB -201774.2 MiB        7754                   g_score[neighbor] = temp_g_score
    43     94.3 MiB -201774.6 MiB        7754                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.3 MiB -197301.6 MiB        7460           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.3 MiB -197301.8 MiB        7460           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     21.1 MiB      0.0 MiB           1       paths = {}
    53     21.3 MiB      0.0 MiB           2       for goal in goals:
    54     21.3 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     21.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.1 MiB     85.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.1 MiB   -251.9 MiB         257       for row in grid:
     8     85.1 MiB -64188.5 MiB       65792           for spot in row:
     9     85.1 MiB -63939.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.8 MiB     -3.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     81.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     81.8 MiB      0.0 MiB           1       came_from = {}
    18     84.4 MiB -489214.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     62.4 MiB    -22.0 MiB           1       g_score[start] = 0
    20                                         
    21     62.7 MiB -1654060.3 MiB       49102       while not open_set.empty():
    22     62.7 MiB -1654062.2 MiB       49102           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     62.7 MiB -1654065.5 MiB       49102           current = open_set.get()[1]
    28                                         
    29     62.7 MiB -1654066.3 MiB       49102           if current in remaining_goals:
    30     47.7 MiB    -14.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     47.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     47.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     62.7 MiB -14839934.5 MiB      440584           for neighbor in current.neighbors:
    35     62.7 MiB -13185902.0 MiB      391483               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     62.7 MiB -13185895.9 MiB      391483               if current.row != neighbor.row and current.col != neighbor.col:
    38     62.7 MiB -6585267.3 MiB      195521                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     62.7 MiB -13185904.5 MiB      391483               if temp_g_score < g_score[neighbor]:
    41     62.7 MiB -1670086.1 MiB       49643                   came_from[neighbor] = current
    42     62.7 MiB -1670090.2 MiB       49643                   g_score[neighbor] = temp_g_score
    43     62.7 MiB -1670090.5 MiB       49643                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     62.7 MiB -1654058.9 MiB       49101           if draw is not None:
    46                                                     draw()
    47                                                     
    48     62.7 MiB -1654059.5 MiB       49101           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     47.7 MiB      0.0 MiB           1       paths = {}
    53     47.9 MiB      0.0 MiB           2       for goal in goals:
    54     47.9 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     48.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.5 MiB     86.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.5 MiB   -435.2 MiB         257       for row in grid:
     8     86.5 MiB -111228.4 MiB       65792           for spot in row:
     9     86.5 MiB -110795.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.5 MiB     -4.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.5 MiB      0.0 MiB           1       came_from = {}
    18     86.8 MiB  -7788.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     86.8 MiB  -8347.6 MiB        4038       while not open_set.empty():
    22     86.8 MiB  -8347.7 MiB        4038           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.8 MiB  -8347.8 MiB        4038           current = open_set.get()[1]
    28                                         
    29     86.8 MiB  -8347.9 MiB        4038           if current in remaining_goals:
    30     80.6 MiB     -6.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     80.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     80.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.8 MiB -74718.5 MiB       36228           for neighbor in current.neighbors:
    35     86.8 MiB -66372.4 MiB       32191               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.8 MiB -66373.9 MiB       32191               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.8 MiB -33130.6 MiB       16078                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.8 MiB -66376.2 MiB       32191               if temp_g_score < g_score[neighbor]:
    41     86.8 MiB  -8591.5 MiB        4295                   came_from[neighbor] = current
    42     86.8 MiB  -8591.5 MiB        4295                   g_score[neighbor] = temp_g_score
    43     86.8 MiB  -8591.5 MiB        4295                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.8 MiB  -8347.0 MiB        4037           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.8 MiB  -8347.3 MiB        4037           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     80.6 MiB      0.0 MiB           1       paths = {}
    53     80.7 MiB      0.0 MiB           2       for goal in goals:
    54     80.7 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     80.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.2 MiB     88.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.2 MiB   -421.0 MiB         257       for row in grid:
     8     88.2 MiB -107668.5 MiB       65792           for spot in row:
     9     88.2 MiB -107248.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.3 MiB     -3.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.3 MiB      0.0 MiB           1       came_from = {}
    18     89.8 MiB      5.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.8 MiB -28822.0 MiB        1635       while not open_set.empty():
    22     89.8 MiB -28822.3 MiB        1635           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.8 MiB -28850.2 MiB        1635           current = open_set.get()[1]
    28                                         
    29     89.8 MiB -28850.3 MiB        1635           if current in remaining_goals:
    30     48.9 MiB    -40.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     48.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     48.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.8 MiB -259313.7 MiB       14706           for neighbor in current.neighbors:
    35     89.8 MiB -230494.9 MiB       13072               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.8 MiB -230497.0 MiB       13072               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.8 MiB -115260.8 MiB        6536                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.8 MiB -230500.8 MiB       13072               if temp_g_score < g_score[neighbor]:
    41     89.8 MiB -31307.2 MiB        1825                   came_from[neighbor] = current
    42     89.8 MiB -31307.9 MiB        1825                   g_score[neighbor] = temp_g_score
    43     89.8 MiB -31309.0 MiB        1825                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.8 MiB -28821.3 MiB        1634           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.8 MiB -28821.6 MiB        1634           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     48.9 MiB      0.0 MiB           1       paths = {}
    53     48.9 MiB      0.0 MiB           2       for goal in goals:
    54     48.9 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     48.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     96.9 MiB     96.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     96.9 MiB   -271.1 MiB         257       for row in grid:
     8     96.9 MiB -69376.5 MiB       65792           for spot in row:
     9     96.9 MiB -69106.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.5 MiB     -2.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.6 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     94.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     94.8 MiB      0.0 MiB           1       came_from = {}
    18     96.4 MiB -99129.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.0 MiB     -9.3 MiB           1       g_score[start] = 0
    20                                         
    21     87.1 MiB -2751881.9 MiB       48680       while not open_set.empty():
    22     87.1 MiB -2751883.5 MiB       48680           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.1 MiB -2751889.1 MiB       48680           current = open_set.get()[1]
    28                                         
    29     87.1 MiB -2751895.0 MiB       48680           if current in remaining_goals:
    30     32.6 MiB    -54.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.1 MiB -24696870.2 MiB      436855           for neighbor in current.neighbors:
    35     87.1 MiB -21945010.8 MiB      388176               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.1 MiB -21945004.2 MiB      388176               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.1 MiB -10960946.6 MiB      193879                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.1 MiB -21945045.2 MiB      388176               if temp_g_score < g_score[neighbor]:
    41     87.1 MiB -2778131.0 MiB       49230                   came_from[neighbor] = current
    42     87.1 MiB -2778132.1 MiB       49230                   g_score[neighbor] = temp_g_score
    43     87.1 MiB -2778134.2 MiB       49230                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.1 MiB -2751874.2 MiB       48679           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.1 MiB -2751876.3 MiB       48679           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.6 MiB      0.0 MiB           1       paths = {}
    53     32.8 MiB      0.0 MiB           2       for goal in goals:
    54     32.8 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.3 MiB     91.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.3 MiB   -815.8 MiB         257       for row in grid:
     8     91.3 MiB -208663.0 MiB       65792           for spot in row:
     9     91.3 MiB -207851.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.3 MiB     -6.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.3 MiB      0.0 MiB           1       came_from = {}
    18     90.4 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.6 MiB -407082.2 MiB        8634       while not open_set.empty():
    22     90.6 MiB -407082.4 MiB        8634           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.6 MiB -407082.7 MiB        8634           current = open_set.get()[1]
    28                                         
    29     90.6 MiB -407083.0 MiB        8634           if current in remaining_goals:
    30     22.0 MiB    -68.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     22.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     22.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.6 MiB -3647211.4 MiB       77448           for neighbor in current.neighbors:
    35     90.6 MiB -3240178.4 MiB       68815               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.6 MiB -3240183.3 MiB       68815               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.6 MiB -1617413.3 MiB       34366                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.6 MiB -3240189.8 MiB       68815               if temp_g_score < g_score[neighbor]:
    41     90.6 MiB -414274.1 MiB        8977                   came_from[neighbor] = current
    42     90.6 MiB -414275.7 MiB        8977                   g_score[neighbor] = temp_g_score
    43     90.6 MiB -414276.5 MiB        8977                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.6 MiB -407081.3 MiB        8633           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.6 MiB -407081.7 MiB        8633           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     22.0 MiB      0.0 MiB           1       paths = {}
    53     22.1 MiB      0.0 MiB           2       for goal in goals:
    54     22.1 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     22.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.4 MiB     89.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.4 MiB  -9545.7 MiB         257       for row in grid:
     8     89.4 MiB -2449013.0 MiB       65792           for spot in row:
     9     89.4 MiB -2439482.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     28.3 MiB    -61.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     28.7 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     28.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     29.0 MiB      0.0 MiB           1       came_from = {}
    18     39.0 MiB     -9.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     39.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     40.0 MiB -460836.2 MiB       46786       while not open_set.empty():
    22     40.0 MiB -460836.6 MiB       46786           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     40.0 MiB -460841.9 MiB       46786           current = open_set.get()[1]
    28                                         
    29     40.0 MiB -460842.2 MiB       46786           if current in remaining_goals:
    30     34.3 MiB     -5.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     40.0 MiB -4129832.4 MiB      419710           for neighbor in current.neighbors:
    35     40.0 MiB -3669003.0 MiB      372925               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     40.0 MiB -3668994.6 MiB      372925               if current.row != neighbor.row and current.col != neighbor.col:
    38     40.0 MiB -1831581.0 MiB      186237                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     40.0 MiB -3669001.5 MiB      372925               if temp_g_score < g_score[neighbor]:
    41     40.0 MiB -463202.3 MiB       47303                   came_from[neighbor] = current
    42     40.0 MiB -463203.1 MiB       47303                   g_score[neighbor] = temp_g_score
    43     40.0 MiB -463204.6 MiB       47303                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     40.0 MiB -460835.0 MiB       46785           if draw is not None:
    46                                                     draw()
    47                                                     
    48     40.0 MiB -460835.7 MiB       46785           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.3 MiB      0.0 MiB           1       paths = {}
    53     34.5 MiB      0.0 MiB           2       for goal in goals:
    54     34.5 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.3 MiB     89.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.3 MiB  -9262.4 MiB         257       for row in grid:
     8     89.3 MiB -2368594.4 MiB       65792           for spot in row:
     9     89.3 MiB -2359383.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     31.7 MiB    -57.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     32.1 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     32.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     32.3 MiB      0.0 MiB           1       came_from = {}
    18     38.5 MiB -132510.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     33.3 MiB     -5.2 MiB           1       g_score[start] = 0
    20                                         
    21     45.3 MiB -502104.6 MiB       51492       while not open_set.empty():
    22     45.3 MiB -502120.0 MiB       51492           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     45.3 MiB -502120.6 MiB       51492           current = open_set.get()[1]
    28                                         
    29     45.3 MiB -502121.4 MiB       51492           if current in remaining_goals:
    30     35.9 MiB     -9.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     45.3 MiB -4503676.5 MiB      461783           for neighbor in current.neighbors:
    35     45.3 MiB -4001593.8 MiB      410292               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     45.3 MiB -4001579.0 MiB      410292               if current.row != neighbor.row and current.col != neighbor.col:
    38     45.3 MiB -1998263.3 MiB      204874                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     45.3 MiB -4001586.4 MiB      410292               if temp_g_score < g_score[neighbor]:
    41     45.3 MiB -504874.7 MiB       51946                   came_from[neighbor] = current
    42     45.3 MiB -504875.3 MiB       51946                   g_score[neighbor] = temp_g_score
    43     45.3 MiB -504877.5 MiB       51946                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     45.3 MiB -502101.8 MiB       51491           if draw is not None:
    46                                                     draw()
    47                                                     
    48     45.3 MiB -502102.0 MiB       51491           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.9 MiB      0.0 MiB           1       paths = {}
    53     36.2 MiB      0.0 MiB           2       for goal in goals:
    54     36.2 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.1 MiB     89.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.1 MiB    -10.3 MiB         257       for row in grid:
     8     89.1 MiB  -2634.4 MiB       65792           for spot in row:
     9     89.1 MiB  -2624.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.0 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.0 MiB      0.0 MiB           1       came_from = {}
    18     94.0 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.1 MiB  -2469.4 MiB        4415       while not open_set.empty():
    22     94.1 MiB  -2469.4 MiB        4415           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.1 MiB  -2469.4 MiB        4415           current = open_set.get()[1]
    28                                         
    29     94.1 MiB  -2469.4 MiB        4415           if current in remaining_goals:
    30     92.5 MiB     -1.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     92.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     92.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.1 MiB -22085.7 MiB       39645           for neighbor in current.neighbors:
    35     94.1 MiB -19616.7 MiB       35231               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.1 MiB -19616.8 MiB       35231               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.1 MiB  -9788.7 MiB       17602                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.1 MiB -19617.8 MiB       35231               if temp_g_score < g_score[neighbor]:
    41     94.1 MiB  -2507.7 MiB        4694                   came_from[neighbor] = current
    42     94.1 MiB  -2507.8 MiB        4694                   g_score[neighbor] = temp_g_score
    43     94.1 MiB  -2507.8 MiB        4694                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.1 MiB  -2469.1 MiB        4414           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.1 MiB  -2469.2 MiB        4414           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     92.5 MiB      0.0 MiB           1       paths = {}
    53     92.5 MiB      0.0 MiB           2       for goal in goals:
    54     92.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     92.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.1 MiB     93.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.1 MiB    -84.6 MiB         257       for row in grid:
     8     93.1 MiB -21311.6 MiB       65792           for spot in row:
     9     93.1 MiB -21228.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.9 MiB     -2.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.9 MiB      0.0 MiB           1       came_from = {}
    18     94.6 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.6 MiB -542817.6 MiB       19160       while not open_set.empty():
    22     94.6 MiB -542817.8 MiB       19160           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.6 MiB -542821.1 MiB       19160           current = open_set.get()[1]
    28                                         
    29     94.6 MiB -542821.6 MiB       19160           if current in remaining_goals:
    30     38.5 MiB    -56.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     38.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.6 MiB -4873754.8 MiB      171960           for neighbor in current.neighbors:
    35     94.6 MiB -4330941.9 MiB      152801               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.6 MiB -4330943.5 MiB      152801               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.6 MiB -2163663.0 MiB       76322                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.6 MiB -4330986.8 MiB      152801               if temp_g_score < g_score[neighbor]:
    41     94.6 MiB -550093.5 MiB       19641                   came_from[neighbor] = current
    42     94.6 MiB -550093.9 MiB       19641                   g_score[neighbor] = temp_g_score
    43     94.6 MiB -550094.4 MiB       19641                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.6 MiB -542816.0 MiB       19159           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.6 MiB -542817.0 MiB       19159           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.5 MiB      0.0 MiB           1       paths = {}
    53     38.6 MiB      0.0 MiB           2       for goal in goals:
    54     38.6 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.1 MiB     88.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.1 MiB    -48.1 MiB         257       for row in grid:
     8     88.1 MiB -12273.9 MiB       65792           for spot in row:
     9     88.1 MiB -12226.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.4 MiB     -0.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.4 MiB      0.0 MiB           1       came_from = {}
    18     87.7 MiB -384509.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     77.6 MiB    -10.0 MiB           1       g_score[start] = 0
    20                                         
    21     77.7 MiB -48138.5 MiB        2214       while not open_set.empty():
    22     77.7 MiB -48138.5 MiB        2214           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     77.7 MiB -48138.5 MiB        2214           current = open_set.get()[1]
    28                                         
    29     77.7 MiB -48138.5 MiB        2214           if current in remaining_goals:
    30     41.2 MiB    -36.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     41.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     77.7 MiB -430288.7 MiB       19842           for neighbor in current.neighbors:
    35     77.7 MiB -382152.8 MiB       17629               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     77.7 MiB -382154.1 MiB       17629               if current.row != neighbor.row and current.col != neighbor.col:
    38     77.7 MiB -190655.1 MiB        8802                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     77.7 MiB -382153.6 MiB       17629               if temp_g_score < g_score[neighbor]:
    41     77.7 MiB -50159.5 MiB        2407                   came_from[neighbor] = current
    42     77.7 MiB -50159.6 MiB        2407                   g_score[neighbor] = temp_g_score
    43     77.7 MiB -50159.6 MiB        2407                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     77.7 MiB -48138.5 MiB        2213           if draw is not None:
    46                                                     draw()
    47                                                     
    48     77.7 MiB -48138.5 MiB        2213           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.2 MiB      0.0 MiB           1       paths = {}
    53     41.2 MiB      0.0 MiB           2       for goal in goals:
    54     41.2 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.2 MiB     86.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.2 MiB    -78.7 MiB         257       for row in grid:
     8     86.2 MiB -19774.6 MiB       65792           for spot in row:
     9     86.2 MiB -19697.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.3 MiB     -3.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     82.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     82.7 MiB      0.0 MiB           1       came_from = {}
    18     84.5 MiB -783706.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     29.8 MiB    -54.8 MiB           1       g_score[start] = 0
    20                                         
    21     33.2 MiB -105806.2 MiB       18442       while not open_set.empty():
    22     33.2 MiB -105806.4 MiB       18442           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     33.2 MiB -105807.2 MiB       18442           current = open_set.get()[1]
    28                                         
    29     33.2 MiB -105807.6 MiB       18442           if current in remaining_goals:
    30     27.4 MiB     -5.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     27.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     27.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     33.2 MiB -949255.7 MiB      165597           for neighbor in current.neighbors:
    35     33.2 MiB -843454.3 MiB      147156               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     33.2 MiB -843448.5 MiB      147156               if current.row != neighbor.row and current.col != neighbor.col:
    38     33.2 MiB -421225.4 MiB       73516                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     33.2 MiB -843455.6 MiB      147156               if temp_g_score < g_score[neighbor]:
    41     33.2 MiB -107058.7 MiB       18938                   came_from[neighbor] = current
    42     33.2 MiB -107059.5 MiB       18938                   g_score[neighbor] = temp_g_score
    43     33.2 MiB -107059.5 MiB       18938                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     33.2 MiB -105815.1 MiB       18441           if draw is not None:
    46                                                     draw()
    47                                                     
    48     33.2 MiB -105805.8 MiB       18441           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.4 MiB      0.0 MiB           1       paths = {}
    53     27.6 MiB      0.0 MiB           2       for goal in goals:
    54     27.6 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     82.3 MiB     82.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     82.3 MiB   -107.8 MiB         257       for row in grid:
     8     82.3 MiB -27422.3 MiB       65792           for spot in row:
     9     82.3 MiB -27315.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.3 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     80.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     80.3 MiB      0.0 MiB           1       came_from = {}
    18     85.5 MiB  -2446.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.4 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     85.5 MiB -998508.6 MiB       24080       while not open_set.empty():
    22     85.5 MiB -998509.6 MiB       24080           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.5 MiB -998512.3 MiB       24080           current = open_set.get()[1]
    28                                         
    29     85.5 MiB -998513.2 MiB       24080           if current in remaining_goals:
    30     42.5 MiB    -43.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     42.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     85.5 MiB -8948950.9 MiB      215818           for neighbor in current.neighbors:
    35     85.5 MiB -7950457.1 MiB      191739               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.5 MiB -7950464.3 MiB      191739               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.5 MiB -3969078.6 MiB       95721                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.5 MiB -7950479.0 MiB      191739               if temp_g_score < g_score[neighbor]:
    41     85.5 MiB -1007899.9 MiB       24465                   came_from[neighbor] = current
    42     85.5 MiB -1007901.4 MiB       24465                   g_score[neighbor] = temp_g_score
    43     85.5 MiB -1007904.5 MiB       24465                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.5 MiB -998505.6 MiB       24079           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.5 MiB -998507.3 MiB       24079           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.5 MiB      0.0 MiB           1       paths = {}
    53     42.7 MiB      0.0 MiB           2       for goal in goals:
    54     42.7 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.5 MiB     92.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.5 MiB      0.0 MiB         257       for row in grid:
     8     92.5 MiB      0.0 MiB       65792           for spot in row:
     9     92.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.5 MiB      0.0 MiB           1       came_from = {}
    18     96.0 MiB   -376.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.0 MiB -2352386.6 MiB       45140       while not open_set.empty():
    22     96.0 MiB -2352387.0 MiB       45140           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.0 MiB -2352387.3 MiB       45140           current = open_set.get()[1]
    28                                         
    29     96.0 MiB -2352388.3 MiB       45140           if current in remaining_goals:
    30     38.9 MiB    -57.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     38.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.0 MiB -21147014.9 MiB      405849           for neighbor in current.neighbors:
    35     96.0 MiB -18794693.8 MiB      360710               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.0 MiB -18794698.8 MiB      360710               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.0 MiB -9393446.6 MiB      180288                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.0 MiB -18794712.1 MiB      360710               if temp_g_score < g_score[neighbor]:
    41     96.0 MiB -2378334.4 MiB       45966                   came_from[neighbor] = current
    42     96.0 MiB -2378335.2 MiB       45966                   g_score[neighbor] = temp_g_score
    43     96.0 MiB -2378336.4 MiB       45966                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.0 MiB -2352384.4 MiB       45139           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.0 MiB -2352385.8 MiB       45139           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.9 MiB      0.0 MiB           1       paths = {}
    53     39.2 MiB      0.0 MiB           2       for goal in goals:
    54     39.2 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     39.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.0 MiB     93.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.0 MiB    -18.3 MiB         257       for row in grid:
     8     93.0 MiB  -4689.5 MiB       65792           for spot in row:
     9     93.0 MiB  -4671.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.9 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.9 MiB      0.0 MiB           1       came_from = {}
    18     95.4 MiB -12415.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.3 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.4 MiB -41065.7 MiB        6124       while not open_set.empty():
    22     95.4 MiB -41065.9 MiB        6124           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.4 MiB -41066.2 MiB        6124           current = open_set.get()[1]
    28                                         
    29     95.4 MiB -41066.3 MiB        6124           if current in remaining_goals:
    30     81.5 MiB    -13.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     81.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     81.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     95.4 MiB -367949.3 MiB       54858           for neighbor in current.neighbors:
    35     95.4 MiB -326890.4 MiB       48735               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.4 MiB -326891.9 MiB       48735               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.4 MiB -163194.8 MiB       24326                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.4 MiB -326893.8 MiB       48735               if temp_g_score < g_score[neighbor]:
    41     95.4 MiB -42054.5 MiB        6401                   came_from[neighbor] = current
    42     95.4 MiB -42054.8 MiB        6401                   g_score[neighbor] = temp_g_score
    43     95.4 MiB -42055.4 MiB        6401                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.4 MiB -41063.5 MiB        6123           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.4 MiB -41065.5 MiB        6123           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     81.5 MiB      0.0 MiB           1       paths = {}
    53     81.6 MiB      0.0 MiB           2       for goal in goals:
    54     81.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     81.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.4 MiB     92.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.4 MiB   -180.7 MiB         257       for row in grid:
     8     92.4 MiB -46298.4 MiB       65792           for spot in row:
     9     92.4 MiB -46118.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.8 MiB     -1.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.8 MiB      0.0 MiB           1       came_from = {}
    18     93.9 MiB  -1089.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.9 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.9 MiB -1802740.5 MiB       34220       while not open_set.empty():
    22     93.9 MiB -1802742.9 MiB       34220           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.9 MiB -1802745.9 MiB       34220           current = open_set.get()[1]
    28                                         
    29     93.9 MiB -1802747.6 MiB       34220           if current in remaining_goals:
    30     32.2 MiB    -61.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.9 MiB -16169188.6 MiB      306766           for neighbor in current.neighbors:
    35     93.9 MiB -14366475.2 MiB      272547               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.9 MiB -14366477.8 MiB      272547               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.9 MiB -7174096.9 MiB      136073                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.9 MiB -14366493.5 MiB      272547               if temp_g_score < g_score[neighbor]:
    41     93.9 MiB -1819434.7 MiB       34663                   came_from[neighbor] = current
    42     93.9 MiB -1819435.8 MiB       34663                   g_score[neighbor] = temp_g_score
    43     93.9 MiB -1819438.8 MiB       34663                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.9 MiB -1802737.6 MiB       34219           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.9 MiB -1802738.5 MiB       34219           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.2 MiB      0.0 MiB           1       paths = {}
    53     32.4 MiB      0.0 MiB           2       for goal in goals:
    54     32.4 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.2 MiB     88.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.2 MiB     -1.5 MiB         257       for row in grid:
     8     88.2 MiB   -377.8 MiB       65792           for spot in row:
     9     88.2 MiB   -376.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.1 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.1 MiB      0.0 MiB           1       came_from = {}
    18     92.2 MiB   -424.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.1 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     92.2 MiB -31325.4 MiB        5822       while not open_set.empty():
    22     92.2 MiB -31325.7 MiB        5822           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.2 MiB -31326.2 MiB        5822           current = open_set.get()[1]
    28                                         
    29     92.2 MiB -31326.4 MiB        5822           if current in remaining_goals:
    30     83.2 MiB     -9.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     83.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     83.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.2 MiB -279997.2 MiB       52179           for neighbor in current.neighbors:
    35     92.2 MiB -248674.9 MiB       46358               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.2 MiB -248676.3 MiB       46358               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.2 MiB -124031.8 MiB       23144                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.2 MiB -248678.6 MiB       46358               if temp_g_score < g_score[neighbor]:
    41     92.2 MiB -31685.5 MiB        6090                   came_from[neighbor] = current
    42     92.2 MiB -31685.6 MiB        6090                   g_score[neighbor] = temp_g_score
    43     92.2 MiB -31685.8 MiB        6090                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.2 MiB -31324.8 MiB        5821           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.2 MiB -31325.2 MiB        5821           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     83.2 MiB      0.0 MiB           1       paths = {}
    53     83.2 MiB      0.0 MiB           2       for goal in goals:
    54     83.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     83.2 MiB      0.0 MiB           1       return paths


