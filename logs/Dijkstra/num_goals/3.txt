Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.1 MiB     67.1 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/3.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     70.3 MiB    -40.4 MiB         257       for row in grid:
     8     70.3 MiB -10403.0 MiB       65792           for spot in row:
     9     70.3 MiB -10359.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     69.8 MiB     -0.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     69.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     69.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     69.8 MiB      0.0 MiB           1       came_from = {}
    18     74.1 MiB -35649.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     74.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     74.1 MiB -1080343.9 MiB       61471       while not open_set.empty():
    22     74.1 MiB -1080345.0 MiB       61471           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     74.1 MiB -1080347.4 MiB       61471           current = open_set.get()[1]
    28                                         
    29     74.1 MiB -1080349.4 MiB       61471           if current in remaining_goals:
    30     60.0 MiB    -76.4 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     60.0 MiB    -34.1 MiB           3               if not remaining_goals:
    32     43.8 MiB    -16.3 MiB           1                   break  # All goals found
    33                                         
    34     74.1 MiB -9673677.0 MiB      550886           for neighbor in current.neighbors:
    35     74.1 MiB -8593371.5 MiB      489416               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     74.1 MiB -8593375.0 MiB      489416               if current.row != neighbor.row and current.col != neighbor.col:
    38     74.1 MiB -4288511.7 MiB      244318                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     74.1 MiB -8593383.9 MiB      489416               if temp_g_score < g_score[neighbor]:
    41     74.1 MiB -1076672.6 MiB       61709                   came_from[neighbor] = current
    42     74.1 MiB -1076673.1 MiB       61709                   g_score[neighbor] = temp_g_score
    43     74.1 MiB -1076674.2 MiB       61709                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     74.1 MiB -1080341.7 MiB       61470           if draw is not None:
    46                                                     draw()
    47                                                     
    48     74.1 MiB -1080342.8 MiB       61470           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.8 MiB      0.0 MiB           1       paths = {}
    53     44.0 MiB      0.0 MiB           4       for goal in goals:
    54     44.0 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.0 MiB     89.0 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/7.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.9 MiB     -0.1 MiB         257       for row in grid:
     8     92.9 MiB    -45.2 MiB       65792           for spot in row:
     9     92.9 MiB    -41.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.9 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.9 MiB      0.0 MiB           1       came_from = {}
    18     98.0 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     98.0 MiB -1494314.8 MiB       39698       while not open_set.empty():
    22     98.0 MiB -1494315.8 MiB       39698           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     98.0 MiB -1494318.3 MiB       39698           current = open_set.get()[1]
    28                                         
    29     98.0 MiB -1494320.0 MiB       39698           if current in remaining_goals:
    30     73.1 MiB   -122.5 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     73.1 MiB    -47.9 MiB           3               if not remaining_goals:
    32     49.4 MiB    -23.7 MiB           1                   break  # All goals found
    33                                         
    34     98.0 MiB -13395361.9 MiB      356182           for neighbor in current.neighbors:
    35     98.0 MiB -11901112.3 MiB      316485               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     98.0 MiB -11901125.1 MiB      316485               if current.row != neighbor.row and current.col != neighbor.col:
    38     98.0 MiB -5941758.3 MiB      158061                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     98.0 MiB -11901139.2 MiB      316485               if temp_g_score < g_score[neighbor]:
    41     98.0 MiB -1498853.3 MiB       40207                   came_from[neighbor] = current
    42     98.0 MiB -1498854.1 MiB       40207                   g_score[neighbor] = temp_g_score
    43     98.0 MiB -1498855.7 MiB       40207                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     98.0 MiB -1494311.5 MiB       39697           if draw is not None:
    46                                                     draw()
    47                                                     
    48     98.0 MiB -1494312.9 MiB       39697           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     49.4 MiB      0.0 MiB           1       paths = {}
    53     49.5 MiB      0.0 MiB           4       for goal in goals:
    54     49.5 MiB      0.1 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     49.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.9 MiB     93.9 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.9 MiB    -76.8 MiB         257       for row in grid:
     8     93.9 MiB -19742.9 MiB       65792           for spot in row:
     9     93.9 MiB -19666.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.6 MiB     -0.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.6 MiB      0.0 MiB           1       came_from = {}
    18     98.9 MiB  -3437.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.3 MiB -2670175.7 MiB       57860       while not open_set.empty():
    22     99.3 MiB -2670176.4 MiB       57860           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.3 MiB -2670176.7 MiB       57860           current = open_set.get()[1]
    28                                         
    29     99.3 MiB -2670176.9 MiB       57860           if current in remaining_goals:
    30     82.7 MiB   -137.8 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     82.7 MiB    -87.8 MiB           3               if not remaining_goals:
    32     37.9 MiB    -44.7 MiB           1                   break  # All goals found
    33                                         
    34     99.3 MiB -23944903.6 MiB      518753           for neighbor in current.neighbors:
    35     99.3 MiB -21274789.4 MiB      460894               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.3 MiB -21274785.7 MiB      460894               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.3 MiB -10623116.6 MiB      230118                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.3 MiB -21274795.6 MiB      460894               if temp_g_score < g_score[neighbor]:
    41     99.3 MiB -2669844.8 MiB       58216                   came_from[neighbor] = current
    42     99.3 MiB -2669845.7 MiB       58216                   g_score[neighbor] = temp_g_score
    43     99.3 MiB -2669848.0 MiB       58216                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.3 MiB -2670175.1 MiB       57859           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.3 MiB -2670175.4 MiB       57859           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.9 MiB      0.0 MiB           1       paths = {}
    53     39.0 MiB      0.0 MiB           4       for goal in goals:
    54     39.0 MiB      1.0 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     39.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.2 MiB     99.2 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.2 MiB  -1376.7 MiB         257       for row in grid:
     8     99.2 MiB -352012.9 MiB       65792           for spot in row:
     9     99.2 MiB -350643.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.4 MiB    -10.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.6 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     88.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     88.8 MiB      0.0 MiB           1       came_from = {}
    18     93.3 MiB  -6819.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.2 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     93.4 MiB -2550498.8 MiB       65204       while not open_set.empty():
    22     93.4 MiB -2550499.3 MiB       65204           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.4 MiB -2550499.6 MiB       65204           current = open_set.get()[1]
    28                                         
    29     93.4 MiB -2550500.8 MiB       65204           if current in remaining_goals:
    30     45.8 MiB   -145.4 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.8 MiB      0.0 MiB           3               if not remaining_goals:
    32     45.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.4 MiB -22840332.8 MiB      583985           for neighbor in current.neighbors:
    35     93.4 MiB -20289942.6 MiB      518782               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.4 MiB -20289940.3 MiB      518782               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.4 MiB -10126037.0 MiB      258918                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.4 MiB -20289953.1 MiB      518782               if temp_g_score < g_score[neighbor]:
    41     93.4 MiB -2536662.8 MiB       65276                   came_from[neighbor] = current
    42     93.4 MiB -2536664.2 MiB       65276                   g_score[neighbor] = temp_g_score
    43     93.4 MiB -2536666.4 MiB       65276                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.4 MiB -2550497.6 MiB       65203           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.4 MiB -2550498.5 MiB       65203           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.8 MiB      0.0 MiB           1       paths = {}
    53     46.0 MiB      0.0 MiB           4       for goal in goals:
    54     46.0 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.3 MiB   -108.2 MiB         257       for row in grid:
     8    100.3 MiB -27697.5 MiB       65792           for spot in row:
     9    100.3 MiB -27590.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     98.3 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     98.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     98.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     98.3 MiB      0.0 MiB           1       came_from = {}
    18    103.4 MiB -52967.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     99.1 MiB     -4.2 MiB           1       g_score[start] = 0
    20                                         
    21     99.2 MiB -1496442.7 MiB       36242       while not open_set.empty():
    22     99.2 MiB -1496443.7 MiB       36242           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.2 MiB -1496445.5 MiB       36242           current = open_set.get()[1]
    28                                         
    29     99.2 MiB -1496446.5 MiB       36242           if current in remaining_goals:
    30     50.4 MiB   -168.3 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     50.4 MiB     -9.4 MiB           3               if not remaining_goals:
    32     41.0 MiB     -9.4 MiB           1                   break  # All goals found
    33                                         
    34     99.2 MiB -13450185.2 MiB      325830           for neighbor in current.neighbors:
    35     99.2 MiB -11953866.6 MiB      289589               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.2 MiB -11953872.8 MiB      289589               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.2 MiB -5974093.3 MiB      144738                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.2 MiB -11953893.8 MiB      289589               if temp_g_score < g_score[neighbor]:
    41     99.2 MiB -1515260.4 MiB       37001                   came_from[neighbor] = current
    42     99.2 MiB -1515261.5 MiB       37001                   g_score[neighbor] = temp_g_score
    43     99.2 MiB -1515263.0 MiB       37001                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.2 MiB -1496440.0 MiB       36241           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.2 MiB -1496440.7 MiB       36241           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.0 MiB      0.0 MiB           1       paths = {}
    53     41.2 MiB      0.0 MiB           4       for goal in goals:
    54     41.2 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.5 MiB     98.5 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.5 MiB   -223.1 MiB         257       for row in grid:
     8     98.5 MiB -57093.3 MiB       65792           for spot in row:
     9     98.5 MiB -56871.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.0 MiB     -1.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.0 MiB      0.0 MiB           1       came_from = {}
    18    101.9 MiB   -464.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    101.9 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21    102.1 MiB -2418423.2 MiB       64453       while not open_set.empty():
    22    102.1 MiB -2418425.8 MiB       64453           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    102.1 MiB -2418426.6 MiB       64453           current = open_set.get()[1]
    28                                         
    29    102.1 MiB -2418428.5 MiB       64453           if current in remaining_goals:
    30    101.9 MiB   -107.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31    101.9 MiB   -107.4 MiB           3               if not remaining_goals:
    32     48.3 MiB    -53.6 MiB           1                   break  # All goals found
    33                                         
    34    102.1 MiB -21656399.3 MiB      577409           for neighbor in current.neighbors:
    35    102.1 MiB -19237987.2 MiB      512957               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    102.1 MiB -19237993.9 MiB      512957               if current.row != neighbor.row and current.col != neighbor.col:
    38    102.1 MiB -9600922.4 MiB      256036                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    102.1 MiB -19238013.1 MiB      512957               if temp_g_score < g_score[neighbor]:
    41    102.1 MiB -2401890.6 MiB       64586                   came_from[neighbor] = current
    42    102.1 MiB -2401892.5 MiB       64586                   g_score[neighbor] = temp_g_score
    43    102.1 MiB -2401894.0 MiB       64586                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    102.1 MiB -2418422.1 MiB       64452           if draw is not None:
    46                                                     draw()
    47                                                     
    48    102.1 MiB -2418422.6 MiB       64452           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     48.3 MiB      0.0 MiB           1       paths = {}
    53     48.4 MiB      0.0 MiB           4       for goal in goals:
    54     48.4 MiB      0.1 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     48.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.3 MiB     99.3 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.3 MiB   -134.6 MiB         257       for row in grid:
     8     99.3 MiB -33900.9 MiB       65792           for spot in row:
     9     99.3 MiB -33767.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     96.2 MiB     -3.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     96.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     96.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     96.2 MiB      0.0 MiB           1       came_from = {}
    18    101.2 MiB -13407.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.6 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21    100.6 MiB -805532.6 MiB       23552       while not open_set.empty():
    22    100.6 MiB -805533.1 MiB       23552           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.6 MiB -805534.4 MiB       23552           current = open_set.get()[1]
    28                                         
    29    100.6 MiB -805535.0 MiB       23552           if current in remaining_goals:
    30     50.6 MiB   -152.0 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     50.6 MiB      0.0 MiB           3               if not remaining_goals:
    32     50.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.6 MiB -7228509.9 MiB      211548           for neighbor in current.neighbors:
    35    100.6 MiB -6423116.3 MiB      187997               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.6 MiB -6423120.4 MiB      187997               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.6 MiB -3208112.8 MiB       93930                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.6 MiB -6423130.2 MiB      187997               if temp_g_score < g_score[neighbor]:
    41    100.6 MiB -813477.4 MiB       24113                   came_from[neighbor] = current
    42    100.6 MiB -813478.0 MiB       24113                   g_score[neighbor] = temp_g_score
    43    100.6 MiB -813479.2 MiB       24113                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.6 MiB -805514.5 MiB       23551           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.6 MiB -805532.0 MiB       23551           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     50.6 MiB      0.0 MiB           1       paths = {}
    53     50.7 MiB      0.0 MiB           4       for goal in goals:
    54     50.7 MiB      0.0 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     50.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.0 MiB     98.0 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.0 MiB   -275.8 MiB         257       for row in grid:
     8     98.0 MiB -70730.5 MiB       65792           for spot in row:
     9     98.0 MiB -70456.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     96.3 MiB     -1.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     96.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     96.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     96.3 MiB      0.0 MiB           1       came_from = {}
    18     98.5 MiB -36417.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.8 MiB     -1.7 MiB           1       g_score[start] = 0
    20                                         
    21     97.0 MiB -2615738.2 MiB       48532       while not open_set.empty():
    22     97.0 MiB -2615739.4 MiB       48532           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.0 MiB -2615740.9 MiB       48532           current = open_set.get()[1]
    28                                         
    29     97.0 MiB -2615746.0 MiB       48532           if current in remaining_goals:
    30     41.6 MiB   -175.2 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.6 MiB      0.0 MiB           3               if not remaining_goals:
    32     41.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     97.0 MiB -23462599.8 MiB      435397           for neighbor in current.neighbors:
    35     97.0 MiB -20847003.0 MiB      386866               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.0 MiB -20847002.2 MiB      386866               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.0 MiB -10410443.3 MiB      193203                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.0 MiB -20847029.4 MiB      386866               if temp_g_score < g_score[neighbor]:
    41     97.0 MiB -2629604.0 MiB       49020                   came_from[neighbor] = current
    42     97.0 MiB -2629609.1 MiB       49020                   g_score[neighbor] = temp_g_score
    43     97.0 MiB -2629614.2 MiB       49020                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.0 MiB -2615735.0 MiB       48531           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.0 MiB -2615736.1 MiB       48531           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.6 MiB      0.0 MiB           1       paths = {}
    53     41.9 MiB      0.0 MiB           4       for goal in goals:
    54     41.9 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     96.9 MiB     96.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     96.9 MiB   -244.9 MiB         257       for row in grid:
     8     96.9 MiB -62416.7 MiB       65792           for spot in row:
     9     96.9 MiB -62175.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.7 MiB     -3.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.7 MiB      0.0 MiB           1       came_from = {}
    18     95.4 MiB -91416.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.2 MiB     -1.2 MiB           1       g_score[start] = 0
    20                                         
    21     94.5 MiB -2972755.2 MiB       52273       while not open_set.empty():
    22     94.5 MiB -2972758.0 MiB       52273           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.5 MiB -2972757.2 MiB       52273           current = open_set.get()[1]
    28                                         
    29     94.5 MiB -2972809.5 MiB       52273           if current in remaining_goals:
    30     37.0 MiB   -192.4 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.0 MiB    -20.0 MiB           3               if not remaining_goals:
    32     27.2 MiB     -9.8 MiB           1                   break  # All goals found
    33                                         
    34     94.5 MiB -26661537.1 MiB      468758           for neighbor in current.neighbors:
    35     94.5 MiB -23688925.3 MiB      416486               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.5 MiB -23688912.7 MiB      416486               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.5 MiB -11829138.1 MiB      207962                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.5 MiB -23688949.0 MiB      416486               if temp_g_score < g_score[neighbor]:
    41     94.5 MiB -2982374.3 MiB       52699                   came_from[neighbor] = current
    42     94.5 MiB -2982376.6 MiB       52699                   g_score[neighbor] = temp_g_score
    43     94.5 MiB -2982380.1 MiB       52699                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.5 MiB -2972750.5 MiB       52272           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.5 MiB -2972752.6 MiB       52272           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.2 MiB      0.0 MiB           1       paths = {}
    53     28.0 MiB      0.0 MiB           4       for goal in goals:
    54     28.0 MiB      0.8 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     28.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.8 MiB     84.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.8 MiB  -8637.6 MiB         257       for row in grid:
     8     84.8 MiB -2214739.6 MiB       65792           for spot in row:
     9     84.8 MiB -2206140.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     31.6 MiB    -53.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     32.0 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     32.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     32.2 MiB      0.0 MiB           1       came_from = {}
    18     40.5 MiB -12875.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     39.1 MiB     -1.4 MiB           1       g_score[start] = 0
    20                                         
    21     42.2 MiB -790117.0 MiB       62278       while not open_set.empty():
    22     42.2 MiB -790117.5 MiB       62278           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     42.2 MiB -790119.3 MiB       62278           current = open_set.get()[1]
    28                                         
    29     42.2 MiB -790120.3 MiB       62278           if current in remaining_goals:
    30     26.3 MiB    -50.2 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     26.3 MiB     -0.9 MiB           3               if not remaining_goals:
    32     25.4 MiB     -0.9 MiB           1                   break  # All goals found
    33                                         
    34     42.2 MiB -7077488.1 MiB      558012           for neighbor in current.neighbors:
    35     42.2 MiB -6287430.6 MiB      495735               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     42.2 MiB -6287415.1 MiB      495735               if current.row != neighbor.row and current.col != neighbor.col:
    38     42.2 MiB -3138221.1 MiB      247455                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     42.2 MiB -6287430.4 MiB      495735               if temp_g_score < g_score[neighbor]:
    41     42.2 MiB -791401.8 MiB       62471                   came_from[neighbor] = current
    42     42.2 MiB -791405.1 MiB       62471                   g_score[neighbor] = temp_g_score
    43     42.2 MiB -791419.0 MiB       62471                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     42.2 MiB -790113.4 MiB       62277           if draw is not None:
    46                                                     draw()
    47                                                     
    48     42.2 MiB -790115.7 MiB       62277           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     25.4 MiB      0.0 MiB           1       paths = {}
    53     27.2 MiB      0.0 MiB           4       for goal in goals:
    54     27.2 MiB      1.7 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.3 MiB     86.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.3 MiB   -329.6 MiB         257       for row in grid:
     8     86.3 MiB -84173.8 MiB       65792           for spot in row:
     9     86.3 MiB -83848.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.2 MiB     -6.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     80.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     80.2 MiB      0.0 MiB           1       came_from = {}
    18     83.3 MiB -14656.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     83.2 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     83.3 MiB -3025693.5 MiB       57673       while not open_set.empty():
    22     83.3 MiB -3025694.2 MiB       57673           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     83.3 MiB -3025696.0 MiB       57673           current = open_set.get()[1]
    28                                         
    29     83.3 MiB -3025697.1 MiB       57673           if current in remaining_goals:
    30     35.1 MiB   -160.1 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.1 MiB     -2.5 MiB           3               if not remaining_goals:
    32     32.6 MiB     -2.4 MiB           1                   break  # All goals found
    33                                         
    34     83.3 MiB -27129521.3 MiB      517094           for neighbor in current.neighbors:
    35     83.3 MiB -24103947.5 MiB      459422               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     83.3 MiB -24103935.6 MiB      459422               if current.row != neighbor.row and current.col != neighbor.col:
    38     83.3 MiB -12035205.1 MiB      229386                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     83.3 MiB -24103947.3 MiB      459422               if temp_g_score < g_score[neighbor]:
    41     83.3 MiB -3039966.7 MiB       58033                   came_from[neighbor] = current
    42     83.3 MiB -3039968.2 MiB       58033                   g_score[neighbor] = temp_g_score
    43     83.3 MiB -3039969.1 MiB       58033                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     83.3 MiB -3025691.0 MiB       57672           if draw is not None:
    46                                                     draw()
    47                                                     
    48     83.3 MiB -3025692.5 MiB       57672           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.6 MiB      0.0 MiB           1       paths = {}
    53     44.0 MiB     11.1 MiB           4       for goal in goals:
    54     44.0 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.7 MiB     92.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.7 MiB  -9909.0 MiB         257       for row in grid:
     8     92.7 MiB -2538303.1 MiB       65792           for spot in row:
     9     92.7 MiB -2528415.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     33.7 MiB    -59.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     34.1 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     34.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     34.3 MiB      0.0 MiB           1       came_from = {}
    18     43.7 MiB    -38.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     43.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     44.2 MiB -752977.9 MiB       60527       while not open_set.empty():
    22     44.2 MiB -752978.6 MiB       60527           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     44.2 MiB -752979.4 MiB       60527           current = open_set.get()[1]
    28                                         
    29     44.2 MiB -752980.4 MiB       60527           if current in remaining_goals:
    30     28.5 MiB    -48.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     28.5 MiB     -1.3 MiB           3               if not remaining_goals:
    32     27.2 MiB     -1.3 MiB           1                   break  # All goals found
    33                                         
    34     44.2 MiB -6748632.6 MiB      542618           for neighbor in current.neighbors:
    35     44.2 MiB -5995698.7 MiB      482092               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     44.2 MiB -5995704.6 MiB      482092               if current.row != neighbor.row and current.col != neighbor.col:
    38     44.2 MiB -2993205.6 MiB      240694                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     44.2 MiB -5995720.1 MiB      482092               if temp_g_score < g_score[neighbor]:
    41     44.2 MiB -753923.2 MiB       60841                   came_from[neighbor] = current
    42     44.2 MiB -753923.6 MiB       60841                   g_score[neighbor] = temp_g_score
    43     44.2 MiB -753923.6 MiB       60841                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     44.2 MiB -752977.1 MiB       60526           if draw is not None:
    46                                                     draw()
    47                                                     
    48     44.2 MiB -752977.8 MiB       60526           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.2 MiB      0.0 MiB           1       paths = {}
    53     28.0 MiB      0.0 MiB           4       for goal in goals:
    54     28.0 MiB      0.8 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     28.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.5 MiB     91.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.5 MiB   -476.2 MiB         257       for row in grid:
     8     91.5 MiB -121844.2 MiB       65792           for spot in row:
     9     91.5 MiB -121371.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.5 MiB     -5.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     85.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     85.9 MiB      0.0 MiB           1       came_from = {}
    18     89.0 MiB -30878.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.1 MiB     -0.9 MiB           1       g_score[start] = 0
    20                                         
    21     88.2 MiB -2272411.5 MiB       43348       while not open_set.empty():
    22     88.2 MiB -2272412.5 MiB       43348           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.2 MiB -2272414.0 MiB       43348           current = open_set.get()[1]
    28                                         
    29     88.2 MiB -2272414.9 MiB       43348           if current in remaining_goals:
    30     38.1 MiB   -166.5 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.1 MiB      0.0 MiB           3               if not remaining_goals:
    32     38.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.2 MiB -20390896.0 MiB      388741           for neighbor in current.neighbors:
    35     88.2 MiB -18118615.1 MiB      345394               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.2 MiB -18118612.2 MiB      345394               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.2 MiB -9049281.2 MiB      172467                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.2 MiB -18118640.4 MiB      345394               if temp_g_score < g_score[neighbor]:
    41     88.2 MiB -2292418.2 MiB       43842                   came_from[neighbor] = current
    42     88.2 MiB -2292419.7 MiB       43842                   g_score[neighbor] = temp_g_score
    43     88.2 MiB -2292422.4 MiB       43842                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.2 MiB -2272409.0 MiB       43347           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.2 MiB -2272410.3 MiB       43347           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.1 MiB      0.0 MiB           1       paths = {}
    53     38.3 MiB      0.0 MiB           4       for goal in goals:
    54     38.3 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.5 MiB     92.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.5 MiB  -2978.9 MiB         257       for row in grid:
     8     92.5 MiB -763326.2 MiB       65792           for spot in row:
     9     92.5 MiB -760352.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.0 MiB    -13.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     79.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     79.0 MiB      0.0 MiB           1       came_from = {}
    18     84.2 MiB  -1367.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     84.3 MiB -3039177.1 MiB       65105       while not open_set.empty():
    22     84.3 MiB -3039178.6 MiB       65105           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.3 MiB -3039181.2 MiB       65105           current = open_set.get()[1]
    28                                         
    29     84.3 MiB -3039182.5 MiB       65105           if current in remaining_goals:
    30     33.1 MiB   -162.6 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.1 MiB     -2.7 MiB           3               if not remaining_goals:
    32     33.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.3 MiB -27206425.4 MiB      583083           for neighbor in current.neighbors:
    35     84.3 MiB -24167370.0 MiB      517979               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.3 MiB -24167388.9 MiB      517979               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.3 MiB -12059526.7 MiB      258515                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.3 MiB -24167416.7 MiB      517979               if temp_g_score < g_score[neighbor]:
    41     84.3 MiB -3025611.7 MiB       65174                   came_from[neighbor] = current
    42     84.3 MiB -3025612.2 MiB       65174                   g_score[neighbor] = temp_g_score
    43     84.3 MiB -3025612.6 MiB       65174                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.3 MiB -3039171.8 MiB       65104           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.3 MiB -3039173.7 MiB       65104           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.1 MiB      0.0 MiB           1       paths = {}
    53     34.0 MiB      0.0 MiB           4       for goal in goals:
    54     34.0 MiB      0.9 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.6 MiB     89.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.6 MiB   -212.7 MiB         257       for row in grid:
     8     89.6 MiB -54209.2 MiB       65792           for spot in row:
     9     89.6 MiB -54000.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.8 MiB     -4.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.8 MiB      0.0 MiB           1       came_from = {}
    18     88.9 MiB -25228.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.0 MiB     -0.9 MiB           1       g_score[start] = 0
    20                                         
    21     88.4 MiB -2586773.6 MiB       47261       while not open_set.empty():
    22     88.4 MiB -2586774.5 MiB       47261           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.4 MiB -2586777.6 MiB       47261           current = open_set.get()[1]
    28                                         
    29     88.4 MiB -2586779.5 MiB       47261           if current in remaining_goals:
    30     36.2 MiB   -176.8 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.2 MiB      0.0 MiB           3               if not remaining_goals:
    32     36.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.4 MiB -23199739.9 MiB      423749           for neighbor in current.neighbors:
    35     88.4 MiB -20613116.9 MiB      376489               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.4 MiB -20613113.9 MiB      376489               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.4 MiB -10293172.8 MiB      187980                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.4 MiB -20613137.4 MiB      376489               if temp_g_score < g_score[neighbor]:
    41     88.4 MiB -2599096.1 MiB       47672                   came_from[neighbor] = current
    42     88.4 MiB -2599097.1 MiB       47672                   g_score[neighbor] = temp_g_score
    43     88.4 MiB -2599098.8 MiB       47672                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.4 MiB -2586771.7 MiB       47260           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.4 MiB -2586772.6 MiB       47260           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.2 MiB      0.0 MiB           1       paths = {}
    53     36.4 MiB      0.0 MiB           4       for goal in goals:
    54     36.4 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.9 MiB     89.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.9 MiB   -449.0 MiB         257       for row in grid:
     8     89.9 MiB -114571.5 MiB       65792           for spot in row:
     9     89.9 MiB -114128.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.3 MiB     -9.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     80.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     80.7 MiB      0.0 MiB           1       came_from = {}
    18     82.2 MiB -1861993.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     28.9 MiB    -53.3 MiB           1       g_score[start] = 0
    20                                         
    21     46.0 MiB -209459.0 MiB       53022       while not open_set.empty():
    22     46.0 MiB -209459.4 MiB       53022           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     46.0 MiB -209460.2 MiB       53022           current = open_set.get()[1]
    28                                         
    29     46.0 MiB -209460.4 MiB       53022           if current in remaining_goals:
    30     33.0 MiB    -17.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.0 MiB      0.0 MiB           3               if not remaining_goals:
    32     33.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     46.0 MiB -1877189.1 MiB      475508           for neighbor in current.neighbors:
    35     46.0 MiB -1667755.0 MiB      422487               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     46.0 MiB -1667744.2 MiB      422487               if current.row != neighbor.row and current.col != neighbor.col:
    38     46.0 MiB -832610.2 MiB      210964                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     46.0 MiB -1667753.8 MiB      422487               if temp_g_score < g_score[neighbor]:
    41     46.0 MiB -209343.3 MiB       53471                   came_from[neighbor] = current
    42     46.0 MiB -209344.9 MiB       53471                   g_score[neighbor] = temp_g_score
    43     46.0 MiB -209349.7 MiB       53471                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     46.0 MiB -209458.5 MiB       53021           if draw is not None:
    46                                                     draw()
    47                                                     
    48     46.0 MiB -209458.7 MiB       53021           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.0 MiB      0.0 MiB           1       paths = {}
    53     33.3 MiB      0.0 MiB           4       for goal in goals:
    54     33.3 MiB      0.3 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.7 MiB     86.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.7 MiB   -220.9 MiB         257       for row in grid:
     8     86.7 MiB -56650.0 MiB       65792           for spot in row:
     9     86.7 MiB -56429.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.9 MiB     -0.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.9 MiB      0.0 MiB           1       came_from = {}
    18     90.4 MiB  -9661.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.7 MiB     -3.7 MiB           1       g_score[start] = 0
    20                                         
    21     86.7 MiB -2093528.0 MiB       42301       while not open_set.empty():
    22     86.7 MiB -2093528.2 MiB       42301           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.7 MiB -2093550.3 MiB       42301           current = open_set.get()[1]
    28                                         
    29     86.7 MiB -2093551.5 MiB       42301           if current in remaining_goals:
    30     33.8 MiB   -168.4 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.8 MiB      0.0 MiB           3               if not remaining_goals:
    32     33.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.7 MiB -18780999.5 MiB      379384           for neighbor in current.neighbors:
    35     86.7 MiB -16687610.0 MiB      337084               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.7 MiB -16687605.0 MiB      337084               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.7 MiB -8333766.2 MiB      168323                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.7 MiB -16687609.4 MiB      337084               if temp_g_score < g_score[neighbor]:
    41     86.7 MiB -2108600.1 MiB       42795                   came_from[neighbor] = current
    42     86.7 MiB -2108600.6 MiB       42795                   g_score[neighbor] = temp_g_score
    43     86.7 MiB -2108601.5 MiB       42795                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.7 MiB -2093526.9 MiB       42300           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.7 MiB -2093527.2 MiB       42300           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.8 MiB      0.0 MiB           1       paths = {}
    53     34.1 MiB      0.0 MiB           4       for goal in goals:
    54     34.1 MiB      0.3 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.6 MiB     85.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.6 MiB   -347.2 MiB         257       for row in grid:
     8     85.6 MiB -88666.9 MiB       65792           for spot in row:
     9     85.6 MiB -88320.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     78.7 MiB     -6.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     78.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     78.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     78.7 MiB      0.0 MiB           1       came_from = {}
    18     84.5 MiB  -3455.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.4 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     84.5 MiB -2486134.0 MiB       50875       while not open_set.empty():
    22     84.5 MiB -2486134.9 MiB       50875           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.5 MiB -2486136.2 MiB       50875           current = open_set.get()[1]
    28                                         
    29     84.5 MiB -2486136.8 MiB       50875           if current in remaining_goals:
    30     35.2 MiB   -171.8 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.2 MiB    -11.2 MiB           3               if not remaining_goals:
    32     24.0 MiB    -11.2 MiB           1                   break  # All goals found
    33                                         
    34     84.5 MiB -22292456.6 MiB      456131           for neighbor in current.neighbors:
    35     84.5 MiB -19806472.7 MiB      405257               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.5 MiB -19806486.4 MiB      405257               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.5 MiB -9889589.9 MiB      202340                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.5 MiB -19806500.6 MiB      405257               if temp_g_score < g_score[neighbor]:
    41     84.5 MiB -2494541.8 MiB       51260                   came_from[neighbor] = current
    42     84.5 MiB -2494543.8 MiB       51260                   g_score[neighbor] = temp_g_score
    43     84.5 MiB -2494544.8 MiB       51260                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.5 MiB -2486130.9 MiB       50874           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.5 MiB -2486132.8 MiB       50874           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     24.0 MiB      0.0 MiB           1       paths = {}
    53     25.2 MiB      0.0 MiB           4       for goal in goals:
    54     25.2 MiB      1.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     25.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.8 MiB     85.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.8 MiB     -3.0 MiB         257       for row in grid:
     8     85.8 MiB   -766.2 MiB       65792           for spot in row:
     9     85.8 MiB   -763.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     90.2 MiB  -1519.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.1 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     90.1 MiB -2021376.8 MiB       44631       while not open_set.empty():
    22     90.1 MiB -2021377.3 MiB       44631           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.1 MiB -2021379.1 MiB       44631           current = open_set.get()[1]
    28                                         
    29     90.1 MiB -2021379.8 MiB       44631           if current in remaining_goals:
    30     79.0 MiB   -131.6 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     79.0 MiB    -98.3 MiB           3               if not remaining_goals:
    32     34.3 MiB    -44.7 MiB           1                   break  # All goals found
    33                                         
    34     90.1 MiB -18126077.5 MiB      400097           for neighbor in current.neighbors:
    35     90.1 MiB -16104746.5 MiB      355467               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.1 MiB -16104750.2 MiB      355467               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.1 MiB -8041474.7 MiB      177472                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.1 MiB -16104768.8 MiB      355467               if temp_g_score < g_score[neighbor]:
    41     90.1 MiB -2023190.5 MiB       45022                   came_from[neighbor] = current
    42     90.1 MiB -2023191.5 MiB       45022                   g_score[neighbor] = temp_g_score
    43     90.1 MiB -2023193.0 MiB       45022                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.1 MiB -2021372.4 MiB       44630           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.1 MiB -2021376.0 MiB       44630           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.3 MiB      0.0 MiB           1       paths = {}
    53     34.5 MiB      0.0 MiB           4       for goal in goals:
    54     34.5 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.0 MiB     88.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.0 MiB   -877.8 MiB         257       for row in grid:
     8     88.0 MiB -225052.9 MiB       65792           for spot in row:
     9     88.0 MiB -224180.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.6 MiB     -6.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     81.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     81.6 MiB      0.0 MiB           1       came_from = {}
    18     87.1 MiB  -2483.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.9 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     87.0 MiB -3072936.5 MiB       63798       while not open_set.empty():
    22     87.0 MiB -3072937.5 MiB       63798           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.0 MiB -3072942.1 MiB       63798           current = open_set.get()[1]
    28                                         
    29     87.0 MiB -3072943.6 MiB       63798           if current in remaining_goals:
    30     30.5 MiB   -172.1 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.5 MiB     -2.6 MiB           3               if not remaining_goals:
    32     29.3 MiB     -1.3 MiB           1                   break  # All goals found
    33                                         
    34     87.0 MiB -27536334.4 MiB      571491           for neighbor in current.neighbors:
    35     87.0 MiB -24463535.3 MiB      507694               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.0 MiB -24463545.1 MiB      507694               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.0 MiB -12211965.9 MiB      253401                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.0 MiB -24463557.5 MiB      507694               if temp_g_score < g_score[neighbor]:
    41     87.0 MiB -3068543.0 MiB       63924                   came_from[neighbor] = current
    42     87.0 MiB -3068543.9 MiB       63924                   g_score[neighbor] = temp_g_score
    43     87.0 MiB -3068551.8 MiB       63924                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.0 MiB -3072930.2 MiB       63797           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.0 MiB -3072934.6 MiB       63797           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.3 MiB      0.0 MiB           1       paths = {}
    53     30.6 MiB      0.0 MiB           4       for goal in goals:
    54     30.6 MiB      1.3 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.1 MiB     92.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.1 MiB   -641.5 MiB         257       for row in grid:
     8     92.1 MiB -164086.4 MiB       65792           for spot in row:
     9     92.1 MiB -163449.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.1 MiB     -5.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.1 MiB      0.0 MiB           1       came_from = {}
    18     91.5 MiB  -1490.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.6 MiB -3463056.2 MiB       59591       while not open_set.empty():
    22     91.6 MiB -3463057.4 MiB       59591           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.6 MiB -3463057.8 MiB       59591           current = open_set.get()[1]
    28                                         
    29     91.6 MiB -3463058.1 MiB       59591           if current in remaining_goals:
    30     35.2 MiB   -186.0 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.2 MiB      0.0 MiB           3               if not remaining_goals:
    32     35.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.6 MiB -31051473.6 MiB      534096           for neighbor in current.neighbors:
    35     91.6 MiB -27588554.9 MiB      474506               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.6 MiB -27588541.2 MiB      474506               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.6 MiB -13775143.2 MiB      236885                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.6 MiB -27588550.1 MiB      474506               if temp_g_score < g_score[neighbor]:
    41     91.6 MiB -3475159.5 MiB       59873                   came_from[neighbor] = current
    42     91.6 MiB -3475160.3 MiB       59873                   g_score[neighbor] = temp_g_score
    43     91.6 MiB -3475160.8 MiB       59873                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.6 MiB -3463054.6 MiB       59590           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.6 MiB -3463055.4 MiB       59590           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.2 MiB      0.0 MiB           1       paths = {}
    53     35.7 MiB      0.0 MiB           4       for goal in goals:
    54     35.7 MiB      0.5 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.8 MiB     91.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.8 MiB   -630.5 MiB         257       for row in grid:
     8     91.8 MiB -160629.2 MiB       65792           for spot in row:
     9     91.8 MiB -160008.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.6 MiB    -12.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.8 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     80.0 MiB      0.2 MiB           1       open_set.put((0, start))
    17     80.0 MiB      0.0 MiB           1       came_from = {}
    18     81.4 MiB -1966644.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     26.3 MiB    -55.0 MiB           1       g_score[start] = 0
    20                                         
    21     43.8 MiB -91636.2 MiB       32757       while not open_set.empty():
    22     43.8 MiB -91636.5 MiB       32757           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     43.8 MiB -91636.9 MiB       32757           current = open_set.get()[1]
    28                                         
    29     43.8 MiB -91637.4 MiB       32757           if current in remaining_goals:
    30     42.2 MiB     -4.0 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.2 MiB      0.0 MiB           3               if not remaining_goals:
    32     42.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     43.8 MiB -820799.0 MiB      293623           for neighbor in current.neighbors:
    35     43.8 MiB -729184.9 MiB      260867               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     43.8 MiB -729175.3 MiB      260867               if current.row != neighbor.row and current.col != neighbor.col:
    38     43.8 MiB -363944.9 MiB      130237                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     43.8 MiB -729181.5 MiB      260867               if temp_g_score < g_score[neighbor]:
    41     43.8 MiB -92621.7 MiB       33186                   came_from[neighbor] = current
    42     43.8 MiB -92622.2 MiB       33186                   g_score[neighbor] = temp_g_score
    43     43.8 MiB -92622.5 MiB       33186                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     43.8 MiB -91634.7 MiB       32756           if draw is not None:
    46                                                     draw()
    47                                                     
    48     43.8 MiB -91635.0 MiB       32756           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.2 MiB      0.0 MiB           1       paths = {}
    53     42.5 MiB      0.0 MiB           4       for goal in goals:
    54     42.5 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.4 MiB     89.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.5 MiB  -7191.5 MiB         257       for row in grid:
     8     89.5 MiB -1837114.4 MiB       65792           for spot in row:
     9     89.5 MiB -1829968.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     24.9 MiB    -64.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     25.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     25.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     25.5 MiB      0.0 MiB           1       came_from = {}
    18     36.1 MiB  -1948.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     36.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     38.2 MiB -324630.0 MiB       52223       while not open_set.empty():
    22     38.2 MiB -324632.7 MiB       52223           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     38.2 MiB -324634.3 MiB       52223           current = open_set.get()[1]
    28                                         
    29     38.2 MiB -324635.5 MiB       52223           if current in remaining_goals:
    30     38.0 MiB     -8.3 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.0 MiB     -7.9 MiB           3               if not remaining_goals:
    32     33.0 MiB     -5.0 MiB           1                   break  # All goals found
    33                                         
    34     38.2 MiB -2911429.9 MiB      468161           for neighbor in current.neighbors:
    35     38.2 MiB -2586812.5 MiB      415939               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     38.2 MiB -2586798.6 MiB      415939               if current.row != neighbor.row and current.col != neighbor.col:
    38     38.2 MiB -1291709.0 MiB      207664                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     38.2 MiB -2586809.0 MiB      415939               if temp_g_score < g_score[neighbor]:
    41     38.2 MiB -327925.7 MiB       52580                   came_from[neighbor] = current
    42     38.2 MiB -327926.2 MiB       52580                   g_score[neighbor] = temp_g_score
    43     38.2 MiB -327926.5 MiB       52580                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     38.2 MiB -324626.3 MiB       52222           if draw is not None:
    46                                                     draw()
    47                                                     
    48     38.2 MiB -324629.6 MiB       52222           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.0 MiB      0.0 MiB           1       paths = {}
    53     33.3 MiB      0.0 MiB           4       for goal in goals:
    54     33.3 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.8 MiB  -1607.5 MiB         257       for row in grid:
     8     88.8 MiB -411325.0 MiB       65792           for spot in row:
     9     88.8 MiB -409728.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     74.3 MiB    -14.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     74.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     74.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     74.7 MiB      0.0 MiB           1       came_from = {}
    18     74.8 MiB -1717009.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     36.3 MiB    -38.5 MiB           1       g_score[start] = 0
    20                                         
    21     43.8 MiB -863363.2 MiB       65526       while not open_set.empty():
    22     43.8 MiB -863364.2 MiB       65526           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     43.8 MiB -863366.2 MiB       65526           current = open_set.get()[1]
    28                                         
    29     43.8 MiB -863368.3 MiB       65526           if current in remaining_goals:
    30     29.3 MiB    -47.8 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.3 MiB     -5.6 MiB           3               if not remaining_goals:
    32     23.7 MiB     -5.6 MiB           1                   break  # All goals found
    33                                         
    34     43.8 MiB -7723783.7 MiB      586683           for neighbor in current.neighbors:
    35     43.8 MiB -6860463.9 MiB      521158               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     43.8 MiB -6860462.4 MiB      521158               if current.row != neighbor.row and current.col != neighbor.col:
    38     43.8 MiB -3422568.1 MiB      260073                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     43.8 MiB -6860492.5 MiB      521158               if temp_g_score < g_score[neighbor]:
    41     43.8 MiB -858359.9 MiB       65532                   came_from[neighbor] = current
    42     43.8 MiB -858360.5 MiB       65532                   g_score[neighbor] = temp_g_score
    43     43.8 MiB -858361.5 MiB       65532                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     43.8 MiB -863361.3 MiB       65525           if draw is not None:
    46                                                     draw()
    47                                                     
    48     43.8 MiB -863362.2 MiB       65525           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     23.7 MiB      0.0 MiB           1       paths = {}
    53     25.3 MiB      0.0 MiB           4       for goal in goals:
    54     25.3 MiB      1.6 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     25.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.8 MiB     87.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.8 MiB   -106.4 MiB         257       for row in grid:
     8     87.8 MiB -27163.6 MiB       65792           for spot in row:
     9     87.8 MiB -27058.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.7 MiB     -1.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.7 MiB      0.0 MiB           1       came_from = {}
    18     89.1 MiB -128175.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.7 MiB     -2.5 MiB           1       g_score[start] = 0
    20                                         
    21     86.7 MiB -2622761.3 MiB       58184       while not open_set.empty():
    22     86.7 MiB -2622761.6 MiB       58184           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.7 MiB -2622764.1 MiB       58184           current = open_set.get()[1]
    28                                         
    29     86.7 MiB -2622765.4 MiB       58184           if current in remaining_goals:
    30     34.9 MiB   -157.6 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.9 MiB     -2.2 MiB           3               if not remaining_goals:
    32     32.7 MiB     -2.2 MiB           1                   break  # All goals found
    33                                         
    34     86.7 MiB -23513309.9 MiB      521669           for neighbor in current.neighbors:
    35     86.7 MiB -20890707.1 MiB      463486               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.7 MiB -20890698.5 MiB      463486               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.7 MiB -10430255.2 MiB      231414                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.7 MiB -20890711.7 MiB      463486               if temp_g_score < g_score[neighbor]:
    41     86.7 MiB -2623517.0 MiB       58540                   came_from[neighbor] = current
    42     86.7 MiB -2623518.1 MiB       58540                   g_score[neighbor] = temp_g_score
    43     86.7 MiB -2623520.4 MiB       58540                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.7 MiB -2622759.4 MiB       58183           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.7 MiB -2622760.9 MiB       58183           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.7 MiB      0.0 MiB           1       paths = {}
    53     33.0 MiB      0.0 MiB           4       for goal in goals:
    54     33.0 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.7 MiB     86.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.7 MiB  -2657.9 MiB         257       for row in grid:
     8     86.7 MiB -681158.1 MiB       65792           for spot in row:
     9     86.7 MiB -678508.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     74.6 MiB    -12.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     74.8 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     75.0 MiB      0.2 MiB           1       open_set.put((0, start))
    17     75.0 MiB      0.0 MiB           1       came_from = {}
    18     80.3 MiB      5.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     80.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     80.6 MiB -2084533.2 MiB       49515       while not open_set.empty():
    22     80.6 MiB -2084534.3 MiB       49515           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     80.6 MiB -2084537.4 MiB       49515           current = open_set.get()[1]
    28                                         
    29     80.6 MiB -2084539.1 MiB       49515           if current in remaining_goals:
    30     36.5 MiB   -141.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.5 MiB      0.0 MiB           3               if not remaining_goals:
    32     36.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     80.6 MiB -18687504.5 MiB      443996           for neighbor in current.neighbors:
    35     80.6 MiB -16603082.1 MiB      394482               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     80.6 MiB -16603078.8 MiB      394482               if current.row != neighbor.row and current.col != neighbor.col:
    38     80.6 MiB -8289450.9 MiB      196970                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     80.6 MiB -16603093.1 MiB      394482               if temp_g_score < g_score[neighbor]:
    41     80.6 MiB -2091746.0 MiB       49929                   came_from[neighbor] = current
    42     80.6 MiB -2091752.1 MiB       49929                   g_score[neighbor] = temp_g_score
    43     80.6 MiB -2091755.5 MiB       49929                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     80.6 MiB -2084530.5 MiB       49514           if draw is not None:
    46                                                     draw()
    47                                                     
    48     80.6 MiB -2084532.8 MiB       49514           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.5 MiB      0.0 MiB           1       paths = {}
    53     37.3 MiB      0.0 MiB           4       for goal in goals:
    54     37.3 MiB      0.7 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.8 MiB     87.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.8 MiB    -83.3 MiB         257       for row in grid:
     8     87.8 MiB -21291.8 MiB       65792           for spot in row:
     9     87.8 MiB -21209.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.1 MiB     -0.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.1 MiB      0.0 MiB           1       came_from = {}
    18     91.0 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.0 MiB -2865252.7 MiB       55024       while not open_set.empty():
    22     91.0 MiB -2865253.7 MiB       55024           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.0 MiB -2865254.9 MiB       55024           current = open_set.get()[1]
    28                                         
    29     91.0 MiB -2865260.2 MiB       55024           if current in remaining_goals:
    30     35.3 MiB   -172.6 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.3 MiB     -2.3 MiB           3               if not remaining_goals:
    32     33.0 MiB     -2.3 MiB           1                   break  # All goals found
    33                                         
    34     91.0 MiB -25685882.3 MiB      493406           for neighbor in current.neighbors:
    35     91.0 MiB -22820795.8 MiB      438383               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.0 MiB -22820797.3 MiB      438383               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.0 MiB -11393711.9 MiB      218892                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.0 MiB -22820807.8 MiB      438383               if temp_g_score < g_score[neighbor]:
    41     91.0 MiB -2869249.2 MiB       55417                   came_from[neighbor] = current
    42     91.0 MiB -2869250.4 MiB       55417                   g_score[neighbor] = temp_g_score
    43     91.0 MiB -2869252.7 MiB       55417                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.0 MiB -2865250.3 MiB       55023           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.0 MiB -2865252.0 MiB       55023           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.0 MiB      0.0 MiB           1       paths = {}
    53     33.2 MiB      0.0 MiB           4       for goal in goals:
    54     33.2 MiB      0.1 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.5 MiB     85.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.5 MiB    -17.7 MiB         257       for row in grid:
     8     85.5 MiB  -4529.8 MiB       65792           for spot in row:
     9     85.5 MiB  -4512.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.4 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.4 MiB      0.0 MiB           1       came_from = {}
    18     91.1 MiB      5.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.5 MiB -1493612.0 MiB       37431       while not open_set.empty():
    22     91.5 MiB -1493613.5 MiB       37431           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.5 MiB -1493616.5 MiB       37431           current = open_set.get()[1]
    28                                         
    29     91.5 MiB -1493617.5 MiB       37431           if current in remaining_goals:
    30     68.3 MiB   -146.3 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     68.3 MiB    -76.9 MiB           3               if not remaining_goals:
    32     31.0 MiB    -37.3 MiB           1                   break  # All goals found
    33                                         
    34     91.5 MiB -13407153.2 MiB      335668           for neighbor in current.neighbors:
    35     91.5 MiB -11913626.4 MiB      298238               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.5 MiB -11913625.6 MiB      298238               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.5 MiB -5951058.2 MiB      148919                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.5 MiB -11913637.7 MiB      298238               if temp_g_score < g_score[neighbor]:
    41     91.5 MiB -1503850.4 MiB       37899                   came_from[neighbor] = current
    42     91.5 MiB -1503852.3 MiB       37899                   g_score[neighbor] = temp_g_score
    43     91.5 MiB -1503854.0 MiB       37899                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.5 MiB -1493590.8 MiB       37430           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.5 MiB -1493592.5 MiB       37430           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.0 MiB      0.0 MiB           1       paths = {}
    53     31.2 MiB      0.0 MiB           4       for goal in goals:
    54     31.2 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.0 MiB     92.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.0 MiB    -17.9 MiB         257       for row in grid:
     8     92.0 MiB  -4547.7 MiB       65792           for spot in row:
     9     92.0 MiB  -4529.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.9 MiB     -1.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.9 MiB      0.0 MiB           1       came_from = {}
    18     95.9 MiB     -8.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.9 MiB -3073654.1 MiB       57329       while not open_set.empty():
    22     95.9 MiB -3073654.2 MiB       57329           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.9 MiB -3073654.8 MiB       57329           current = open_set.get()[1]
    28                                         
    29     95.9 MiB -3073655.3 MiB       57329           if current in remaining_goals:
    30     38.8 MiB   -177.0 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.8 MiB     -5.7 MiB           3               if not remaining_goals:
    32     38.5 MiB     -0.4 MiB           1                   break  # All goals found
    33                                         
    34     95.9 MiB -27553342.0 MiB      514091           for neighbor in current.neighbors:
    35     95.9 MiB -24479815.9 MiB      456763               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.9 MiB -24479807.4 MiB      456763               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.9 MiB -12221767.1 MiB      228072                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.9 MiB -24479845.0 MiB      456763               if temp_g_score < g_score[neighbor]:
    41     95.9 MiB -3077559.4 MiB       57724                   came_from[neighbor] = current
    42     95.9 MiB -3077559.9 MiB       57724                   g_score[neighbor] = temp_g_score
    43     95.9 MiB -3077562.0 MiB       57724                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.9 MiB -3073653.6 MiB       57328           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.9 MiB -3073653.6 MiB       57328           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.5 MiB      0.0 MiB           1       paths = {}
    53     38.7 MiB      0.0 MiB           4       for goal in goals:
    54     38.7 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.8 MiB     92.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.8 MiB   -363.8 MiB         257       for row in grid:
     8     92.8 MiB -92892.8 MiB       65792           for spot in row:
     9     92.8 MiB -92530.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.7 MiB     -4.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.7 MiB      0.0 MiB           1       came_from = {}
    18     93.7 MiB   -404.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.7 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.9 MiB -1377832.0 MiB       30680       while not open_set.empty():
    22     93.9 MiB -1377832.9 MiB       30680           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.9 MiB -1377835.0 MiB       30680           current = open_set.get()[1]
    28                                         
    29     93.9 MiB -1377835.7 MiB       30680           if current in remaining_goals:
    30     93.9 MiB   -124.4 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     93.9 MiB   -124.3 MiB           3               if not remaining_goals:
    32     32.4 MiB    -61.4 MiB           1                   break  # All goals found
    33                                         
    34     93.9 MiB -12339528.0 MiB      275122           for neighbor in current.neighbors:
    35     93.9 MiB -10961710.4 MiB      244443               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.9 MiB -10961721.8 MiB      244443               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.9 MiB -5470828.5 MiB      122057                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.9 MiB -10961739.8 MiB      244443               if temp_g_score < g_score[neighbor]:
    41     93.9 MiB -1378643.2 MiB       31119                   came_from[neighbor] = current
    42     93.9 MiB -1378645.0 MiB       31119                   g_score[neighbor] = temp_g_score
    43     93.9 MiB -1378648.3 MiB       31119                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.9 MiB -1377829.5 MiB       30679           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.9 MiB -1377830.2 MiB       30679           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.4 MiB      0.0 MiB           1       paths = {}
    53     32.7 MiB      0.0 MiB           4       for goal in goals:
    54     32.7 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.8 MiB     89.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.8 MiB   -228.0 MiB         257       for row in grid:
     8     89.8 MiB -58200.2 MiB       65792           for spot in row:
     9     89.8 MiB -57973.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.8 MiB     -1.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.8 MiB      0.0 MiB           1       came_from = {}
    18     92.7 MiB  -2009.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.8 MiB -1151885.2 MiB       34009       while not open_set.empty():
    22     92.8 MiB -1151885.6 MiB       34009           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.8 MiB -1151887.7 MiB       34009           current = open_set.get()[1]
    28                                         
    29     92.8 MiB -1151889.4 MiB       34009           if current in remaining_goals:
    30     84.9 MiB   -129.4 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     84.9 MiB   -105.8 MiB           3               if not remaining_goals:
    32     35.1 MiB    -49.8 MiB           1                   break  # All goals found
    33                                         
    34     92.8 MiB -10337826.7 MiB      305586           for neighbor in current.neighbors:
    35     92.8 MiB -9185963.8 MiB      271578               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.8 MiB -9185969.3 MiB      271578               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.8 MiB -4588289.8 MiB      135708                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.8 MiB -9186013.6 MiB      271578               if temp_g_score < g_score[neighbor]:
    41     92.8 MiB -1157341.0 MiB       34671                   came_from[neighbor] = current
    42     92.8 MiB -1157341.2 MiB       34671                   g_score[neighbor] = temp_g_score
    43     92.8 MiB -1157341.3 MiB       34671                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.8 MiB -1151884.7 MiB       34008           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.8 MiB -1151885.0 MiB       34008           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.1 MiB      0.0 MiB           1       paths = {}
    53     35.3 MiB      0.0 MiB           4       for goal in goals:
    54     35.3 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.2 MiB     89.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.2 MiB    -81.3 MiB         257       for row in grid:
     8     89.2 MiB -20823.6 MiB       65792           for spot in row:
     9     89.2 MiB -20742.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.7 MiB     -0.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.7 MiB      0.0 MiB           1       came_from = {}
    18     91.9 MiB -161553.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     80.8 MiB    -11.1 MiB           1       g_score[start] = 0
    20                                         
    21     83.2 MiB -1146501.0 MiB       43137       while not open_set.empty():
    22     83.2 MiB -1146501.9 MiB       43137           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     83.2 MiB -1146507.3 MiB       43137           current = open_set.get()[1]
    28                                         
    29     83.2 MiB -1146508.9 MiB       43137           if current in remaining_goals:
    30     35.7 MiB   -148.8 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.7 MiB      0.0 MiB           3               if not remaining_goals:
    32     35.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     83.2 MiB -10292214.7 MiB      386810           for neighbor in current.neighbors:
    35     83.2 MiB -9145829.2 MiB      343674               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     83.2 MiB -9145827.4 MiB      343674               if current.row != neighbor.row and current.col != neighbor.col:
    38     83.2 MiB -4568630.8 MiB      171602                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     83.2 MiB -9145839.1 MiB      343674               if temp_g_score < g_score[neighbor]:
    41     83.2 MiB -1152259.4 MiB       43601                   came_from[neighbor] = current
    42     83.2 MiB -1152273.4 MiB       43601                   g_score[neighbor] = temp_g_score
    43     83.2 MiB -1152274.8 MiB       43601                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     83.2 MiB -1146499.4 MiB       43136           if draw is not None:
    46                                                     draw()
    47                                                     
    48     83.2 MiB -1146500.2 MiB       43136           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.7 MiB      0.0 MiB           1       paths = {}
    53     35.9 MiB      0.0 MiB           4       for goal in goals:
    54     35.9 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.0 MiB     87.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.0 MiB    -72.6 MiB         257       for row in grid:
     8     87.0 MiB -18466.4 MiB       65792           for spot in row:
     9     87.0 MiB -18395.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.8 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.9 MiB      0.0 MiB           1       came_from = {}
    18     88.8 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.3 MiB -2273794.8 MiB       60595       while not open_set.empty():
    22     89.3 MiB -2273796.2 MiB       60595           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.3 MiB -2273799.7 MiB       60595           current = open_set.get()[1]
    28                                         
    29     89.3 MiB -2273801.7 MiB       60595           if current in remaining_goals:
    30     38.1 MiB   -155.4 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.1 MiB     -1.4 MiB           3               if not remaining_goals:
    32     36.8 MiB     -1.4 MiB           1                   break  # All goals found
    33                                         
    34     89.3 MiB -20352484.4 MiB      543239           for neighbor in current.neighbors:
    35     89.3 MiB -18078817.0 MiB      482645               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.3 MiB -18078818.2 MiB      482645               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.3 MiB -9020937.2 MiB      240972                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.3 MiB -18078834.0 MiB      482645               if temp_g_score < g_score[neighbor]:
    41     89.3 MiB -2257315.9 MiB       60912                   came_from[neighbor] = current
    42     89.3 MiB -2257317.3 MiB       60912                   g_score[neighbor] = temp_g_score
    43     89.3 MiB -2257319.9 MiB       60912                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.3 MiB -2273791.4 MiB       60594           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.3 MiB -2273793.4 MiB       60594           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.8 MiB      0.0 MiB           1       paths = {}
    53     37.0 MiB      0.0 MiB           4       for goal in goals:
    54     37.0 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.2 MiB     87.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.2 MiB   -371.3 MiB         257       for row in grid:
     8     87.2 MiB -95272.4 MiB       65792           for spot in row:
     9     87.2 MiB -94901.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.3 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.3 MiB      0.0 MiB           1       came_from = {}
    18     90.6 MiB   -181.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.6 MiB -2064086.7 MiB       56475       while not open_set.empty():
    22     90.6 MiB -2064087.9 MiB       56475           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.6 MiB -2064095.2 MiB       56475           current = open_set.get()[1]
    28                                         
    29     90.6 MiB -2064096.6 MiB       56475           if current in remaining_goals:
    30     77.8 MiB   -113.7 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     77.8 MiB    -75.2 MiB           3               if not remaining_goals:
    32     40.7 MiB    -37.1 MiB           1                   break  # All goals found
    33                                         
    34     90.6 MiB -18513211.8 MiB      506396           for neighbor in current.neighbors:
    35     90.6 MiB -16449166.3 MiB      449922               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.6 MiB -16449166.4 MiB      449922               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.6 MiB -8214083.5 MiB      224650                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.6 MiB -16449179.8 MiB      449922               if temp_g_score < g_score[neighbor]:
    41     90.6 MiB -2067610.8 MiB       56861                   came_from[neighbor] = current
    42     90.6 MiB -2067612.7 MiB       56861                   g_score[neighbor] = temp_g_score
    43     90.6 MiB -2067615.2 MiB       56861                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.6 MiB -2064082.4 MiB       56474           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.6 MiB -2064084.0 MiB       56474           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.7 MiB      0.0 MiB           1       paths = {}
    53     41.0 MiB      0.0 MiB           4       for goal in goals:
    54     41.0 MiB      0.3 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.3 MiB     87.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.3 MiB   -108.7 MiB         257       for row in grid:
     8     87.3 MiB -27636.9 MiB       65792           for spot in row:
     9     87.3 MiB -27529.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.0 MiB     -1.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.0 MiB      0.0 MiB           1       came_from = {}
    18     89.1 MiB -18374.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.5 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21     88.8 MiB -2079765.0 MiB       51193       while not open_set.empty():
    22     88.8 MiB -2079766.5 MiB       51193           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.8 MiB -2079768.6 MiB       51193           current = open_set.get()[1]
    28                                         
    29     88.8 MiB -2079769.4 MiB       51193           if current in remaining_goals:
    30     88.8 MiB   -121.7 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     88.8 MiB   -121.7 MiB           3               if not remaining_goals:
    32     25.9 MiB    -62.9 MiB           1                   break  # All goals found
    33                                         
    34     88.8 MiB -18637345.4 MiB      458915           for neighbor in current.neighbors:
    35     88.8 MiB -16557604.1 MiB      407723               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.8 MiB -16557611.6 MiB      407723               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.8 MiB -8265532.3 MiB      203560                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.8 MiB -16557644.2 MiB      407723               if temp_g_score < g_score[neighbor]:
    41     88.8 MiB -2077112.2 MiB       51550                   came_from[neighbor] = current
    42     88.8 MiB -2077113.8 MiB       51550                   g_score[neighbor] = temp_g_score
    43     88.8 MiB -2077115.7 MiB       51550                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.8 MiB -2079761.9 MiB       51192           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.8 MiB -2079763.5 MiB       51192           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     25.9 MiB      0.0 MiB           1       paths = {}
    53     27.3 MiB      0.0 MiB           4       for goal in goals:
    54     27.3 MiB      1.3 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.6 MiB    -38.1 MiB         257       for row in grid:
     8     86.6 MiB  -9771.7 MiB       65792           for spot in row:
     9     86.6 MiB  -9733.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.3 MiB     -0.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.3 MiB      0.0 MiB           1       came_from = {}
    18     91.9 MiB      5.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.0 MiB -2686638.1 MiB       58602       while not open_set.empty():
    22     92.0 MiB -2686639.0 MiB       58602           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.0 MiB -2686640.5 MiB       58602           current = open_set.get()[1]
    28                                         
    29     92.0 MiB -2686641.2 MiB       58602           if current in remaining_goals:
    30     29.6 MiB   -189.4 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.6 MiB     -0.2 MiB           3               if not remaining_goals:
    32     29.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.0 MiB -24093996.1 MiB      525416           for neighbor in current.neighbors:
    35     92.0 MiB -21407498.2 MiB      466815               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.0 MiB -21407491.3 MiB      466815               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.0 MiB -10689569.8 MiB      233076                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.0 MiB -21407546.0 MiB      466815               if temp_g_score < g_score[neighbor]:
    41     92.0 MiB -2687866.8 MiB       58957                   came_from[neighbor] = current
    42     92.0 MiB -2687867.7 MiB       58957                   g_score[neighbor] = temp_g_score
    43     92.0 MiB -2687869.6 MiB       58957                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.0 MiB -2686635.5 MiB       58601           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.0 MiB -2686637.0 MiB       58601           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.6 MiB      0.0 MiB           1       paths = {}
    53     30.4 MiB      0.0 MiB           4       for goal in goals:
    54     30.4 MiB      0.8 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.5 MiB     85.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.5 MiB   -720.2 MiB         257       for row in grid:
     8     85.5 MiB -176597.7 MiB       65792           for spot in row:
     9     85.5 MiB -175909.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     44.1 MiB    -41.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     35.2 MiB     -8.9 MiB           1       open_set = PriorityQueue()
    16     19.8 MiB    -15.4 MiB           1       open_set.put((0, start))
    17     19.8 MiB      0.0 MiB           1       came_from = {}
    18     27.2 MiB -46340.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     25.2 MiB     -2.0 MiB           1       g_score[start] = 0
    20                                         
    21     45.5 MiB -18634.2 MiB       42123       while not open_set.empty():
    22     45.5 MiB -18634.9 MiB       42123           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     45.5 MiB -18634.8 MiB       42123           current = open_set.get()[1]
    28                                         
    29     45.5 MiB -18638.4 MiB       42123           if current in remaining_goals:
    30     45.5 MiB      0.0 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.5 MiB      0.0 MiB           3               if not remaining_goals:
    32     45.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     45.5 MiB -167106.1 MiB      377678           for neighbor in current.neighbors:
    35     45.5 MiB -148481.8 MiB      335556               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     45.5 MiB -148472.4 MiB      335556               if current.row != neighbor.row and current.col != neighbor.col:
    38     45.5 MiB -74133.5 MiB      167542                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     45.5 MiB -148482.4 MiB      335556               if temp_g_score < g_score[neighbor]:
    41     45.5 MiB -18923.5 MiB       42557                   came_from[neighbor] = current
    42     45.5 MiB -18926.8 MiB       42557                   g_score[neighbor] = temp_g_score
    43     45.5 MiB -18926.7 MiB       42557                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     45.5 MiB -18633.5 MiB       42122           if draw is not None:
    46                                                     draw()
    47                                                     
    48     45.5 MiB -18633.7 MiB       42122           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.5 MiB      0.0 MiB           1       paths = {}
    53     45.7 MiB      0.0 MiB           4       for goal in goals:
    54     45.7 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.0 MiB     92.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.0 MiB   -110.4 MiB         257       for row in grid:
     8     92.0 MiB -28362.8 MiB       65792           for spot in row:
     9     92.0 MiB -28252.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.4 MiB     -0.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.4 MiB      0.0 MiB           1       came_from = {}
    18     96.5 MiB  -9665.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.8 MiB     -0.7 MiB           1       g_score[start] = 0
    20                                         
    21     95.9 MiB -337105.6 MiB       25606       while not open_set.empty():
    22     95.9 MiB -337105.7 MiB       25606           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.9 MiB -337107.1 MiB       25606           current = open_set.get()[1]
    28                                         
    29     95.9 MiB -337107.4 MiB       25606           if current in remaining_goals:
    30     95.8 MiB    -29.6 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     95.8 MiB    -29.3 MiB           3               if not remaining_goals:
    32     73.0 MiB    -22.8 MiB           1                   break  # All goals found
    33                                         
    34     95.9 MiB -3019039.0 MiB      229516           for neighbor in current.neighbors:
    35     95.9 MiB -2681937.1 MiB      203911               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.9 MiB -2681937.9 MiB      203911               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.9 MiB -1338538.3 MiB      101801                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.9 MiB -2681952.5 MiB      203911               if temp_g_score < g_score[neighbor]:
    41     95.9 MiB -337999.1 MiB       26003                   came_from[neighbor] = current
    42     95.9 MiB -337999.8 MiB       26003                   g_score[neighbor] = temp_g_score
    43     95.9 MiB -338000.4 MiB       26003                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.9 MiB -337105.3 MiB       25605           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.9 MiB -337105.6 MiB       25605           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     73.0 MiB      0.0 MiB           1       paths = {}
    53     73.1 MiB      0.0 MiB           4       for goal in goals:
    54     73.1 MiB      0.1 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     73.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.7 MiB     94.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.7 MiB   -283.8 MiB         257       for row in grid:
     8     94.7 MiB -72474.1 MiB       65792           for spot in row:
     9     94.7 MiB -72191.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.1 MiB     -3.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.1 MiB      0.0 MiB           1       came_from = {}
    18     96.0 MiB -13227.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.4 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21     95.5 MiB -1818955.2 MiB       62603       while not open_set.empty():
    22     95.5 MiB -1818956.1 MiB       62603           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.5 MiB -1818957.5 MiB       62603           current = open_set.get()[1]
    28                                         
    29     95.5 MiB -1818958.4 MiB       62603           if current in remaining_goals:
    30     93.8 MiB   -107.2 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     93.8 MiB   -102.1 MiB           3               if not remaining_goals:
    32     43.0 MiB    -50.8 MiB           1                   break  # All goals found
    33                                         
    34     95.5 MiB -16299328.2 MiB      560940           for neighbor in current.neighbors:
    35     95.5 MiB -14480385.4 MiB      498338               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.5 MiB -14480417.8 MiB      498338               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.5 MiB -7228438.0 MiB      248757                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.5 MiB -14480425.0 MiB      498338               if temp_g_score < g_score[neighbor]:
    41     95.5 MiB -1808911.0 MiB       62797                   came_from[neighbor] = current
    42     95.5 MiB -1808912.1 MiB       62797                   g_score[neighbor] = temp_g_score
    43     95.5 MiB -1808913.0 MiB       62797                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.5 MiB -1818952.0 MiB       62602           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.5 MiB -1818954.0 MiB       62602           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.0 MiB      0.0 MiB           1       paths = {}
    53     43.1 MiB      0.0 MiB           4       for goal in goals:
    54     43.1 MiB      0.1 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.9 MiB     89.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.9 MiB     -9.9 MiB         257       for row in grid:
     8     89.9 MiB  -2543.0 MiB       65792           for spot in row:
     9     89.9 MiB  -2533.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.8 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.8 MiB      0.0 MiB           1       came_from = {}
    18     93.5 MiB    -66.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.5 MiB -3551916.2 MiB       64292       while not open_set.empty():
    22     93.5 MiB -3551917.2 MiB       64292           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.5 MiB -3551919.7 MiB       64292           current = open_set.get()[1]
    28                                         
    29     93.5 MiB -3551920.1 MiB       64292           if current in remaining_goals:
    30     40.5 MiB   -164.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.5 MiB     -6.1 MiB           3               if not remaining_goals:
    32     37.7 MiB     -2.8 MiB           1                   break  # All goals found
    33                                         
    34     93.5 MiB -31822127.9 MiB      576014           for neighbor in current.neighbors:
    35     93.5 MiB -28270330.1 MiB      511723               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.5 MiB -28270324.1 MiB      511723               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.5 MiB -14111190.9 MiB      255428                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.5 MiB -28270355.9 MiB      511723               if temp_g_score < g_score[neighbor]:
    41     93.5 MiB -3551405.4 MiB       64443                   came_from[neighbor] = current
    42     93.5 MiB -3551406.9 MiB       64443                   g_score[neighbor] = temp_g_score
    43     93.5 MiB -3551409.0 MiB       64443                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.5 MiB -3551913.6 MiB       64291           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.5 MiB -3551915.0 MiB       64291           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.7 MiB      0.0 MiB           1       paths = {}
    53     37.9 MiB      0.0 MiB           4       for goal in goals:
    54     37.9 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.9 MiB     88.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.9 MiB     -4.5 MiB         257       for row in grid:
     8     88.9 MiB  -1120.3 MiB       65792           for spot in row:
     9     88.9 MiB  -1116.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.7 MiB     -0.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.7 MiB      0.0 MiB           1       came_from = {}
    18     89.3 MiB -158457.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.1 MiB     -3.2 MiB           1       g_score[start] = 0
    20                                         
    21     86.2 MiB -954943.4 MiB       38227       while not open_set.empty():
    22     86.2 MiB -954944.4 MiB       38227           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.2 MiB -954945.7 MiB       38227           current = open_set.get()[1]
    28                                         
    29     86.2 MiB -954946.5 MiB       38227           if current in remaining_goals:
    30     37.3 MiB   -151.1 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.3 MiB      0.0 MiB           3               if not remaining_goals:
    32     37.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.2 MiB -8573238.1 MiB      342757           for neighbor in current.neighbors:
    35     86.2 MiB -7618409.6 MiB      304531               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.2 MiB -7618415.8 MiB      304531               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.2 MiB -3805772.6 MiB      152053                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.2 MiB -7618434.8 MiB      304531               if temp_g_score < g_score[neighbor]:
    41     86.2 MiB -962003.6 MiB       38694                   came_from[neighbor] = current
    42     86.2 MiB -962004.4 MiB       38694                   g_score[neighbor] = temp_g_score
    43     86.2 MiB -962006.3 MiB       38694                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.2 MiB -954942.4 MiB       38226           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.2 MiB -954942.7 MiB       38226           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.3 MiB      0.0 MiB           1       paths = {}
    53     37.5 MiB      0.0 MiB           4       for goal in goals:
    54     37.5 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.1 MiB     88.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.1 MiB      0.0 MiB         257       for row in grid:
     8     88.1 MiB      0.0 MiB       65792           for spot in row:
     9     88.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.1 MiB      0.0 MiB           1       came_from = {}
    18     93.2 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.3 MiB -550750.2 MiB       33767       while not open_set.empty():
    22     93.3 MiB -550751.0 MiB       33767           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.3 MiB -550752.5 MiB       33767           current = open_set.get()[1]
    28                                         
    29     93.3 MiB -550753.4 MiB       33767           if current in remaining_goals:
    30     92.5 MiB   -104.8 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     92.5 MiB   -102.3 MiB           3               if not remaining_goals:
    32     41.5 MiB    -51.0 MiB           1                   break  # All goals found
    33                                         
    34     93.3 MiB -4939211.9 MiB      302833           for neighbor in current.neighbors:
    35     93.3 MiB -4388475.8 MiB      269067               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.3 MiB -4388482.7 MiB      269067               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.3 MiB -2191401.0 MiB      134357                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.3 MiB -4388494.2 MiB      269067               if temp_g_score < g_score[neighbor]:
    41     93.3 MiB -552346.0 MiB       34228                   came_from[neighbor] = current
    42     93.3 MiB -552347.5 MiB       34228                   g_score[neighbor] = temp_g_score
    43     93.3 MiB -552349.0 MiB       34228                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.3 MiB -550747.1 MiB       33766           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.3 MiB -550748.2 MiB       33766           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.5 MiB      0.0 MiB           1       paths = {}
    53     41.8 MiB      0.0 MiB           4       for goal in goals:
    54     41.8 MiB      0.3 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.2 MiB     87.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.2 MiB      0.0 MiB         257       for row in grid:
     8     87.2 MiB      0.0 MiB       65792           for spot in row:
     9     87.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.2 MiB      0.0 MiB           1       came_from = {}
    18     90.0 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.1 MiB -189968.5 MiB       46342       while not open_set.empty():
    22     91.1 MiB -189969.5 MiB       46342           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.1 MiB -189972.1 MiB       46342           current = open_set.get()[1]
    28                                         
    29     91.1 MiB -189973.3 MiB       46342           if current in remaining_goals:
    30     89.1 MiB    -60.2 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     89.1 MiB    -54.1 MiB           3               if not remaining_goals:
    32     37.3 MiB    -51.9 MiB           1                   break  # All goals found
    33                                         
    34     91.1 MiB -1706346.3 MiB      415765           for neighbor in current.neighbors:
    35     91.1 MiB -1516393.3 MiB      369424               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.1 MiB -1516403.3 MiB      369424               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.1 MiB -757727.2 MiB      184495                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.1 MiB -1516418.6 MiB      369424               if temp_g_score < g_score[neighbor]:
    41     91.1 MiB -191104.4 MiB       46866                   came_from[neighbor] = current
    42     91.1 MiB -191106.1 MiB       46866                   g_score[neighbor] = temp_g_score
    43     91.1 MiB -191111.0 MiB       46866                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.1 MiB -189966.5 MiB       46341           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.1 MiB -189967.4 MiB       46341           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.3 MiB      0.0 MiB           1       paths = {}
    53     37.5 MiB      0.0 MiB           4       for goal in goals:
    54     37.5 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.0 MiB     88.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.0 MiB      0.0 MiB         257       for row in grid:
     8     88.0 MiB      0.0 MiB       65792           for spot in row:
     9     88.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.0 MiB      0.0 MiB           1       came_from = {}
    18     94.2 MiB      6.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.3 MiB -718820.7 MiB       22402       while not open_set.empty():
    22     94.3 MiB -718821.2 MiB       22402           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.3 MiB -718822.6 MiB       22402           current = open_set.get()[1]
    28                                         
    29     94.3 MiB -718823.2 MiB       22402           if current in remaining_goals:
    30     67.8 MiB   -120.3 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     67.8 MiB    -41.1 MiB           3               if not remaining_goals:
    32     47.3 MiB    -20.5 MiB           1                   break  # All goals found
    33                                         
    34     94.3 MiB -6435674.0 MiB      200761           for neighbor in current.neighbors:
    35     94.3 MiB -5716919.1 MiB      178360               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.3 MiB -5716927.2 MiB      178360               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.3 MiB -2852964.6 MiB       89039                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.3 MiB -5716943.9 MiB      178360               if temp_g_score < g_score[neighbor]:
    41     94.3 MiB -721449.4 MiB       22778                   came_from[neighbor] = current
    42     94.3 MiB -721450.3 MiB       22778                   g_score[neighbor] = temp_g_score
    43     94.3 MiB -721452.0 MiB       22778                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.3 MiB -718818.7 MiB       22401           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.3 MiB -718819.6 MiB       22401           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     47.3 MiB      0.0 MiB           1       paths = {}
    53     47.4 MiB      0.0 MiB           4       for goal in goals:
    54     47.4 MiB      0.1 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.0 MiB     86.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.0 MiB      0.0 MiB         257       for row in grid:
     8     86.0 MiB      0.0 MiB       65792           for spot in row:
     9     86.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.0 MiB      0.0 MiB           1       came_from = {}
    18     90.6 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.7 MiB -1655281.5 MiB       49395       while not open_set.empty():
    22     90.7 MiB -1655282.8 MiB       49395           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.7 MiB -1655286.4 MiB       49395           current = open_set.get()[1]
    28                                         
    29     90.7 MiB -1655287.6 MiB       49395           if current in remaining_goals:
    30     90.0 MiB   -102.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.0 MiB   -100.8 MiB           3               if not remaining_goals:
    32     40.3 MiB    -49.7 MiB           1                   break  # All goals found
    33                                         
    34     90.7 MiB -14859174.7 MiB      443110           for neighbor in current.neighbors:
    35     90.7 MiB -13203913.0 MiB      393716               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.7 MiB -13203917.4 MiB      393716               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.7 MiB -6595654.3 MiB      196619                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.7 MiB -13203932.1 MiB      393716               if temp_g_score < g_score[neighbor]:
    41     90.7 MiB -1663239.3 MiB       49897                   came_from[neighbor] = current
    42     90.7 MiB -1663240.4 MiB       49897                   g_score[neighbor] = temp_g_score
    43     90.7 MiB -1663242.7 MiB       49897                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.7 MiB -1655278.5 MiB       49394           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.7 MiB -1655279.8 MiB       49394           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.3 MiB      0.0 MiB           1       paths = {}
    53     40.5 MiB      0.0 MiB           4       for goal in goals:
    54     40.5 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.7 MiB     94.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.7 MiB      0.0 MiB         257       for row in grid:
     8     94.7 MiB      0.0 MiB       65792           for spot in row:
     9     94.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.7 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     94.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     94.7 MiB      0.0 MiB           1       came_from = {}
    18     97.0 MiB -14682.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.2 MiB -2888056.3 MiB       65001       while not open_set.empty():
    22     97.2 MiB -2888057.9 MiB       65001           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.2 MiB -2888061.3 MiB       65001           current = open_set.get()[1]
    28                                         
    29     97.2 MiB -2888063.0 MiB       65001           if current in remaining_goals:
    30     40.2 MiB   -176.6 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.2 MiB     -2.3 MiB           3               if not remaining_goals:
    32     40.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     97.2 MiB -25848775.1 MiB      582227           for neighbor in current.neighbors:
    35     97.2 MiB -22960856.0 MiB      517227               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.2 MiB -22960861.7 MiB      517227               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.2 MiB -11456635.8 MiB      258152                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.2 MiB -22960881.7 MiB      517227               if temp_g_score < g_score[neighbor]:
    41     97.2 MiB -2865842.7 MiB       65096                   came_from[neighbor] = current
    42     97.2 MiB -2865844.0 MiB       65096                   g_score[neighbor] = temp_g_score
    43     97.2 MiB -2865846.6 MiB       65096                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.2 MiB -2888052.1 MiB       65000           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.2 MiB -2888054.2 MiB       65000           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.2 MiB      0.0 MiB           1       paths = {}
    53     41.0 MiB      0.0 MiB           4       for goal in goals:
    54     41.0 MiB      0.7 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.2 MiB     93.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.2 MiB   -198.4 MiB         257       for row in grid:
     8     93.2 MiB -50995.3 MiB       65792           for spot in row:
     9     93.2 MiB -50797.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.4 MiB     -0.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.4 MiB      0.0 MiB           1       came_from = {}
    18     96.0 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.0 MiB -758664.2 MiB       21977       while not open_set.empty():
    22     96.0 MiB -758665.4 MiB       21977           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.0 MiB -758668.2 MiB       21977           current = open_set.get()[1]
    28                                         
    29     96.0 MiB -758670.4 MiB       21977           if current in remaining_goals:
    30     29.1 MiB   -203.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.1 MiB      0.0 MiB           3               if not remaining_goals:
    32     29.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.0 MiB -6809477.1 MiB      197292           for neighbor in current.neighbors:
    35     96.0 MiB -6050966.0 MiB      175316               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.0 MiB -6050976.8 MiB      175316               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.0 MiB -3022540.4 MiB       87576                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.0 MiB -6050994.6 MiB      175316               if temp_g_score < g_score[neighbor]:
    41     96.0 MiB -767127.4 MiB       22487                   came_from[neighbor] = current
    42     96.0 MiB -767129.0 MiB       22487                   g_score[neighbor] = temp_g_score
    43     96.0 MiB -767132.5 MiB       22487                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.0 MiB -758660.9 MiB       21976           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.0 MiB -758662.6 MiB       21976           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.1 MiB      0.0 MiB           1       paths = {}
    53     29.2 MiB      0.0 MiB           4       for goal in goals:
    54     29.2 MiB      0.1 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.2 MiB     90.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.2 MiB    -11.5 MiB         257       for row in grid:
     8     90.2 MiB  -2944.2 MiB       65792           for spot in row:
     9     90.2 MiB  -2932.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.1 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.1 MiB      0.0 MiB           1       came_from = {}
    18     94.7 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.8 MiB -1996797.7 MiB       55061       while not open_set.empty():
    22     94.8 MiB -1996798.8 MiB       55061           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.8 MiB -1996801.3 MiB       55061           current = open_set.get()[1]
    28                                         
    29     94.8 MiB -1996802.3 MiB       55061           if current in remaining_goals:
    30     94.8 MiB   -105.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     94.8 MiB   -105.7 MiB           3               if not remaining_goals:
    32     36.2 MiB    -58.5 MiB           1                   break  # All goals found
    33                                         
    34     94.8 MiB -17917409.0 MiB      493799           for neighbor in current.neighbors:
    35     94.8 MiB -15920631.0 MiB      438739               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.8 MiB -15920638.7 MiB      438739               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.8 MiB -7951488.5 MiB      219080                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.8 MiB -15920667.3 MiB      438739               if temp_g_score < g_score[neighbor]:
    41     94.8 MiB -2002804.6 MiB       55496                   came_from[neighbor] = current
    42     94.8 MiB -2002806.4 MiB       55496                   g_score[neighbor] = temp_g_score
    43     94.8 MiB -2002808.3 MiB       55496                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.8 MiB -1996795.8 MiB       55060           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.8 MiB -1996796.8 MiB       55060           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.2 MiB      0.0 MiB           1       paths = {}
    53     36.6 MiB      0.0 MiB           4       for goal in goals:
    54     36.6 MiB      0.3 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.6 MiB     90.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.6 MiB      0.0 MiB         257       for row in grid:
     8     90.6 MiB      0.0 MiB       65792           for spot in row:
     9     90.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.6 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.6 MiB      0.0 MiB           1       came_from = {}
    18     95.7 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.9 MiB -2057576.1 MiB       61770       while not open_set.empty():
    22     95.9 MiB -2057577.4 MiB       61770           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.9 MiB -2057580.5 MiB       61770           current = open_set.get()[1]
    28                                         
    29     95.9 MiB -2057582.2 MiB       61770           if current in remaining_goals:
    30     90.5 MiB   -110.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.5 MiB    -94.7 MiB           3               if not remaining_goals:
    32     43.0 MiB    -47.5 MiB           1                   break  # All goals found
    33                                         
    34     95.9 MiB -18425000.3 MiB      554175           for neighbor in current.neighbors:
    35     95.9 MiB -16367450.1 MiB      492406               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.9 MiB -16367456.3 MiB      492406               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.9 MiB -8168282.9 MiB      245912                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.9 MiB -16367472.3 MiB      492406               if temp_g_score < g_score[neighbor]:
    41     95.9 MiB -2042561.1 MiB       62206                   came_from[neighbor] = current
    42     95.9 MiB -2042562.4 MiB       62206                   g_score[neighbor] = temp_g_score
    43     95.9 MiB -2042564.7 MiB       62206                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.9 MiB -2057572.9 MiB       61769           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.9 MiB -2057574.6 MiB       61769           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.0 MiB      0.0 MiB           1       paths = {}
    53     43.2 MiB      0.0 MiB           4       for goal in goals:
    54     43.2 MiB      0.2 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.7 MiB     90.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.7 MiB   -170.7 MiB         257       for row in grid:
     8     90.7 MiB -43852.8 MiB       65792           for spot in row:
     9     90.7 MiB -43682.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.2 MiB     -1.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.2 MiB      0.0 MiB           1       came_from = {}
    18     93.0 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.2 MiB -872601.5 MiB       53577       while not open_set.empty():
    22     93.2 MiB -872604.2 MiB       53577           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.2 MiB -872607.2 MiB       53577           current = open_set.get()[1]
    28                                         
    29     93.2 MiB -872608.9 MiB       53577           if current in remaining_goals:
    30     75.8 MiB   -114.9 MiB           3               remaining_goals.remove(current)  # Remove this goal from the list
    31     75.8 MiB    -62.7 MiB           3               if not remaining_goals:
    32     45.2 MiB    -30.6 MiB           1                   break  # All goals found
    33                                         
    34     93.2 MiB -7819649.6 MiB      480419           for neighbor in current.neighbors:
    35     93.2 MiB -6947103.1 MiB      426843               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.2 MiB -6947105.3 MiB      426843               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.2 MiB -3468030.6 MiB      213128                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.2 MiB -6947117.4 MiB      426843               if temp_g_score < g_score[neighbor]:
    41     93.2 MiB -869740.4 MiB       53974                   came_from[neighbor] = current
    42     93.2 MiB -869741.3 MiB       53974                   g_score[neighbor] = temp_g_score
    43     93.2 MiB -869742.8 MiB       53974                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.2 MiB -872599.1 MiB       53576           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.2 MiB -872600.3 MiB       53576           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.2 MiB      0.0 MiB           1       paths = {}
    53     45.6 MiB      0.0 MiB           4       for goal in goals:
    54     45.6 MiB      0.4 MiB           3           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.6 MiB      0.0 MiB           1       return paths


