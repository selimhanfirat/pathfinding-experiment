Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.2 MiB     67.2 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/2.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     69.9 MiB   -732.7 MiB         257       for row in grid:
     8     69.9 MiB -186521.6 MiB       65792           for spot in row:
     9     69.9 MiB -185792.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     59.9 MiB     -9.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     60.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     60.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     60.0 MiB      0.0 MiB           1       came_from = {}
    18     65.3 MiB -29117.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     65.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     65.5 MiB -488051.9 MiB       44589       while not open_set.empty():
    22     65.5 MiB -488052.3 MiB       44589           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     65.5 MiB -488052.7 MiB       44589           current = open_set.get()[1]
    28                                         
    29     65.5 MiB -488053.1 MiB       44589           if current in remaining_goals:
    30     62.3 MiB    -24.2 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     62.3 MiB    -18.0 MiB           2               if not remaining_goals:
    32     44.4 MiB    -18.0 MiB           1                   break  # All goals found
    33                                         
    34     65.5 MiB -4377261.9 MiB      400257           for neighbor in current.neighbors:
    35     65.5 MiB -3889221.6 MiB      355669               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     65.5 MiB -3889234.0 MiB      355669               if current.row != neighbor.row and current.col != neighbor.col:
    38     65.5 MiB -1942124.8 MiB      177662                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     65.5 MiB -3889236.3 MiB      355669               if temp_g_score < g_score[neighbor]:
    41     65.5 MiB -488964.1 MiB       45172                   came_from[neighbor] = current
    42     65.5 MiB -488964.2 MiB       45172                   g_score[neighbor] = temp_g_score
    43     65.5 MiB -488964.3 MiB       45172                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     65.5 MiB -488050.2 MiB       44588           if draw is not None:
    46                                                     draw()
    47                                                     
    48     65.5 MiB -488051.5 MiB       44588           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.4 MiB      0.0 MiB           1       paths = {}
    53     44.5 MiB      0.0 MiB           3       for goal in goals:
    54     44.5 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.4 MiB     89.4 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/5.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.4 MiB      0.0 MiB         257       for row in grid:
     8     93.4 MiB      0.0 MiB       65792           for spot in row:
     9     93.4 MiB      4.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.4 MiB      0.0 MiB           1       came_from = {}
    18     98.1 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     98.4 MiB -1076522.0 MiB       27503       while not open_set.empty():
    22     98.4 MiB -1076525.2 MiB       27503           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     98.4 MiB -1076528.1 MiB       27503           current = open_set.get()[1]
    28                                         
    29     98.4 MiB -1076529.5 MiB       27503           if current in remaining_goals:
    30     86.4 MiB    -67.8 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     86.4 MiB    -43.9 MiB           2               if not remaining_goals:
    32     42.5 MiB    -43.9 MiB           1                   break  # All goals found
    33                                         
    34     98.4 MiB -9636535.5 MiB      246571           for neighbor in current.neighbors:
    35     98.4 MiB -8560043.9 MiB      219069               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     98.4 MiB -8560050.1 MiB      219069               if current.row != neighbor.row and current.col != neighbor.col:
    38     98.4 MiB -4271453.3 MiB      109377                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     98.4 MiB -8560063.6 MiB      219069               if temp_g_score < g_score[neighbor]:
    41     98.4 MiB -1075832.0 MiB       27914                   came_from[neighbor] = current
    42     98.4 MiB -1075837.4 MiB       27914                   g_score[neighbor] = temp_g_score
    43     98.4 MiB -1075839.1 MiB       27914                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     98.4 MiB -1076519.6 MiB       27502           if draw is not None:
    46                                                     draw()
    47                                                     
    48     98.4 MiB -1076520.7 MiB       27502           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.5 MiB      0.0 MiB           1       paths = {}
    53     42.7 MiB      0.0 MiB           3       for goal in goals:
    54     42.7 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.1 MiB     94.1 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/7.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.4 MiB    -59.0 MiB         257       for row in grid:
     8     94.4 MiB -15112.8 MiB       65792           for spot in row:
     9     94.4 MiB -15054.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.7 MiB     -0.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.7 MiB      0.0 MiB           1       came_from = {}
    18     98.5 MiB  -5166.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.0 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     98.1 MiB -2760887.5 MiB       65258       while not open_set.empty():
    22     98.1 MiB -2760888.6 MiB       65258           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     98.1 MiB -2760893.5 MiB       65258           current = open_set.get()[1]
    28                                         
    29     98.1 MiB -2760895.3 MiB       65258           if current in remaining_goals:
    30     45.3 MiB   -106.1 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.3 MiB      0.0 MiB           2               if not remaining_goals:
    32     45.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     98.1 MiB -24697471.6 MiB      584447           for neighbor in current.neighbors:
    35     98.1 MiB -21936656.1 MiB      519190               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     98.1 MiB -21936665.8 MiB      519190               if current.row != neighbor.row and current.col != neighbor.col:
    38     98.1 MiB -10943371.9 MiB      259118                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     98.1 MiB -21936681.5 MiB      519190               if temp_g_score < g_score[neighbor]:
    41     98.1 MiB -2737687.0 MiB       65322                   came_from[neighbor] = current
    42     98.1 MiB -2737687.5 MiB       65322                   g_score[neighbor] = temp_g_score
    43     98.1 MiB -2737689.0 MiB       65322                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     98.1 MiB -2760884.2 MiB       65257           if draw is not None:
    46                                                     draw()
    47                                                     
    48     98.1 MiB -2760886.1 MiB       65257           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.3 MiB      0.0 MiB           1       paths = {}
    53     45.5 MiB      0.0 MiB           3       for goal in goals:
    54     45.5 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.7 MiB    100.7 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.7 MiB      0.0 MiB         257       for row in grid:
     8    100.7 MiB      0.0 MiB       65792           for spot in row:
     9    100.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    100.7 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    100.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    100.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17    100.7 MiB      0.0 MiB           1       came_from = {}
    18    105.7 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    105.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    106.2 MiB -1995457.4 MiB       52788       while not open_set.empty():
    22    106.2 MiB -1995458.6 MiB       52788           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    106.2 MiB -1995460.3 MiB       52788           current = open_set.get()[1]
    28                                         
    29    106.2 MiB -1995461.8 MiB       52788           if current in remaining_goals:
    30    105.7 MiB    -59.9 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31    105.7 MiB    -59.4 MiB           2               if not remaining_goals:
    32     46.3 MiB    -59.4 MiB           1                   break  # All goals found
    33                                         
    34    106.2 MiB -17912590.5 MiB      473644           for neighbor in current.neighbors:
    35    106.2 MiB -15917155.6 MiB      420857               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    106.2 MiB -15917161.7 MiB      420857               if current.row != neighbor.row and current.col != neighbor.col:
    38    106.2 MiB -7950951.4 MiB      210189                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    106.2 MiB -15917177.5 MiB      420857               if temp_g_score < g_score[neighbor]:
    41    106.2 MiB -2003766.5 MiB       53315                   came_from[neighbor] = current
    42    106.2 MiB -2003768.3 MiB       53315                   g_score[neighbor] = temp_g_score
    43    106.2 MiB -2003769.9 MiB       53315                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    106.2 MiB -1995455.6 MiB       52787           if draw is not None:
    46                                                     draw()
    47                                                     
    48    106.2 MiB -1995456.5 MiB       52787           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.3 MiB      0.0 MiB           1       paths = {}
    53     46.4 MiB      0.0 MiB           3       for goal in goals:
    54     46.4 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.4 MiB    100.4 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.4 MiB  -1403.0 MiB         257       for row in grid:
     8    100.4 MiB -358642.2 MiB       65792           for spot in row:
     9    100.4 MiB -357248.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.0 MiB    -10.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.1 MiB      0.0 MiB           1       came_from = {}
    18     95.8 MiB      5.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.0 MiB -2881957.2 MiB       59127       while not open_set.empty():
    22     96.0 MiB -2881961.1 MiB       59127           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.0 MiB -2881963.4 MiB       59127           current = open_set.get()[1]
    28                                         
    29     96.0 MiB -2881964.7 MiB       59127           if current in remaining_goals:
    30     47.2 MiB   -106.6 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     47.2 MiB      0.0 MiB           2               if not remaining_goals:
    32     47.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.0 MiB -25823434.5 MiB      530047           for neighbor in current.neighbors:
    35     96.0 MiB -22941549.2 MiB      470921               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.0 MiB -22941547.6 MiB      470921               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.0 MiB -11451853.0 MiB      235113                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.0 MiB -22941562.4 MiB      470921               if temp_g_score < g_score[neighbor]:
    41     96.0 MiB -2879278.3 MiB       59450                   came_from[neighbor] = current
    42     96.0 MiB -2879279.3 MiB       59450                   g_score[neighbor] = temp_g_score
    43     96.0 MiB -2879280.6 MiB       59450                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.0 MiB -2881952.9 MiB       59126           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.0 MiB -2881953.6 MiB       59126           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     47.2 MiB      0.0 MiB           1       paths = {}
    53     47.4 MiB      0.0 MiB           3       for goal in goals:
    54     47.4 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.5 MiB     99.5 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.5 MiB    -50.4 MiB         257       for row in grid:
     8     99.5 MiB -12923.5 MiB       65792           for spot in row:
     9     99.5 MiB -12873.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     99.3 MiB     -0.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     99.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     99.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     99.3 MiB      0.0 MiB           1       came_from = {}
    18    104.3 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    104.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    104.4 MiB -3495870.3 MiB       65127       while not open_set.empty():
    22    104.4 MiB -3495871.0 MiB       65127           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    104.4 MiB -3495874.2 MiB       65127           current = open_set.get()[1]
    28                                         
    29    104.4 MiB -3495874.7 MiB       65127           if current in remaining_goals:
    30     40.8 MiB   -128.7 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.8 MiB      0.0 MiB           2               if not remaining_goals:
    32     40.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    104.4 MiB -31313092.8 MiB      583281           for neighbor in current.neighbors:
    35    104.4 MiB -27817298.6 MiB      518155               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    104.4 MiB -27817295.3 MiB      518155               if current.row != neighbor.row and current.col != neighbor.col:
    38    104.4 MiB -13883859.7 MiB      258603                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    104.4 MiB -27817303.4 MiB      518155               if temp_g_score < g_score[neighbor]:
    41    104.4 MiB -3484799.2 MiB       65196                   came_from[neighbor] = current
    42    104.4 MiB -3484799.7 MiB       65196                   g_score[neighbor] = temp_g_score
    43    104.4 MiB -3484801.3 MiB       65196                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    104.4 MiB -3495868.1 MiB       65126           if draw is not None:
    46                                                     draw()
    47                                                     
    48    104.4 MiB -3495869.8 MiB       65126           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.8 MiB      0.0 MiB           1       paths = {}
    53     41.3 MiB      0.0 MiB           3       for goal in goals:
    54     41.3 MiB      0.4 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.5 MiB     98.5 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.5 MiB    -95.2 MiB         257       for row in grid:
     8     98.5 MiB -24198.4 MiB       65792           for spot in row:
     9     98.5 MiB -24103.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     96.2 MiB     -2.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     96.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     96.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     96.2 MiB      0.0 MiB           1       came_from = {}
    18     98.8 MiB -56079.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.9 MiB     -0.8 MiB           1       g_score[start] = 0
    20                                         
    21     97.9 MiB -2597477.2 MiB       64764       while not open_set.empty():
    22     97.9 MiB -2597480.5 MiB       64764           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.9 MiB -2597481.7 MiB       64764           current = open_set.get()[1]
    28                                         
    29     97.9 MiB -2597482.3 MiB       64764           if current in remaining_goals:
    30     51.0 MiB   -101.5 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     51.0 MiB     -7.6 MiB           2               if not remaining_goals:
    32     43.4 MiB     -7.6 MiB           1                   break  # All goals found
    33                                         
    34     97.9 MiB -23264841.8 MiB      580092           for neighbor in current.neighbors:
    35     97.9 MiB -20667447.0 MiB      515329               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.9 MiB -20667452.3 MiB      515329               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.9 MiB -10315137.6 MiB      257203                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.9 MiB -20667462.8 MiB      515329               if temp_g_score < g_score[neighbor]:
    41     97.9 MiB -2584732.9 MiB       64859                   came_from[neighbor] = current
    42     97.9 MiB -2584733.7 MiB       64859                   g_score[neighbor] = temp_g_score
    43     97.9 MiB -2584736.4 MiB       64859                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.9 MiB -2597474.7 MiB       64763           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.9 MiB -2597475.9 MiB       64763           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.4 MiB      0.0 MiB           1       paths = {}
    53     43.9 MiB      0.0 MiB           3       for goal in goals:
    54     43.9 MiB      0.5 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.7 MiB     97.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/0.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.7 MiB   -407.7 MiB         257       for row in grid:
     8     97.7 MiB -104640.1 MiB       65792           for spot in row:
     9     97.7 MiB -104234.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     95.2 MiB     -2.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     95.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     95.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     95.2 MiB      0.0 MiB           1       came_from = {}
    18     96.9 MiB -48194.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.8 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.9 MiB -1972810.8 MiB       34288       while not open_set.empty():
    22     96.9 MiB -1972811.1 MiB       34288           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.9 MiB -1972811.6 MiB       34288           current = open_set.get()[1]
    28                                         
    29     96.9 MiB -1972811.9 MiB       34288           if current in remaining_goals:
    30     39.5 MiB   -117.0 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     39.5 MiB      0.0 MiB           2               if not remaining_goals:
    32     39.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.9 MiB -17694112.4 MiB      307312           for neighbor in current.neighbors:
    35     96.9 MiB -15721367.8 MiB      273025               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.9 MiB -15721412.8 MiB      273025               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.9 MiB -7850616.7 MiB      136301                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.9 MiB -15721421.1 MiB      273025               if temp_g_score < g_score[neighbor]:
    41     96.9 MiB -1993138.9 MiB       34727                   came_from[neighbor] = current
    42     96.9 MiB -1993139.3 MiB       34727                   g_score[neighbor] = temp_g_score
    43     96.9 MiB -1993140.4 MiB       34727                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.9 MiB -1972809.7 MiB       34287           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.9 MiB -1972810.6 MiB       34287           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.5 MiB      0.0 MiB           1       paths = {}
    53     39.6 MiB      0.0 MiB           3       for goal in goals:
    54     39.6 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     39.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     95.2 MiB     95.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     95.2 MiB   -168.2 MiB         257       for row in grid:
     8     95.2 MiB -43085.0 MiB       65792           for spot in row:
     9     95.2 MiB -42918.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.2 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.2 MiB      0.0 MiB           1       came_from = {}
    18     96.7 MiB  -8826.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.5 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     96.6 MiB -1742906.1 MiB       33529       while not open_set.empty():
    22     96.6 MiB -1742908.8 MiB       33529           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.6 MiB -1742909.5 MiB       33529           current = open_set.get()[1]
    28                                         
    29     96.6 MiB -1742912.3 MiB       33529           if current in remaining_goals:
    30     30.4 MiB   -132.9 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.4 MiB     -0.6 MiB           2               if not remaining_goals:
    32     29.8 MiB     -0.6 MiB           1                   break  # All goals found
    33                                         
    34     96.6 MiB -15660547.0 MiB      301374           for neighbor in current.neighbors:
    35     96.6 MiB -13917766.1 MiB      267846               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.6 MiB -13917747.7 MiB      267846               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.6 MiB -6954963.3 MiB      133860                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.6 MiB -13917813.1 MiB      267846               if temp_g_score < g_score[neighbor]:
    41     96.6 MiB -1765574.2 MiB       34235                   came_from[neighbor] = current
    42     96.6 MiB -1765576.1 MiB       34235                   g_score[neighbor] = temp_g_score
    43     96.6 MiB -1765584.6 MiB       34235                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.6 MiB -1742878.5 MiB       33528           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.6 MiB -1742882.2 MiB       33528           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.8 MiB      0.0 MiB           1       paths = {}
    53     29.9 MiB      0.0 MiB           3       for goal in goals:
    54     29.9 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     83.4 MiB     83.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     83.4 MiB -10259.5 MiB         257       for row in grid:
     8     83.4 MiB -2627779.7 MiB       65792           for spot in row:
     9     83.4 MiB -2617571.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     28.6 MiB    -54.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     29.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     29.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     29.2 MiB      0.0 MiB           1       came_from = {}
    18     36.7 MiB -23880.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     36.2 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     37.1 MiB -273616.2 MiB       17639       while not open_set.empty():
    22     37.1 MiB -273616.3 MiB       17639           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     37.1 MiB -273617.0 MiB       17639           current = open_set.get()[1]
    28                                         
    29     37.1 MiB -273617.2 MiB       17639           if current in remaining_goals:
    30     23.1 MiB    -28.1 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     23.1 MiB      0.0 MiB           2               if not remaining_goals:
    32     23.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     37.1 MiB -2449825.3 MiB      157939           for neighbor in current.neighbors:
    35     37.1 MiB -2176228.5 MiB      140301               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     37.1 MiB -2176232.8 MiB      140301               if current.row != neighbor.row and current.col != neighbor.col:
    38     37.1 MiB -1086034.9 MiB       70017                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     37.1 MiB -2176234.4 MiB      140301               if temp_g_score < g_score[neighbor]:
    41     37.1 MiB -277210.0 MiB       17968                   came_from[neighbor] = current
    42     37.1 MiB -277210.3 MiB       17968                   g_score[neighbor] = temp_g_score
    43     37.1 MiB -277210.5 MiB       17968                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     37.1 MiB -273616.0 MiB       17638           if draw is not None:
    46                                                     draw()
    47                                                     
    48     37.1 MiB -273616.2 MiB       17638           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     23.1 MiB      0.0 MiB           1       paths = {}
    53     23.2 MiB      0.0 MiB           3       for goal in goals:
    54     23.2 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     23.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.9 MiB     84.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.9 MiB  -3592.1 MiB         257       for row in grid:
     8     84.9 MiB -918313.4 MiB       65792           for spot in row:
     9     84.9 MiB -914764.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     26.9 MiB    -58.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     27.2 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     27.4 MiB      0.2 MiB           1       open_set.put((0, start))
    17     27.4 MiB      0.0 MiB           1       came_from = {}
    18     36.7 MiB  -7887.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     36.7 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     37.0 MiB -464692.4 MiB       43351       while not open_set.empty():
    22     37.0 MiB -464692.8 MiB       43351           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     37.0 MiB -464693.6 MiB       43351           current = open_set.get()[1]
    28                                         
    29     37.0 MiB -464693.9 MiB       43351           if current in remaining_goals:
    30     32.9 MiB    -12.0 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.9 MiB      0.0 MiB           2               if not remaining_goals:
    32     32.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     37.0 MiB -4166159.1 MiB      388858           for neighbor in current.neighbors:
    35     37.0 MiB -3701482.5 MiB      345508               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     37.0 MiB -3701474.9 MiB      345508               if current.row != neighbor.row and current.col != neighbor.col:
    38     37.0 MiB -1848097.3 MiB      172539                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     37.0 MiB -3701482.7 MiB      345508               if temp_g_score < g_score[neighbor]:
    41     37.0 MiB -468032.1 MiB       43855                   came_from[neighbor] = current
    42     37.0 MiB -468032.5 MiB       43855                   g_score[neighbor] = temp_g_score
    43     37.0 MiB -468034.1 MiB       43855                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     37.0 MiB -464691.3 MiB       43350           if draw is not None:
    46                                                     draw()
    47                                                     
    48     37.0 MiB -464691.7 MiB       43350           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.9 MiB      0.0 MiB           1       paths = {}
    53     33.1 MiB      0.0 MiB           3       for goal in goals:
    54     33.1 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     95.4 MiB     95.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     95.4 MiB  -5820.3 MiB         257       for row in grid:
     8     95.4 MiB -1488863.5 MiB       65792           for spot in row:
     9     95.4 MiB -1483076.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     24.8 MiB    -70.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     25.1 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     25.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     25.3 MiB      0.0 MiB           1       came_from = {}
    18     37.2 MiB     12.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     37.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     42.1 MiB -361417.3 MiB       34687       while not open_set.empty():
    22     42.1 MiB -361417.6 MiB       34687           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     42.1 MiB -361419.5 MiB       34687           current = open_set.get()[1]
    28                                         
    29     42.1 MiB -361420.2 MiB       34687           if current in remaining_goals:
    30     31.1 MiB    -26.1 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     31.1 MiB      0.0 MiB           2               if not remaining_goals:
    32     31.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     42.1 MiB -3240969.6 MiB      311062           for neighbor in current.neighbors:
    35     42.1 MiB -2879579.5 MiB      276376               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     42.1 MiB -2879571.5 MiB      276376               if current.row != neighbor.row and current.col != neighbor.col:
    38     42.1 MiB -1437857.5 MiB      138003                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     42.1 MiB -2879580.8 MiB      276376               if temp_g_score < g_score[neighbor]:
    41     42.1 MiB -364708.9 MiB       35149                   came_from[neighbor] = current
    42     42.1 MiB -364709.9 MiB       35149                   g_score[neighbor] = temp_g_score
    43     42.1 MiB -364710.2 MiB       35149                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     42.1 MiB -361416.1 MiB       34686           if draw is not None:
    46                                                     draw()
    47                                                     
    48     42.1 MiB -361417.0 MiB       34686           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.1 MiB      0.0 MiB           1       paths = {}
    53     31.3 MiB      0.0 MiB           3       for goal in goals:
    54     31.3 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.8 MiB     91.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.8 MiB  -1106.3 MiB         257       for row in grid:
     8     91.8 MiB -282111.8 MiB       65792           for spot in row:
     9     91.8 MiB -281017.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     73.3 MiB    -18.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     73.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     73.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     73.8 MiB      0.0 MiB           1       came_from = {}
    18     74.8 MiB -2522235.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     34.7 MiB    -40.1 MiB           1       g_score[start] = 0
    20                                         
    21     43.4 MiB -298282.1 MiB       33105       while not open_set.empty():
    22     43.4 MiB -298283.2 MiB       33105           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     43.4 MiB -298283.8 MiB       33105           current = open_set.get()[1]
    28                                         
    29     43.4 MiB -298284.6 MiB       33105           if current in remaining_goals:
    30     32.3 MiB    -25.2 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.3 MiB      0.0 MiB           2               if not remaining_goals:
    32     32.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     43.4 MiB -2683565.6 MiB      297867           for neighbor in current.neighbors:
    35     43.4 MiB -2385310.4 MiB      264763               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     43.4 MiB -2385299.5 MiB      264763               if current.row != neighbor.row and current.col != neighbor.col:
    38     43.4 MiB -1192540.5 MiB      132370                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     43.4 MiB -2385318.7 MiB      264763               if temp_g_score < g_score[neighbor]:
    41     43.4 MiB -303129.2 MiB       33934                   came_from[neighbor] = current
    42     43.4 MiB -303129.9 MiB       33934                   g_score[neighbor] = temp_g_score
    43     43.4 MiB -303130.8 MiB       33934                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     43.4 MiB -298279.1 MiB       33104           if draw is not None:
    46                                                     draw()
    47                                                     
    48     43.4 MiB -298280.5 MiB       33104           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.3 MiB      0.0 MiB           1       paths = {}
    53     32.5 MiB      0.0 MiB           3       for goal in goals:
    54     32.5 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.5 MiB     89.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.5 MiB    -48.1 MiB         257       for row in grid:
     8     89.5 MiB -12244.4 MiB       65792           for spot in row:
     9     89.5 MiB -12196.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.9 MiB     -0.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.9 MiB      0.0 MiB           1       came_from = {}
    18     91.4 MiB -16762.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.3 MiB     -2.1 MiB           1       g_score[start] = 0
    20                                         
    21     89.3 MiB -1682260.1 MiB       31287       while not open_set.empty():
    22     89.3 MiB -1844558.6 MiB       31287           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.3 MiB -1844561.2 MiB       31287           current = open_set.get()[1]
    28                                         
    29     89.3 MiB -1844561.7 MiB       31287           if current in remaining_goals:
    30     44.4 MiB   -107.5 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.4 MiB      0.0 MiB           2               if not remaining_goals:
    32     44.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.3 MiB -16559368.5 MiB      280908           for neighbor in current.neighbors:
    35     89.3 MiB -14714883.1 MiB      249622               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.3 MiB -14714890.0 MiB      249622               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.3 MiB -7350615.1 MiB      124700                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.3 MiB -14714919.4 MiB      249622               if temp_g_score < g_score[neighbor]:
    41     89.3 MiB -1873034.0 MiB       31891                   came_from[neighbor] = current
    42     89.3 MiB -1873041.0 MiB       31891                   g_score[neighbor] = temp_g_score
    43     89.3 MiB -1873043.8 MiB       31891                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.1 MiB -1844556.3 MiB       31286           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.1 MiB -1682259.4 MiB       31286           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.4 MiB      0.0 MiB           1       paths = {}
    53     44.5 MiB      0.0 MiB           3       for goal in goals:
    54     44.5 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.1 MiB     88.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.1 MiB   -440.9 MiB         257       for row in grid:
     8     88.1 MiB -112965.6 MiB       65792           for spot in row:
     9     88.1 MiB -112525.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.7 MiB     -2.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.7 MiB      0.0 MiB           1       came_from = {}
    18     87.6 MiB -369479.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     77.3 MiB    -10.2 MiB           1       g_score[start] = 0
    20                                         
    21     78.0 MiB -2159049.9 MiB       45976       while not open_set.empty():
    22     78.0 MiB -2159050.8 MiB       45976           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     78.0 MiB -2159051.9 MiB       45976           current = open_set.get()[1]
    28                                         
    29     78.0 MiB -2159052.3 MiB       45976           if current in remaining_goals:
    30     38.3 MiB    -90.1 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.3 MiB      0.0 MiB           2               if not remaining_goals:
    32     38.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     78.0 MiB -19361491.1 MiB      412348           for neighbor in current.neighbors:
    35     78.0 MiB -17202523.8 MiB      366373               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     78.0 MiB -17202512.2 MiB      366373               if current.row != neighbor.row and current.col != neighbor.col:
    38     78.0 MiB -8589708.6 MiB      182949                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     78.0 MiB -17202526.1 MiB      366373               if temp_g_score < g_score[neighbor]:
    41     78.0 MiB -2177762.2 MiB       46485                   came_from[neighbor] = current
    42     78.0 MiB -2177765.1 MiB       46485                   g_score[neighbor] = temp_g_score
    43     78.0 MiB -2177765.8 MiB       46485                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     78.0 MiB -2159047.6 MiB       45975           if draw is not None:
    46                                                     draw()
    47                                                     
    48     78.0 MiB -2159049.5 MiB       45975           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.3 MiB      0.0 MiB           1       paths = {}
    53     38.6 MiB      0.0 MiB           3       for goal in goals:
    54     38.6 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.7 MiB     89.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.7 MiB   -633.9 MiB         257       for row in grid:
     8     89.7 MiB -162103.7 MiB       65792           for spot in row:
     9     89.7 MiB -161473.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.1 MiB     -6.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.1 MiB      0.0 MiB           1       came_from = {}
    18     86.4 MiB -30357.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.6 MiB     -0.8 MiB           1       g_score[start] = 0
    20                                         
    21     85.9 MiB -2609260.5 MiB       62096       while not open_set.empty():
    22     85.9 MiB -2609261.7 MiB       62096           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.9 MiB -2609263.9 MiB       62096           current = open_set.get()[1]
    28                                         
    29     85.9 MiB -2609264.5 MiB       62096           if current in remaining_goals:
    30     85.7 MiB    -56.5 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     85.7 MiB    -56.2 MiB           2               if not remaining_goals:
    32     29.5 MiB    -56.2 MiB           1                   break  # All goals found
    33                                         
    34     85.9 MiB -23390767.9 MiB      556419           for neighbor in current.neighbors:
    35     85.9 MiB -20781550.3 MiB      494324               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.9 MiB -20781541.2 MiB      494324               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.9 MiB -10375488.2 MiB      246757                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.9 MiB -20781552.2 MiB      494324               if temp_g_score < g_score[neighbor]:
    41     85.9 MiB -2607812.0 MiB       62304                   came_from[neighbor] = current
    42     85.9 MiB -2607812.8 MiB       62304                   g_score[neighbor] = temp_g_score
    43     85.9 MiB -2607815.4 MiB       62304                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.9 MiB -2609233.2 MiB       62095           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.9 MiB -2609234.0 MiB       62095           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.5 MiB      0.0 MiB           1       paths = {}
    53     30.6 MiB      0.0 MiB           3       for goal in goals:
    54     30.6 MiB      1.0 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.6 MiB     87.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.6 MiB   -663.2 MiB         257       for row in grid:
     8     87.6 MiB -169387.2 MiB       65792           for spot in row:
     9     87.6 MiB -168728.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.6 MiB     -6.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     82.0 MiB      0.2 MiB           1       open_set.put((0, start))
    17     82.0 MiB      0.0 MiB           1       came_from = {}
    18     86.4 MiB -18078.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.8 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21     86.0 MiB -3072456.1 MiB       55151       while not open_set.empty():
    22     86.0 MiB -3072456.9 MiB       55151           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.0 MiB -3072457.2 MiB       55151           current = open_set.get()[1]
    28                                         
    29     86.0 MiB -3072457.7 MiB       55151           if current in remaining_goals:
    30     28.7 MiB   -119.1 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     28.7 MiB      0.0 MiB           2               if not remaining_goals:
    32     28.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.0 MiB -27553928.6 MiB      494468           for neighbor in current.neighbors:
    35     86.0 MiB -24481541.0 MiB      439318               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.0 MiB -24481529.1 MiB      439318               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.0 MiB -12224537.6 MiB      219346                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.0 MiB -24481596.1 MiB      439318               if temp_g_score < g_score[neighbor]:
    41     86.0 MiB -3088830.4 MiB       55543                   came_from[neighbor] = current
    42     86.0 MiB -3088833.9 MiB       55543                   g_score[neighbor] = temp_g_score
    43     86.0 MiB -3088835.4 MiB       55543                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.0 MiB -3072454.9 MiB       55150           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.0 MiB -3072455.4 MiB       55150           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     28.7 MiB      0.0 MiB           1       paths = {}
    53     29.8 MiB      0.0 MiB           3       for goal in goals:
    54     29.8 MiB      1.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.1 MiB     86.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.1 MiB   -177.8 MiB         257       for row in grid:
     8     86.1 MiB -44345.5 MiB       65792           for spot in row:
     9     86.1 MiB -44173.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     78.1 MiB     -8.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     78.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     78.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     78.5 MiB      0.0 MiB           1       came_from = {}
    18     79.7 MiB -62330.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     79.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     80.1 MiB -1134009.6 MiB       28721       while not open_set.empty():
    22     80.1 MiB -1134009.7 MiB       28721           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     80.1 MiB -1134010.1 MiB       28721           current = open_set.get()[1]
    28                                         
    29     80.1 MiB -1134010.4 MiB       28721           if current in remaining_goals:
    30     30.6 MiB   -104.2 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.6 MiB      0.0 MiB           2               if not remaining_goals:
    32     30.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     80.1 MiB -10164974.8 MiB      257467           for neighbor in current.neighbors:
    35     80.1 MiB -9031029.1 MiB      228747               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     80.1 MiB -9031027.7 MiB      228747               if current.row != neighbor.row and current.col != neighbor.col:
    38     80.1 MiB -4508794.8 MiB      114205                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     80.1 MiB -9031050.7 MiB      228747               if temp_g_score < g_score[neighbor]:
    41     80.1 MiB -1139750.5 MiB       29136                   came_from[neighbor] = current
    42     80.1 MiB -1139751.2 MiB       29136                   g_score[neighbor] = temp_g_score
    43     80.1 MiB -1139751.8 MiB       29136                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     80.1 MiB -1134006.3 MiB       28720           if draw is not None:
    46                                                     draw()
    47                                                     
    48     80.1 MiB -1134006.7 MiB       28720           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.6 MiB      0.0 MiB           1       paths = {}
    53     30.9 MiB      0.0 MiB           3       for goal in goals:
    54     30.9 MiB      0.3 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.4 MiB     85.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.7 MiB     -2.2 MiB         257       for row in grid:
     8     85.7 MiB   -579.0 MiB       65792           for spot in row:
     9     85.7 MiB   -576.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.7 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.7 MiB      0.0 MiB           1       came_from = {}
    18     91.1 MiB   -157.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.2 MiB -1168015.6 MiB       28270       while not open_set.empty():
    22     91.2 MiB -1168020.9 MiB       28270           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.2 MiB -1168022.0 MiB       28270           current = open_set.get()[1]
    28                                         
    29     91.2 MiB -1168022.8 MiB       28270           if current in remaining_goals:
    30     88.6 MiB    -66.4 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     88.6 MiB    -61.2 MiB           2               if not remaining_goals:
    32     27.4 MiB    -61.2 MiB           1                   break  # All goals found
    33                                         
    34     91.2 MiB -10481351.5 MiB      253339           for neighbor in current.neighbors:
    35     91.2 MiB -9313350.4 MiB      225070               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.2 MiB -9313354.2 MiB      225070               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.2 MiB -4651666.9 MiB      112355                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.2 MiB -9313389.1 MiB      225070               if temp_g_score < g_score[neighbor]:
    41     91.2 MiB -1178211.5 MiB       28674                   came_from[neighbor] = current
    42     91.2 MiB -1178213.5 MiB       28674                   g_score[neighbor] = temp_g_score
    43     91.2 MiB -1178215.5 MiB       28674                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.2 MiB -1168011.8 MiB       28269           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.2 MiB -1168013.2 MiB       28269           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.4 MiB      0.0 MiB           1       paths = {}
    53     27.6 MiB      0.0 MiB           3       for goal in goals:
    54     27.6 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.7 MiB     84.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.7 MiB  -4155.3 MiB         257       for row in grid:
     8     84.7 MiB -1060649.6 MiB       65792           for spot in row:
     9     84.7 MiB -1056498.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     22.0 MiB    -62.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     22.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     22.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     22.5 MiB      0.0 MiB           1       came_from = {}
    18     35.0 MiB    -10.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     35.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     47.8 MiB -302108.7 MiB       48929       while not open_set.empty():
    22     47.8 MiB -302108.9 MiB       48929           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     47.8 MiB -302109.6 MiB       48929           current = open_set.get()[1]
    28                                         
    29     47.8 MiB -302110.0 MiB       48929           if current in remaining_goals:
    30     37.8 MiB    -23.7 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.8 MiB      0.0 MiB           2               if not remaining_goals:
    32     37.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     47.8 MiB -2705775.8 MiB      438593           for neighbor in current.neighbors:
    35     47.8 MiB -2403700.7 MiB      389665               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     47.8 MiB -2403688.9 MiB      389665               if current.row != neighbor.row and current.col != neighbor.col:
    38     47.8 MiB -1199687.5 MiB      194540                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     47.8 MiB -2403709.9 MiB      389665               if temp_g_score < g_score[neighbor]:
    41     47.8 MiB -301482.1 MiB       49286                   came_from[neighbor] = current
    42     47.8 MiB -301483.3 MiB       49286                   g_score[neighbor] = temp_g_score
    43     47.8 MiB -301483.7 MiB       49286                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     47.8 MiB -302107.7 MiB       48928           if draw is not None:
    46                                                     draw()
    47                                                     
    48     47.8 MiB -302108.2 MiB       48928           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.8 MiB      0.0 MiB           1       paths = {}
    53     38.0 MiB      0.0 MiB           3       for goal in goals:
    54     38.0 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.2 MiB     93.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.2 MiB   -648.5 MiB         257       for row in grid:
     8     93.2 MiB -165293.4 MiB       65792           for spot in row:
     9     93.2 MiB -164652.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.5 MiB    -10.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     82.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     82.9 MiB      0.0 MiB           1       came_from = {}
    18     85.9 MiB  -7523.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.8 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     85.9 MiB -1669076.6 MiB       31769       while not open_set.empty():
    22     85.9 MiB -1669077.6 MiB       31769           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.9 MiB -1669080.1 MiB       31769           current = open_set.get()[1]
    28                                         
    29     85.9 MiB -1669082.1 MiB       31769           if current in remaining_goals:
    30     27.4 MiB   -116.8 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     27.4 MiB      0.0 MiB           2               if not remaining_goals:
    32     27.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     85.9 MiB -14970263.1 MiB      284797           for neighbor in current.neighbors:
    35     85.9 MiB -13301262.6 MiB      253029               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.9 MiB -13301265.3 MiB      253029               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.9 MiB -6642180.7 MiB      126329                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.9 MiB -13301281.8 MiB      253029               if temp_g_score < g_score[neighbor]:
    41     85.9 MiB -1683314.1 MiB       32216                   came_from[neighbor] = current
    42     85.9 MiB -1683315.2 MiB       32216                   g_score[neighbor] = temp_g_score
    43     85.9 MiB -1683317.0 MiB       32216                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.9 MiB -1669073.4 MiB       31768           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.9 MiB -1669074.8 MiB       31768           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.4 MiB      0.0 MiB           1       paths = {}
    53     27.7 MiB      0.0 MiB           3       for goal in goals:
    54     27.7 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.0 MiB     90.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.0 MiB     -1.1 MiB         257       for row in grid:
     8     90.0 MiB   -286.3 MiB       65792           for spot in row:
     9     90.0 MiB   -285.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.0 MiB      0.0 MiB           1       came_from = {}
    18     94.8 MiB  -2730.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.0 MiB     -0.9 MiB           1       g_score[start] = 0
    20                                         
    21     94.0 MiB -2490578.5 MiB       47595       while not open_set.empty():
    22     94.0 MiB -2490578.8 MiB       47595           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.0 MiB -2490580.8 MiB       47595           current = open_set.get()[1]
    28                                         
    29     94.0 MiB -2490581.3 MiB       47595           if current in remaining_goals:
    30     93.2 MiB    -59.2 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     93.2 MiB    -57.6 MiB           2               if not remaining_goals:
    32     35.6 MiB    -57.6 MiB           1                   break  # All goals found
    33                                         
    34     94.0 MiB -22323508.7 MiB      426740           for neighbor in current.neighbors:
    35     94.0 MiB -19832953.5 MiB      379146               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.0 MiB -19832960.2 MiB      379146               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.0 MiB -9901358.1 MiB      189306                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.0 MiB -19832993.3 MiB      379146               if temp_g_score < g_score[neighbor]:
    41     94.0 MiB -2496485.4 MiB       47997                   came_from[neighbor] = current
    42     94.0 MiB -2496497.5 MiB       47997                   g_score[neighbor] = temp_g_score
    43     94.0 MiB -2496499.4 MiB       47997                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.0 MiB -2490576.5 MiB       47594           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.0 MiB -2490577.4 MiB       47594           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.6 MiB      0.0 MiB           1       paths = {}
    53     35.8 MiB      0.0 MiB           3       for goal in goals:
    54     35.8 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.2 MiB     91.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.2 MiB  -2798.9 MiB         257       for row in grid:
     8     91.2 MiB -717216.7 MiB       65792           for spot in row:
     9     91.2 MiB -714431.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     73.5 MiB    -17.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     73.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     73.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     73.9 MiB      0.0 MiB           1       came_from = {}
    18     80.4 MiB      6.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     80.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     81.0 MiB -2710364.5 MiB       65070       while not open_set.empty():
    22     81.0 MiB -2710364.6 MiB       65070           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.0 MiB -2710365.1 MiB       65070           current = open_set.get()[1]
    28                                         
    29     81.0 MiB -2710365.5 MiB       65070           if current in remaining_goals:
    30     34.2 MiB    -94.9 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.2 MiB      0.0 MiB           2               if not remaining_goals:
    32     34.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.0 MiB -24273177.2 MiB      582786           for neighbor in current.neighbors:
    35     81.0 MiB -21562868.2 MiB      517717               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.0 MiB -21562900.5 MiB      517717               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.0 MiB -10761567.4 MiB      258387                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.0 MiB -21562912.4 MiB      517717               if temp_g_score < g_score[neighbor]:
    41     81.0 MiB -2699599.2 MiB       65145                   came_from[neighbor] = current
    42     81.0 MiB -2699600.2 MiB       65145                   g_score[neighbor] = temp_g_score
    43     81.0 MiB -2699601.4 MiB       65145                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.0 MiB -2710363.8 MiB       65069           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.0 MiB -2710364.0 MiB       65069           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.2 MiB      0.0 MiB           1       paths = {}
    53     34.8 MiB      0.0 MiB           3       for goal in goals:
    54     34.8 MiB      0.6 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.1 MiB     89.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.1 MiB   -220.0 MiB         257       for row in grid:
     8     89.1 MiB -56214.0 MiB       65792           for spot in row:
     9     89.1 MiB -55996.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.8 MiB     -2.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.8 MiB      0.0 MiB           1       came_from = {}
    18     90.1 MiB  -2872.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.4 MiB     -0.8 MiB           1       g_score[start] = 0
    20                                         
    21     89.5 MiB -2798672.9 MiB       56557       while not open_set.empty():
    22     89.5 MiB -2798673.9 MiB       56557           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.5 MiB -2798675.1 MiB       56557           current = open_set.get()[1]
    28                                         
    29     89.5 MiB -2798676.7 MiB       56557           if current in remaining_goals:
    30     31.7 MiB   -118.6 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     31.7 MiB      0.0 MiB           2               if not remaining_goals:
    32     31.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.5 MiB -25093134.0 MiB      507062           for neighbor in current.neighbors:
    35     89.5 MiB -22294563.4 MiB      450506               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.5 MiB -22294582.3 MiB      450506               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.5 MiB -11131664.5 MiB      224930                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.5 MiB -22294597.3 MiB      450506               if temp_g_score < g_score[neighbor]:
    41     89.5 MiB -2800774.0 MiB       56913                   came_from[neighbor] = current
    42     89.5 MiB -2800775.0 MiB       56913                   g_score[neighbor] = temp_g_score
    43     89.5 MiB -2800777.1 MiB       56913                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.5 MiB -2798669.9 MiB       56556           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.5 MiB -2798671.9 MiB       56556           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.7 MiB      0.0 MiB           1       paths = {}
    53     32.9 MiB      0.0 MiB           3       for goal in goals:
    54     32.9 MiB      1.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.7 MiB     87.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.7 MiB    -39.1 MiB         257       for row in grid:
     8     87.7 MiB  -9946.5 MiB       65792           for spot in row:
     9     87.7 MiB  -9907.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.3 MiB     -0.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.3 MiB      0.0 MiB           1       came_from = {}
    18     92.2 MiB      4.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.3 MiB -3237102.3 MiB       65505       while not open_set.empty():
    22     92.3 MiB -3237104.4 MiB       65505           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.3 MiB -3237106.4 MiB       65505           current = open_set.get()[1]
    28                                         
    29     92.3 MiB -3237111.1 MiB       65505           if current in remaining_goals:
    30     81.4 MiB    -72.2 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     81.4 MiB    -50.2 MiB           2               if not remaining_goals:
    32     31.1 MiB    -50.2 MiB           1                   break  # All goals found
    33                                         
    34     92.3 MiB -28951471.1 MiB      586515           for neighbor in current.neighbors:
    35     92.3 MiB -25714401.1 MiB      521011               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.3 MiB -25714402.7 MiB      521011               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.3 MiB -12826940.6 MiB      260003                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.3 MiB -25714431.9 MiB      521011               if temp_g_score < g_score[neighbor]:
    41     92.3 MiB -3207405.2 MiB       65518                   came_from[neighbor] = current
    42     92.3 MiB -3207407.7 MiB       65518                   g_score[neighbor] = temp_g_score
    43     92.3 MiB -3207409.8 MiB       65518                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.3 MiB -3237097.3 MiB       65504           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.3 MiB -3237101.0 MiB       65504           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.1 MiB      0.0 MiB           1       paths = {}
    53     31.6 MiB      0.0 MiB           3       for goal in goals:
    54     31.6 MiB      0.4 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.1 MiB     87.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.1 MiB    -70.0 MiB         257       for row in grid:
     8     87.1 MiB -17703.9 MiB       65792           for spot in row:
     9     87.1 MiB -17635.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.0 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.0 MiB      0.0 MiB           1       came_from = {}
    18     87.9 MiB -122387.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     81.8 MiB     -6.1 MiB           1       g_score[start] = 0
    20                                         
    21     81.9 MiB -2178443.5 MiB       45626       while not open_set.empty():
    22     81.9 MiB -2178444.8 MiB       45626           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.9 MiB -2178447.6 MiB       45626           current = open_set.get()[1]
    28                                         
    29     81.9 MiB -2178449.3 MiB       45626           if current in remaining_goals:
    30     34.2 MiB   -103.0 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.2 MiB      0.0 MiB           2               if not remaining_goals:
    32     34.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.9 MiB -19541912.4 MiB      409408           for neighbor in current.neighbors:
    35     81.9 MiB -17363549.0 MiB      363783               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.9 MiB -17363547.0 MiB      363783               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.9 MiB -8671206.4 MiB      181689                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.9 MiB -17363561.9 MiB      363783               if temp_g_score < g_score[neighbor]:
    41     81.9 MiB -2190823.0 MiB       46161                   came_from[neighbor] = current
    42     81.9 MiB -2190824.4 MiB       46161                   g_score[neighbor] = temp_g_score
    43     81.9 MiB -2190826.9 MiB       46161                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.9 MiB -2178437.3 MiB       45625           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.9 MiB -2178439.6 MiB       45625           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.2 MiB      0.0 MiB           1       paths = {}
    53     34.4 MiB      0.0 MiB           3       for goal in goals:
    54     34.4 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.6 MiB     84.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.6 MiB   -726.9 MiB         257       for row in grid:
     8     84.6 MiB -186175.9 MiB       65792           for spot in row:
     9     84.6 MiB -185452.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.2 MiB     -5.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     79.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     79.2 MiB      0.0 MiB           1       came_from = {}
    18     83.1 MiB -30234.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     81.5 MiB     -1.5 MiB           1       g_score[start] = 0
    20                                         
    21     81.6 MiB -1937330.7 MiB       36985       while not open_set.empty():
    22     81.6 MiB -1937332.0 MiB       36985           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.6 MiB -1937341.8 MiB       36985           current = open_set.get()[1]
    28                                         
    29     81.6 MiB -1937345.2 MiB       36985           if current in remaining_goals:
    30     28.4 MiB   -112.6 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     28.4 MiB      0.0 MiB           2               if not remaining_goals:
    32     28.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.6 MiB -17368815.1 MiB      331621           for neighbor in current.neighbors:
    35     81.6 MiB -15431562.2 MiB      294637               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.6 MiB -15431564.9 MiB      294637               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.6 MiB -7704725.1 MiB      147113                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.6 MiB -15431585.0 MiB      294637               if temp_g_score < g_score[neighbor]:
    41     81.6 MiB -1958406.3 MiB       37436                   came_from[neighbor] = current
    42     81.6 MiB -1958407.8 MiB       37436                   g_score[neighbor] = temp_g_score
    43     81.6 MiB -1958411.4 MiB       37436                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.6 MiB -1937327.5 MiB       36984           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.6 MiB -1937329.1 MiB       36984           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     28.4 MiB      0.0 MiB           1       paths = {}
    53     28.7 MiB      0.0 MiB           3       for goal in goals:
    54     28.7 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     28.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.0 MiB     85.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.0 MiB  -7663.4 MiB         257       for row in grid:
     8     85.0 MiB -1958722.3 MiB       65792           for spot in row:
     9     85.0 MiB -1951101.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     23.7 MiB    -61.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     24.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     24.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     24.3 MiB      0.0 MiB           1       came_from = {}
    18     35.8 MiB    -33.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     35.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     38.6 MiB -225172.1 MiB       39758       while not open_set.empty():
    22     38.6 MiB -225181.0 MiB       39758           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     38.6 MiB -225181.3 MiB       39758           current = open_set.get()[1]
    28                                         
    29     38.6 MiB -225181.4 MiB       39758           if current in remaining_goals:
    30     37.6 MiB     -2.6 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.6 MiB      0.0 MiB           2               if not remaining_goals:
    32     37.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     38.6 MiB -2020671.9 MiB      356501           for neighbor in current.neighbors:
    35     38.6 MiB -1795508.2 MiB      316744               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     38.6 MiB -1795492.2 MiB      316744               if current.row != neighbor.row and current.col != neighbor.col:
    38     38.6 MiB -896770.8 MiB      158154                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     38.6 MiB -1795499.0 MiB      316744               if temp_g_score < g_score[neighbor]:
    41     38.6 MiB -228088.6 MiB       40200                   came_from[neighbor] = current
    42     38.6 MiB -228089.1 MiB       40200                   g_score[neighbor] = temp_g_score
    43     38.6 MiB -228089.1 MiB       40200                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     38.6 MiB -225170.0 MiB       39757           if draw is not None:
    46                                                     draw()
    47                                                     
    48     38.6 MiB -225171.1 MiB       39757           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.6 MiB      0.0 MiB           1       paths = {}
    53     37.9 MiB      0.0 MiB           3       for goal in goals:
    54     37.9 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.2 MiB     92.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.2 MiB      0.0 MiB         257       for row in grid:
     8     92.2 MiB      0.0 MiB       65792           for spot in row:
     9     92.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.2 MiB      0.0 MiB           1       came_from = {}
    18     94.8 MiB -187301.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.9 MiB     -6.8 MiB           1       g_score[start] = 0
    20                                         
    21     88.6 MiB -2325417.8 MiB       44224       while not open_set.empty():
    22     88.6 MiB -2325419.2 MiB       44224           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.6 MiB -2325420.3 MiB       44224           current = open_set.get()[1]
    28                                         
    29     88.6 MiB -2325421.0 MiB       44224           if current in remaining_goals:
    30     36.1 MiB   -114.7 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.1 MiB      0.0 MiB           2               if not remaining_goals:
    32     36.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.6 MiB -20893721.2 MiB      397383           for neighbor in current.neighbors:
    35     88.6 MiB -18568375.2 MiB      353160               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.6 MiB -18568400.2 MiB      353160               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.6 MiB -9278486.6 MiB      176476                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.6 MiB -18568431.7 MiB      353160               if temp_g_score < g_score[neighbor]:
    41     88.6 MiB -2353594.5 MiB       44954                   came_from[neighbor] = current
    42     88.6 MiB -2353597.5 MiB       44954                   g_score[neighbor] = temp_g_score
    43     88.6 MiB -2353599.5 MiB       44954                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.6 MiB -2325415.5 MiB       44223           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.6 MiB -2325416.5 MiB       44223           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.1 MiB      0.0 MiB           1       paths = {}
    53     36.2 MiB      0.0 MiB           3       for goal in goals:
    54     36.2 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.6 MiB     93.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.6 MiB   -889.6 MiB         257       for row in grid:
     8     93.6 MiB -227929.2 MiB       65792           for spot in row:
     9     93.6 MiB -227044.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.8 MiB     -5.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.8 MiB      0.0 MiB           1       came_from = {}
    18     92.4 MiB  -1731.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.5 MiB -3050770.0 MiB       55943       while not open_set.empty():
    22     92.5 MiB -3050771.1 MiB       55943           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.5 MiB -3050772.6 MiB       55943           current = open_set.get()[1]
    28                                         
    29     92.5 MiB -3050773.2 MiB       55943           if current in remaining_goals:
    30     35.1 MiB   -120.6 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.1 MiB     -6.0 MiB           2               if not remaining_goals:
    32     29.2 MiB     -6.0 MiB           1                   break  # All goals found
    33                                         
    34     92.5 MiB -27349657.5 MiB      501683           for neighbor in current.neighbors:
    35     92.5 MiB -24298969.7 MiB      445741               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.5 MiB -24298969.6 MiB      445741               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.5 MiB -12131789.4 MiB      222572                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.5 MiB -24298992.5 MiB      445741               if temp_g_score < g_score[neighbor]:
    41     92.5 MiB -3055904.0 MiB       56350                   came_from[neighbor] = current
    42     92.5 MiB -3055906.2 MiB       56350                   g_score[neighbor] = temp_g_score
    43     92.5 MiB -3055914.6 MiB       56350                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.5 MiB -3050763.7 MiB       55942           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.5 MiB -3050764.4 MiB       55942           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.2 MiB      0.0 MiB           1       paths = {}
    53     30.2 MiB      0.0 MiB           3       for goal in goals:
    54     30.2 MiB      1.0 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.8 MiB     90.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.8 MiB   -413.0 MiB         257       for row in grid:
     8     90.8 MiB -105753.6 MiB       65792           for spot in row:
     9     90.8 MiB -105342.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.0 MiB     -2.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.0 MiB      0.0 MiB           1       came_from = {}
    18     89.3 MiB -281026.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     39.2 MiB    -50.1 MiB           1       g_score[start] = 0
    20                                         
    21     41.7 MiB -63624.4 MiB       13301       while not open_set.empty():
    22     41.7 MiB -63624.6 MiB       13301           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     41.7 MiB -63624.5 MiB       13301           current = open_set.get()[1]
    28                                         
    29     41.7 MiB -63625.1 MiB       13301           if current in remaining_goals:
    30     41.1 MiB     -1.2 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.1 MiB     -0.6 MiB           2               if not remaining_goals:
    32     40.5 MiB     -0.6 MiB           1                   break  # All goals found
    33                                         
    34     41.7 MiB -572612.7 MiB      119700           for neighbor in current.neighbors:
    35     41.7 MiB -508993.5 MiB      106400               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     41.7 MiB -508992.4 MiB      106400               if current.row != neighbor.row and current.col != neighbor.col:
    38     41.7 MiB -254496.6 MiB       53200                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     41.7 MiB -509003.8 MiB      106400               if temp_g_score < g_score[neighbor]:
    41     41.7 MiB -66076.3 MiB       13851                   came_from[neighbor] = current
    42     41.7 MiB -66076.6 MiB       13851                   g_score[neighbor] = temp_g_score
    43     41.7 MiB -66079.0 MiB       13851                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     41.7 MiB -63624.0 MiB       13300           if draw is not None:
    46                                                     draw()
    47                                                     
    48     41.7 MiB -63624.3 MiB       13300           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.5 MiB      0.0 MiB           1       paths = {}
    53     40.6 MiB      0.0 MiB           3       for goal in goals:
    54     40.6 MiB      0.0 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.6 MiB     88.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.6 MiB   -447.5 MiB         257       for row in grid:
     8     88.6 MiB -114105.2 MiB       65792           for spot in row:
     9     88.6 MiB -113666.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     73.4 MiB    -15.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     73.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     73.4 MiB      0.0 MiB           1       came_from = {}
    18     80.1 MiB  -3331.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     80.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     81.0 MiB -423822.0 MiB       10619       while not open_set.empty():
    22     81.0 MiB -423822.8 MiB       10619           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.0 MiB -423825.2 MiB       10619           current = open_set.get()[1]
    28                                         
    29     81.0 MiB -423826.2 MiB       10619           if current in remaining_goals:
    30     29.8 MiB   -104.0 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.8 MiB      0.0 MiB           2               if not remaining_goals:
    32     29.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.0 MiB -3790998.8 MiB       94939           for neighbor in current.neighbors:
    35     81.0 MiB -3367243.2 MiB       84321               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.0 MiB -3367249.7 MiB       84321               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.0 MiB -1679835.4 MiB       42057                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.0 MiB -3367263.9 MiB       84321               if temp_g_score < g_score[neighbor]:
    41     81.0 MiB -428271.6 MiB       10880                   came_from[neighbor] = current
    42     81.0 MiB -428272.8 MiB       10880                   g_score[neighbor] = temp_g_score
    43     81.0 MiB -428274.3 MiB       10880                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.0 MiB -423819.8 MiB       10618           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.0 MiB -423820.8 MiB       10618           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.8 MiB      0.0 MiB           1       paths = {}
    53     29.9 MiB      0.0 MiB           3       for goal in goals:
    54     29.9 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.7 MiB     88.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.7 MiB   -144.6 MiB         257       for row in grid:
     8     88.7 MiB -36899.2 MiB       65792           for spot in row:
     9     88.7 MiB -36756.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.1 MiB     -2.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.1 MiB      0.0 MiB           1       came_from = {}
    18     89.1 MiB -34774.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.1 MiB -2830035.8 MiB       59136       while not open_set.empty():
    22     89.1 MiB -2830036.3 MiB       59136           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.1 MiB -2830036.8 MiB       59136           current = open_set.get()[1]
    28                                         
    29     89.1 MiB -2830037.4 MiB       59136           if current in remaining_goals:
    30     36.3 MiB   -111.6 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.3 MiB      0.0 MiB           2               if not remaining_goals:
    32     36.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.1 MiB -25379561.3 MiB      530105           for neighbor in current.neighbors:
    35     89.1 MiB -22549592.4 MiB      470970               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.1 MiB -22549586.7 MiB      470970               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.1 MiB -11259838.3 MiB      235134                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.1 MiB -22549647.1 MiB      470970               if temp_g_score < g_score[neighbor]:
    41     89.1 MiB -2833467.1 MiB       59452                   came_from[neighbor] = current
    42     89.1 MiB -2833468.3 MiB       59452                   g_score[neighbor] = temp_g_score
    43     89.1 MiB -2833469.3 MiB       59452                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.1 MiB -2830033.8 MiB       59135           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.1 MiB -2830035.0 MiB       59135           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.3 MiB      0.0 MiB           1       paths = {}
    53     36.5 MiB      0.0 MiB           3       for goal in goals:
    54     36.5 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.4 MiB     87.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.4 MiB      0.0 MiB         257       for row in grid:
     8     87.4 MiB      0.0 MiB       65792           for spot in row:
     9     87.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.4 MiB      0.0 MiB           1       came_from = {}
    18     90.5 MiB  -2817.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.7 MiB     -0.8 MiB           1       g_score[start] = 0
    20                                         
    21     89.7 MiB -526545.1 MiB       21130       while not open_set.empty():
    22     89.7 MiB -526545.6 MiB       21130           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.7 MiB -526550.5 MiB       21130           current = open_set.get()[1]
    28                                         
    29     89.7 MiB -526551.0 MiB       21130           if current in remaining_goals:
    30     78.8 MiB    -57.6 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     78.8 MiB    -35.9 MiB           2               if not remaining_goals:
    32     43.0 MiB    -35.9 MiB           1                   break  # All goals found
    33                                         
    34     89.7 MiB -4725047.0 MiB      189864           for neighbor in current.neighbors:
    35     89.7 MiB -4198523.4 MiB      168735               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.7 MiB -4198527.3 MiB      168735               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.7 MiB -2097031.3 MiB       84318                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.7 MiB -4198538.6 MiB      168735               if temp_g_score < g_score[neighbor]:
    41     89.7 MiB -531530.8 MiB       21693                   came_from[neighbor] = current
    42     89.7 MiB -531531.9 MiB       21693                   g_score[neighbor] = temp_g_score
    43     89.7 MiB -531547.2 MiB       21693                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.7 MiB -526544.0 MiB       21129           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.7 MiB -526544.6 MiB       21129           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.0 MiB      0.0 MiB           1       paths = {}
    53     43.0 MiB      0.0 MiB           3       for goal in goals:
    54     43.0 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.6 MiB     85.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.6 MiB   -221.0 MiB         257       for row in grid:
     8     85.6 MiB -56524.2 MiB       65792           for spot in row:
     9     85.6 MiB -56304.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.7 MiB     -1.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.7 MiB      0.0 MiB           1       came_from = {}
    18     88.7 MiB   -624.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.9 MiB -2409851.3 MiB       59471       while not open_set.empty():
    22     88.9 MiB -2409852.3 MiB       59471           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.9 MiB -2409879.9 MiB       59471           current = open_set.get()[1]
    28                                         
    29     88.9 MiB -2409880.5 MiB       59471           if current in remaining_goals:
    30     41.6 MiB    -98.8 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.6 MiB     -4.2 MiB           2               if not remaining_goals:
    32     37.4 MiB     -4.2 MiB           1                   break  # All goals found
    33                                         
    34     88.9 MiB -21606533.4 MiB      533625           for neighbor in current.neighbors:
    35     88.9 MiB -19196749.3 MiB      474155               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.9 MiB -19196745.8 MiB      474155               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.9 MiB -9584750.3 MiB      236810                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.9 MiB -19196761.9 MiB      474155               if temp_g_score < g_score[neighbor]:
    41     88.9 MiB -2408472.9 MiB       59954                   came_from[neighbor] = current
    42     88.9 MiB -2408473.4 MiB       59954                   g_score[neighbor] = temp_g_score
    43     88.9 MiB -2408480.3 MiB       59954                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.9 MiB -2409846.3 MiB       59470           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.9 MiB -2409846.6 MiB       59470           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.4 MiB      0.0 MiB           1       paths = {}
    53     37.5 MiB      0.0 MiB           3       for goal in goals:
    54     37.5 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.7 MiB     85.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.7 MiB    -99.4 MiB         257       for row in grid:
     8     85.7 MiB -25465.4 MiB       65792           for spot in row:
     9     85.7 MiB -25367.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.1 MiB     -1.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.1 MiB      0.0 MiB           1       came_from = {}
    18     89.7 MiB    -85.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.7 MiB -3244740.3 MiB       65066       while not open_set.empty():
    22     89.7 MiB -3244741.5 MiB       65066           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.7 MiB -3244742.4 MiB       65066           current = open_set.get()[1]
    28                                         
    29     89.7 MiB -3244743.3 MiB       65066           if current in remaining_goals:
    30     35.8 MiB   -112.4 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.8 MiB     -4.7 MiB           2               if not remaining_goals:
    32     31.1 MiB     -4.7 MiB           1                   break  # All goals found
    33                                         
    34     89.7 MiB -29061682.6 MiB      582714           for neighbor in current.neighbors:
    35     89.7 MiB -25817014.1 MiB      517649               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.7 MiB -25817004.4 MiB      517649               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.7 MiB -12885239.0 MiB      258347                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.7 MiB -25817012.5 MiB      517649               if temp_g_score < g_score[neighbor]:
    41     89.7 MiB -3231747.5 MiB       65129                   came_from[neighbor] = current
    42     89.7 MiB -3231748.9 MiB       65129                   g_score[neighbor] = temp_g_score
    43     89.7 MiB -3231750.7 MiB       65129                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.7 MiB -3244732.9 MiB       65065           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.7 MiB -3244738.2 MiB       65065           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.1 MiB      0.0 MiB           1       paths = {}
    53     32.2 MiB      0.0 MiB           3       for goal in goals:
    54     32.2 MiB      1.0 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.5 MiB     85.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.5 MiB   -620.8 MiB         257       for row in grid:
     8     85.5 MiB -158746.9 MiB       65792           for spot in row:
     9     85.5 MiB -158127.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.4 MiB     -4.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.6 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     81.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     81.8 MiB      0.0 MiB           1       came_from = {}
    18     86.8 MiB  -6299.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.1 MiB -2315570.2 MiB       56847       while not open_set.empty():
    22     87.1 MiB -2315572.0 MiB       56847           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.1 MiB -2315573.6 MiB       56847           current = open_set.get()[1]
    28                                         
    29     87.1 MiB -2315574.5 MiB       56847           if current in remaining_goals:
    30     38.6 MiB    -97.3 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.6 MiB     -0.3 MiB           2               if not remaining_goals:
    32     38.2 MiB     -0.3 MiB           1                   break  # All goals found
    33                                         
    34     87.1 MiB -20770790.5 MiB      509577           for neighbor in current.neighbors:
    35     87.1 MiB -18455287.6 MiB      452731               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.1 MiB -18455284.2 MiB      452731               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.1 MiB -9216226.5 MiB      226027                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.1 MiB -18455318.8 MiB      452731               if temp_g_score < g_score[neighbor]:
    41     87.1 MiB -2320895.1 MiB       57188                   came_from[neighbor] = current
    42     87.1 MiB -2320896.1 MiB       57188                   g_score[neighbor] = temp_g_score
    43     87.1 MiB -2320896.9 MiB       57188                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.1 MiB -2315564.9 MiB       56846           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.1 MiB -2315568.0 MiB       56846           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.2 MiB      0.0 MiB           1       paths = {}
    53     38.4 MiB      0.0 MiB           3       for goal in goals:
    54     38.4 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.3 MiB     93.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.3 MiB    -89.0 MiB         257       for row in grid:
     8     93.3 MiB -22699.6 MiB       65792           for spot in row:
     9     93.3 MiB -22611.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.0 MiB     -1.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.1 MiB      0.1 MiB           1       open_set = PriorityQueue()
    16     92.2 MiB      0.1 MiB           1       open_set.put((0, start))
    17     92.2 MiB      0.0 MiB           1       came_from = {}
    18     93.0 MiB -78681.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.1 MiB -1625117.0 MiB       35297       while not open_set.empty():
    22     93.1 MiB -1625118.4 MiB       35297           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.1 MiB -1625121.9 MiB       35297           current = open_set.get()[1]
    28                                         
    29     93.1 MiB -1625123.5 MiB       35297           if current in remaining_goals:
    30     39.7 MiB   -110.1 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     39.7 MiB      0.0 MiB           2               if not remaining_goals:
    32     39.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.1 MiB -14567431.1 MiB      316555           for neighbor in current.neighbors:
    35     93.1 MiB -12942387.2 MiB      281259               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.1 MiB -12942391.4 MiB      281259               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.1 MiB -6461551.5 MiB      140445                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.1 MiB -12942408.3 MiB      281259               if temp_g_score < g_score[neighbor]:
    41     93.1 MiB -1632662.3 MiB       35760                   came_from[neighbor] = current
    42     93.1 MiB -1632664.5 MiB       35760                   g_score[neighbor] = temp_g_score
    43     93.1 MiB -1632667.1 MiB       35760                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.1 MiB -1625113.2 MiB       35296           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.1 MiB -1625115.3 MiB       35296           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.7 MiB      0.0 MiB           1       paths = {}
    53     40.0 MiB      0.0 MiB           3       for goal in goals:
    54     40.0 MiB      0.3 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.0 MiB     91.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.0 MiB   -309.1 MiB         257       for row in grid:
     8     91.0 MiB -77976.4 MiB       65792           for spot in row:
     9     91.0 MiB -77675.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.1 MiB    -10.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     80.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     80.5 MiB      0.0 MiB           1       came_from = {}
    18     81.5 MiB -2041332.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     25.4 MiB    -56.1 MiB           1       g_score[start] = 0
    20                                         
    21     42.0 MiB -66640.1 MiB       42833       while not open_set.empty():
    22     42.0 MiB -66640.4 MiB       42833           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     42.0 MiB -66641.2 MiB       42833           current = open_set.get()[1]
    28                                         
    29     42.0 MiB -66642.1 MiB       42833           if current in remaining_goals:
    30     34.2 MiB     -7.8 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.2 MiB      0.0 MiB           2               if not remaining_goals:
    32     34.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     42.0 MiB -596671.5 MiB      383945           for neighbor in current.neighbors:
    35     42.0 MiB -530045.5 MiB      341113               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     42.0 MiB -530041.5 MiB      341113               if current.row != neighbor.row and current.col != neighbor.col:
    38     42.0 MiB -264531.7 MiB      170300                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     42.0 MiB -530047.8 MiB      341113               if temp_g_score < g_score[neighbor]:
    41     42.0 MiB -66297.1 MiB       43214                   came_from[neighbor] = current
    42     42.0 MiB -66300.4 MiB       43214                   g_score[neighbor] = temp_g_score
    43     42.0 MiB -66301.4 MiB       43214                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     42.0 MiB -66639.7 MiB       42832           if draw is not None:
    46                                                     draw()
    47                                                     
    48     42.0 MiB -66639.9 MiB       42832           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.2 MiB      0.0 MiB           1       paths = {}
    53     34.7 MiB      0.0 MiB           3       for goal in goals:
    54     34.7 MiB      0.5 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.3 MiB     89.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.3 MiB   -172.0 MiB         257       for row in grid:
     8     89.3 MiB -43986.5 MiB       65792           for spot in row:
     9     89.3 MiB -43816.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.9 MiB     -1.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.9 MiB      0.0 MiB           1       came_from = {}
    18     93.4 MiB      5.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.4 MiB -2576125.6 MiB       58053       while not open_set.empty():
    22     93.4 MiB -2576126.3 MiB       58053           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.4 MiB -2576127.6 MiB       58053           current = open_set.get()[1]
    28                                         
    29     93.4 MiB -2576128.5 MiB       58053           if current in remaining_goals:
    30     38.2 MiB   -117.0 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.2 MiB      0.0 MiB           2               if not remaining_goals:
    32     38.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.4 MiB -23090166.4 MiB      520562           for neighbor in current.neighbors:
    35     93.4 MiB -20514117.2 MiB      462510               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.4 MiB -20514131.5 MiB      462510               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.4 MiB -10241373.8 MiB      230938                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.4 MiB -20514149.7 MiB      462510               if temp_g_score < g_score[neighbor]:
    41     93.4 MiB -2572934.7 MiB       58435                   came_from[neighbor] = current
    42     93.4 MiB -2572935.7 MiB       58435                   g_score[neighbor] = temp_g_score
    43     93.4 MiB -2572938.8 MiB       58435                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.4 MiB -2576122.2 MiB       58052           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.4 MiB -2576123.6 MiB       58052           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.2 MiB      0.0 MiB           1       paths = {}
    53     38.4 MiB      0.0 MiB           3       for goal in goals:
    54     38.4 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.2 MiB     88.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.2 MiB   -898.4 MiB         257       for row in grid:
     8     88.2 MiB -229253.1 MiB       65792           for spot in row:
     9     88.2 MiB -228364.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     75.5 MiB    -12.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     75.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     75.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     75.9 MiB      0.0 MiB           1       came_from = {}
    18     77.0 MiB -1843793.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     41.4 MiB    -35.5 MiB           1       g_score[start] = 0
    20                                         
    21     47.2 MiB -138701.5 MiB       30565       while not open_set.empty():
    22     47.2 MiB -138701.9 MiB       30565           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     47.2 MiB -138702.5 MiB       30565           current = open_set.get()[1]
    28                                         
    29     47.2 MiB -138702.7 MiB       30565           if current in remaining_goals:
    30     42.6 MiB    -18.8 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.6 MiB     -9.7 MiB           2               if not remaining_goals:
    32     32.9 MiB     -9.7 MiB           1                   break  # All goals found
    33                                         
    34     47.2 MiB -1243833.7 MiB      273991           for neighbor in current.neighbors:
    35     47.2 MiB -1105148.7 MiB      243427               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     47.2 MiB -1105145.5 MiB      243427               if current.row != neighbor.row and current.col != neighbor.col:
    38     47.2 MiB -551863.5 MiB      121533                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     47.2 MiB -1105154.0 MiB      243427               if temp_g_score < g_score[neighbor]:
    41     47.2 MiB -139591.7 MiB       31016                   came_from[neighbor] = current
    42     47.2 MiB -139592.7 MiB       31016                   g_score[neighbor] = temp_g_score
    43     47.2 MiB -139593.6 MiB       31016                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     47.2 MiB -138700.7 MiB       30564           if draw is not None:
    46                                                     draw()
    47                                                     
    48     47.2 MiB -138701.0 MiB       30564           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.9 MiB      0.0 MiB           1       paths = {}
    53     33.1 MiB      0.0 MiB           3       for goal in goals:
    54     33.1 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.9 MiB     86.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.9 MiB  -5888.9 MiB         257       for row in grid:
     8     86.9 MiB -1499637.6 MiB       65792           for spot in row:
     9     86.9 MiB -1493783.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     25.2 MiB    -61.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     25.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     25.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     25.7 MiB      0.0 MiB           1       came_from = {}
    18     35.5 MiB  -7302.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     35.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     42.7 MiB -207507.4 MiB       60421       while not open_set.empty():
    22     42.7 MiB -207507.9 MiB       60421           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     42.7 MiB -207508.4 MiB       60421           current = open_set.get()[1]
    28                                         
    29     42.7 MiB -207508.6 MiB       60421           if current in remaining_goals:
    30     42.6 MiB     -6.5 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.6 MiB      0.0 MiB           2               if not remaining_goals:
    32     42.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     42.7 MiB -1859079.5 MiB      541595           for neighbor in current.neighbors:
    35     42.7 MiB -1651587.5 MiB      481175               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     42.7 MiB -1651572.5 MiB      481175               if current.row != neighbor.row and current.col != neighbor.col:
    38     42.7 MiB -824385.0 MiB      240224                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     42.7 MiB -1651582.7 MiB      481175               if temp_g_score < g_score[neighbor]:
    41     42.7 MiB -208461.4 MiB       60712                   came_from[neighbor] = current
    42     42.7 MiB -208462.9 MiB       60712                   g_score[neighbor] = temp_g_score
    43     42.7 MiB -208464.2 MiB       60712                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     42.7 MiB -207506.1 MiB       60420           if draw is not None:
    46                                                     draw()
    47                                                     
    48     42.7 MiB -207506.2 MiB       60420           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.6 MiB      0.0 MiB           1       paths = {}
    53     42.8 MiB      0.0 MiB           3       for goal in goals:
    54     42.8 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.9 MiB     87.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.9 MiB     -0.2 MiB         257       for row in grid:
     8     87.9 MiB    -56.4 MiB       65792           for spot in row:
     9     87.9 MiB    -56.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.9 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.9 MiB      0.0 MiB           1       came_from = {}
    18     92.8 MiB -23980.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.1 MiB     -1.7 MiB           1       g_score[start] = 0
    20                                         
    21     91.1 MiB -766130.4 MiB       39840       while not open_set.empty():
    22     91.1 MiB -766131.2 MiB       39840           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.1 MiB -766133.4 MiB       39840           current = open_set.get()[1]
    28                                         
    29     91.1 MiB -766134.3 MiB       39840           if current in remaining_goals:
    30     89.3 MiB    -49.8 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     89.3 MiB    -46.1 MiB           2               if not remaining_goals:
    32     43.1 MiB    -46.1 MiB           1                   break  # All goals found
    33                                         
    34     91.1 MiB -6861768.8 MiB      357436           for neighbor in current.neighbors:
    35     91.1 MiB -6095653.0 MiB      317597               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.1 MiB -6095662.0 MiB      317597               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.1 MiB -3042371.0 MiB      158613                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.1 MiB -6095675.6 MiB      317597               if temp_g_score < g_score[neighbor]:
    41     91.1 MiB -764154.4 MiB       40345                   came_from[neighbor] = current
    42     91.1 MiB -764156.8 MiB       40345                   g_score[neighbor] = temp_g_score
    43     91.1 MiB -764158.8 MiB       40345                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.1 MiB -766127.3 MiB       39839           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.1 MiB -766129.6 MiB       39839           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.1 MiB      0.0 MiB           1       paths = {}
    53     43.3 MiB      0.0 MiB           3       for goal in goals:
    54     43.3 MiB      0.1 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.0 MiB     86.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.0 MiB      0.0 MiB         257       for row in grid:
     8     86.0 MiB      0.0 MiB       65792           for spot in row:
     9     86.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.0 MiB      0.0 MiB           1       came_from = {}
    18     90.4 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.7 MiB -60143.8 MiB       14382       while not open_set.empty():
    22     90.7 MiB -60143.8 MiB       14382           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.7 MiB -60143.9 MiB       14382           current = open_set.get()[1]
    28                                         
    29     90.7 MiB -60143.9 MiB       14382           if current in remaining_goals:
    30     87.2 MiB    -10.2 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     87.2 MiB     -3.2 MiB           2               if not remaining_goals:
    32     84.0 MiB     -3.2 MiB           1                   break  # All goals found
    33                                         
    34     90.7 MiB -539449.0 MiB      129042           for neighbor in current.neighbors:
    35     90.7 MiB -479311.3 MiB      114661               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.7 MiB -479313.1 MiB      114661               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.7 MiB -239360.3 MiB       57266                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.7 MiB -479315.5 MiB      114661               if temp_g_score < g_score[neighbor]:
    41     90.7 MiB -61025.4 MiB       14805                   came_from[neighbor] = current
    42     90.7 MiB -61025.7 MiB       14805                   g_score[neighbor] = temp_g_score
    43     90.7 MiB -61025.8 MiB       14805                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.7 MiB -60143.4 MiB       14381           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.7 MiB -60143.5 MiB       14381           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     84.0 MiB      0.0 MiB           1       paths = {}
    53     84.0 MiB      0.0 MiB           3       for goal in goals:
    54     84.0 MiB      0.0 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     84.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.4 MiB     -0.5 MiB         257       for row in grid:
     8     86.4 MiB   -129.6 MiB       65792           for spot in row:
     9     86.4 MiB   -129.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.4 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.4 MiB      0.0 MiB           1       came_from = {}
    18     89.5 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.5 MiB -2170120.7 MiB       53640       while not open_set.empty():
    22     90.5 MiB -2170122.7 MiB       53640           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.5 MiB -2170124.8 MiB       53640           current = open_set.get()[1]
    28                                         
    29     90.5 MiB -2170127.2 MiB       53640           if current in remaining_goals:
    30     30.3 MiB   -121.1 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.3 MiB     -0.6 MiB           2               if not remaining_goals:
    32     29.7 MiB     -0.6 MiB           1                   break  # All goals found
    33                                         
    34     90.5 MiB -19469778.5 MiB      480950           for neighbor in current.neighbors:
    35     90.5 MiB -17299730.7 MiB      427311               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.5 MiB -17299748.2 MiB      427311               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.5 MiB -8639812.0 MiB      213356                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.5 MiB -17299763.0 MiB      427311               if temp_g_score < g_score[neighbor]:
    41     90.5 MiB -2172792.6 MiB       54029                   came_from[neighbor] = current
    42     90.5 MiB -2172795.7 MiB       54029                   g_score[neighbor] = temp_g_score
    43     90.5 MiB -2172797.7 MiB       54029                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.5 MiB -2170117.8 MiB       53639           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.5 MiB -2170119.3 MiB       53639           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.7 MiB      0.0 MiB           1       paths = {}
    53     30.4 MiB      0.0 MiB           3       for goal in goals:
    54     30.4 MiB      0.7 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.2 MiB     84.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.2 MiB   -158.3 MiB         257       for row in grid:
     8     84.2 MiB -40565.0 MiB       65792           for spot in row:
     9     84.2 MiB -40407.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.1 MiB     -1.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.1 MiB      0.0 MiB           1       came_from = {}
    18     88.4 MiB      5.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.4 MiB -1667328.0 MiB       43141       while not open_set.empty():
    22     88.4 MiB -1667329.0 MiB       43141           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.4 MiB -1667332.0 MiB       43141           current = open_set.get()[1]
    28                                         
    29     88.4 MiB -1667334.2 MiB       43141           if current in remaining_goals:
    30     83.2 MiB    -52.8 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     83.2 MiB    -42.5 MiB           2               if not remaining_goals:
    32     40.7 MiB    -42.5 MiB           1                   break  # All goals found
    33                                         
    34     88.4 MiB -14947011.6 MiB      386812           for neighbor in current.neighbors:
    35     88.4 MiB -13279705.1 MiB      343672               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.4 MiB -13279705.4 MiB      343672               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.4 MiB -6630135.8 MiB      171595                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.4 MiB -13279719.6 MiB      343672               if temp_g_score < g_score[neighbor]:
    41     88.4 MiB -1670458.5 MiB       43565                   came_from[neighbor] = current
    42     88.4 MiB -1670460.2 MiB       43565                   g_score[neighbor] = temp_g_score
    43     88.4 MiB -1670463.1 MiB       43565                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.4 MiB -1667325.6 MiB       43140           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.4 MiB -1667326.9 MiB       43140           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.7 MiB      0.0 MiB           1       paths = {}
    53     41.0 MiB      0.0 MiB           3       for goal in goals:
    54     41.0 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.9 MiB     91.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.9 MiB      0.0 MiB         257       for row in grid:
     8     91.9 MiB      0.0 MiB       65792           for spot in row:
     9     91.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.9 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.9 MiB      0.0 MiB           1       came_from = {}
    18     96.9 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.0 MiB -149072.5 MiB       26056       while not open_set.empty():
    22     97.0 MiB -149072.5 MiB       26056           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.0 MiB -149074.5 MiB       26056           current = open_set.get()[1]
    28                                         
    29     97.0 MiB -149074.7 MiB       26056           if current in remaining_goals:
    30     92.8 MiB    -13.5 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     92.8 MiB     -5.0 MiB           2               if not remaining_goals:
    32     87.7 MiB     -5.0 MiB           1                   break  # All goals found
    33                                         
    34     97.0 MiB -1341603.4 MiB      234495           for neighbor in current.neighbors:
    35     97.0 MiB -1192538.3 MiB      208440               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.0 MiB -1192539.9 MiB      208440               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.0 MiB -596280.7 MiB      104220                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.0 MiB -1192543.9 MiB      208440               if temp_g_score < g_score[neighbor]:
    41     97.0 MiB -151922.1 MiB       26822                   came_from[neighbor] = current
    42     97.0 MiB -151922.5 MiB       26822                   g_score[neighbor] = temp_g_score
    43     97.0 MiB -151922.7 MiB       26822                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.0 MiB -149072.2 MiB       26055           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.0 MiB -149072.3 MiB       26055           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     87.7 MiB      0.0 MiB           1       paths = {}
    53     87.8 MiB      0.0 MiB           3       for goal in goals:
    54     87.8 MiB      0.0 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     87.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.6 MiB     94.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.6 MiB      0.0 MiB         257       for row in grid:
     8     94.6 MiB      0.0 MiB       65792           for spot in row:
     9     94.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.6 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     94.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     94.6 MiB      0.0 MiB           1       came_from = {}
    18     97.0 MiB   -517.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.9 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.9 MiB -1358223.0 MiB       50614       while not open_set.empty():
    22     96.9 MiB -1358224.1 MiB       50614           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.9 MiB -1358227.2 MiB       50614           current = open_set.get()[1]
    28                                         
    29     96.9 MiB -1358228.7 MiB       50614           if current in remaining_goals:
    30     88.4 MiB    -58.1 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     88.4 MiB    -41.0 MiB           2               if not remaining_goals:
    32     47.4 MiB    -41.0 MiB           1                   break  # All goals found
    33                                         
    34     96.9 MiB -12162690.0 MiB      453984           for neighbor in current.neighbors:
    35     96.9 MiB -10804492.2 MiB      403371               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.9 MiB -10804496.5 MiB      403371               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.9 MiB -5392117.4 MiB      201430                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.9 MiB -10804509.6 MiB      403371               if temp_g_score < g_score[neighbor]:
    41     96.9 MiB -1351649.0 MiB       51063                   came_from[neighbor] = current
    42     96.9 MiB -1351650.5 MiB       51063                   g_score[neighbor] = temp_g_score
    43     96.9 MiB -1351652.5 MiB       51063                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.9 MiB -1358220.4 MiB       50613           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.9 MiB -1358221.9 MiB       50613           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     47.4 MiB      0.0 MiB           1       paths = {}
    53     47.6 MiB      0.0 MiB           3       for goal in goals:
    54     47.6 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.5 MiB     92.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.5 MiB      0.0 MiB         257       for row in grid:
     8     92.5 MiB      0.0 MiB       65792           for spot in row:
     9     92.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.5 MiB      0.0 MiB           1       came_from = {}
    18     97.5 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.7 MiB -2582872.5 MiB       62301       while not open_set.empty():
    22     97.7 MiB -2582874.6 MiB       62301           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.7 MiB -2582878.3 MiB       62301           current = open_set.get()[1]
    28                                         
    29     97.7 MiB -2582881.5 MiB       62301           if current in remaining_goals:
    30     97.5 MiB    -57.7 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     97.5 MiB    -57.5 MiB           2               if not remaining_goals:
    32     40.0 MiB    -57.5 MiB           1                   break  # All goals found
    33                                         
    34     97.7 MiB -23148587.3 MiB      558261           for neighbor in current.neighbors:
    35     97.7 MiB -20565731.5 MiB      495961               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.7 MiB -20565734.6 MiB      495961               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.7 MiB -10266784.3 MiB      247575                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.7 MiB -20565751.6 MiB      495961               if temp_g_score < g_score[neighbor]:
    41     97.7 MiB -2575141.8 MiB       62508                   came_from[neighbor] = current
    42     97.7 MiB -2575145.0 MiB       62508                   g_score[neighbor] = temp_g_score
    43     97.7 MiB -2575148.0 MiB       62508                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.7 MiB -2582867.8 MiB       62300           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.7 MiB -2582869.8 MiB       62300           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.0 MiB      0.0 MiB           1       paths = {}
    53     40.3 MiB      0.0 MiB           3       for goal in goals:
    54     40.3 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.0 MiB     90.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.1 MiB      0.0 MiB         257       for row in grid:
     8     90.1 MiB      0.0 MiB       65792           for spot in row:
     9     90.1 MiB      0.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.1 MiB      0.0 MiB           1       came_from = {}
    18     93.1 MiB   -435.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.1 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.2 MiB -2254350.1 MiB       62129       while not open_set.empty():
    22     93.2 MiB -2254352.6 MiB       62129           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.2 MiB -2254356.0 MiB       62129           current = open_set.get()[1]
    28                                         
    29     93.2 MiB -2254357.8 MiB       62129           if current in remaining_goals:
    30     48.9 MiB    -99.2 MiB           2               remaining_goals.remove(current)  # Remove this goal from the list
    31     48.9 MiB    -10.7 MiB           2               if not remaining_goals:
    32     38.3 MiB    -10.7 MiB           1                   break  # All goals found
    33                                         
    34     93.2 MiB -20199901.1 MiB      556659           for neighbor in current.neighbors:
    35     93.2 MiB -17945613.5 MiB      494531               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.2 MiB -17945621.5 MiB      494531               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.2 MiB -8958071.2 MiB      246851                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.2 MiB -17945642.1 MiB      494531               if temp_g_score < g_score[neighbor]:
    41     93.2 MiB -2247041.0 MiB       62318                   came_from[neighbor] = current
    42     93.2 MiB -2247042.4 MiB       62318                   g_score[neighbor] = temp_g_score
    43     93.2 MiB -2247044.2 MiB       62318                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.2 MiB -2254345.9 MiB       62128           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.2 MiB -2254347.8 MiB       62128           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.3 MiB      0.0 MiB           1       paths = {}
    53     38.5 MiB      0.0 MiB           3       for goal in goals:
    54     38.5 MiB      0.2 MiB           2           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.5 MiB      0.0 MiB           1       return paths


