Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.4 MiB     67.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     69.5 MiB  -1412.8 MiB         257       for row in grid:
     8     69.6 MiB -361438.2 MiB       65792           for spot in row:
     9     69.6 MiB -360034.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     56.3 MiB    -13.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     56.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     56.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     56.4 MiB      0.0 MiB           1       came_from = {}
    18     63.5 MiB   -105.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     63.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     63.6 MiB  -1625.6 MiB        3697       while not open_set.empty():
    22     63.6 MiB  -1625.8 MiB        3697           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     63.6 MiB  -1625.8 MiB        3697           current = open_set.get()[1]
    28                                         
    29     63.6 MiB  -1625.8 MiB        3697           if current in remaining_goals:
    30     63.4 MiB     -0.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     63.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     63.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     63.6 MiB -10397.7 MiB       23764           for neighbor in current.neighbors:
    35     63.6 MiB  -8772.3 MiB       20068               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     63.6 MiB  -8772.4 MiB       20068               if current.row != neighbor.row and current.col != neighbor.col:
    38     63.6 MiB  -4173.4 MiB        9560                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     63.6 MiB  -8772.5 MiB       20068               if temp_g_score < g_score[neighbor]:
    41     63.6 MiB  -1695.1 MiB        3863                   came_from[neighbor] = current
    42     63.6 MiB  -1695.1 MiB        3863                   g_score[neighbor] = temp_g_score
    43     63.6 MiB  -1695.1 MiB        3863                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     63.6 MiB  -1625.6 MiB        3696           if draw is not None:
    46                                                     draw()
    47                                                     
    48     63.6 MiB  -1625.6 MiB        3696           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     63.4 MiB      0.0 MiB           1       paths = {}
    53     63.4 MiB      0.0 MiB           2       for goal in goals:
    54     63.4 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     63.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.9 MiB     90.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.9 MiB      0.0 MiB         257       for row in grid:
     8     90.9 MiB      0.0 MiB       65792           for spot in row:
     9     90.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.9 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.9 MiB      0.0 MiB           1       came_from = {}
    18     96.5 MiB      5.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.6 MiB      0.0 MiB        9331       while not open_set.empty():
    22     96.6 MiB      0.0 MiB        9331           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.6 MiB      0.0 MiB        9331           current = open_set.get()[1]
    28                                         
    29     96.6 MiB      0.0 MiB        9331           if current in remaining_goals:
    30     96.6 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     96.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.6 MiB      0.0 MiB       59826           for neighbor in current.neighbors:
    35     96.6 MiB      0.0 MiB       50496               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.6 MiB      0.0 MiB       50496               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.6 MiB      0.0 MiB       23991                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.6 MiB      0.0 MiB       50496               if temp_g_score < g_score[neighbor]:
    41     96.6 MiB      0.1 MiB        9520                   came_from[neighbor] = current
    42     96.6 MiB      0.0 MiB        9520                   g_score[neighbor] = temp_g_score
    43     96.6 MiB      0.0 MiB        9520                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.6 MiB      0.0 MiB        9330           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.6 MiB      0.0 MiB        9330           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     96.6 MiB      0.0 MiB           1       paths = {}
    53     96.6 MiB      0.0 MiB           2       for goal in goals:
    54     96.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     96.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.7 MiB     97.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.7 MiB      0.0 MiB         257       for row in grid:
     8     97.7 MiB      0.0 MiB       65792           for spot in row:
     9     97.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.7 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.7 MiB      0.0 MiB           1       came_from = {}
    18    100.5 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    100.5 MiB -18648.5 MiB       12618       while not open_set.empty():
    22    100.5 MiB -18648.6 MiB       12618           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.5 MiB -18649.0 MiB       12618           current = open_set.get()[1]
    28                                         
    29    100.5 MiB -18649.0 MiB       12618           if current in remaining_goals:
    30     96.5 MiB     -4.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     96.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.5 MiB -118537.6 MiB       80890           for neighbor in current.neighbors:
    35    100.5 MiB -99890.5 MiB       68273               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.5 MiB -99890.9 MiB       68273               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.5 MiB -47388.6 MiB       32483                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.5 MiB -99892.0 MiB       68273               if temp_g_score < g_score[neighbor]:
    41    100.5 MiB -18719.1 MiB       12793                   came_from[neighbor] = current
    42    100.5 MiB -18719.1 MiB       12793                   g_score[neighbor] = temp_g_score
    43    100.5 MiB -18719.3 MiB       12793                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.5 MiB -18647.8 MiB       12617           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.5 MiB -18648.2 MiB       12617           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     96.5 MiB      0.0 MiB           1       paths = {}
    53     96.5 MiB      0.0 MiB           2       for goal in goals:
    54     96.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     96.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.1 MiB    100.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.1 MiB      0.0 MiB         257       for row in grid:
     8    100.1 MiB      0.0 MiB       65792           for spot in row:
     9    100.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    100.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    100.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    100.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17    100.1 MiB      0.0 MiB           1       came_from = {}
    18    103.9 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    104.1 MiB -487652.8 MiB       40896       while not open_set.empty():
    22    104.1 MiB -487653.9 MiB       40896           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    104.1 MiB -487656.9 MiB       40896           current = open_set.get()[1]
    28                                         
    29    104.1 MiB -487658.2 MiB       40896           if current in remaining_goals:
    30     60.2 MiB    -43.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     60.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     60.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    104.1 MiB -3129285.9 MiB      262593           for neighbor in current.neighbors:
    35    104.1 MiB -2641643.2 MiB      221698               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    104.1 MiB -2641651.1 MiB      221698               if current.row != neighbor.row and current.col != neighbor.col:
    38    104.1 MiB -1258349.4 MiB      105594                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    104.1 MiB -2641660.1 MiB      221698               if temp_g_score < g_score[neighbor]:
    41    104.1 MiB -484686.7 MiB       41139                   came_from[neighbor] = current
    42    104.1 MiB -484688.8 MiB       41139                   g_score[neighbor] = temp_g_score
    43    104.1 MiB -484691.0 MiB       41139                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    104.1 MiB -487650.1 MiB       40895           if draw is not None:
    46                                                     draw()
    47                                                     
    48    104.1 MiB -487651.4 MiB       40895           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     60.2 MiB      0.0 MiB           1       paths = {}
    53     60.5 MiB      0.0 MiB           2       for goal in goals:
    54     60.5 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     60.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.1 MiB     94.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.1 MiB     -1.8 MiB         257       for row in grid:
     8     94.1 MiB   -457.6 MiB       65792           for spot in row:
     9     94.1 MiB   -455.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.1 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     94.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     94.1 MiB      0.0 MiB           1       came_from = {}
    18     98.8 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.0 MiB -31579.9 MiB        7349       while not open_set.empty():
    22     99.0 MiB -31580.3 MiB        7349           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.0 MiB -31581.0 MiB        7349           current = open_set.get()[1]
    28                                         
    29     99.0 MiB -31581.7 MiB        7349           if current in remaining_goals:
    30     88.0 MiB    -11.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     88.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     88.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     99.0 MiB -203650.3 MiB       47549           for neighbor in current.neighbors:
    35     99.0 MiB -172073.1 MiB       40201               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.0 MiB -172074.6 MiB       40201               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.0 MiB -82230.2 MiB       19209                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.0 MiB -172076.7 MiB       40201               if temp_g_score < g_score[neighbor]:
    41     99.0 MiB -32341.8 MiB        7621                   came_from[neighbor] = current
    42     99.0 MiB -32342.2 MiB        7621                   g_score[neighbor] = temp_g_score
    43     99.0 MiB -32342.9 MiB        7621                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.0 MiB -31579.3 MiB        7348           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.0 MiB -31579.6 MiB        7348           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     88.0 MiB      0.0 MiB           1       paths = {}
    53     88.0 MiB      0.0 MiB           2       for goal in goals:
    54     88.0 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     88.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.1 MiB     98.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.1 MiB   -170.0 MiB         257       for row in grid:
     8     98.1 MiB -42584.2 MiB       65792           for spot in row:
     9     98.1 MiB -42418.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.9 MiB     -5.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.9 MiB      0.0 MiB           1       came_from = {}
    18     97.4 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.4 MiB -13636.4 MiB       10939       while not open_set.empty():
    22     97.4 MiB -13636.4 MiB       10939           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.4 MiB -13637.2 MiB       10939           current = open_set.get()[1]
    28                                         
    29     97.4 MiB -13637.5 MiB       10939           if current in remaining_goals:
    30     96.7 MiB     -0.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     96.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     97.4 MiB -87196.7 MiB       69959           for neighbor in current.neighbors:
    35     97.4 MiB -73560.3 MiB       59021               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.4 MiB -73560.4 MiB       59021               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.4 MiB -35044.1 MiB       28115                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.4 MiB -73560.4 MiB       59021               if temp_g_score < g_score[neighbor]:
    41     97.4 MiB -13863.1 MiB       11159                   came_from[neighbor] = current
    42     97.4 MiB -13863.1 MiB       11159                   g_score[neighbor] = temp_g_score
    43     97.4 MiB -13863.1 MiB       11159                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.4 MiB -13636.4 MiB       10938           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.4 MiB -13636.4 MiB       10938           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     96.7 MiB      0.0 MiB           1       paths = {}
    53     96.7 MiB      0.0 MiB           2       for goal in goals:
    54     96.7 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     96.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.8 MiB     97.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.8 MiB   -125.0 MiB         257       for row in grid:
     8     97.8 MiB -31626.9 MiB       65792           for spot in row:
     9     97.8 MiB -31503.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     95.8 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     95.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     95.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     95.8 MiB      0.0 MiB           1       came_from = {}
    18     99.1 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     99.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.3 MiB -145220.8 MiB       41592       while not open_set.empty():
    22     99.3 MiB -145220.8 MiB       41592           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.3 MiB -145220.8 MiB       41592           current = open_set.get()[1]
    28                                         
    29     99.3 MiB -145220.8 MiB       41592           if current in remaining_goals:
    30     95.8 MiB     -3.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     95.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     95.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     99.3 MiB -931453.5 MiB      267015           for neighbor in current.neighbors:
    35     99.3 MiB -786235.1 MiB      225424               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.3 MiB -786235.9 MiB      225424               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.3 MiB -374363.4 MiB      107365                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.3 MiB -786237.0 MiB      225424               if temp_g_score < g_score[neighbor]:
    41     99.3 MiB -145489.8 MiB       41828                   came_from[neighbor] = current
    42     99.3 MiB -145489.9 MiB       41828                   g_score[neighbor] = temp_g_score
    43     99.3 MiB -145490.1 MiB       41828                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.3 MiB -145220.6 MiB       41591           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.3 MiB -145220.8 MiB       41591           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     95.8 MiB      0.0 MiB           1       paths = {}
    53     95.8 MiB      0.0 MiB           2       for goal in goals:
    54     95.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     95.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.1 MiB     97.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.1 MiB      0.0 MiB         257       for row in grid:
     8     97.1 MiB      0.0 MiB       65792           for spot in row:
     9     97.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.1 MiB      0.0 MiB           1       came_from = {}
    18    100.5 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    100.5 MiB  -7531.2 MiB        8372       while not open_set.empty():
    22    100.5 MiB  -7531.2 MiB        8372           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.5 MiB  -7531.2 MiB        8372           current = open_set.get()[1]
    28                                         
    29    100.5 MiB  -7531.3 MiB        8372           if current in remaining_goals:
    30     99.1 MiB     -1.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     99.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     99.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.5 MiB -47832.6 MiB       53759           for neighbor in current.neighbors:
    35    100.5 MiB -40302.0 MiB       45388               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.5 MiB -40302.2 MiB       45388               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.5 MiB -19122.0 MiB       21609                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.5 MiB -40302.6 MiB       45388               if temp_g_score < g_score[neighbor]:
    41    100.5 MiB  -7745.6 MiB        8722                   came_from[neighbor] = current
    42    100.5 MiB  -7745.6 MiB        8722                   g_score[neighbor] = temp_g_score
    43    100.5 MiB  -7745.7 MiB        8722                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.5 MiB  -7530.9 MiB        8371           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.5 MiB  -7531.0 MiB        8371           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     99.1 MiB      0.0 MiB           1       paths = {}
    53     99.1 MiB      0.0 MiB           2       for goal in goals:
    54     99.1 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     99.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.4 MiB     99.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.4 MiB      0.0 MiB         257       for row in grid:
     8     99.4 MiB      0.0 MiB       65792           for spot in row:
     9     99.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     99.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     99.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     99.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     99.4 MiB      0.0 MiB           1       came_from = {}
    18    100.2 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    100.2 MiB -42566.6 MiB       21506       while not open_set.empty():
    22    100.2 MiB -42566.6 MiB       21506           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.2 MiB -42566.6 MiB       21506           current = open_set.get()[1]
    28                                         
    29    100.2 MiB -42566.6 MiB       21506           if current in remaining_goals:
    30     97.3 MiB     -2.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     97.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     97.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.2 MiB -272526.6 MiB      137971           for neighbor in current.neighbors:
    35    100.2 MiB -229960.2 MiB      116466               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.2 MiB -229961.2 MiB      116466               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.2 MiB -109488.9 MiB       55517                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.2 MiB -229961.8 MiB      116466               if temp_g_score < g_score[neighbor]:
    41    100.2 MiB -42973.1 MiB       21891                   came_from[neighbor] = current
    42    100.2 MiB -42973.2 MiB       21891                   g_score[neighbor] = temp_g_score
    43    100.2 MiB -42973.3 MiB       21891                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.2 MiB -42566.6 MiB       21505           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.2 MiB -42566.6 MiB       21505           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     97.3 MiB      0.0 MiB           1       paths = {}
    53     97.3 MiB      0.0 MiB           2       for goal in goals:
    54     97.3 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     97.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.7 MiB     97.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.7 MiB      0.0 MiB         257       for row in grid:
     8     97.7 MiB      0.0 MiB       65792           for spot in row:
     9     97.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.7 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.7 MiB      0.0 MiB           1       came_from = {}
    18     99.4 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     99.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.5 MiB      0.0 MiB        9004       while not open_set.empty():
    22     99.5 MiB      0.0 MiB        9004           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.5 MiB      0.0 MiB        9004           current = open_set.get()[1]
    28                                         
    29     99.5 MiB      0.0 MiB        9004           if current in remaining_goals:
    30     99.5 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     99.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     99.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     99.5 MiB      0.0 MiB       58006           for neighbor in current.neighbors:
    35     99.5 MiB      0.0 MiB       49003               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.5 MiB      0.0 MiB       49003               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.5 MiB      0.0 MiB       23411                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.5 MiB      0.0 MiB       49003               if temp_g_score < g_score[neighbor]:
    41     99.5 MiB      0.1 MiB        9331                   came_from[neighbor] = current
    42     99.5 MiB      0.0 MiB        9331                   g_score[neighbor] = temp_g_score
    43     99.5 MiB      0.0 MiB        9331                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.5 MiB      0.0 MiB        9003           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.5 MiB      0.0 MiB        9003           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     99.5 MiB      0.0 MiB           1       paths = {}
    53     99.5 MiB      0.0 MiB           2       for goal in goals:
    54     99.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     99.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.1 MiB    100.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.1 MiB      0.0 MiB         257       for row in grid:
     8    100.1 MiB      0.0 MiB       65792           for spot in row:
     9    100.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    100.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    100.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    100.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17    100.1 MiB      0.0 MiB           1       came_from = {}
    18    103.4 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    103.5 MiB    -71.1 MiB       24851       while not open_set.empty():
    22    103.5 MiB    -71.1 MiB       24851           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.5 MiB    -71.1 MiB       24851           current = open_set.get()[1]
    28                                         
    29    103.5 MiB    -71.1 MiB       24851           if current in remaining_goals:
    30    103.5 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.5 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.5 MiB   -461.4 MiB      160834           for neighbor in current.neighbors:
    35    103.5 MiB   -390.3 MiB      135984               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.5 MiB   -390.3 MiB      135984               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.5 MiB   -186.5 MiB       64894                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.5 MiB   -390.3 MiB      135984               if temp_g_score < g_score[neighbor]:
    41    103.5 MiB    -72.2 MiB       25117                   came_from[neighbor] = current
    42    103.5 MiB    -72.2 MiB       25117                   g_score[neighbor] = temp_g_score
    43    103.5 MiB    -72.3 MiB       25117                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.5 MiB    -71.1 MiB       24850           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.5 MiB    -71.1 MiB       24850           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.5 MiB      0.0 MiB           1       paths = {}
    53    103.5 MiB      0.0 MiB           2       for goal in goals:
    54    103.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    103.6 MiB    103.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    103.6 MiB     -4.0 MiB         257       for row in grid:
     8    103.6 MiB  -1021.9 MiB       65792           for spot in row:
     9    103.6 MiB  -1018.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    103.6 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    103.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    103.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17    103.6 MiB      0.0 MiB           1       came_from = {}
    18    103.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    103.6 MiB      0.0 MiB         338       while not open_set.empty():
    22    103.6 MiB      0.0 MiB         338           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.6 MiB      0.0 MiB         338           current = open_set.get()[1]
    28                                         
    29    103.6 MiB      0.0 MiB         338           if current in remaining_goals:
    30    103.6 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.6 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.6 MiB      0.0 MiB        2174           for neighbor in current.neighbors:
    35    103.6 MiB      0.0 MiB        1837               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.6 MiB      0.0 MiB        1837               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.6 MiB      0.0 MiB         874                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.6 MiB      0.0 MiB        1837               if temp_g_score < g_score[neighbor]:
    41    103.6 MiB      0.0 MiB         399                   came_from[neighbor] = current
    42    103.6 MiB      0.0 MiB         399                   g_score[neighbor] = temp_g_score
    43    103.6 MiB      0.0 MiB         399                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.6 MiB      0.0 MiB         337           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.6 MiB      0.0 MiB         337           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.6 MiB      0.0 MiB           1       paths = {}
    53    103.6 MiB      0.0 MiB           2       for goal in goals:
    54    103.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    104.9 MiB    104.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    104.9 MiB    -99.3 MiB         257       for row in grid:
     8    104.9 MiB -25445.9 MiB       65792           for spot in row:
     9    104.9 MiB -25346.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    104.4 MiB     -0.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    104.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    104.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17    104.4 MiB      0.0 MiB           1       came_from = {}
    18    105.0 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    105.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    105.0 MiB      0.0 MiB       15145       while not open_set.empty():
    22    105.0 MiB      0.0 MiB       15145           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    105.0 MiB      0.0 MiB       15145           current = open_set.get()[1]
    28                                         
    29    105.0 MiB      0.0 MiB       15145           if current in remaining_goals:
    30    105.0 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    105.0 MiB      0.0 MiB           1               if not remaining_goals:
    32    105.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    105.0 MiB      0.0 MiB       97863           for neighbor in current.neighbors:
    35    105.0 MiB      0.0 MiB       82719               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    105.0 MiB      0.0 MiB       82719               if current.row != neighbor.row and current.col != neighbor.col:
    38    105.0 MiB      0.0 MiB       39499                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    105.0 MiB      0.0 MiB       82719               if temp_g_score < g_score[neighbor]:
    41    105.0 MiB      0.0 MiB       15349                   came_from[neighbor] = current
    42    105.0 MiB      0.0 MiB       15349                   g_score[neighbor] = temp_g_score
    43    105.0 MiB      0.0 MiB       15349                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    105.0 MiB      0.0 MiB       15144           if draw is not None:
    46                                                     draw()
    47                                                     
    48    105.0 MiB      0.0 MiB       15144           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    105.0 MiB      0.0 MiB           1       paths = {}
    53    105.0 MiB      0.0 MiB           2       for goal in goals:
    54    105.0 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    105.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    105.1 MiB    105.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    105.1 MiB     -5.6 MiB         257       for row in grid:
     8    105.1 MiB  -1430.8 MiB       65792           for spot in row:
     9    105.1 MiB  -1425.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    105.0 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    105.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    105.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17    105.0 MiB      0.0 MiB           1       came_from = {}
    18    105.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    105.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    105.4 MiB      0.0 MiB       39902       while not open_set.empty():
    22    105.4 MiB      0.0 MiB       39902           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    105.4 MiB      0.0 MiB       39902           current = open_set.get()[1]
    28                                         
    29    105.4 MiB      0.0 MiB       39902           if current in remaining_goals:
    30    105.4 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    105.4 MiB      0.0 MiB           1               if not remaining_goals:
    32    105.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    105.4 MiB      0.0 MiB      254790           for neighbor in current.neighbors:
    35    105.4 MiB      0.0 MiB      214889               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    105.4 MiB      0.0 MiB      214889               if current.row != neighbor.row and current.col != neighbor.col:
    38    105.4 MiB      0.0 MiB      102242                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    105.4 MiB      0.0 MiB      214889               if temp_g_score < g_score[neighbor]:
    41    105.4 MiB      0.4 MiB       40110                   came_from[neighbor] = current
    42    105.4 MiB      0.0 MiB       40110                   g_score[neighbor] = temp_g_score
    43    105.4 MiB      0.0 MiB       40110                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    105.4 MiB      0.0 MiB       39901           if draw is not None:
    46                                                     draw()
    47                                                     
    48    105.4 MiB      0.0 MiB       39901           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    105.4 MiB      0.0 MiB           1       paths = {}
    53    105.4 MiB      0.0 MiB           2       for goal in goals:
    54    105.4 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    105.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    105.4 MiB    105.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    105.4 MiB      0.0 MiB         257       for row in grid:
     8    105.4 MiB      0.0 MiB       65792           for spot in row:
     9    105.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    105.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    105.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    105.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17    105.4 MiB      0.0 MiB           1       came_from = {}
    18    105.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    105.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    105.6 MiB      0.0 MiB       34728       while not open_set.empty():
    22    105.6 MiB      0.0 MiB       34728           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    105.6 MiB      0.0 MiB       34728           current = open_set.get()[1]
    28                                         
    29    105.6 MiB      0.0 MiB       34728           if current in remaining_goals:
    30    105.6 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    105.6 MiB      0.0 MiB           1               if not remaining_goals:
    32    105.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    105.6 MiB      0.0 MiB      222019           for neighbor in current.neighbors:
    35    105.6 MiB      0.0 MiB      187292               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    105.6 MiB      0.0 MiB      187292               if current.row != neighbor.row and current.col != neighbor.col:
    38    105.6 MiB      0.0 MiB       89135                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    105.6 MiB      0.0 MiB      187292               if temp_g_score < g_score[neighbor]:
    41    105.6 MiB      0.2 MiB       35077                   came_from[neighbor] = current
    42    105.6 MiB      0.0 MiB       35077                   g_score[neighbor] = temp_g_score
    43    105.6 MiB      0.0 MiB       35077                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    105.6 MiB      0.0 MiB       34727           if draw is not None:
    46                                                     draw()
    47                                                     
    48    105.6 MiB      0.0 MiB       34727           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    105.6 MiB      0.0 MiB           1       paths = {}
    53    105.6 MiB      0.0 MiB           2       for goal in goals:
    54    105.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    105.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    106.0 MiB    106.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    106.0 MiB      0.0 MiB         257       for row in grid:
     8    106.0 MiB      0.0 MiB       65792           for spot in row:
     9    106.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    106.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    106.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    106.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17    106.0 MiB      0.0 MiB           1       came_from = {}
    18    106.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    106.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    106.0 MiB -42392.5 MiB       20200       while not open_set.empty():
    22    106.0 MiB -42392.5 MiB       20200           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    106.0 MiB -42392.5 MiB       20200           current = open_set.get()[1]
    28                                         
    29    106.0 MiB -42392.5 MiB       20200           if current in remaining_goals:
    30    103.1 MiB     -2.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.1 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    106.0 MiB -271065.3 MiB      129458           for neighbor in current.neighbors:
    35    106.0 MiB -228674.2 MiB      109259               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    106.0 MiB -228674.7 MiB      109259               if current.row != neighbor.row and current.col != neighbor.col:
    38    106.0 MiB -108889.8 MiB       52040                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    106.0 MiB -228675.4 MiB      109259               if temp_g_score < g_score[neighbor]:
    41    106.0 MiB -43012.6 MiB       20652                   came_from[neighbor] = current
    42    106.0 MiB -43012.6 MiB       20652                   g_score[neighbor] = temp_g_score
    43    106.0 MiB -43012.8 MiB       20652                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    106.0 MiB -42392.2 MiB       20199           if draw is not None:
    46                                                     draw()
    47                                                     
    48    106.0 MiB -42392.4 MiB       20199           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.1 MiB      0.0 MiB           1       paths = {}
    53    103.1 MiB      0.0 MiB           2       for goal in goals:
    54    103.1 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    103.1 MiB    103.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    103.1 MiB   -241.3 MiB         257       for row in grid:
     8    103.1 MiB -61864.9 MiB       65792           for spot in row:
     9    103.1 MiB -61624.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    102.0 MiB     -1.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    102.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    102.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17    102.0 MiB      0.0 MiB           1       came_from = {}
    18    102.3 MiB      0.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    102.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    102.9 MiB   -822.8 MiB       26780       while not open_set.empty():
    22    102.9 MiB   -822.8 MiB       26780           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    102.9 MiB   -822.8 MiB       26780           current = open_set.get()[1]
    28                                         
    29    102.9 MiB   -822.8 MiB       26780           if current in remaining_goals:
    30    102.9 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    102.9 MiB      0.0 MiB           1               if not remaining_goals:
    32    102.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    102.9 MiB  -5303.9 MiB      171575           for neighbor in current.neighbors:
    35    102.9 MiB  -4481.1 MiB      144796               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    102.9 MiB  -4481.2 MiB      144796               if current.row != neighbor.row and current.col != neighbor.col:
    38    102.9 MiB  -2137.2 MiB       68967                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    102.9 MiB  -4481.2 MiB      144796               if temp_g_score < g_score[neighbor]:
    41    102.9 MiB   -827.0 MiB       27068                   came_from[neighbor] = current
    42    102.9 MiB   -827.6 MiB       27068                   g_score[neighbor] = temp_g_score
    43    102.9 MiB   -827.6 MiB       27068                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    102.9 MiB   -822.8 MiB       26779           if draw is not None:
    46                                                     draw()
    47                                                     
    48    102.9 MiB   -822.8 MiB       26779           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    102.9 MiB      0.0 MiB           1       paths = {}
    53    102.9 MiB      0.0 MiB           2       for goal in goals:
    54    102.9 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    102.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    101.3 MiB    101.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    101.3 MiB      0.0 MiB         257       for row in grid:
     8    101.3 MiB      0.0 MiB       65792           for spot in row:
     9    101.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    101.3 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    101.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    101.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17    101.3 MiB      0.0 MiB           1       came_from = {}
    18    101.3 MiB  -6791.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.9 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21    100.9 MiB -18659.8 MiB       17426       while not open_set.empty():
    22    100.9 MiB -18659.9 MiB       17426           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.9 MiB -18659.9 MiB       17426           current = open_set.get()[1]
    28                                         
    29    100.9 MiB -18659.9 MiB       17426           if current in remaining_goals:
    30     99.6 MiB     -1.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     99.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     99.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.9 MiB -119063.8 MiB      111290           for neighbor in current.neighbors:
    35    100.9 MiB -100404.2 MiB       93865               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.9 MiB -100405.1 MiB       93865               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.9 MiB -47788.0 MiB       44671                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.9 MiB -100405.6 MiB       93865               if temp_g_score < g_score[neighbor]:
    41    100.9 MiB -18828.5 MiB       17671                   came_from[neighbor] = current
    42    100.9 MiB -18828.5 MiB       17671                   g_score[neighbor] = temp_g_score
    43    100.9 MiB -18828.5 MiB       17671                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.9 MiB -18659.8 MiB       17425           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.9 MiB -18659.8 MiB       17425           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     99.6 MiB      0.0 MiB           1       paths = {}
    53     99.6 MiB      0.0 MiB           2       for goal in goals:
    54     99.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     99.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.6 MiB     99.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.6 MiB      0.0 MiB         257       for row in grid:
     8     99.6 MiB      0.0 MiB       65792           for spot in row:
     9     99.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     99.6 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     99.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     99.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     99.6 MiB      0.0 MiB           1       came_from = {}
    18     99.9 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     99.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.9 MiB      0.0 MiB       10920       while not open_set.empty():
    22     99.9 MiB      0.0 MiB       10920           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.9 MiB      0.0 MiB       10920           current = open_set.get()[1]
    28                                         
    29     99.9 MiB      0.0 MiB       10920           if current in remaining_goals:
    30     99.9 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     99.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     99.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     99.9 MiB      0.0 MiB       69712           for neighbor in current.neighbors:
    35     99.9 MiB      0.0 MiB       58793               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.9 MiB      0.0 MiB       58793               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.9 MiB      0.0 MiB       27927                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.9 MiB      0.0 MiB       58793               if temp_g_score < g_score[neighbor]:
    41     99.9 MiB      0.0 MiB       11124                   came_from[neighbor] = current
    42     99.9 MiB      0.0 MiB       11124                   g_score[neighbor] = temp_g_score
    43     99.9 MiB      0.0 MiB       11124                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.9 MiB      0.0 MiB       10919           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.9 MiB      0.0 MiB       10919           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     99.9 MiB      0.0 MiB           1       paths = {}
    53     99.9 MiB      0.0 MiB           2       for goal in goals:
    54     99.9 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     99.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.2 MiB    100.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.2 MiB      0.0 MiB         257       for row in grid:
     8    100.2 MiB      0.0 MiB       65792           for spot in row:
     9    100.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    100.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    100.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    100.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17    100.2 MiB      0.0 MiB           1       came_from = {}
    18    100.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    100.6 MiB -34063.5 MiB       34297       while not open_set.empty():
    22    100.6 MiB -34063.6 MiB       34297           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.6 MiB -34063.9 MiB       34297           current = open_set.get()[1]
    28                                         
    29    100.6 MiB -34064.3 MiB       34297           if current in remaining_goals:
    30     97.9 MiB     -2.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     97.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     97.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.6 MiB -216103.6 MiB      219810           for neighbor in current.neighbors:
    35    100.6 MiB -182040.8 MiB      185514               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.6 MiB -182041.0 MiB      185514               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.6 MiB -86467.4 MiB       88309                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.6 MiB -182041.5 MiB      185514               if temp_g_score < g_score[neighbor]:
    41    100.6 MiB -34239.7 MiB       34611                   came_from[neighbor] = current
    42    100.6 MiB -34240.1 MiB       34611                   g_score[neighbor] = temp_g_score
    43    100.6 MiB -34240.2 MiB       34611                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.6 MiB -34063.4 MiB       34296           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.6 MiB -34063.5 MiB       34296           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     97.9 MiB      0.0 MiB           1       paths = {}
    53     97.9 MiB      0.0 MiB           2       for goal in goals:
    54     97.9 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     97.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.2 MiB     99.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.2 MiB      0.0 MiB         257       for row in grid:
     8     99.2 MiB      0.0 MiB       65792           for spot in row:
     9     99.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     99.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     99.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     99.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     99.2 MiB      0.0 MiB           1       came_from = {}
    18    103.0 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    103.1 MiB      0.0 MiB         194       while not open_set.empty():
    22    103.1 MiB      0.0 MiB         194           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.1 MiB      0.0 MiB         194           current = open_set.get()[1]
    28                                         
    29    103.1 MiB      0.0 MiB         194           if current in remaining_goals:
    30    103.1 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.1 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.1 MiB      0.0 MiB        1212           for neighbor in current.neighbors:
    35    103.1 MiB      0.0 MiB        1019               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.1 MiB      0.0 MiB        1019               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.1 MiB      0.0 MiB         483                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.1 MiB      0.0 MiB        1019               if temp_g_score < g_score[neighbor]:
    41    103.1 MiB      0.0 MiB         237                   came_from[neighbor] = current
    42    103.1 MiB      0.0 MiB         237                   g_score[neighbor] = temp_g_score
    43    103.1 MiB      0.0 MiB         237                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.1 MiB      0.0 MiB         193           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.1 MiB      0.0 MiB         193           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.1 MiB      0.0 MiB           1       paths = {}
    53    103.1 MiB      0.0 MiB           2       for goal in goals:
    54    103.1 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    103.7 MiB    103.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    103.7 MiB    -52.1 MiB         257       for row in grid:
     8    103.7 MiB -13334.6 MiB       65792           for spot in row:
     9    103.7 MiB -13282.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    103.4 MiB     -0.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    103.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    103.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17    103.4 MiB      0.0 MiB           1       came_from = {}
    18    103.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    103.5 MiB      0.0 MiB        2709       while not open_set.empty():
    22    103.5 MiB      0.0 MiB        2709           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.5 MiB      0.0 MiB        2709           current = open_set.get()[1]
    28                                         
    29    103.5 MiB      0.0 MiB        2709           if current in remaining_goals:
    30    103.5 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.5 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.5 MiB      0.0 MiB       17599           for neighbor in current.neighbors:
    35    103.5 MiB      0.0 MiB       14891               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.5 MiB      0.0 MiB       14891               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.5 MiB      0.0 MiB        7116                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.5 MiB      0.0 MiB       14891               if temp_g_score < g_score[neighbor]:
    41    103.5 MiB      0.0 MiB        2883                   came_from[neighbor] = current
    42    103.5 MiB      0.0 MiB        2883                   g_score[neighbor] = temp_g_score
    43    103.5 MiB      0.0 MiB        2883                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.5 MiB      0.0 MiB        2708           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.5 MiB      0.0 MiB        2708           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.5 MiB      0.0 MiB           1       paths = {}
    53    103.5 MiB      0.0 MiB           2       for goal in goals:
    54    103.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    103.8 MiB    103.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    103.8 MiB      0.0 MiB         257       for row in grid:
     8    103.8 MiB      0.0 MiB       65792           for spot in row:
     9    103.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    103.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    103.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    103.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17    103.8 MiB      0.0 MiB           1       came_from = {}
    18    103.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    103.8 MiB      0.0 MiB        2362       while not open_set.empty():
    22    103.8 MiB      0.0 MiB        2362           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.8 MiB      0.0 MiB        2362           current = open_set.get()[1]
    28                                         
    29    103.8 MiB      0.0 MiB        2362           if current in remaining_goals:
    30    103.8 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.8 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.8 MiB      0.0 MiB       15157           for neighbor in current.neighbors:
    35    103.8 MiB      0.0 MiB       12796               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.8 MiB      0.0 MiB       12796               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.8 MiB      0.0 MiB        6080                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.8 MiB      0.0 MiB       12796               if temp_g_score < g_score[neighbor]:
    41    103.8 MiB      0.0 MiB        2535                   came_from[neighbor] = current
    42    103.8 MiB      0.0 MiB        2535                   g_score[neighbor] = temp_g_score
    43    103.8 MiB      0.0 MiB        2535                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.8 MiB      0.0 MiB        2361           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.8 MiB      0.0 MiB        2361           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.8 MiB      0.0 MiB           1       paths = {}
    53    103.8 MiB      0.0 MiB           2       for goal in goals:
    54    103.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    103.8 MiB    103.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    103.8 MiB      0.0 MiB         257       for row in grid:
     8    103.8 MiB      0.0 MiB       65792           for spot in row:
     9    103.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    103.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    103.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    103.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17    103.8 MiB      0.0 MiB           1       came_from = {}
    18    103.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    103.8 MiB      0.0 MiB       43592       while not open_set.empty():
    22    103.8 MiB      0.0 MiB       43592           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.8 MiB      0.0 MiB       43592           current = open_set.get()[1]
    28                                         
    29    103.8 MiB      0.0 MiB       43592           if current in remaining_goals:
    30    103.8 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.8 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.8 MiB      0.0 MiB      280179           for neighbor in current.neighbors:
    35    103.8 MiB      0.0 MiB      236588               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.8 MiB      0.0 MiB      236588               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.8 MiB      0.0 MiB      112693                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.8 MiB      0.0 MiB      236588               if temp_g_score < g_score[neighbor]:
    41    103.8 MiB      0.0 MiB       43688                   came_from[neighbor] = current
    42    103.8 MiB      0.0 MiB       43688                   g_score[neighbor] = temp_g_score
    43    103.8 MiB      0.0 MiB       43688                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.8 MiB      0.0 MiB       43591           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.8 MiB      0.0 MiB       43591           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.8 MiB      0.0 MiB           1       paths = {}
    53    103.8 MiB      0.0 MiB           2       for goal in goals:
    54    103.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    103.8 MiB    103.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    103.8 MiB      0.0 MiB         257       for row in grid:
     8    103.8 MiB      0.0 MiB       65792           for spot in row:
     9    103.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    103.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    103.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    103.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17    103.8 MiB      0.0 MiB           1       came_from = {}
    18    103.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    105.1 MiB  -6716.3 MiB       30340       while not open_set.empty():
    22    105.1 MiB  -6716.3 MiB       30340           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    105.1 MiB  -6716.3 MiB       30340           current = open_set.get()[1]
    28                                         
    29    105.1 MiB  -6716.3 MiB       30340           if current in remaining_goals:
    30    103.3 MiB     -1.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.3 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    105.1 MiB -42724.1 MiB      194494           for neighbor in current.neighbors:
    35    105.1 MiB -36008.2 MiB      164155               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    105.1 MiB -36008.6 MiB      164155               if current.row != neighbor.row and current.col != neighbor.col:
    38    105.1 MiB -17102.2 MiB       78109                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    105.1 MiB -36009.2 MiB      164155               if temp_g_score < g_score[neighbor]:
    41    105.1 MiB  -6672.6 MiB       30623                   came_from[neighbor] = current
    42    105.1 MiB  -6673.9 MiB       30623                   g_score[neighbor] = temp_g_score
    43    105.1 MiB  -6673.9 MiB       30623                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    105.1 MiB  -6716.3 MiB       30339           if draw is not None:
    46                                                     draw()
    47                                                     
    48    105.1 MiB  -6716.3 MiB       30339           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.3 MiB      0.0 MiB           1       paths = {}
    53    103.3 MiB      0.0 MiB           2       for goal in goals:
    54    103.3 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.5 MiB     99.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.5 MiB   -419.1 MiB         257       for row in grid:
     8     99.5 MiB -107431.9 MiB       65792           for spot in row:
     9     99.5 MiB -107014.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.2 MiB     -2.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.2 MiB      0.0 MiB           1       came_from = {}
    18    100.1 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    100.2 MiB      0.0 MiB        3743       while not open_set.empty():
    22    100.2 MiB      0.0 MiB        3743           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.2 MiB      0.0 MiB        3743           current = open_set.get()[1]
    28                                         
    29    100.2 MiB      0.0 MiB        3743           if current in remaining_goals:
    30    100.2 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    100.2 MiB      0.0 MiB           1               if not remaining_goals:
    32    100.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.2 MiB      0.0 MiB       24103           for neighbor in current.neighbors:
    35    100.2 MiB      0.0 MiB       20361               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.2 MiB      0.0 MiB       20361               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.2 MiB      0.0 MiB        9698                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.2 MiB      0.0 MiB       20361               if temp_g_score < g_score[neighbor]:
    41    100.2 MiB      0.1 MiB        3934                   came_from[neighbor] = current
    42    100.2 MiB      0.0 MiB        3934                   g_score[neighbor] = temp_g_score
    43    100.2 MiB      0.0 MiB        3934                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.2 MiB      0.0 MiB        3742           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.2 MiB      0.0 MiB        3742           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    100.2 MiB      0.0 MiB           1       paths = {}
    53    100.2 MiB      0.0 MiB           2       for goal in goals:
    54    100.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    100.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    101.1 MiB    101.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    101.1 MiB      0.0 MiB         257       for row in grid:
     8    101.1 MiB      0.0 MiB       65792           for spot in row:
     9    101.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    101.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    101.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    101.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17    101.1 MiB      0.0 MiB           1       came_from = {}
    18    103.6 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    103.8 MiB   -714.7 MiB       12789       while not open_set.empty():
    22    103.8 MiB   -714.7 MiB       12789           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.8 MiB   -714.7 MiB       12789           current = open_set.get()[1]
    28                                         
    29    103.8 MiB   -714.7 MiB       12789           if current in remaining_goals:
    30    103.8 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.8 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.8 MiB  -4592.0 MiB       82335           for neighbor in current.neighbors:
    35    103.8 MiB  -3877.3 MiB       69547               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.8 MiB  -3877.3 MiB       69547               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.8 MiB  -1851.2 MiB       33182                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.8 MiB  -3877.4 MiB       69547               if temp_g_score < g_score[neighbor]:
    41    103.8 MiB   -730.2 MiB       13145                   came_from[neighbor] = current
    42    103.8 MiB   -730.5 MiB       13145                   g_score[neighbor] = temp_g_score
    43    103.8 MiB   -730.5 MiB       13145                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.8 MiB   -714.7 MiB       12788           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.8 MiB   -714.7 MiB       12788           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.8 MiB      0.0 MiB           1       paths = {}
    53    103.8 MiB      0.0 MiB           2       for goal in goals:
    54    103.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    104.2 MiB    104.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    104.2 MiB      0.0 MiB         257       for row in grid:
     8    104.2 MiB      0.0 MiB       65792           for spot in row:
     9    104.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    104.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    104.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    104.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17    104.2 MiB      0.0 MiB           1       came_from = {}
    18    104.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    104.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    104.2 MiB      0.0 MiB        1682       while not open_set.empty():
    22    104.2 MiB      0.0 MiB        1682           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    104.2 MiB      0.0 MiB        1682           current = open_set.get()[1]
    28                                         
    29    104.2 MiB      0.0 MiB        1682           if current in remaining_goals:
    30    104.2 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    104.2 MiB      0.0 MiB           1               if not remaining_goals:
    32    104.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    104.2 MiB      0.0 MiB       11033           for neighbor in current.neighbors:
    35    104.2 MiB      0.0 MiB        9352               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    104.2 MiB      0.0 MiB        9352               if current.row != neighbor.row and current.col != neighbor.col:
    38    104.2 MiB      0.0 MiB        4473                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    104.2 MiB      0.0 MiB        9352               if temp_g_score < g_score[neighbor]:
    41    104.2 MiB      0.0 MiB        1816                   came_from[neighbor] = current
    42    104.2 MiB      0.0 MiB        1816                   g_score[neighbor] = temp_g_score
    43    104.2 MiB      0.0 MiB        1816                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    104.2 MiB      0.0 MiB        1681           if draw is not None:
    46                                                     draw()
    47                                                     
    48    104.2 MiB      0.0 MiB        1681           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    104.2 MiB      0.0 MiB           1       paths = {}
    53    104.2 MiB      0.0 MiB           2       for goal in goals:
    54    104.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    104.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    104.8 MiB    104.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    104.8 MiB      0.0 MiB         257       for row in grid:
     8    104.8 MiB      0.0 MiB       65792           for spot in row:
     9    104.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    104.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    104.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    104.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17    104.8 MiB      0.0 MiB           1       came_from = {}
    18    104.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    104.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    104.8 MiB      0.0 MiB       19015       while not open_set.empty():
    22    104.8 MiB      0.0 MiB       19015           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    104.8 MiB      0.0 MiB       19015           current = open_set.get()[1]
    28                                         
    29    104.8 MiB      0.0 MiB       19015           if current in remaining_goals:
    30    104.8 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    104.8 MiB      0.0 MiB           1               if not remaining_goals:
    32    104.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    104.8 MiB      0.0 MiB      122294           for neighbor in current.neighbors:
    35    104.8 MiB      0.0 MiB      103280               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    104.8 MiB      0.0 MiB      103280               if current.row != neighbor.row and current.col != neighbor.col:
    38    104.8 MiB      0.0 MiB       49206                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    104.8 MiB      0.0 MiB      103280               if temp_g_score < g_score[neighbor]:
    41    104.8 MiB      0.0 MiB       19227                   came_from[neighbor] = current
    42    104.8 MiB      0.0 MiB       19227                   g_score[neighbor] = temp_g_score
    43    104.8 MiB      0.0 MiB       19227                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    104.8 MiB      0.0 MiB       19014           if draw is not None:
    46                                                     draw()
    47                                                     
    48    104.8 MiB      0.0 MiB       19014           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    104.8 MiB      0.0 MiB           1       paths = {}
    53    104.8 MiB      0.0 MiB           2       for goal in goals:
    54    104.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    104.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    105.2 MiB    105.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    105.2 MiB      0.0 MiB         257       for row in grid:
     8    105.2 MiB      0.0 MiB       65792           for spot in row:
     9    105.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    105.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    105.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    105.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17    105.2 MiB      0.0 MiB           1       came_from = {}
    18    105.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    105.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    105.2 MiB      0.0 MiB       37882       while not open_set.empty():
    22    105.2 MiB      0.0 MiB       37882           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    105.2 MiB      0.0 MiB       37882           current = open_set.get()[1]
    28                                         
    29    105.2 MiB      0.0 MiB       37882           if current in remaining_goals:
    30    105.2 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    105.2 MiB      0.0 MiB           1               if not remaining_goals:
    32    105.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    105.2 MiB      0.0 MiB      242959           for neighbor in current.neighbors:
    35    105.2 MiB      0.0 MiB      205078               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    105.2 MiB      0.0 MiB      205078               if current.row != neighbor.row and current.col != neighbor.col:
    38    105.2 MiB      0.0 MiB       97575                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    105.2 MiB      0.0 MiB      205078               if temp_g_score < g_score[neighbor]:
    41    105.2 MiB      0.0 MiB       38202                   came_from[neighbor] = current
    42    105.2 MiB      0.0 MiB       38202                   g_score[neighbor] = temp_g_score
    43    105.2 MiB      0.0 MiB       38202                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    105.2 MiB      0.0 MiB       37881           if draw is not None:
    46                                                     draw()
    47                                                     
    48    105.2 MiB      0.0 MiB       37881           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    105.2 MiB      0.0 MiB           1       paths = {}
    53    105.2 MiB      0.0 MiB           2       for goal in goals:
    54    105.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    105.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    105.2 MiB    105.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    105.2 MiB      0.0 MiB         257       for row in grid:
     8    105.2 MiB      0.0 MiB       65792           for spot in row:
     9    105.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    105.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    105.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    105.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17    105.2 MiB      0.0 MiB           1       came_from = {}
    18    105.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    105.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    105.2 MiB      0.0 MiB       11838       while not open_set.empty():
    22    105.2 MiB      0.0 MiB       11838           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    105.2 MiB      0.0 MiB       11838           current = open_set.get()[1]
    28                                         
    29    105.2 MiB      0.0 MiB       11838           if current in remaining_goals:
    30    105.2 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    105.2 MiB      0.0 MiB           1               if not remaining_goals:
    32    105.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    105.2 MiB      0.0 MiB       75831           for neighbor in current.neighbors:
    35    105.2 MiB      0.0 MiB       63994               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    105.2 MiB      0.0 MiB       63994               if current.row != neighbor.row and current.col != neighbor.col:
    38    105.2 MiB      0.0 MiB       30492                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    105.2 MiB      0.0 MiB       63994               if temp_g_score < g_score[neighbor]:
    41    105.2 MiB      0.0 MiB       12003                   came_from[neighbor] = current
    42    105.2 MiB      0.0 MiB       12003                   g_score[neighbor] = temp_g_score
    43    105.2 MiB      0.0 MiB       12003                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    105.2 MiB      0.0 MiB       11837           if draw is not None:
    46                                                     draw()
    47                                                     
    48    105.2 MiB      0.0 MiB       11837           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    105.2 MiB      0.0 MiB           1       paths = {}
    53    105.2 MiB      0.0 MiB           2       for goal in goals:
    54    105.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    105.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    105.2 MiB    105.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    105.2 MiB      0.0 MiB         257       for row in grid:
     8    105.2 MiB      0.0 MiB       65792           for spot in row:
     9    105.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    105.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    105.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    105.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17    105.2 MiB      0.0 MiB           1       came_from = {}
    18    106.1 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    106.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    106.1 MiB   -147.2 MiB       20006       while not open_set.empty():
    22    106.1 MiB   -147.2 MiB       20006           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    106.1 MiB   -147.2 MiB       20006           current = open_set.get()[1]
    28                                         
    29    106.1 MiB   -147.2 MiB       20006           if current in remaining_goals:
    30    105.4 MiB     -0.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    105.4 MiB      0.0 MiB           1               if not remaining_goals:
    32    105.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    106.1 MiB   -921.4 MiB      128104           for neighbor in current.neighbors:
    35    106.1 MiB   -774.3 MiB      108099               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    106.1 MiB   -774.4 MiB      108099               if current.row != neighbor.row and current.col != neighbor.col:
    38    106.1 MiB   -367.9 MiB       51433                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    106.1 MiB   -774.7 MiB      108099               if temp_g_score < g_score[neighbor]:
    41    106.1 MiB   -143.5 MiB       20240                   came_from[neighbor] = current
    42    106.1 MiB   -143.5 MiB       20240                   g_score[neighbor] = temp_g_score
    43    106.1 MiB   -143.5 MiB       20240                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    106.1 MiB   -147.2 MiB       20005           if draw is not None:
    46                                                     draw()
    47                                                     
    48    106.1 MiB   -147.2 MiB       20005           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    105.4 MiB      0.0 MiB           1       paths = {}
    53    105.4 MiB      0.0 MiB           2       for goal in goals:
    54    105.4 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    105.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    102.8 MiB    102.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    102.8 MiB   -165.9 MiB         257       for row in grid:
     8    102.8 MiB -42433.2 MiB       65792           for spot in row:
     9    102.8 MiB -42268.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    101.2 MiB     -1.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    101.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    101.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17    101.2 MiB      0.0 MiB           1       came_from = {}
    18    104.7 MiB -14322.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    103.7 MiB     -0.9 MiB           1       g_score[start] = 0
    20                                         
    21    103.9 MiB      0.0 MiB       13527       while not open_set.empty():
    22    103.9 MiB      0.0 MiB       13527           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    103.9 MiB      0.0 MiB       13527           current = open_set.get()[1]
    28                                         
    29    103.9 MiB      0.0 MiB       13527           if current in remaining_goals:
    30    103.9 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    103.9 MiB      0.0 MiB           1               if not remaining_goals:
    32    103.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    103.9 MiB      0.0 MiB       86797           for neighbor in current.neighbors:
    35    103.9 MiB      0.0 MiB       73271               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    103.9 MiB      0.0 MiB       73271               if current.row != neighbor.row and current.col != neighbor.col:
    38    103.9 MiB      0.0 MiB       34904                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    103.9 MiB      0.0 MiB       73271               if temp_g_score < g_score[neighbor]:
    41    103.9 MiB      0.2 MiB       13750                   came_from[neighbor] = current
    42    103.9 MiB      0.0 MiB       13750                   g_score[neighbor] = temp_g_score
    43    103.9 MiB      0.0 MiB       13750                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    103.9 MiB      0.0 MiB       13526           if draw is not None:
    46                                                     draw()
    47                                                     
    48    103.9 MiB      0.0 MiB       13526           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    103.9 MiB      0.0 MiB           1       paths = {}
    53    103.9 MiB      0.0 MiB           2       for goal in goals:
    54    103.9 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    103.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    104.2 MiB    104.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    104.2 MiB      0.0 MiB         257       for row in grid:
     8    104.2 MiB      0.0 MiB       65792           for spot in row:
     9    104.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    104.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    104.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    104.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17    104.2 MiB      0.0 MiB           1       came_from = {}
    18    106.6 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    106.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    108.2 MiB      0.0 MiB       25344       while not open_set.empty():
    22    108.2 MiB      0.0 MiB       25344           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    108.2 MiB      0.0 MiB       25344           current = open_set.get()[1]
    28                                         
    29    108.2 MiB      0.0 MiB       25344           if current in remaining_goals:
    30    108.2 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    108.2 MiB      0.0 MiB           1               if not remaining_goals:
    32    108.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    108.2 MiB      0.0 MiB      162704           for neighbor in current.neighbors:
    35    108.2 MiB      0.0 MiB      137361               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    108.2 MiB      0.0 MiB      137361               if current.row != neighbor.row and current.col != neighbor.col:
    38    108.2 MiB      0.0 MiB       65451                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    108.2 MiB      0.0 MiB      137361               if temp_g_score < g_score[neighbor]:
    41    108.2 MiB      1.6 MiB       25619                   came_from[neighbor] = current
    42    108.2 MiB      0.0 MiB       25619                   g_score[neighbor] = temp_g_score
    43    108.2 MiB      0.0 MiB       25619                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    108.2 MiB      0.0 MiB       25343           if draw is not None:
    46                                                     draw()
    47                                                     
    48    108.2 MiB      0.0 MiB       25343           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    108.2 MiB      0.0 MiB           1       paths = {}
    53    108.2 MiB      0.0 MiB           2       for goal in goals:
    54    108.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    108.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    108.2 MiB    108.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    108.2 MiB      0.0 MiB         257       for row in grid:
     8    108.2 MiB      0.0 MiB       65792           for spot in row:
     9    108.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    108.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    108.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    108.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17    108.2 MiB      0.0 MiB           1       came_from = {}
    18    108.7 MiB  -1930.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    108.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    108.7 MiB -39445.2 MiB       36974       while not open_set.empty():
    22    108.7 MiB -39445.3 MiB       36974           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    108.7 MiB -39445.4 MiB       36974           current = open_set.get()[1]
    28                                         
    29    108.7 MiB -39445.4 MiB       36974           if current in remaining_goals:
    30    105.0 MiB     -3.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    105.0 MiB      0.0 MiB           1               if not remaining_goals:
    32    105.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    108.7 MiB -250576.0 MiB      235527           for neighbor in current.neighbors:
    35    108.7 MiB -211131.7 MiB      198554               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    108.7 MiB -211132.1 MiB      198554               if current.row != neighbor.row and current.col != neighbor.col:
    38    108.7 MiB -100391.8 MiB       94434                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    108.7 MiB -211132.9 MiB      198554               if temp_g_score < g_score[neighbor]:
    41    108.7 MiB -39255.5 MiB       37154                   came_from[neighbor] = current
    42    108.7 MiB -39255.6 MiB       37154                   g_score[neighbor] = temp_g_score
    43    108.7 MiB -39256.0 MiB       37154                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    108.7 MiB -39445.0 MiB       36973           if draw is not None:
    46                                                     draw()
    47                                                     
    48    108.7 MiB -39445.2 MiB       36973           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    105.0 MiB      0.0 MiB           1       paths = {}
    53    105.0 MiB      0.0 MiB           2       for goal in goals:
    54    105.0 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    105.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    101.1 MiB    101.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    101.1 MiB   -994.2 MiB         257       for row in grid:
     8    101.1 MiB -254841.4 MiB       65792           for spot in row:
     9    101.1 MiB -253850.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     96.1 MiB     -5.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     96.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     96.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     96.1 MiB      0.0 MiB           1       came_from = {}
    18     98.6 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.2 MiB      0.0 MiB       16424       while not open_set.empty():
    22     99.2 MiB      0.0 MiB       16424           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.2 MiB      0.0 MiB       16424           current = open_set.get()[1]
    28                                         
    29     99.2 MiB      0.0 MiB       16424           if current in remaining_goals:
    30     99.2 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     99.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     99.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     99.2 MiB      0.0 MiB      105222           for neighbor in current.neighbors:
    35     99.2 MiB      0.0 MiB       88799               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.2 MiB      0.0 MiB       88799               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.2 MiB      0.0 MiB       42250                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.2 MiB      0.0 MiB       88799               if temp_g_score < g_score[neighbor]:
    41     99.2 MiB      0.6 MiB       16679                   came_from[neighbor] = current
    42     99.2 MiB      0.0 MiB       16679                   g_score[neighbor] = temp_g_score
    43     99.2 MiB      0.0 MiB       16679                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.2 MiB      0.0 MiB       16423           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.2 MiB      0.0 MiB       16423           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     99.2 MiB      0.0 MiB           1       paths = {}
    53     99.2 MiB      0.0 MiB           2       for goal in goals:
    54     99.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     99.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.8 MiB     99.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.8 MiB      0.0 MiB         257       for row in grid:
     8     99.8 MiB      0.0 MiB       65792           for spot in row:
     9     99.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     99.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     99.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     99.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     99.8 MiB      0.0 MiB           1       came_from = {}
    18    100.7 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    101.3 MiB      0.0 MiB       23763       while not open_set.empty():
    22    101.3 MiB      0.0 MiB       23763           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    101.3 MiB      0.0 MiB       23763           current = open_set.get()[1]
    28                                         
    29    101.3 MiB      0.0 MiB       23763           if current in remaining_goals:
    30    101.3 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    101.3 MiB      0.0 MiB           1               if not remaining_goals:
    32    101.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    101.3 MiB      0.0 MiB      153203           for neighbor in current.neighbors:
    35    101.3 MiB      0.0 MiB      129441               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    101.3 MiB      0.0 MiB      129441               if current.row != neighbor.row and current.col != neighbor.col:
    38    101.3 MiB      0.0 MiB       61651                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    101.3 MiB      0.0 MiB      129441               if temp_g_score < g_score[neighbor]:
    41    101.3 MiB      0.6 MiB       24027                   came_from[neighbor] = current
    42    101.3 MiB      0.0 MiB       24027                   g_score[neighbor] = temp_g_score
    43    101.3 MiB      0.0 MiB       24027                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    101.3 MiB      0.0 MiB       23762           if draw is not None:
    46                                                     draw()
    47                                                     
    48    101.3 MiB      0.0 MiB       23762           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    101.3 MiB      0.0 MiB           1       paths = {}
    53    101.3 MiB      0.0 MiB           2       for goal in goals:
    54    101.3 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    101.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    101.4 MiB    101.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    101.4 MiB      0.0 MiB         257       for row in grid:
     8    101.4 MiB      0.0 MiB       65792           for spot in row:
     9    101.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    101.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    101.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    101.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17    101.4 MiB      0.0 MiB           1       came_from = {}
    18    104.9 MiB      3.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    104.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    104.9 MiB      0.0 MiB        1381       while not open_set.empty():
    22    104.9 MiB      0.0 MiB        1381           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    104.9 MiB      0.0 MiB        1381           current = open_set.get()[1]
    28                                         
    29    104.9 MiB      0.0 MiB        1381           if current in remaining_goals:
    30    104.9 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    104.9 MiB      0.0 MiB           1               if not remaining_goals:
    32    104.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    104.9 MiB      0.0 MiB        9041           for neighbor in current.neighbors:
    35    104.9 MiB      0.0 MiB        7661               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    104.9 MiB      0.0 MiB        7661               if current.row != neighbor.row and current.col != neighbor.col:
    38    104.9 MiB      0.0 MiB        3667                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    104.9 MiB      0.0 MiB        7661               if temp_g_score < g_score[neighbor]:
    41    104.9 MiB      0.0 MiB        1490                   came_from[neighbor] = current
    42    104.9 MiB      0.0 MiB        1490                   g_score[neighbor] = temp_g_score
    43    104.9 MiB      0.0 MiB        1490                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    104.9 MiB      0.0 MiB        1380           if draw is not None:
    46                                                     draw()
    47                                                     
    48    104.9 MiB      0.0 MiB        1380           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    104.9 MiB      0.0 MiB           1       paths = {}
    53    104.9 MiB      0.0 MiB           2       for goal in goals:
    54    104.9 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    104.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    105.3 MiB    105.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    105.3 MiB      0.0 MiB         257       for row in grid:
     8    105.3 MiB      0.0 MiB       65792           for spot in row:
     9    105.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12    105.3 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15    105.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16    105.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17    105.3 MiB      0.0 MiB           1       came_from = {}
    18    105.4 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    105.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    105.4 MiB -119206.3 MiB       26763       while not open_set.empty():
    22    105.4 MiB -119206.6 MiB       26763           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    105.4 MiB -119206.8 MiB       26763           current = open_set.get()[1]
    28                                         
    29    105.4 MiB -119207.0 MiB       26763           if current in remaining_goals:
    30     98.8 MiB     -6.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     98.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     98.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    105.4 MiB -761504.3 MiB      170961           for neighbor in current.neighbors:
    35    105.4 MiB -642299.4 MiB      144199               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    105.4 MiB -642300.4 MiB      144199               if current.row != neighbor.row and current.col != neighbor.col:
    38    105.4 MiB -305888.5 MiB       68647                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    105.4 MiB -642301.8 MiB      144199               if temp_g_score < g_score[neighbor]:
    41    105.4 MiB -119375.5 MiB       27037                   came_from[neighbor] = current
    42    105.4 MiB -119375.8 MiB       27037                   g_score[neighbor] = temp_g_score
    43    105.4 MiB -119376.8 MiB       27037                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    105.4 MiB -119206.3 MiB       26762           if draw is not None:
    46                                                     draw()
    47                                                     
    48    105.4 MiB -119206.3 MiB       26762           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     98.8 MiB      0.0 MiB           1       paths = {}
    53     98.8 MiB      0.0 MiB           2       for goal in goals:
    54     98.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     98.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.2 MiB     99.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.2 MiB    -34.4 MiB         257       for row in grid:
     8     99.2 MiB  -8800.2 MiB       65792           for spot in row:
     9     99.2 MiB  -8769.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     98.7 MiB     -0.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     98.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     98.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     98.7 MiB      0.0 MiB           1       came_from = {}
    18    100.7 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    100.7 MiB -161120.5 MiB       35190       while not open_set.empty():
    22    100.7 MiB -161120.8 MiB       35190           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.7 MiB -161121.3 MiB       35190           current = open_set.get()[1]
    28                                         
    29    100.7 MiB -161121.5 MiB       35190           if current in remaining_goals:
    30     94.6 MiB     -6.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     94.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     94.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.7 MiB -1035693.1 MiB      226223           for neighbor in current.neighbors:
    35    100.7 MiB -874574.3 MiB      191034               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.7 MiB -874574.8 MiB      191034               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.7 MiB -416610.8 MiB       91014                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.7 MiB -874576.0 MiB      191034               if temp_g_score < g_score[neighbor]:
    41    100.7 MiB -161599.1 MiB       35471                   came_from[neighbor] = current
    42    100.7 MiB -161599.2 MiB       35471                   g_score[neighbor] = temp_g_score
    43    100.7 MiB -161599.5 MiB       35471                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.7 MiB -161120.0 MiB       35189           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.7 MiB -161120.3 MiB       35189           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     94.6 MiB      0.0 MiB           1       paths = {}
    53     94.6 MiB      0.0 MiB           2       for goal in goals:
    54     94.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     94.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.5 MiB     97.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.5 MiB      0.0 MiB         257       for row in grid:
     8     97.5 MiB      0.0 MiB       65792           for spot in row:
     9     97.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.5 MiB      0.0 MiB           1       came_from = {}
    18     99.3 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     99.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.9 MiB      0.0 MiB       18861       while not open_set.empty():
    22     99.9 MiB      0.0 MiB       18861           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.9 MiB      0.0 MiB       18861           current = open_set.get()[1]
    28                                         
    29     99.9 MiB      0.0 MiB       18861           if current in remaining_goals:
    30     99.9 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     99.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     99.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     99.9 MiB      0.0 MiB      120975           for neighbor in current.neighbors:
    35     99.9 MiB      0.0 MiB      102115               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.9 MiB      0.0 MiB      102115               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.9 MiB      0.0 MiB       48637                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.9 MiB      0.0 MiB      102115               if temp_g_score < g_score[neighbor]:
    41     99.9 MiB      0.5 MiB       19102                   came_from[neighbor] = current
    42     99.9 MiB      0.0 MiB       19102                   g_score[neighbor] = temp_g_score
    43     99.9 MiB      0.0 MiB       19102                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.9 MiB      0.0 MiB       18860           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.9 MiB      0.0 MiB       18860           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     99.9 MiB      0.0 MiB           1       paths = {}
    53     99.9 MiB      0.0 MiB           2       for goal in goals:
    54     99.9 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     99.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    100.0 MiB    100.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    100.0 MiB   -149.2 MiB         257       for row in grid:
     8    100.0 MiB -37750.9 MiB       65792           for spot in row:
     9    100.0 MiB -37605.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.8 MiB     -5.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     94.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     94.8 MiB      0.0 MiB           1       came_from = {}
    18     95.7 MiB  -6980.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.7 MiB -890303.7 MiB       36877       while not open_set.empty():
    22     95.7 MiB -890304.9 MiB       36877           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.7 MiB -890308.4 MiB       36877           current = open_set.get()[1]
    28                                         
    29     95.7 MiB -890309.5 MiB       36877           if current in remaining_goals:
    30     54.2 MiB    -41.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     54.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     54.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     95.7 MiB -5694565.1 MiB      236767           for neighbor in current.neighbors:
    35     95.7 MiB -4804275.7 MiB      199891               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.7 MiB -4804279.3 MiB      199891               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.7 MiB -2287489.8 MiB       95281                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.7 MiB -4804289.4 MiB      199891               if temp_g_score < g_score[neighbor]:
    41     95.7 MiB -888145.0 MiB       37074                   came_from[neighbor] = current
    42     95.7 MiB -888146.2 MiB       37074                   g_score[neighbor] = temp_g_score
    43     95.7 MiB -888149.5 MiB       37074                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.7 MiB -890298.6 MiB       36876           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.7 MiB -890300.3 MiB       36876           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     54.2 MiB      0.0 MiB           1       paths = {}
    53     54.4 MiB      0.0 MiB           2       for goal in goals:
    54     54.4 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     54.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.1 MiB     91.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.1 MiB      0.0 MiB         257       for row in grid:
     8     91.1 MiB      0.0 MiB       65792           for spot in row:
     9     91.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.1 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.1 MiB      0.0 MiB           1       came_from = {}
    18     94.3 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.5 MiB      0.0 MiB        3905       while not open_set.empty():
    22     94.5 MiB      0.0 MiB        3905           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.5 MiB      0.0 MiB        3905           current = open_set.get()[1]
    28                                         
    29     94.5 MiB      0.0 MiB        3905           if current in remaining_goals:
    30     94.5 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     94.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     94.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.5 MiB      0.0 MiB       25010           for neighbor in current.neighbors:
    35     94.5 MiB      0.0 MiB       21106               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.5 MiB      0.0 MiB       21106               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.5 MiB      0.0 MiB       10051                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.5 MiB      0.0 MiB       21106               if temp_g_score < g_score[neighbor]:
    41     94.5 MiB      0.1 MiB        4104                   came_from[neighbor] = current
    42     94.5 MiB      0.0 MiB        4104                   g_score[neighbor] = temp_g_score
    43     94.5 MiB      0.0 MiB        4104                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.5 MiB      0.0 MiB        3904           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.5 MiB      0.0 MiB        3904           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     94.5 MiB      0.0 MiB           1       paths = {}
    53     94.5 MiB      0.0 MiB           2       for goal in goals:
    54     94.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     94.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.9 MiB     94.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.9 MiB    -81.5 MiB         257       for row in grid:
     8     94.9 MiB -20689.4 MiB       65792           for spot in row:
     9     94.9 MiB -20609.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.9 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.9 MiB      0.0 MiB           1       came_from = {}
    18     95.4 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.6 MiB -44421.2 MiB       44896       while not open_set.empty():
    22     96.6 MiB -44421.5 MiB       44896           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.6 MiB -44421.9 MiB       44896           current = open_set.get()[1]
    28                                         
    29     96.6 MiB -44421.9 MiB       44896           if current in remaining_goals:
    30     96.3 MiB     -0.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     96.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.6 MiB -284320.0 MiB      287885           for neighbor in current.neighbors:
    35     96.6 MiB -239899.9 MiB      242990               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.6 MiB -239899.9 MiB      242990               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.6 MiB -114070.2 MiB      115710                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.6 MiB -239900.5 MiB      242990               if temp_g_score < g_score[neighbor]:
    41     96.6 MiB -43620.3 MiB       44960                   came_from[neighbor] = current
    42     96.6 MiB -43621.5 MiB       44960                   g_score[neighbor] = temp_g_score
    43     96.6 MiB -43621.5 MiB       44960                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.6 MiB -44420.7 MiB       44895           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.6 MiB -44420.9 MiB       44895           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     96.3 MiB      0.0 MiB           1       paths = {}
    53     96.3 MiB      0.0 MiB           2       for goal in goals:
    54     96.3 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     96.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     98.2 MiB     98.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     98.2 MiB      0.0 MiB         257       for row in grid:
     8     98.2 MiB      0.0 MiB       65792           for spot in row:
     9     98.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     98.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     98.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     98.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     98.2 MiB      0.0 MiB           1       came_from = {}
    18    100.8 MiB   -172.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    100.9 MiB -67680.3 MiB       24611       while not open_set.empty():
    22    100.9 MiB -67680.5 MiB       24611           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    100.9 MiB -67680.8 MiB       24611           current = open_set.get()[1]
    28                                         
    29    100.9 MiB -67680.9 MiB       24611           if current in remaining_goals:
    30     96.6 MiB     -4.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     96.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     96.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    100.9 MiB -434435.0 MiB      157933           for neighbor in current.neighbors:
    35    100.9 MiB -366756.1 MiB      133323               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    100.9 MiB -366757.0 MiB      133323               if current.row != neighbor.row and current.col != neighbor.col:
    38    100.9 MiB -174953.0 MiB       63563                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    100.9 MiB -366757.8 MiB      133323               if temp_g_score < g_score[neighbor]:
    41    100.9 MiB -68322.9 MiB       24905                   came_from[neighbor] = current
    42    100.9 MiB -68323.1 MiB       24905                   g_score[neighbor] = temp_g_score
    43    100.9 MiB -68323.5 MiB       24905                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    100.9 MiB -67679.8 MiB       24610           if draw is not None:
    46                                                     draw()
    47                                                     
    48    100.9 MiB -67680.0 MiB       24610           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     96.6 MiB      0.0 MiB           1       paths = {}
    53     96.6 MiB      0.0 MiB           2       for goal in goals:
    54     96.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     96.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.4 MiB     97.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.4 MiB     -3.0 MiB         257       for row in grid:
     8     97.4 MiB   -765.7 MiB       65792           for spot in row:
     9     97.4 MiB   -762.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.3 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.3 MiB      0.0 MiB           1       came_from = {}
    18    101.3 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    101.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    102.2 MiB -79950.8 MiB       25721       while not open_set.empty():
    22    102.2 MiB -79950.9 MiB       25721           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    102.2 MiB -79951.1 MiB       25721           current = open_set.get()[1]
    28                                         
    29    102.2 MiB -79951.3 MiB       25721           if current in remaining_goals:
    30     97.1 MiB     -5.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     97.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     97.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    102.2 MiB -512045.3 MiB      164416           for neighbor in current.neighbors:
    35    102.2 MiB -432095.7 MiB      138696               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    102.2 MiB -432096.6 MiB      138696               if current.row != neighbor.row and current.col != neighbor.col:
    38    102.2 MiB -205572.9 MiB       65970                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    102.2 MiB -432098.4 MiB      138696               if temp_g_score < g_score[neighbor]:
    41    102.2 MiB -80065.2 MiB       25998                   came_from[neighbor] = current
    42    102.2 MiB -80066.2 MiB       25998                   g_score[neighbor] = temp_g_score
    43    102.2 MiB -80066.3 MiB       25998                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    102.2 MiB -79950.5 MiB       25720           if draw is not None:
    46                                                     draw()
    47                                                     
    48    102.2 MiB -79950.6 MiB       25720           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     97.1 MiB      0.0 MiB           1       paths = {}
    53     97.1 MiB      0.0 MiB           2       for goal in goals:
    54     97.1 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     97.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     97.5 MiB     97.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     97.5 MiB      0.0 MiB         257       for row in grid:
     8     97.5 MiB      0.0 MiB       65792           for spot in row:
     9     97.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     97.5 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     97.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     97.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     97.5 MiB      0.0 MiB           1       came_from = {}
    18    100.7 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19    100.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21    101.6 MiB      0.0 MiB       23414       while not open_set.empty():
    22    101.6 MiB      0.0 MiB       23414           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27    101.6 MiB      0.0 MiB       23414           current = open_set.get()[1]
    28                                         
    29    101.6 MiB      0.0 MiB       23414           if current in remaining_goals:
    30    101.6 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31    101.6 MiB      0.0 MiB           1               if not remaining_goals:
    32    101.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34    101.6 MiB      0.0 MiB      150700           for neighbor in current.neighbors:
    35    101.6 MiB      0.0 MiB      127287               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37    101.6 MiB      0.0 MiB      127287               if current.row != neighbor.row and current.col != neighbor.col:
    38    101.6 MiB      0.0 MiB       60613                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40    101.6 MiB      0.0 MiB      127287               if temp_g_score < g_score[neighbor]:
    41    101.6 MiB      1.0 MiB       23695                   came_from[neighbor] = current
    42    101.6 MiB      0.0 MiB       23695                   g_score[neighbor] = temp_g_score
    43    101.6 MiB      0.0 MiB       23695                   open_set.put((temp_g_score, neighbor))
    44                                         
    45    101.6 MiB      0.0 MiB       23413           if draw is not None:
    46                                                     draw()
    47                                                     
    48    101.6 MiB      0.0 MiB       23413           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52    101.6 MiB      0.0 MiB           1       paths = {}
    53    101.6 MiB      0.0 MiB           2       for goal in goals:
    54    101.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56    101.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5    103.5 MiB    103.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7    103.5 MiB  -1247.5 MiB         257       for row in grid:
     8    103.5 MiB -319125.2 MiB       65792           for spot in row:
     9    103.5 MiB -317884.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     94.0 MiB     -9.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     94.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     94.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     94.0 MiB      0.0 MiB           1       came_from = {}
    18     97.7 MiB -58601.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.5 MiB     -3.2 MiB           1       g_score[start] = 0
    20                                         
    21     95.0 MiB  -7335.9 MiB        7436       while not open_set.empty():
    22     95.0 MiB  -7336.1 MiB        7436           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.0 MiB  -7336.4 MiB        7436           current = open_set.get()[1]
    28                                         
    29     95.0 MiB  -7336.6 MiB        7436           if current in remaining_goals:
    30     92.0 MiB     -3.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     92.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     92.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     95.0 MiB -47103.5 MiB       47221           for neighbor in current.neighbors:
    35     95.0 MiB -39768.8 MiB       39786               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.0 MiB -39768.5 MiB       39786               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.0 MiB -18987.0 MiB       18916                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.0 MiB -39769.5 MiB       39786               if temp_g_score < g_score[neighbor]:
    41     95.0 MiB  -7580.6 MiB        7673                   came_from[neighbor] = current
    42     95.0 MiB  -7580.8 MiB        7673                   g_score[neighbor] = temp_g_score
    43     95.0 MiB  -7580.8 MiB        7673                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.0 MiB  -7335.4 MiB        7435           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.0 MiB  -7335.6 MiB        7435           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     92.0 MiB      0.0 MiB           1       paths = {}
    53     92.0 MiB      0.0 MiB           2       for goal in goals:
    54     92.0 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     92.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     96.8 MiB     96.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     96.8 MiB      0.0 MiB         257       for row in grid:
     8     96.8 MiB      0.0 MiB       65792           for spot in row:
     9     96.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     96.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     96.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     96.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     96.8 MiB      0.0 MiB           1       came_from = {}
    18    100.4 MiB -18659.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     99.5 MiB     -1.0 MiB           1       g_score[start] = 0
    20                                         
    21     99.6 MiB -11031.0 MiB       19383       while not open_set.empty():
    22     99.6 MiB -11031.1 MiB       19383           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     99.6 MiB -11031.2 MiB       19383           current = open_set.get()[1]
    28                                         
    29     99.6 MiB -11031.2 MiB       19383           if current in remaining_goals:
    30     99.0 MiB     -0.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     99.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     99.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     99.6 MiB -70731.7 MiB      124653           for neighbor in current.neighbors:
    35     99.6 MiB -59701.1 MiB      105271               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     99.6 MiB -59701.2 MiB      105271               if current.row != neighbor.row and current.col != neighbor.col:
    38     99.6 MiB -28411.2 MiB       50181                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     99.6 MiB -59701.4 MiB      105271               if temp_g_score < g_score[neighbor]:
    41     99.6 MiB -11043.9 MiB       19672                   came_from[neighbor] = current
    42     99.6 MiB -11044.0 MiB       19672                   g_score[neighbor] = temp_g_score
    43     99.6 MiB -11044.1 MiB       19672                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     99.6 MiB -11030.8 MiB       19382           if draw is not None:
    46                                                     draw()
    47                                                     
    48     99.6 MiB -11030.9 MiB       19382           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     99.0 MiB      0.0 MiB           1       paths = {}
    53     99.0 MiB      0.0 MiB           2       for goal in goals:
    54     99.0 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     99.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     99.6 MiB     99.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     99.6 MiB  -1418.9 MiB         257       for row in grid:
     8     99.6 MiB -363326.9 MiB       65792           for spot in row:
     9     99.6 MiB -361915.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.1 MiB    -10.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.1 MiB      0.0 MiB           1       came_from = {}
    18     91.8 MiB -52563.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.9 MiB  -3600.6 MiB        8540       while not open_set.empty():
    22     92.9 MiB  -3600.7 MiB        8540           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.9 MiB  -3601.1 MiB        8540           current = open_set.get()[1]
    28                                         
    29     92.9 MiB  -3601.2 MiB        8540           if current in remaining_goals:
    30     87.1 MiB     -5.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     87.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     87.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.9 MiB -23112.7 MiB       55003           for neighbor in current.neighbors:
    35     92.9 MiB -19513.8 MiB       46464               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.9 MiB -19514.1 MiB       46464               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.9 MiB  -9241.4 MiB       22124                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.9 MiB -19515.8 MiB       46464               if temp_g_score < g_score[neighbor]:
    41     92.9 MiB  -3575.8 MiB        8766                   came_from[neighbor] = current
    42     92.9 MiB  -3576.0 MiB        8766                   g_score[neighbor] = temp_g_score
    43     92.9 MiB  -3576.0 MiB        8766                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.9 MiB  -3600.3 MiB        8539           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.9 MiB  -3600.3 MiB        8539           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     87.1 MiB      0.0 MiB           1       paths = {}
    53     87.1 MiB      0.0 MiB           2       for goal in goals:
    54     87.1 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     87.1 MiB      0.0 MiB           1       return paths


