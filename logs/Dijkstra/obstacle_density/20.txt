Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.3 MiB     67.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/20.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     67.6 MiB  -2884.5 MiB         257       for row in grid:
     8     67.6 MiB -739522.8 MiB       65792           for spot in row:
     9     67.6 MiB -736642.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     58.0 MiB     -9.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     58.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     58.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     58.1 MiB      0.0 MiB           1       came_from = {}
    18     64.4 MiB  -8204.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     64.1 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     64.4 MiB -1034026.4 MiB       41849       while not open_set.empty():
    22     64.4 MiB -1034026.7 MiB       41849           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     64.4 MiB -1034027.2 MiB       41849           current = open_set.get()[1]
    28                                         
    29     64.4 MiB -1034027.7 MiB       41849           if current in remaining_goals:
    30     40.8 MiB    -23.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     40.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     64.4 MiB -7518642.7 MiB      304317           for neighbor in current.neighbors:
    35     64.4 MiB -6484630.4 MiB      262469               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     64.4 MiB -6484619.8 MiB      262469               if current.row != neighbor.row and current.col != neighbor.col:
    38     64.4 MiB -3170318.4 MiB      128350                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     64.4 MiB -6484639.9 MiB      262469               if temp_g_score < g_score[neighbor]:
    41     64.4 MiB -1039994.4 MiB       42249                   came_from[neighbor] = current
    42     64.4 MiB -1039994.6 MiB       42249                   g_score[neighbor] = temp_g_score
    43     64.4 MiB -1039995.2 MiB       42249                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     64.4 MiB -1034024.5 MiB       41848           if draw is not None:
    46                                                     draw()
    47                                                     
    48     64.4 MiB -1034025.1 MiB       41848           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.8 MiB      0.0 MiB           1       paths = {}
    53     41.0 MiB      0.0 MiB           2       for goal in goals:
    54     41.0 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.0 MiB     88.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.0 MiB   -560.9 MiB         257       for row in grid:
     8     88.0 MiB -144156.2 MiB       65792           for spot in row:
     9     88.0 MiB -143590.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB     -2.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     90.9 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.0 MiB -1716498.7 MiB       29602       while not open_set.empty():
    22     91.0 MiB -1716501.1 MiB       29602           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.0 MiB -1716504.3 MiB       29602           current = open_set.get()[1]
    28                                         
    29     91.0 MiB -1716506.4 MiB       29602           if current in remaining_goals:
    30     31.6 MiB    -59.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     31.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     31.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.0 MiB -12457443.2 MiB      214548           for neighbor in current.neighbors:
    35     91.0 MiB -10740992.9 MiB      184947               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.0 MiB -10740992.4 MiB      184947               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.0 MiB -5248437.0 MiB       90362                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.0 MiB -10741013.2 MiB      184947               if temp_g_score < g_score[neighbor]:
    41     91.0 MiB -1732175.8 MiB       29948                   came_from[neighbor] = current
    42     91.0 MiB -1732177.5 MiB       29948                   g_score[neighbor] = temp_g_score
    43     91.0 MiB -1732183.1 MiB       29948                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.0 MiB -1716494.7 MiB       29601           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.0 MiB -1716495.6 MiB       29601           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.6 MiB      0.0 MiB           1       paths = {}
    53     31.8 MiB      0.0 MiB           2       for goal in goals:
    54     31.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     81.3 MiB     81.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     81.3 MiB  -8344.6 MiB         257       for row in grid:
     8     81.3 MiB -2135128.6 MiB       65792           for spot in row:
     9     81.3 MiB -2126798.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     26.5 MiB    -54.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     26.9 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     27.1 MiB      0.2 MiB           1       open_set.put((0, start))
    17     27.1 MiB      0.0 MiB           1       came_from = {}
    18     40.5 MiB   -365.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     40.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     41.8 MiB -412156.3 MiB       35068       while not open_set.empty():
    22     41.8 MiB -412157.6 MiB       35068           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     41.8 MiB -412159.6 MiB       35068           current = open_set.get()[1]
    28                                         
    29     41.8 MiB -412160.6 MiB       35068           if current in remaining_goals:
    30     31.0 MiB    -10.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     31.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     31.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     41.8 MiB -2997828.4 MiB      255371           for neighbor in current.neighbors:
    35     41.8 MiB -2585685.7 MiB      220304               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     41.8 MiB -2585678.0 MiB      220304               if current.row != neighbor.row and current.col != neighbor.col:
    38     41.8 MiB -1264232.3 MiB      107742                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     41.8 MiB -2585694.5 MiB      220304               if temp_g_score < g_score[neighbor]:
    41     41.8 MiB -415545.5 MiB       35437                   came_from[neighbor] = current
    42     41.8 MiB -415546.6 MiB       35437                   g_score[neighbor] = temp_g_score
    43     41.8 MiB -415551.9 MiB       35437                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     41.8 MiB -412154.0 MiB       35067           if draw is not None:
    46                                                     draw()
    47                                                     
    48     41.8 MiB -412155.2 MiB       35067           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.0 MiB      0.0 MiB           1       paths = {}
    53     31.2 MiB      0.0 MiB           2       for goal in goals:
    54     31.2 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.4 MiB  -2726.8 MiB         257       for row in grid:
     8     86.4 MiB -692104.4 MiB       65792           for spot in row:
     9     86.4 MiB -689407.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     33.7 MiB    -52.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     34.1 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     34.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     34.3 MiB      0.0 MiB           1       came_from = {}
    18     42.0 MiB -120742.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     40.4 MiB     -1.7 MiB           1       g_score[start] = 0
    20                                         
    21     41.9 MiB -161172.4 MiB       12851       while not open_set.empty():
    22     41.9 MiB -161173.5 MiB       12851           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     41.9 MiB -161173.8 MiB       12851           current = open_set.get()[1]
    28                                         
    29     41.9 MiB -161175.1 MiB       12851           if current in remaining_goals:
    30     29.5 MiB    -12.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     41.9 MiB -1157471.4 MiB       92622           for neighbor in current.neighbors:
    35     41.9 MiB -996303.3 MiB       79772               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     41.9 MiB -996300.2 MiB       79772               if current.row != neighbor.row and current.col != neighbor.col:
    38     41.9 MiB -486440.6 MiB       38984                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     41.9 MiB -996310.1 MiB       79772               if temp_g_score < g_score[neighbor]:
    41     41.9 MiB -163317.4 MiB       13124                   came_from[neighbor] = current
    42     41.9 MiB -163318.2 MiB       13124                   g_score[neighbor] = temp_g_score
    43     41.9 MiB -163319.7 MiB       13124                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     41.9 MiB -161171.7 MiB       12850           if draw is not None:
    46                                                     draw()
    47                                                     
    48     41.9 MiB -161171.9 MiB       12850           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.5 MiB      0.0 MiB           1       paths = {}
    53     29.6 MiB      0.0 MiB           2       for goal in goals:
    54     29.6 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.6 MiB  -2464.0 MiB         257       for row in grid:
     8     86.6 MiB -629128.6 MiB       65792           for spot in row:
     9     86.6 MiB -626708.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     35.3 MiB    -51.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     35.7 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     35.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     35.9 MiB      0.0 MiB           1       came_from = {}
    18     47.1 MiB -67085.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     33.7 MiB    -13.4 MiB           1       g_score[start] = 0
    20                                         
    21     36.1 MiB -110559.3 MiB       29695       while not open_set.empty():
    22     36.1 MiB -110560.5 MiB       29695           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     36.1 MiB -110564.9 MiB       29695           current = open_set.get()[1]
    28                                         
    29     36.1 MiB -110566.0 MiB       29695           if current in remaining_goals:
    30     33.7 MiB     -2.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     33.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     36.1 MiB -800194.0 MiB      215342           for neighbor in current.neighbors:
    35     36.1 MiB -689654.2 MiB      185648               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     36.1 MiB -689643.0 MiB      185648               if current.row != neighbor.row and current.col != neighbor.col:
    38     36.1 MiB -336880.8 MiB       90729                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     36.1 MiB -689656.5 MiB      185648               if temp_g_score < g_score[neighbor]:
    41     36.1 MiB -113110.8 MiB       30075                   came_from[neighbor] = current
    42     36.1 MiB -113112.0 MiB       30075                   g_score[neighbor] = temp_g_score
    43     36.1 MiB -113112.7 MiB       30075                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     36.1 MiB -110554.5 MiB       29694           if draw is not None:
    46                                                     draw()
    47                                                     
    48     36.1 MiB -110556.9 MiB       29694           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.8 MiB      0.0 MiB           1       paths = {}
    53     34.0 MiB      0.0 MiB           2       for goal in goals:
    54     34.0 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.2 MiB     86.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.2 MiB  -9290.4 MiB         257       for row in grid:
     8     86.2 MiB -2380847.0 MiB       65792           for spot in row:
     9     86.2 MiB -2371606.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     33.9 MiB    -52.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     34.2 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     34.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     34.5 MiB      0.0 MiB           1       came_from = {}
    18     46.6 MiB  -3375.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     46.4 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     48.3 MiB -329151.0 MiB       25537       while not open_set.empty():
    22     48.3 MiB -329151.4 MiB       25537           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     48.3 MiB -329153.4 MiB       25537           current = open_set.get()[1]
    28                                         
    29     48.3 MiB -329154.3 MiB       25537           if current in remaining_goals:
    30     32.0 MiB    -16.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     48.3 MiB -2384271.1 MiB      185141           for neighbor in current.neighbors:
    35     48.3 MiB -2055131.4 MiB      159605               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     48.3 MiB -2055132.3 MiB      159605               if current.row != neighbor.row and current.col != neighbor.col:
    38     48.3 MiB -1004397.3 MiB       78022                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     48.3 MiB -2055142.4 MiB      159605               if temp_g_score < g_score[neighbor]:
    41     48.3 MiB -330732.3 MiB       25875                   came_from[neighbor] = current
    42     48.3 MiB -330733.9 MiB       25875                   g_score[neighbor] = temp_g_score
    43     48.3 MiB -330736.1 MiB       25875                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     48.3 MiB -329147.0 MiB       25536           if draw is not None:
    46                                                     draw()
    47                                                     
    48     48.3 MiB -329148.0 MiB       25536           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.0 MiB      0.0 MiB           1       paths = {}
    53     32.1 MiB      0.0 MiB           2       for goal in goals:
    54     32.1 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.2 MiB     84.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.2 MiB   -320.3 MiB         257       for row in grid:
     8     84.2 MiB -81213.4 MiB       65792           for spot in row:
     9     84.2 MiB -80896.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     77.8 MiB     -6.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     78.0 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     78.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     78.2 MiB      0.0 MiB           1       came_from = {}
    18     83.3 MiB -15272.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     82.9 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     83.1 MiB -1973064.7 MiB       41216       while not open_set.empty():
    22     83.1 MiB -1973065.9 MiB       41216           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     83.1 MiB -1973067.9 MiB       41216           current = open_set.get()[1]
    28                                         
    29     83.1 MiB -1973071.5 MiB       41216           if current in remaining_goals:
    30     38.0 MiB    -45.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     38.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     83.1 MiB -14260051.2 MiB      297823           for neighbor in current.neighbors:
    35     83.1 MiB -12287012.5 MiB      256608               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     83.1 MiB -12287008.0 MiB      256608               if current.row != neighbor.row and current.col != neighbor.col:
    38     83.1 MiB -6002076.9 MiB      125334                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     83.1 MiB -12287037.3 MiB      256608               if temp_g_score < g_score[neighbor]:
    41     83.1 MiB -1979380.1 MiB       41526                   came_from[neighbor] = current
    42     83.1 MiB -1979381.9 MiB       41526                   g_score[neighbor] = temp_g_score
    43     83.1 MiB -1979383.7 MiB       41526                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     83.1 MiB -1973060.3 MiB       41215           if draw is not None:
    46                                                     draw()
    47                                                     
    48     83.1 MiB -1973063.9 MiB       41215           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.0 MiB      0.0 MiB           1       paths = {}
    53     38.1 MiB      0.0 MiB           2       for goal in goals:
    54     38.1 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.3 MiB     84.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.3 MiB  -1208.0 MiB         257       for row in grid:
     8     84.3 MiB -308827.7 MiB       65792           for spot in row:
     9     84.3 MiB -307624.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     76.8 MiB     -7.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     77.0 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     77.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     77.2 MiB      0.0 MiB           1       came_from = {}
    18     81.9 MiB  -7039.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     81.8 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     81.9 MiB -395160.4 MiB        9398       while not open_set.empty():
    22     81.9 MiB -395165.2 MiB        9398           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.9 MiB -395177.5 MiB        9398           current = open_set.get()[1]
    28                                         
    29     81.9 MiB -395178.2 MiB        9398           if current in remaining_goals:
    30     27.2 MiB    -54.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     27.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     27.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.9 MiB -2843623.1 MiB       67770           for neighbor in current.neighbors:
    35     81.9 MiB -2448468.7 MiB       58373               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.9 MiB -2448465.1 MiB       58373               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.9 MiB -1194026.6 MiB       28487                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.9 MiB -2448471.9 MiB       58373               if temp_g_score < g_score[neighbor]:
    41     81.9 MiB -397111.2 MiB        9578                   came_from[neighbor] = current
    42     81.9 MiB -397111.3 MiB        9578                   g_score[neighbor] = temp_g_score
    43     81.9 MiB -397111.5 MiB        9578                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.9 MiB -395158.4 MiB        9397           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.9 MiB -395159.5 MiB        9397           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.2 MiB      0.0 MiB           1       paths = {}
    53     27.4 MiB      0.0 MiB           2       for goal in goals:
    54     27.4 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     82.5 MiB     82.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     82.5 MiB   -933.4 MiB         257       for row in grid:
     8     82.5 MiB -237848.1 MiB       65792           for spot in row:
     9     82.5 MiB -236943.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     50.1 MiB    -32.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     50.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     50.6 MiB      0.2 MiB           1       open_set.put((0, start))
    17     50.6 MiB      0.0 MiB           1       came_from = {}
    18     53.7 MiB -988099.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     40.8 MiB    -13.0 MiB           1       g_score[start] = 0
    20                                         
    21     41.0 MiB -210278.4 MiB       23358       while not open_set.empty():
    22     41.0 MiB -210279.3 MiB       23358           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     41.0 MiB -210281.9 MiB       23358           current = open_set.get()[1]
    28                                         
    29     41.0 MiB -210282.5 MiB       23358           if current in remaining_goals:
    30     32.3 MiB     -8.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     41.0 MiB -1523214.3 MiB      169103           for neighbor in current.neighbors:
    35     41.0 MiB -1312941.9 MiB      145746               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     41.0 MiB -1312936.5 MiB      145746               if current.row != neighbor.row and current.col != neighbor.col:
    38     41.0 MiB -641553.7 MiB       71192                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     41.0 MiB -1312943.5 MiB      145746               if temp_g_score < g_score[neighbor]:
    41     41.0 MiB -211756.1 MiB       23668                   came_from[neighbor] = current
    42     41.0 MiB -211757.1 MiB       23668                   g_score[neighbor] = temp_g_score
    43     41.0 MiB -211758.4 MiB       23668                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     41.0 MiB -210277.4 MiB       23357           if draw is not None:
    46                                                     draw()
    47                                                     
    48     41.0 MiB -210278.0 MiB       23357           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.3 MiB      0.0 MiB           1       paths = {}
    53     32.7 MiB      0.0 MiB           2       for goal in goals:
    54     32.7 MiB      0.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     82.9 MiB     82.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     82.9 MiB   -473.9 MiB         257       for row in grid:
     8     82.9 MiB -121216.5 MiB       65792           for spot in row:
     9     82.9 MiB -120745.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.8 MiB     -3.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     79.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     79.9 MiB      0.0 MiB           1       came_from = {}
    18     85.3 MiB -23904.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     81.4 MiB     -3.9 MiB           1       g_score[start] = 0
    20                                         
    21     81.7 MiB -2013515.1 MiB       51214       while not open_set.empty():
    22     81.7 MiB -2013516.6 MiB       51214           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.7 MiB -2013518.9 MiB       51214           current = open_set.get()[1]
    28                                         
    29     81.7 MiB -2013533.5 MiB       51214           if current in remaining_goals:
    30     43.7 MiB    -38.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     43.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.7 MiB -14582414.7 MiB      370949           for neighbor in current.neighbors:
    35     81.7 MiB -12568919.7 MiB      319736               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.7 MiB -12568915.0 MiB      319736               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.7 MiB -6137796.9 MiB      156157                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.7 MiB -12568922.9 MiB      319736               if temp_g_score < g_score[neighbor]:
    41     81.7 MiB -2008668.7 MiB       51322                   came_from[neighbor] = current
    42     81.7 MiB -2008677.6 MiB       51322                   g_score[neighbor] = temp_g_score
    43     81.7 MiB -2008678.5 MiB       51322                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.7 MiB -2013512.3 MiB       51213           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.7 MiB -2013514.2 MiB       51213           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.7 MiB      0.0 MiB           1       paths = {}
    53     44.1 MiB      0.0 MiB           2       for goal in goals:
    54     44.1 MiB      0.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.0 MiB     85.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.0 MiB   -320.2 MiB         257       for row in grid:
     8     85.0 MiB -81995.8 MiB       65792           for spot in row:
     9     85.0 MiB -81677.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.2 MiB     -1.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.3 MiB      0.0 MiB           1       came_from = {}
    18     87.0 MiB -23504.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.9 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     87.0 MiB -1621131.8 MiB       49106       while not open_set.empty():
    22     87.0 MiB -1621132.9 MiB       49106           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.0 MiB -1621135.3 MiB       49106           current = open_set.get()[1]
    28                                         
    29     87.0 MiB -1621136.5 MiB       49106           if current in remaining_goals:
    30     44.3 MiB    -42.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     44.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.0 MiB -11777770.4 MiB      356385           for neighbor in current.neighbors:
    35     87.0 MiB -10156663.3 MiB      307280               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.0 MiB -10156663.1 MiB      307280               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.0 MiB -4964029.9 MiB      150206                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.0 MiB -10156675.9 MiB      307280               if temp_g_score < g_score[neighbor]:
    41     87.0 MiB -1618708.1 MiB       49363                   came_from[neighbor] = current
    42     87.0 MiB -1618710.7 MiB       49363                   g_score[neighbor] = temp_g_score
    43     87.0 MiB -1618715.7 MiB       49363                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.0 MiB -1621128.3 MiB       49105           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.0 MiB -1621129.7 MiB       49105           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.3 MiB      0.0 MiB           1       paths = {}
    53     44.5 MiB      0.0 MiB           2       for goal in goals:
    54     44.5 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     82.2 MiB     82.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     82.2 MiB      0.0 MiB         257       for row in grid:
     8     82.2 MiB      0.0 MiB       65792           for spot in row:
     9     82.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.2 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.2 MiB      0.0 MiB           1       came_from = {}
    18     85.6 MiB -25008.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.3 MiB     -0.3 MiB           1       g_score[start] = 0
    20                                         
    21     85.4 MiB -2165998.3 MiB       49043       while not open_set.empty():
    22     85.4 MiB -2166000.5 MiB       49043           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.4 MiB -2166004.1 MiB       49043           current = open_set.get()[1]
    28                                         
    29     85.4 MiB -2166005.0 MiB       49043           if current in remaining_goals:
    30     42.0 MiB    -43.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     42.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     85.4 MiB -15744619.4 MiB      356178           for neighbor in current.neighbors:
    35     85.4 MiB -13578637.2 MiB      307136               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.4 MiB -13578637.1 MiB      307136               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.4 MiB -6638670.6 MiB      150123                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.4 MiB -13578644.8 MiB      307136               if temp_g_score < g_score[neighbor]:
    41     85.4 MiB -2166652.6 MiB       49309                   came_from[neighbor] = current
    42     85.4 MiB -2166653.8 MiB       49309                   g_score[neighbor] = temp_g_score
    43     85.4 MiB -2166654.3 MiB       49309                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.4 MiB -2165994.3 MiB       49042           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.4 MiB -2165996.9 MiB       49042           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.0 MiB      0.0 MiB           1       paths = {}
    53     42.9 MiB      0.0 MiB           2       for goal in goals:
    54     42.9 MiB      1.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.9 MiB     85.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.9 MiB   -278.3 MiB         257       for row in grid:
     8     85.9 MiB -70914.9 MiB       65792           for spot in row:
     9     85.9 MiB -70640.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.7 MiB     -5.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.9 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     81.1 MiB      0.2 MiB           1       open_set.put((0, start))
    17     81.1 MiB      0.0 MiB           1       came_from = {}
    18     84.8 MiB -21709.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     84.8 MiB -888543.2 MiB       20574       while not open_set.empty():
    22     84.8 MiB -888543.9 MiB       20574           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.8 MiB -888545.3 MiB       20574           current = open_set.get()[1]
    28                                         
    29     84.8 MiB -888545.9 MiB       20574           if current in remaining_goals:
    30     35.9 MiB    -49.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.8 MiB -6436719.9 MiB      149241           for neighbor in current.neighbors:
    35     84.8 MiB -5548192.6 MiB      128668               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.8 MiB -5548192.4 MiB      128668               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.8 MiB -2709623.1 MiB       62872                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.8 MiB -5548205.4 MiB      128668               if temp_g_score < g_score[neighbor]:
    41     84.8 MiB -894189.9 MiB       20903                   came_from[neighbor] = current
    42     84.8 MiB -894190.8 MiB       20903                   g_score[neighbor] = temp_g_score
    43     84.8 MiB -894193.3 MiB       20903                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.8 MiB -888540.3 MiB       20573           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.8 MiB -888542.3 MiB       20573           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.9 MiB      0.0 MiB           1       paths = {}
    53     36.0 MiB      0.0 MiB           2       for goal in goals:
    54     36.0 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.1 MiB     86.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.1 MiB   -499.0 MiB         257       for row in grid:
     8     86.1 MiB -127881.2 MiB       65792           for spot in row:
     9     86.1 MiB -127384.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.0 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.0 MiB      0.0 MiB           1       came_from = {}
    18     88.3 MiB    -89.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.3 MiB -1417525.5 MiB       27403       while not open_set.empty():
    22     88.3 MiB -1417526.3 MiB       27403           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.3 MiB -1417527.2 MiB       27403           current = open_set.get()[1]
    28                                         
    29     88.3 MiB -1417527.9 MiB       27403           if current in remaining_goals:
    30     42.1 MiB    -46.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     42.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.3 MiB -10250871.8 MiB      198426           for neighbor in current.neighbors:
    35     88.3 MiB -8833393.1 MiB      171024               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.3 MiB -8833388.5 MiB      171024               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.3 MiB -4311287.5 MiB       83502                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.3 MiB -8833393.2 MiB      171024               if temp_g_score < g_score[neighbor]:
    41     88.3 MiB -1430294.7 MiB       27747                   came_from[neighbor] = current
    42     88.3 MiB -1430295.4 MiB       27747                   g_score[neighbor] = temp_g_score
    43     88.3 MiB -1430300.1 MiB       27747                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.3 MiB -1417490.0 MiB       27402           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.3 MiB -1417524.8 MiB       27402           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.1 MiB      0.0 MiB           1       paths = {}
    53     42.3 MiB      0.0 MiB           2       for goal in goals:
    54     42.3 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.7 MiB     86.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.7 MiB  -2121.5 MiB         257       for row in grid:
     8     86.7 MiB -543085.6 MiB       65792           for spot in row:
     9     86.7 MiB -540975.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     72.7 MiB    -14.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     72.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     72.7 MiB      0.0 MiB           1       came_from = {}
    18     80.1 MiB   -190.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     80.1 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     80.2 MiB -1414704.9 MiB       34830       while not open_set.empty():
    22     80.2 MiB -1414705.1 MiB       34830           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     80.2 MiB -1414705.9 MiB       34830           current = open_set.get()[1]
    28                                         
    29     80.2 MiB -1414709.2 MiB       34830           if current in remaining_goals:
    30     30.4 MiB    -49.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     30.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     80.2 MiB -10277185.1 MiB      253203           for neighbor in current.neighbors:
    35     80.2 MiB -8862484.9 MiB      218374               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     80.2 MiB -8862479.2 MiB      218374               if current.row != neighbor.row and current.col != neighbor.col:
    38     80.2 MiB -4333327.4 MiB      106790                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     80.2 MiB -8862522.7 MiB      218374               if temp_g_score < g_score[neighbor]:
    41     80.2 MiB -1425644.7 MiB       35215                   came_from[neighbor] = current
    42     80.2 MiB -1425646.1 MiB       35215                   g_score[neighbor] = temp_g_score
    43     80.2 MiB -1425647.0 MiB       35215                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     80.2 MiB -1414704.1 MiB       34829           if draw is not None:
    46                                                     draw()
    47                                                     
    48     80.2 MiB -1414704.6 MiB       34829           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.4 MiB      0.0 MiB           1       paths = {}
    53     30.8 MiB      0.0 MiB           2       for goal in goals:
    54     30.8 MiB      0.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.3 MiB     84.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.3 MiB  -1124.0 MiB         257       for row in grid:
     8     84.3 MiB -287510.5 MiB       65792           for spot in row:
     9     84.3 MiB -286391.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     77.3 MiB     -7.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     77.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     77.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     77.3 MiB      0.0 MiB           1       came_from = {}
    18     82.1 MiB -27979.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     79.9 MiB     -2.2 MiB           1       g_score[start] = 0
    20                                         
    21     80.0 MiB -2026818.8 MiB       44752       while not open_set.empty():
    22     80.0 MiB -2026819.0 MiB       44752           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     80.0 MiB -2026819.4 MiB       44752           current = open_set.get()[1]
    28                                         
    29     80.0 MiB -2026819.7 MiB       44752           if current in remaining_goals:
    30     42.3 MiB    -37.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     42.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     80.0 MiB -14753614.3 MiB      325813           for neighbor in current.neighbors:
    35     80.0 MiB -12726802.9 MiB      281062               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     80.0 MiB -12726791.3 MiB      281062               if current.row != neighbor.row and current.col != neighbor.col:
    38     80.0 MiB -6220046.0 MiB      137363                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     80.0 MiB -12726799.9 MiB      281062               if temp_g_score < g_score[neighbor]:
    41     80.0 MiB -2036146.0 MiB       45003                   came_from[neighbor] = current
    42     80.0 MiB -2036171.9 MiB       45003                   g_score[neighbor] = temp_g_score
    43     80.0 MiB -2036172.7 MiB       45003                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     80.0 MiB -2026816.3 MiB       44751           if draw is not None:
    46                                                     draw()
    47                                                     
    48     80.0 MiB -2026818.1 MiB       44751           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.3 MiB      0.0 MiB           1       paths = {}
    53     43.1 MiB      0.0 MiB           2       for goal in goals:
    54     43.1 MiB      0.8 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.2 MiB     86.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.2 MiB   -224.8 MiB         257       for row in grid:
     8     86.2 MiB -57456.6 MiB       65792           for spot in row:
     9     86.2 MiB -57232.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.6 MiB     -2.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.6 MiB      0.0 MiB           1       came_from = {}
    18     88.8 MiB      5.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.8 MiB -688266.3 MiB       23700       while not open_set.empty():
    22     88.8 MiB -688269.3 MiB       23700           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.8 MiB -688271.8 MiB       23700           current = open_set.get()[1]
    28                                         
    29     88.8 MiB -688275.4 MiB       23700           if current in remaining_goals:
    30     43.8 MiB    -45.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     43.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.8 MiB -4998003.8 MiB      172011           for neighbor in current.neighbors:
    35     88.8 MiB -4309748.0 MiB      148312               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.8 MiB -4309749.2 MiB      148312               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.8 MiB -2106140.6 MiB       72487                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.8 MiB -4309756.7 MiB      148312               if temp_g_score < g_score[neighbor]:
    41     88.8 MiB -692932.5 MiB       24065                   came_from[neighbor] = current
    42     88.8 MiB -692933.1 MiB       24065                   g_score[neighbor] = temp_g_score
    43     88.8 MiB -692935.7 MiB       24065                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.8 MiB -688264.0 MiB       23699           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.8 MiB -688265.1 MiB       23699           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.8 MiB      0.0 MiB           1       paths = {}
    53     44.0 MiB      0.0 MiB           2       for goal in goals:
    54     44.0 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.2 MiB     84.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.2 MiB   -393.9 MiB         257       for row in grid:
     8     84.2 MiB -100221.1 MiB       65792           for spot in row:
     9     84.2 MiB -99830.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     78.5 MiB     -5.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     78.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     78.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     78.5 MiB      0.0 MiB           1       came_from = {}
    18     85.2 MiB -28746.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     83.9 MiB     -1.4 MiB           1       g_score[start] = 0
    20                                         
    21     84.1 MiB -1183871.1 MiB       28061       while not open_set.empty():
    22     84.1 MiB -1183871.7 MiB       28061           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.1 MiB -1183873.1 MiB       28061           current = open_set.get()[1]
    28                                         
    29     84.1 MiB -1183875.8 MiB       28061           if current in remaining_goals:
    30     37.7 MiB    -46.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     37.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.1 MiB -8568145.6 MiB      203350           for neighbor in current.neighbors:
    35     84.1 MiB -7384298.6 MiB      175290               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.1 MiB -7384304.1 MiB      175290               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.1 MiB -3607251.3 MiB       85620                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.1 MiB -7384315.0 MiB      175290               if temp_g_score < g_score[neighbor]:
    41     84.1 MiB -1193356.3 MiB       28387                   came_from[neighbor] = current
    42     84.1 MiB -1193358.2 MiB       28387                   g_score[neighbor] = temp_g_score
    43     84.1 MiB -1193360.6 MiB       28387                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.1 MiB -1183869.8 MiB       28060           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.1 MiB -1183870.3 MiB       28060           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.7 MiB      0.0 MiB           1       paths = {}
    53     37.9 MiB      0.0 MiB           2       for goal in goals:
    54     37.9 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     82.5 MiB     82.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     82.5 MiB    -92.5 MiB         257       for row in grid:
     8     82.5 MiB -23474.4 MiB       65792           for spot in row:
     9     82.5 MiB -23383.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.0 MiB     -2.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     80.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     80.0 MiB      0.0 MiB           1       came_from = {}
    18     83.9 MiB -40124.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     83.7 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     84.1 MiB -1005212.7 MiB       23793       while not open_set.empty():
    22     84.0 MiB -1005217.4 MiB       23793           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.0 MiB -1004867.5 MiB       23793           current = open_set.get()[1]
    28                                         
    29     84.0 MiB -1004871.1 MiB       23793           if current in remaining_goals:
    30     33.9 MiB    -50.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     33.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.1 MiB -7292621.5 MiB      172836           for neighbor in current.neighbors:
    35     84.1 MiB -6287779.0 MiB      149044               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.1 MiB -6287783.2 MiB      149044               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.1 MiB -3072124.5 MiB       72843                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.1 MiB -6287792.8 MiB      149044               if temp_g_score < g_score[neighbor]:
    41     84.1 MiB -1014042.1 MiB       24184                   came_from[neighbor] = current
    42     84.1 MiB -1014045.3 MiB       24184                   g_score[neighbor] = temp_g_score
    43     84.1 MiB -1014048.4 MiB       24184                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.1 MiB -1005208.3 MiB       23792           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.1 MiB -1005209.2 MiB       23792           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.9 MiB      0.0 MiB           1       paths = {}
    53     34.0 MiB      0.0 MiB           2       for goal in goals:
    54     34.0 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     83.4 MiB     83.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     83.4 MiB   -125.4 MiB         257       for row in grid:
     8     83.4 MiB -32158.1 MiB       65792           for spot in row:
     9     83.4 MiB -32033.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.6 MiB     -0.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.6 MiB      0.0 MiB           1       came_from = {}
    18     86.9 MiB  -4325.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.6 MiB     -0.3 MiB           1       g_score[start] = 0
    20                                         
    21     86.8 MiB -626442.5 MiB       20527       while not open_set.empty():
    22     86.8 MiB -626442.9 MiB       20527           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.8 MiB -626443.9 MiB       20527           current = open_set.get()[1]
    28                                         
    29     86.8 MiB -626462.8 MiB       20527           if current in remaining_goals:
    30     36.2 MiB    -50.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     36.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.8 MiB -4553708.9 MiB      149236           for neighbor in current.neighbors:
    35     86.8 MiB -3927275.2 MiB      128710               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.8 MiB -3927278.8 MiB      128710               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.8 MiB -1921461.3 MiB       62934                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.8 MiB -3927284.0 MiB      128710               if temp_g_score < g_score[neighbor]:
    41     86.8 MiB -631862.0 MiB       20811                   came_from[neighbor] = current
    42     86.8 MiB -631862.5 MiB       20811                   g_score[neighbor] = temp_g_score
    43     86.8 MiB -631863.0 MiB       20811                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.8 MiB -626441.5 MiB       20526           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.8 MiB -626442.1 MiB       20526           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.2 MiB      0.0 MiB           1       paths = {}
    53     36.3 MiB      0.0 MiB           2       for goal in goals:
    54     36.3 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.6 MiB     -6.4 MiB         257       for row in grid:
     8     86.6 MiB  -1651.4 MiB       65792           for spot in row:
     9     86.6 MiB  -1645.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.6 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.6 MiB      0.0 MiB           1       came_from = {}
    18     91.6 MiB  -1393.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.7 MiB -295163.7 MiB        7455       while not open_set.empty():
    22     91.7 MiB -295166.0 MiB        7455           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.7 MiB -295167.3 MiB        7455           current = open_set.get()[1]
    28                                         
    29     91.7 MiB -295167.9 MiB        7455           if current in remaining_goals:
    30     30.0 MiB    -61.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     30.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.7 MiB -2164734.9 MiB       54476           for neighbor in current.neighbors:
    35     91.7 MiB -1869586.3 MiB       47022               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.7 MiB -1869592.6 MiB       47022               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.7 MiB -915540.7 MiB       22999                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.7 MiB -1869598.3 MiB       47022               if temp_g_score < g_score[neighbor]:
    41     91.7 MiB -299491.2 MiB        7632                   came_from[neighbor] = current
    42     91.7 MiB -299492.1 MiB        7632                   g_score[neighbor] = temp_g_score
    43     91.7 MiB -299493.7 MiB        7632                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.7 MiB -295161.6 MiB        7454           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.7 MiB -295162.0 MiB        7454           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.0 MiB      0.0 MiB           1       paths = {}
    53     30.2 MiB      0.0 MiB           2       for goal in goals:
    54     30.2 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.7 MiB     86.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.7 MiB  -1232.9 MiB         257       for row in grid:
     8     86.7 MiB -316054.0 MiB       65792           for spot in row:
     9     86.7 MiB -314827.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     77.3 MiB     -9.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     77.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     77.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     77.3 MiB      0.0 MiB           1       came_from = {}
    18     83.6 MiB      6.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     83.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     83.8 MiB -197090.8 MiB       14689       while not open_set.empty():
    22     83.8 MiB -197091.2 MiB       14689           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     83.8 MiB -197092.5 MiB       14689           current = open_set.get()[1]
    28                                         
    29     83.8 MiB -197093.0 MiB       14689           if current in remaining_goals:
    30     43.0 MiB    -40.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     43.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     43.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     83.8 MiB -1430346.3 MiB      106362           for neighbor in current.neighbors:
    35     83.8 MiB -1233263.3 MiB       91674               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     83.8 MiB -1233266.5 MiB       91674               if current.row != neighbor.row and current.col != neighbor.col:
    38     83.8 MiB -603041.9 MiB       44759                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     83.8 MiB -1233275.5 MiB       91674               if temp_g_score < g_score[neighbor]:
    41     83.8 MiB -198648.5 MiB       14929                   came_from[neighbor] = current
    42     83.8 MiB -198649.7 MiB       14929                   g_score[neighbor] = temp_g_score
    43     83.8 MiB -198659.7 MiB       14929                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     83.8 MiB -197089.7 MiB       14688           if draw is not None:
    46                                                     draw()
    47                                                     
    48     83.8 MiB -197090.2 MiB       14688           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     43.0 MiB      0.0 MiB           1       paths = {}
    53     43.0 MiB      0.0 MiB           2       for goal in goals:
    54     43.0 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.1 MiB     87.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.1 MiB    -73.6 MiB         257       for row in grid:
     8     87.1 MiB -18831.4 MiB       65792           for spot in row:
     9     87.1 MiB -18757.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.0 MiB     -1.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.0 MiB      0.0 MiB           1       came_from = {}
    18     91.0 MiB  -1185.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.0 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.1 MiB -2140308.4 MiB       49357       while not open_set.empty():
    22     91.1 MiB -2140309.5 MiB       49357           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.1 MiB -2140312.3 MiB       49357           current = open_set.get()[1]
    28                                         
    29     91.1 MiB -2140317.5 MiB       49357           if current in remaining_goals:
    30     41.0 MiB    -50.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     41.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.1 MiB -15538765.5 MiB      358361           for neighbor in current.neighbors:
    35     91.1 MiB -13398482.8 MiB      309005               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.1 MiB -13398479.7 MiB      309005               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.1 MiB -6547807.1 MiB      151033                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.1 MiB -13398499.5 MiB      309005               if temp_g_score < g_score[neighbor]:
    41     91.1 MiB -2138503.0 MiB       49615                   came_from[neighbor] = current
    42     91.1 MiB -2138505.1 MiB       49615                   g_score[neighbor] = temp_g_score
    43     91.1 MiB -2138509.7 MiB       49615                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.1 MiB -2140306.1 MiB       49356           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.1 MiB -2140307.2 MiB       49356           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.0 MiB      0.0 MiB           1       paths = {}
    53     41.3 MiB      0.0 MiB           2       for goal in goals:
    54     41.3 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.9 MiB     85.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.9 MiB    -92.3 MiB         257       for row in grid:
     8     85.9 MiB -23043.6 MiB       65792           for spot in row:
     9     85.9 MiB -22955.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.5 MiB     -4.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     81.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     81.5 MiB      0.0 MiB           1       came_from = {}
    18     86.5 MiB  -4888.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.6 MiB     -1.9 MiB           1       g_score[start] = 0
    20                                         
    21     84.7 MiB   -622.3 MiB        2141       while not open_set.empty():
    22     84.7 MiB   -622.3 MiB        2141           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.7 MiB   -622.3 MiB        2141           current = open_set.get()[1]
    28                                         
    29     84.7 MiB   -622.3 MiB        2141           if current in remaining_goals:
    30     84.2 MiB     -0.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     84.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     84.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.7 MiB  -4576.6 MiB       15818           for neighbor in current.neighbors:
    35     84.7 MiB  -3954.4 MiB       13678               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.7 MiB  -3954.2 MiB       13678               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.7 MiB  -1946.5 MiB        6718                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.7 MiB  -3954.4 MiB       13678               if temp_g_score < g_score[neighbor]:
    41     84.7 MiB   -661.7 MiB        2331                   came_from[neighbor] = current
    42     84.7 MiB   -661.8 MiB        2331                   g_score[neighbor] = temp_g_score
    43     84.7 MiB   -661.8 MiB        2331                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.7 MiB   -622.3 MiB        2140           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.7 MiB   -622.3 MiB        2140           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     84.2 MiB      0.0 MiB           1       paths = {}
    53     84.2 MiB      0.0 MiB           2       for goal in goals:
    54     84.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     84.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.1 MiB     91.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.1 MiB  -1001.8 MiB         257       for row in grid:
     8     91.1 MiB -256802.3 MiB       65792           for spot in row:
     9     91.1 MiB -255802.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.2 MiB     -5.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.4 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     85.6 MiB      0.2 MiB           1       open_set.put((0, start))
    17     85.6 MiB      0.0 MiB           1       came_from = {}
    18     86.9 MiB -1579028.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     55.6 MiB    -31.3 MiB           1       g_score[start] = 0
    20                                         
    21     56.0 MiB -802733.2 MiB       53114       while not open_set.empty():
    22     56.0 MiB -802734.8 MiB       53114           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     56.0 MiB -802737.5 MiB       53114           current = open_set.get()[1]
    28                                         
    29     56.0 MiB -802738.8 MiB       53114           if current in remaining_goals:
    30     37.7 MiB    -18.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     37.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     56.0 MiB -5837127.7 MiB      385881           for neighbor in current.neighbors:
    35     56.0 MiB -5034412.0 MiB      332768               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     56.0 MiB -5034401.8 MiB      332768               if current.row != neighbor.row and current.col != neighbor.col:
    38     56.0 MiB -2460478.4 MiB      162629                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     56.0 MiB -5034417.2 MiB      332768               if temp_g_score < g_score[neighbor]:
    41     56.0 MiB -799079.5 MiB       53131                   came_from[neighbor] = current
    42     56.0 MiB -799081.2 MiB       53131                   g_score[neighbor] = temp_g_score
    43     56.0 MiB -799082.6 MiB       53131                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     56.0 MiB -802729.5 MiB       53113           if draw is not None:
    46                                                     draw()
    47                                                     
    48     56.0 MiB -802731.9 MiB       53113           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.7 MiB      0.0 MiB           1       paths = {}
    53     38.5 MiB      0.0 MiB           2       for goal in goals:
    54     38.5 MiB      0.8 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.2 MiB     85.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.2 MiB    -13.5 MiB         257       for row in grid:
     8     85.2 MiB  -3454.5 MiB       65792           for spot in row:
     9     85.2 MiB  -3441.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.1 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.1 MiB      0.0 MiB           1       came_from = {}
    18     87.2 MiB -19522.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.0 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     87.5 MiB      0.0 MiB        4439       while not open_set.empty():
    22     87.5 MiB      0.0 MiB        4439           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.5 MiB      0.0 MiB        4439           current = open_set.get()[1]
    28                                         
    29     87.5 MiB      0.0 MiB        4439           if current in remaining_goals:
    30     87.5 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     87.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     87.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.5 MiB      0.1 MiB       31605           for neighbor in current.neighbors:
    35     87.5 MiB      0.0 MiB       27167               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.5 MiB      0.1 MiB       27167               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.5 MiB      0.0 MiB       13222                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.5 MiB      0.0 MiB       27167               if temp_g_score < g_score[neighbor]:
    41     87.5 MiB      0.3 MiB        4567                   came_from[neighbor] = current
    42     87.5 MiB      0.0 MiB        4567                   g_score[neighbor] = temp_g_score
    43     87.5 MiB      0.0 MiB        4567                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.5 MiB      0.0 MiB        4438           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.5 MiB      0.0 MiB        4438           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     87.5 MiB      0.0 MiB           1       paths = {}
    53     87.5 MiB      0.0 MiB           2       for goal in goals:
    54     87.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     87.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.9 MiB     88.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.9 MiB    -55.9 MiB         257       for row in grid:
     8     88.9 MiB -14326.7 MiB       65792           for spot in row:
     9     88.9 MiB -14270.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.7 MiB     -0.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.7 MiB      0.0 MiB           1       came_from = {}
    18     93.8 MiB  -1526.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.8 MiB -1853439.2 MiB       39079       while not open_set.empty():
    22     93.8 MiB -1853439.8 MiB       39079           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.8 MiB -1853442.4 MiB       39079           current = open_set.get()[1]
    28                                         
    29     93.8 MiB -1853443.3 MiB       39079           if current in remaining_goals:
    30     38.8 MiB    -55.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     38.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.8 MiB -13444355.1 MiB      283356           for neighbor in current.neighbors:
    35     93.8 MiB -11590933.6 MiB      244278               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.8 MiB -11590923.5 MiB      244278               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.8 MiB -5666377.4 MiB      119371                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.8 MiB -11590937.8 MiB      244278               if temp_g_score < g_score[neighbor]:
    41     93.8 MiB -1864969.5 MiB       39448                   came_from[neighbor] = current
    42     93.8 MiB -1864970.0 MiB       39448                   g_score[neighbor] = temp_g_score
    43     93.8 MiB -1864972.1 MiB       39448                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.8 MiB -1853432.5 MiB       39078           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.8 MiB -1853436.4 MiB       39078           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.8 MiB      0.0 MiB           1       paths = {}
    53     38.9 MiB      0.0 MiB           2       for goal in goals:
    54     38.9 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     39.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.0 MiB     84.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.0 MiB      0.0 MiB         257       for row in grid:
     8     84.0 MiB      0.0 MiB       65792           for spot in row:
     9     84.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.0 MiB      0.0 MiB           1       came_from = {}
    18     88.8 MiB -155982.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     71.5 MiB    -17.3 MiB           1       g_score[start] = 0
    20                                         
    21     71.8 MiB -1320830.8 MiB       35888       while not open_set.empty():
    22     71.8 MiB -1320831.3 MiB       35888           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     71.8 MiB -1320832.4 MiB       35888           current = open_set.get()[1]
    28                                         
    29     71.8 MiB -1320835.8 MiB       35888           if current in remaining_goals:
    30     40.9 MiB    -30.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     40.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     71.8 MiB -9578335.0 MiB      260322           for neighbor in current.neighbors:
    35     71.8 MiB -8257521.6 MiB      224435               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     71.8 MiB -8257511.8 MiB      224435               if current.row != neighbor.row and current.col != neighbor.col:
    38     71.8 MiB -4033433.7 MiB      109621                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     71.8 MiB -8257521.1 MiB      224435               if temp_g_score < g_score[neighbor]:
    41     71.8 MiB -1332095.6 MiB       36163                   came_from[neighbor] = current
    42     71.8 MiB -1332099.1 MiB       36163                   g_score[neighbor] = temp_g_score
    43     71.8 MiB -1332120.6 MiB       36163                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     71.8 MiB -1320829.1 MiB       35887           if draw is not None:
    46                                                     draw()
    47                                                     
    48     71.8 MiB -1320829.7 MiB       35887           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.9 MiB      0.0 MiB           1       paths = {}
    53     41.2 MiB      0.0 MiB           2       for goal in goals:
    54     41.2 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     82.0 MiB     82.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     82.0 MiB   -548.4 MiB         257       for row in grid:
     8     82.0 MiB -139856.5 MiB       65792           for spot in row:
     9     82.0 MiB -139314.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     73.4 MiB     -8.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     73.6 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     73.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     73.8 MiB      0.0 MiB           1       came_from = {}
    18     81.5 MiB  -3937.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     81.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     81.5 MiB -1169535.0 MiB       30853       while not open_set.empty():
    22     81.5 MiB -1169536.9 MiB       30853           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.5 MiB -1169539.3 MiB       30853           current = open_set.get()[1]
    28                                         
    29     81.5 MiB -1169540.6 MiB       30853           if current in remaining_goals:
    30     34.6 MiB    -46.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.5 MiB -8510182.3 MiB      224238           for neighbor in current.neighbors:
    35     81.5 MiB -7340662.4 MiB      193386               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.5 MiB -7340666.1 MiB      193386               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.5 MiB -3589963.7 MiB       94570                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.5 MiB -7340685.4 MiB      193386               if temp_g_score < g_score[neighbor]:
    41     81.5 MiB -1176627.2 MiB       31208                   came_from[neighbor] = current
    42     81.5 MiB -1176628.9 MiB       31208                   g_score[neighbor] = temp_g_score
    43     81.5 MiB -1176631.5 MiB       31208                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.5 MiB -1169532.1 MiB       30852           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.5 MiB -1169533.0 MiB       30852           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.6 MiB      0.0 MiB           1       paths = {}
    53     35.0 MiB      0.0 MiB           2       for goal in goals:
    54     35.0 MiB      0.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.5 MiB     86.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.5 MiB    -37.3 MiB         257       for row in grid:
     8     86.5 MiB  -9385.7 MiB       65792           for spot in row:
     9     86.5 MiB  -9349.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.4 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     84.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     84.8 MiB      0.0 MiB           1       came_from = {}
    18     85.6 MiB -2660879.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     32.1 MiB    -53.5 MiB           1       g_score[start] = 0
    20                                         
    21     35.8 MiB -82394.1 MiB       20382       while not open_set.empty():
    22     35.8 MiB -82394.3 MiB       20382           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     35.8 MiB -82395.6 MiB       20382           current = open_set.get()[1]
    28                                         
    29     35.8 MiB -82396.0 MiB       20382           if current in remaining_goals:
    30     35.3 MiB     -0.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     35.8 MiB -600647.4 MiB      149011           for neighbor in current.neighbors:
    35     35.8 MiB -518261.0 MiB      128630               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     35.8 MiB -518253.3 MiB      128630               if current.row != neighbor.row and current.col != neighbor.col:
    38     35.8 MiB -253415.6 MiB       62919                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     35.8 MiB -518259.0 MiB      128630               if temp_g_score < g_score[neighbor]:
    41     35.8 MiB -83622.6 MiB       20784                   came_from[neighbor] = current
    42     35.8 MiB -83623.5 MiB       20784                   g_score[neighbor] = temp_g_score
    43     35.8 MiB -83623.6 MiB       20784                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     35.8 MiB -82391.8 MiB       20381           if draw is not None:
    46                                                     draw()
    47                                                     
    48     35.8 MiB -82392.3 MiB       20381           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.3 MiB      0.0 MiB           1       paths = {}
    53     35.5 MiB      0.0 MiB           2       for goal in goals:
    54     35.5 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.6 MiB  -3051.5 MiB         257       for row in grid:
     8     86.6 MiB -777627.2 MiB       65792           for spot in row:
     9     86.6 MiB -774629.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     21.9 MiB    -64.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     22.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     22.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     22.5 MiB      0.0 MiB           1       came_from = {}
    18     38.2 MiB -26197.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     36.7 MiB     -1.5 MiB           1       g_score[start] = 0
    20                                         
    21     43.2 MiB -170880.5 MiB       38013       while not open_set.empty():
    22     43.2 MiB -170882.4 MiB       38013           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     43.2 MiB -170883.8 MiB       38013           current = open_set.get()[1]
    28                                         
    29     43.2 MiB -170884.2 MiB       38013           if current in remaining_goals:
    30     38.2 MiB     -5.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     38.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     43.2 MiB -1236321.2 MiB      274677           for neighbor in current.neighbors:
    35     43.2 MiB -1065454.1 MiB      236665               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     43.2 MiB -1065443.9 MiB      236665               if current.row != neighbor.row and current.col != neighbor.col:
    38     43.2 MiB -520981.0 MiB      115724                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     43.2 MiB -1065451.0 MiB      236665               if temp_g_score < g_score[neighbor]:
    41     43.2 MiB -174978.1 MiB       38504                   came_from[neighbor] = current
    42     43.2 MiB -174981.8 MiB       38504                   g_score[neighbor] = temp_g_score
    43     43.2 MiB -174982.3 MiB       38504                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     43.2 MiB -170879.1 MiB       38012           if draw is not None:
    46                                                     draw()
    47                                                     
    48     43.2 MiB -170879.6 MiB       38012           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.2 MiB      0.0 MiB           1       paths = {}
    53     38.4 MiB      0.0 MiB           2       for goal in goals:
    54     38.4 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.5 MiB     86.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.5 MiB  -8428.2 MiB         257       for row in grid:
     8     86.5 MiB -2156103.6 MiB       65792           for spot in row:
     9     86.5 MiB -2147708.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     36.2 MiB    -50.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     36.6 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     36.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     36.8 MiB      0.0 MiB           1       came_from = {}
    18     49.8 MiB   -132.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     49.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     50.0 MiB -535097.2 MiB       30413       while not open_set.empty():
    22     50.0 MiB -535098.2 MiB       30413           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     50.0 MiB -535100.1 MiB       30413           current = open_set.get()[1]
    28                                         
    29     50.0 MiB -535100.8 MiB       30413           if current in remaining_goals:
    30     34.6 MiB    -15.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     50.0 MiB -3878749.7 MiB      220609           for neighbor in current.neighbors:
    35     50.0 MiB -3343664.5 MiB      190197               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     50.0 MiB -3343658.0 MiB      190197               if current.row != neighbor.row and current.col != neighbor.col:
    38     50.0 MiB -1632906.5 MiB       92886                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     50.0 MiB -3343665.4 MiB      190197               if temp_g_score < g_score[neighbor]:
    41     50.0 MiB -538090.6 MiB       30703                   came_from[neighbor] = current
    42     50.0 MiB -538092.9 MiB       30703                   g_score[neighbor] = temp_g_score
    43     50.0 MiB -538093.3 MiB       30703                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     50.0 MiB -535095.4 MiB       30412           if draw is not None:
    46                                                     draw()
    47                                                     
    48     50.0 MiB -535095.8 MiB       30412           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.6 MiB      0.0 MiB           1       paths = {}
    53     34.9 MiB      0.0 MiB           2       for goal in goals:
    54     34.9 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.4 MiB   -145.8 MiB         257       for row in grid:
     8     86.4 MiB -37242.6 MiB       65792           for spot in row:
     9     86.4 MiB -37097.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.2 MiB     -2.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.2 MiB      0.0 MiB           1       came_from = {}
    18     87.1 MiB -16827.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.3 MiB -11203.6 MiB        3165       while not open_set.empty():
    22     87.3 MiB -11203.7 MiB        3165           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.3 MiB -11204.0 MiB        3165           current = open_set.get()[1]
    28                                         
    29     87.3 MiB -11209.0 MiB        3165           if current in remaining_goals:
    30     74.6 MiB    -12.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     74.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     74.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.3 MiB -81244.1 MiB       23037           for neighbor in current.neighbors:
    35     87.3 MiB -70043.2 MiB       19873               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.3 MiB -70043.7 MiB       19873               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.3 MiB -34291.6 MiB        9733                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.3 MiB -70047.0 MiB       19873               if temp_g_score < g_score[neighbor]:
    41     87.3 MiB -11824.8 MiB        3401                   came_from[neighbor] = current
    42     87.3 MiB -11825.0 MiB        3401                   g_score[neighbor] = temp_g_score
    43     87.3 MiB -11825.0 MiB        3401                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.3 MiB -11203.5 MiB        3164           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.3 MiB -11203.6 MiB        3164           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     74.6 MiB      0.0 MiB           1       paths = {}
    53     74.6 MiB      0.0 MiB           2       for goal in goals:
    54     74.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     74.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.0 MiB     87.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.0 MiB      0.0 MiB         257       for row in grid:
     8     87.0 MiB      0.0 MiB       65792           for spot in row:
     9     87.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.0 MiB      0.0 MiB           1       came_from = {}
    18     92.0 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.2 MiB -2181787.8 MiB       46931       while not open_set.empty():
    22     92.2 MiB -2181790.0 MiB       46931           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.2 MiB -2181796.4 MiB       46931           current = open_set.get()[1]
    28                                         
    29     92.2 MiB -2181799.2 MiB       46931           if current in remaining_goals:
    30     37.8 MiB    -54.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     37.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.2 MiB -15814520.0 MiB      340038           for neighbor in current.neighbors:
    35     92.2 MiB -13632761.1 MiB      293108               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.2 MiB -13632759.7 MiB      293108               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.2 MiB -6660510.0 MiB      143166                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.2 MiB -13632775.5 MiB      293108               if temp_g_score < g_score[neighbor]:
    41     92.2 MiB -2183695.6 MiB       47164                   came_from[neighbor] = current
    42     92.2 MiB -2183698.1 MiB       47164                   g_score[neighbor] = temp_g_score
    43     92.2 MiB -2183702.9 MiB       47164                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.2 MiB -2181781.5 MiB       46930           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.2 MiB -2181785.4 MiB       46930           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.8 MiB      0.0 MiB           1       paths = {}
    53     38.2 MiB      0.0 MiB           2       for goal in goals:
    54     38.2 MiB      0.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.0 MiB     85.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.0 MiB     -0.8 MiB         257       for row in grid:
     8     85.0 MiB   -203.2 MiB       65792           for spot in row:
     9     85.0 MiB   -202.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.0 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.0 MiB      0.0 MiB           1       came_from = {}
    18     89.6 MiB  -1549.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.6 MiB -504679.5 MiB       15896       while not open_set.empty():
    22     89.6 MiB -504680.5 MiB       15896           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.6 MiB -504681.4 MiB       15896           current = open_set.get()[1]
    28                                         
    29     89.6 MiB -504681.8 MiB       15896           if current in remaining_goals:
    30     39.7 MiB    -49.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     39.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     39.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.6 MiB -3653320.4 MiB      114656           for neighbor in current.neighbors:
    35     89.6 MiB -3148649.7 MiB       98761               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.6 MiB -3148656.6 MiB       98761               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.6 MiB -1538547.0 MiB       48219                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.6 MiB -3148681.3 MiB       98761               if temp_g_score < g_score[neighbor]:
    41     89.6 MiB -509251.6 MiB       16162                   came_from[neighbor] = current
    42     89.6 MiB -509252.9 MiB       16162                   g_score[neighbor] = temp_g_score
    43     89.6 MiB -509256.8 MiB       16162                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.6 MiB -504677.4 MiB       15895           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.6 MiB -504678.0 MiB       15895           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.7 MiB      0.0 MiB           1       paths = {}
    53     39.9 MiB      0.0 MiB           2       for goal in goals:
    54     39.9 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     39.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     83.0 MiB     83.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     83.0 MiB   -469.1 MiB         257       for row in grid:
     8     83.0 MiB -118667.7 MiB       65792           for spot in row:
     9     83.0 MiB -118201.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     73.5 MiB     -9.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     73.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     73.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     73.9 MiB      0.0 MiB           1       came_from = {}
    18     80.1 MiB  -8877.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     80.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     81.8 MiB   -640.5 MiB        6875       while not open_set.empty():
    22     81.8 MiB   -640.5 MiB        6875           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.8 MiB   -640.5 MiB        6875           current = open_set.get()[1]
    28                                         
    29     81.8 MiB   -640.5 MiB        6875           if current in remaining_goals:
    30     81.6 MiB     -0.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     81.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     81.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.8 MiB  -4671.4 MiB       50326           for neighbor in current.neighbors:
    35     81.8 MiB  -4031.4 MiB       43452               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.8 MiB  -4030.7 MiB       43452               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.8 MiB  -1975.0 MiB       21282                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.8 MiB  -4031.4 MiB       43452               if temp_g_score < g_score[neighbor]:
    41     81.8 MiB   -670.2 MiB        7215                   came_from[neighbor] = current
    42     81.8 MiB   -670.7 MiB        7215                   g_score[neighbor] = temp_g_score
    43     81.8 MiB   -670.7 MiB        7215                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.8 MiB   -640.5 MiB        6874           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.8 MiB   -640.5 MiB        6874           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     81.6 MiB      0.0 MiB           1       paths = {}
    53     81.6 MiB      0.0 MiB           2       for goal in goals:
    54     81.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     81.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.7 MiB     88.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.7 MiB     -9.6 MiB         257       for row in grid:
     8     88.7 MiB  -2458.3 MiB       65792           for spot in row:
     9     88.7 MiB  -2448.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.6 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.6 MiB      0.0 MiB           1       came_from = {}
    18     91.1 MiB -35053.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.1 MiB -180122.0 MiB       25566       while not open_set.empty():
    22     91.1 MiB -180122.3 MiB       25566           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.1 MiB -180123.6 MiB       25566           current = open_set.get()[1]
    28                                         
    29     91.1 MiB -180123.8 MiB       25566           if current in remaining_goals:
    30     76.9 MiB    -14.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     76.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     76.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.1 MiB -1302083.9 MiB      185725           for neighbor in current.neighbors:
    35     91.1 MiB -1121964.0 MiB      160160               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.1 MiB -1121964.4 MiB      160160               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.1 MiB -547731.7 MiB       78296                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.1 MiB -1121970.6 MiB      160160               if temp_g_score < g_score[neighbor]:
    41     91.1 MiB -181033.1 MiB       25860                   came_from[neighbor] = current
    42     91.1 MiB -181033.3 MiB       25860                   g_score[neighbor] = temp_g_score
    43     91.1 MiB -181033.9 MiB       25860                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.1 MiB -180121.7 MiB       25565           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.1 MiB -180121.9 MiB       25565           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     76.9 MiB      0.0 MiB           1       paths = {}
    53     76.9 MiB      0.0 MiB           2       for goal in goals:
    54     76.9 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     76.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.9 MiB     84.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.9 MiB   -344.0 MiB         257       for row in grid:
     8     84.9 MiB -88241.0 MiB       65792           for spot in row:
     9     84.9 MiB -87898.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.4 MiB     -2.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.4 MiB      0.0 MiB           1       came_from = {}
    18     85.7 MiB -22459.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     79.2 MiB     -6.5 MiB           1       g_score[start] = 0
    20                                         
    21     79.8 MiB -245670.5 MiB        9788       while not open_set.empty():
    22     79.8 MiB -245671.5 MiB        9788           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     79.8 MiB -245672.5 MiB        9788           current = open_set.get()[1]
    28                                         
    29     79.8 MiB -245673.5 MiB        9788           if current in remaining_goals:
    30     32.3 MiB    -47.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     79.8 MiB -1779442.4 MiB       70998           for neighbor in current.neighbors:
    35     79.8 MiB -1533783.4 MiB       61211               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     79.8 MiB -1533784.2 MiB       61211               if current.row != neighbor.row and current.col != neighbor.col:
    38     79.8 MiB -749889.1 MiB       29937                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     79.8 MiB -1533787.3 MiB       61211               if temp_g_score < g_score[neighbor]:
    41     79.8 MiB -250599.2 MiB       10086                   came_from[neighbor] = current
    42     79.8 MiB -250599.6 MiB       10086                   g_score[neighbor] = temp_g_score
    43     79.8 MiB -250600.4 MiB       10086                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     79.8 MiB -245667.6 MiB        9787           if draw is not None:
    46                                                     draw()
    47                                                     
    48     79.8 MiB -245668.9 MiB        9787           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.3 MiB      0.0 MiB           1       paths = {}
    53     32.4 MiB      0.0 MiB           2       for goal in goals:
    54     32.4 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.7 MiB     85.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.7 MiB    -33.0 MiB         257       for row in grid:
     8     85.7 MiB  -8396.1 MiB       65792           for spot in row:
     9     85.7 MiB  -8363.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.2 MiB     -0.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.2 MiB      0.0 MiB           1       came_from = {}
    18     90.6 MiB   -985.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.6 MiB -260495.9 MiB        6851       while not open_set.empty():
    22     90.6 MiB -260497.5 MiB        6851           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.6 MiB -260498.2 MiB        6851           current = open_set.get()[1]
    28                                         
    29     90.6 MiB -260498.6 MiB        6851           if current in remaining_goals:
    30     30.1 MiB    -60.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     30.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.6 MiB -1887357.2 MiB       49616           for neighbor in current.neighbors:
    35     90.6 MiB -1626885.5 MiB       42766               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.6 MiB -1626904.5 MiB       42766               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.6 MiB -794813.5 MiB       20899                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.6 MiB -1626915.2 MiB       42766               if temp_g_score < g_score[neighbor]:
    41     90.6 MiB -265036.8 MiB        7072                   came_from[neighbor] = current
    42     90.6 MiB -265037.1 MiB        7072                   g_score[neighbor] = temp_g_score
    43     90.6 MiB -265038.4 MiB        7072                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.6 MiB -260495.2 MiB        6850           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.6 MiB -260495.5 MiB        6850           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.1 MiB      0.0 MiB           1       paths = {}
    53     30.2 MiB      0.0 MiB           2       for goal in goals:
    54     30.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.4 MiB     85.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.4 MiB      0.0 MiB         257       for row in grid:
     8     85.4 MiB      0.0 MiB       65792           for spot in row:
     9     85.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.4 MiB      0.0 MiB           1       came_from = {}
    18     90.1 MiB      4.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.1 MiB -1802346.5 MiB       43865       while not open_set.empty():
    22     90.1 MiB -1802346.7 MiB       43865           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.1 MiB -1802347.0 MiB       43865           current = open_set.get()[1]
    28                                         
    29     90.1 MiB -1802347.2 MiB       43865           if current in remaining_goals:
    30     39.8 MiB    -50.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     39.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     39.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.1 MiB -13000648.7 MiB      316868           for neighbor in current.neighbors:
    35     90.1 MiB -11198309.7 MiB      273004               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.1 MiB -11198305.6 MiB      273004               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.1 MiB -5467431.9 MiB      133333                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.1 MiB -11198362.1 MiB      273004               if temp_g_score < g_score[neighbor]:
    41     90.1 MiB -1803264.1 MiB       44129                   came_from[neighbor] = current
    42     90.1 MiB -1803264.4 MiB       44129                   g_score[neighbor] = temp_g_score
    43     90.1 MiB -1803264.5 MiB       44129                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.1 MiB -1802344.6 MiB       43864           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.1 MiB -1802345.5 MiB       43864           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.8 MiB      0.0 MiB           1       paths = {}
    53     40.2 MiB      0.0 MiB           2       for goal in goals:
    54     40.2 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.3 MiB     86.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.3 MiB    -75.1 MiB         257       for row in grid:
     8     86.3 MiB -19120.7 MiB       65792           for spot in row:
     9     86.3 MiB -19046.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.4 MiB     -0.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.4 MiB      0.0 MiB           1       came_from = {}
    18     90.4 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.5 MiB    -25.6 MiB        1575       while not open_set.empty():
    22     90.5 MiB    -25.6 MiB        1575           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.5 MiB    -25.6 MiB        1575           current = open_set.get()[1]
    28                                         
    29     90.5 MiB    -25.6 MiB        1575           if current in remaining_goals:
    30     90.5 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     90.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.5 MiB   -184.6 MiB       11570           for neighbor in current.neighbors:
    35     90.5 MiB   -159.0 MiB        9996               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.5 MiB   -159.0 MiB        9996               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.5 MiB    -77.8 MiB        4900                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.5 MiB   -159.0 MiB        9996               if temp_g_score < g_score[neighbor]:
    41     90.5 MiB    -27.4 MiB        1714                   came_from[neighbor] = current
    42     90.5 MiB    -27.5 MiB        1714                   g_score[neighbor] = temp_g_score
    43     90.5 MiB    -27.5 MiB        1714                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.5 MiB    -25.6 MiB        1574           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.5 MiB    -25.6 MiB        1574           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     90.5 MiB      0.0 MiB           1       paths = {}
    53     90.5 MiB      0.0 MiB           2       for goal in goals:
    54     90.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     90.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.7 MiB     87.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.7 MiB  -4518.5 MiB         257       for row in grid:
     8     87.7 MiB -1159349.8 MiB       65792           for spot in row:
     9     87.7 MiB -1154870.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     43.7 MiB    -44.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     44.1 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     44.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     44.3 MiB      0.0 MiB           1       came_from = {}
    18     49.8 MiB -31638.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     49.8 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     50.2 MiB -157815.9 MiB       10537       while not open_set.empty():
    22     50.2 MiB -157818.9 MiB       10537           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     50.2 MiB -157820.7 MiB       10537           current = open_set.get()[1]
    28                                         
    29     50.2 MiB -157821.3 MiB       10537           if current in remaining_goals:
    30     27.4 MiB    -22.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     27.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     27.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     50.2 MiB -1156459.0 MiB       77107           for neighbor in current.neighbors:
    35     50.2 MiB -998648.9 MiB       66571               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     50.2 MiB -998647.8 MiB       66571               if current.row != neighbor.row and current.col != neighbor.col:
    38     50.2 MiB -489512.1 MiB       32618                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     50.2 MiB -998655.9 MiB       66571               if temp_g_score < g_score[neighbor]:
    41     50.2 MiB -161285.9 MiB       10923                   came_from[neighbor] = current
    42     50.2 MiB -161286.9 MiB       10923                   g_score[neighbor] = temp_g_score
    43     50.2 MiB -161287.5 MiB       10923                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     50.2 MiB -157813.7 MiB       10536           if draw is not None:
    46                                                     draw()
    47                                                     
    48     50.2 MiB -157814.1 MiB       10536           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.4 MiB      0.0 MiB           1       paths = {}
    53     27.6 MiB      0.0 MiB           2       for goal in goals:
    54     27.6 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     83.6 MiB     83.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     83.6 MiB  -3353.1 MiB         257       for row in grid:
     8     83.6 MiB -854507.0 MiB       65792           for spot in row:
     9     83.6 MiB -851192.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     22.2 MiB    -61.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     22.7 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     22.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     22.9 MiB      0.0 MiB           1       came_from = {}
    18     32.3 MiB -83835.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     20.7 MiB    -11.6 MiB           1       g_score[start] = 0
    20                                         
    21     46.9 MiB -19067.6 MiB       36820       while not open_set.empty():
    22     46.9 MiB -19068.0 MiB       36820           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     46.9 MiB -19068.1 MiB       36820           current = open_set.get()[1]
    28                                         
    29     46.9 MiB -19068.9 MiB       36820           if current in remaining_goals:
    30     46.9 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     46.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     46.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     46.9 MiB -138651.5 MiB      267411           for neighbor in current.neighbors:
    35     46.9 MiB -119601.8 MiB      230592               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     46.9 MiB -119592.2 MiB      230592               if current.row != neighbor.row and current.col != neighbor.col:
    38     46.9 MiB -58512.4 MiB      112693                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     46.9 MiB -119597.5 MiB      230592               if temp_g_score < g_score[neighbor]:
    41     46.9 MiB -19694.0 MiB       37225                   came_from[neighbor] = current
    42     46.9 MiB -19696.8 MiB       37225                   g_score[neighbor] = temp_g_score
    43     46.9 MiB -19696.9 MiB       37225                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     46.9 MiB -19074.7 MiB       36819           if draw is not None:
    46                                                     draw()
    47                                                     
    48     46.9 MiB -19067.2 MiB       36819           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.9 MiB      0.0 MiB           1       paths = {}
    53     47.1 MiB      0.0 MiB           2       for goal in goals:
    54     47.1 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     82.2 MiB     82.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     82.2 MiB    -66.6 MiB         257       for row in grid:
     8     82.2 MiB -17009.1 MiB       65792           for spot in row:
     9     82.2 MiB -16942.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.6 MiB     -0.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     81.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     81.6 MiB      0.0 MiB           1       came_from = {}
    18     86.0 MiB  -3634.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     86.0 MiB -53378.9 MiB       10894       while not open_set.empty():
    22     86.0 MiB -53379.0 MiB       10894           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.0 MiB -53379.4 MiB       10894           current = open_set.get()[1]
    28                                         
    29     86.0 MiB -53379.7 MiB       10894           if current in remaining_goals:
    30     76.5 MiB     -9.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     76.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     76.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.0 MiB -386107.6 MiB       78787           for neighbor in current.neighbors:
    35     86.0 MiB -332732.6 MiB       67894               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.0 MiB -332734.0 MiB       67894               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.0 MiB -162364.7 MiB       33129                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.0 MiB -332735.7 MiB       67894               if temp_g_score < g_score[neighbor]:
    41     86.0 MiB -53784.6 MiB       11081                   came_from[neighbor] = current
    42     86.0 MiB -53784.6 MiB       11081                   g_score[neighbor] = temp_g_score
    43     86.0 MiB -53784.8 MiB       11081                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.0 MiB -53376.9 MiB       10893           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.0 MiB -53378.6 MiB       10893           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     76.5 MiB      0.0 MiB           1       paths = {}
    53     76.5 MiB      0.0 MiB           2       for goal in goals:
    54     76.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     76.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.9 MiB     85.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.9 MiB    -22.7 MiB         257       for row in grid:
     8     85.9 MiB  -5805.7 MiB       65792           for spot in row:
     9     85.9 MiB  -5783.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     90.7 MiB    -25.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.7 MiB -1737104.2 MiB       43521       while not open_set.empty():
    22     90.7 MiB -1737105.0 MiB       43521           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.7 MiB -1737109.3 MiB       43521           current = open_set.get()[1]
    28                                         
    29     90.7 MiB -1737111.0 MiB       43521           if current in remaining_goals:
    30     45.4 MiB    -45.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     45.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.7 MiB -12571969.5 MiB      315410           for neighbor in current.neighbors:
    35     90.7 MiB -10834882.6 MiB      271890               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.7 MiB -10834885.9 MiB      271890               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.7 MiB -5291398.1 MiB      132837                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.7 MiB -10834897.2 MiB      271890               if temp_g_score < g_score[neighbor]:
    41     90.7 MiB -1743597.2 MiB       43934                   came_from[neighbor] = current
    42     90.7 MiB -1743598.4 MiB       43934                   g_score[neighbor] = temp_g_score
    43     90.7 MiB -1743600.2 MiB       43934                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.7 MiB -1737100.0 MiB       43520           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.7 MiB -1737102.1 MiB       43520           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.4 MiB      0.0 MiB           1       paths = {}
    53     45.8 MiB      0.0 MiB           2       for goal in goals:
    54     45.8 MiB      0.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     82.9 MiB     82.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     82.9 MiB   -156.8 MiB         257       for row in grid:
     8     82.9 MiB -40172.5 MiB       65792           for spot in row:
     9     82.9 MiB -40017.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.2 MiB     -1.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     81.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     81.2 MiB      0.0 MiB           1       came_from = {}
    18     86.4 MiB    -75.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     86.4 MiB -1164569.1 MiB       38579       while not open_set.empty():
    22     86.4 MiB -1164571.6 MiB       38579           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.4 MiB -1164574.1 MiB       38579           current = open_set.get()[1]
    28                                         
    29     86.4 MiB -1164575.3 MiB       38579           if current in remaining_goals:
    30     35.8 MiB    -50.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.4 MiB -8415808.0 MiB      279081           for neighbor in current.neighbors:
    35     86.4 MiB -7251253.1 MiB      240503               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.4 MiB -7251261.0 MiB      240503               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.4 MiB -3544123.4 MiB      117572                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.4 MiB -7251274.9 MiB      240503               if temp_g_score < g_score[neighbor]:
    41     86.4 MiB -1163507.5 MiB       38971                   came_from[neighbor] = current
    42     86.4 MiB -1163510.5 MiB       38971                   g_score[neighbor] = temp_g_score
    43     86.4 MiB -1163515.9 MiB       38971                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.4 MiB -1164566.2 MiB       38578           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.4 MiB -1164567.8 MiB       38578           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.8 MiB      0.0 MiB           1       paths = {}
    53     36.2 MiB      0.0 MiB           2       for goal in goals:
    54     36.2 MiB      0.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     79.9 MiB     79.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     79.9 MiB  -1258.8 MiB         257       for row in grid:
     8     79.9 MiB -322579.4 MiB       65792           for spot in row:
     9     79.9 MiB -321324.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     74.0 MiB     -6.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     74.2 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     74.4 MiB      0.2 MiB           1       open_set.put((0, start))
    17     74.4 MiB      0.0 MiB           1       came_from = {}
    18     81.1 MiB   -216.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     81.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     81.3 MiB -296471.6 MiB       18597       while not open_set.empty():
    22     81.3 MiB -296472.5 MiB       18597           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.3 MiB -296475.5 MiB       18597           current = open_set.get()[1]
    28                                         
    29     81.3 MiB -296476.3 MiB       18597           if current in remaining_goals:
    30     50.0 MiB    -31.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     50.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     50.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.3 MiB -2140993.1 MiB      134973           for neighbor in current.neighbors:
    35     81.3 MiB -1844536.9 MiB      116377               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.3 MiB -1844538.7 MiB      116377               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.3 MiB -899279.2 MiB       56847                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.3 MiB -1844545.9 MiB      116377               if temp_g_score < g_score[neighbor]:
    41     81.3 MiB -296681.9 MiB       18880                   came_from[neighbor] = current
    42     81.3 MiB -296682.6 MiB       18880                   g_score[neighbor] = temp_g_score
    43     81.3 MiB -296683.7 MiB       18880                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.3 MiB -296469.2 MiB       18596           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.3 MiB -296470.6 MiB       18596           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     50.0 MiB      0.0 MiB           1       paths = {}
    53     50.0 MiB      0.0 MiB           2       for goal in goals:
    54     50.0 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     50.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.9 MiB     86.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.9 MiB      0.0 MiB         257       for row in grid:
     8     86.9 MiB      0.0 MiB       65792           for spot in row:
     9     86.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.9 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.9 MiB      0.0 MiB           1       came_from = {}
    18     91.6 MiB      4.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.1 MiB -1411057.6 MiB       49707       while not open_set.empty():
    22     92.1 MiB -1411060.4 MiB       49707           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.1 MiB -1411065.8 MiB       49707           current = open_set.get()[1]
    28                                         
    29     92.1 MiB -1411067.3 MiB       49707           if current in remaining_goals:
    30     47.4 MiB    -44.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     47.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     47.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.1 MiB -10205554.3 MiB      360083           for neighbor in current.neighbors:
    35     92.1 MiB -8794508.8 MiB      310377               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.1 MiB -8794513.0 MiB      310377               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.1 MiB -4292309.2 MiB      151577                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.1 MiB -8794528.4 MiB      310377               if temp_g_score < g_score[neighbor]:
    41     92.1 MiB -1405332.5 MiB       49981                   came_from[neighbor] = current
    42     92.1 MiB -1405334.4 MiB       49981                   g_score[neighbor] = temp_g_score
    43     92.1 MiB -1405337.7 MiB       49981                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.1 MiB -1411055.1 MiB       49706           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.1 MiB -1411056.5 MiB       49706           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     47.4 MiB      0.0 MiB           1       paths = {}
    53     47.5 MiB      0.0 MiB           2       for goal in goals:
    54     47.5 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.8 MiB   -208.0 MiB         257       for row in grid:
     8     88.8 MiB -53355.9 MiB       65792           for spot in row:
     9     88.8 MiB -53147.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.4 MiB     -1.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.4 MiB      0.0 MiB           1       came_from = {}
    18     91.1 MiB   -910.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.0 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     91.1 MiB  -1017.4 MiB        7008       while not open_set.empty():
    22     91.1 MiB  -1017.4 MiB        7008           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.1 MiB  -1017.4 MiB        7008           current = open_set.get()[1]
    28                                         
    29     91.1 MiB  -1017.6 MiB        7008           if current in remaining_goals:
    30     91.1 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     91.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     91.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.1 MiB  -7407.1 MiB       50930           for neighbor in current.neighbors:
    35     91.1 MiB  -6389.7 MiB       43923               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.1 MiB  -6389.7 MiB       43923               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.1 MiB  -3124.7 MiB       21463                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.1 MiB  -6389.7 MiB       43923               if temp_g_score < g_score[neighbor]:
    41     91.1 MiB  -1046.1 MiB        7248                   came_from[neighbor] = current
    42     91.1 MiB  -1046.2 MiB        7248                   g_score[neighbor] = temp_g_score
    43     91.1 MiB  -1046.2 MiB        7248                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.1 MiB  -1017.4 MiB        7007           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.1 MiB  -1017.4 MiB        7007           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     91.1 MiB      0.0 MiB           1       paths = {}
    53     91.1 MiB      0.0 MiB           2       for goal in goals:
    54     91.1 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     91.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.9 MiB     91.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.9 MiB   -264.6 MiB         257       for row in grid:
     8     91.9 MiB -67937.3 MiB       65792           for spot in row:
     9     91.9 MiB -67674.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.6 MiB     -1.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.6 MiB      0.0 MiB           1       came_from = {}
    18     95.5 MiB  -9662.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.9 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21     94.9 MiB -1510366.5 MiB       41032       while not open_set.empty():
    22     94.9 MiB -1510371.2 MiB       41032           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.9 MiB -1510383.6 MiB       41032           current = open_set.get()[1]
    28                                         
    29     94.9 MiB -1510385.2 MiB       41032           if current in remaining_goals:
    30     46.1 MiB    -48.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     46.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     46.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.9 MiB -10990694.9 MiB      298812           for neighbor in current.neighbors:
    35     94.9 MiB -9480340.5 MiB      257781               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.9 MiB -9480348.5 MiB      257781               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.9 MiB -4635920.2 MiB      126124                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.9 MiB -9480355.6 MiB      257781               if temp_g_score < g_score[neighbor]:
    41     94.9 MiB -1509332.4 MiB       41443                   came_from[neighbor] = current
    42     94.9 MiB -1509333.5 MiB       41443                   g_score[neighbor] = temp_g_score
    43     94.9 MiB -1509336.3 MiB       41443                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.9 MiB -1510364.2 MiB       41031           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.9 MiB -1510365.5 MiB       41031           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.1 MiB      0.0 MiB           1       paths = {}
    53     46.3 MiB      0.0 MiB           2       for goal in goals:
    54     46.3 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.3 MiB      0.0 MiB           1       return paths


