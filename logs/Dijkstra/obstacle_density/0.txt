Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.5 MiB     67.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/0.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     67.7 MiB  -3792.1 MiB         257       for row in grid:
     8     67.8 MiB -973747.0 MiB       65792           for spot in row:
     9     67.8 MiB -969961.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     57.6 MiB    -10.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     57.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     57.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     57.7 MiB      0.0 MiB           1       came_from = {}
    18     64.1 MiB  -7517.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     63.4 MiB     -0.7 MiB           1       g_score[start] = 0
    20                                         
    21     63.7 MiB -456290.3 MiB       16924       while not open_set.empty():
    22     63.7 MiB -456290.6 MiB       16924           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     63.7 MiB -456293.0 MiB       16924           current = open_set.get()[1]
    28                                         
    29     63.7 MiB -456293.2 MiB       16924           if current in remaining_goals:
    30     34.3 MiB    -29.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     63.7 MiB -4083767.9 MiB      151552           for neighbor in current.neighbors:
    35     63.7 MiB -3627481.4 MiB      134629               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     63.7 MiB -3627483.7 MiB      134629               if current.row != neighbor.row and current.col != neighbor.col:
    38     63.7 MiB -1810012.5 MiB       67189                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     63.7 MiB -3627503.9 MiB      134629               if temp_g_score < g_score[neighbor]:
    41     63.7 MiB -459925.9 MiB       17251                   came_from[neighbor] = current
    42     63.7 MiB -459926.0 MiB       17251                   g_score[neighbor] = temp_g_score
    43     63.7 MiB -459927.3 MiB       17251                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     63.7 MiB -456290.0 MiB       16923           if draw is not None:
    46                                                     draw()
    47                                                     
    48     63.7 MiB -456290.1 MiB       16923           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.3 MiB      0.0 MiB           1       paths = {}
    53     34.4 MiB      0.0 MiB           2       for goal in goals:
    54     34.4 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.7 MiB     87.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.3 MiB   -993.3 MiB         257       for row in grid:
     8     89.3 MiB -254399.1 MiB       65792           for spot in row:
     9     89.3 MiB -253406.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.7 MiB     -7.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     81.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     81.7 MiB      0.0 MiB           1       came_from = {}
    18     87.0 MiB -12623.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.9 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     87.0 MiB  -3385.0 MiB        1903       while not open_set.empty():
    22     87.0 MiB  -3385.0 MiB        1903           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.0 MiB  -3385.0 MiB        1903           current = open_set.get()[1]
    28                                         
    29     87.0 MiB  -3385.0 MiB        1903           if current in remaining_goals:
    30     83.4 MiB     -3.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     83.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     83.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.0 MiB -30202.6 MiB       17040           for neighbor in current.neighbors:
    35     87.0 MiB -26819.6 MiB       15138               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.0 MiB -26819.9 MiB       15138               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.0 MiB -13373.4 MiB        7556                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.0 MiB -26820.2 MiB       15138               if temp_g_score < g_score[neighbor]:
    41     87.0 MiB  -3519.4 MiB        2079                   came_from[neighbor] = current
    42     87.0 MiB  -3519.4 MiB        2079                   g_score[neighbor] = temp_g_score
    43     87.0 MiB  -3519.5 MiB        2079                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.0 MiB  -3385.0 MiB        1902           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.0 MiB  -3385.0 MiB        1902           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     83.4 MiB      0.0 MiB           1       paths = {}
    53     83.4 MiB      0.0 MiB           2       for goal in goals:
    54     83.4 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     83.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.1 MiB     93.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.1 MiB   -643.5 MiB         257       for row in grid:
     8     93.1 MiB -163553.0 MiB       65792           for spot in row:
     9     93.1 MiB -162918.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.0 MiB    -10.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.0 MiB      0.0 MiB           1       came_from = {}
    18     88.9 MiB  -8460.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.9 MiB -2901774.4 MiB       54772       while not open_set.empty():
    22     88.9 MiB -2901777.1 MiB       54772           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.9 MiB -2901778.8 MiB       54772           current = open_set.get()[1]
    28                                         
    29     88.9 MiB -2901780.8 MiB       54772           if current in remaining_goals:
    30     29.0 MiB    -59.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.9 MiB -26025032.6 MiB      491204           for neighbor in current.neighbors:
    35     88.9 MiB -23123292.7 MiB      436433               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.9 MiB -23123299.8 MiB      436433               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.9 MiB -11546720.7 MiB      217928                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.9 MiB -23123337.6 MiB      436433               if temp_g_score < g_score[neighbor]:
    41     88.9 MiB -2911970.5 MiB       55213                   came_from[neighbor] = current
    42     88.9 MiB -2911974.3 MiB       55213                   g_score[neighbor] = temp_g_score
    43     88.9 MiB -2911979.0 MiB       55213                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.9 MiB -2901761.9 MiB       54771           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.9 MiB -2901765.7 MiB       54771           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.0 MiB      0.0 MiB           1       paths = {}
    53     29.5 MiB      0.0 MiB           2       for goal in goals:
    54     29.5 MiB      0.5 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.3 MiB     90.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.3 MiB  -5332.8 MiB         257       for row in grid:
     8     90.3 MiB -1361406.8 MiB       65792           for spot in row:
     9     90.3 MiB -1356119.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     26.1 MiB    -64.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     26.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     26.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     26.7 MiB      0.0 MiB           1       came_from = {}
    18     35.9 MiB  -2819.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     35.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     38.4 MiB -179332.5 MiB       19213       while not open_set.empty():
    22     38.4 MiB -179333.4 MiB       19213           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     38.4 MiB -179334.2 MiB       19213           current = open_set.get()[1]
    28                                         
    29     38.4 MiB -179334.8 MiB       19213           if current in remaining_goals:
    30     27.7 MiB    -10.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     27.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     27.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     38.4 MiB -1613818.6 MiB      172908           for neighbor in current.neighbors:
    35     38.4 MiB -1434498.2 MiB      153696               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     38.4 MiB -1434500.1 MiB      153696               if current.row != neighbor.row and current.col != neighbor.col:
    38     38.4 MiB -717280.7 MiB       76848                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     38.4 MiB -1434508.1 MiB      153696               if temp_g_score < g_score[neighbor]:
    41     38.4 MiB -183924.1 MiB       19867                   came_from[neighbor] = current
    42     38.4 MiB -183924.9 MiB       19867                   g_score[neighbor] = temp_g_score
    43     38.4 MiB -183925.3 MiB       19867                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     38.4 MiB -179329.9 MiB       19212           if draw is not None:
    46                                                     draw()
    47                                                     
    48     38.4 MiB -179332.0 MiB       19212           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.7 MiB      0.0 MiB           1       paths = {}
    53     27.9 MiB      0.0 MiB           2       for goal in goals:
    54     27.9 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.9 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.1 MiB     90.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.1 MiB  -4867.2 MiB         257       for row in grid:
     8     90.1 MiB -1246339.9 MiB       65792           for spot in row:
     9     90.1 MiB -1241535.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     21.1 MiB    -69.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     21.4 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     21.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     21.7 MiB      0.0 MiB           1       came_from = {}
    18     33.1 MiB     11.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     33.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     34.6 MiB -269677.1 MiB       45135       while not open_set.empty():
    22     34.6 MiB -269677.4 MiB       45135           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     34.6 MiB -269678.7 MiB       45135           current = open_set.get()[1]
    28                                         
    29     34.6 MiB -269679.2 MiB       45135           if current in remaining_goals:
    30     34.7 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     34.6 MiB -2415877.7 MiB      404896           for neighbor in current.neighbors:
    35     34.6 MiB -2146208.5 MiB      359762               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     34.6 MiB -2146198.0 MiB      359762               if current.row != neighbor.row and current.col != neighbor.col:
    38     34.6 MiB -1071251.2 MiB      179663                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     34.6 MiB -2146205.9 MiB      359762               if temp_g_score < g_score[neighbor]:
    41     34.6 MiB -270676.1 MiB       45645                   came_from[neighbor] = current
    42     34.6 MiB -270677.5 MiB       45645                   g_score[neighbor] = temp_g_score
    43     34.6 MiB -270678.6 MiB       45645                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     34.6 MiB -269676.3 MiB       45134           if draw is not None:
    46                                                     draw()
    47                                                     
    48     34.6 MiB -269676.9 MiB       45134           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.7 MiB      0.0 MiB           1       paths = {}
    53     34.8 MiB      0.0 MiB           2       for goal in goals:
    54     34.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.7 MiB     89.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.7 MiB   -518.9 MiB         257       for row in grid:
     8     89.7 MiB -132048.0 MiB       65792           for spot in row:
     9     89.7 MiB -131536.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.4 MiB     -9.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     80.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     80.4 MiB      0.0 MiB           1       came_from = {}
    18     84.6 MiB -21931.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.6 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     84.6 MiB -1773991.2 MiB       34903       while not open_set.empty():
    22     84.6 MiB -1773993.2 MiB       34903           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.6 MiB -1773996.4 MiB       34903           current = open_set.get()[1]
    28                                         
    29     84.6 MiB -1773997.9 MiB       34903           if current in remaining_goals:
    30     32.7 MiB    -51.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.6 MiB -15963645.3 MiB      314079           for neighbor in current.neighbors:
    35     84.6 MiB -14189670.4 MiB      279177               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.6 MiB -14189674.6 MiB      279177               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.6 MiB -7094551.0 MiB      139582                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.6 MiB -14189700.9 MiB      279177               if temp_g_score < g_score[neighbor]:
    41     84.6 MiB -1809213.6 MiB       35770                   came_from[neighbor] = current
    42     84.6 MiB -1809217.7 MiB       35770                   g_score[neighbor] = temp_g_score
    43     84.6 MiB -1809220.0 MiB       35770                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.6 MiB -1773987.8 MiB       34902           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.6 MiB -1773989.3 MiB       34902           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.7 MiB      0.0 MiB           1       paths = {}
    53     32.8 MiB      0.0 MiB           2       for goal in goals:
    54     32.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.9 MiB     88.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.9 MiB  -2060.6 MiB         257       for row in grid:
     8     88.9 MiB -523420.0 MiB       65792           for spot in row:
     9     88.9 MiB -521392.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     50.7 MiB    -38.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     51.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     51.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     51.3 MiB      0.0 MiB           1       came_from = {}
    18     52.6 MiB -1500775.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     21.9 MiB    -30.7 MiB           1       g_score[start] = 0
    20                                         
    21     31.3 MiB -42465.4 MiB       30616       while not open_set.empty():
    22     31.3 MiB -42466.5 MiB       30616           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     31.3 MiB -42466.6 MiB       30616           current = open_set.get()[1]
    28                                         
    29     31.3 MiB -42467.1 MiB       30616           if current in remaining_goals:
    30     29.4 MiB     -1.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     31.3 MiB -380347.7 MiB      274462           for neighbor in current.neighbors:
    35     31.3 MiB -337901.8 MiB      243847               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     31.3 MiB -337894.1 MiB      243847               if current.row != neighbor.row and current.col != neighbor.col:
    38     31.3 MiB -168656.2 MiB      121745                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     31.3 MiB -337901.0 MiB      243847               if temp_g_score < g_score[neighbor]:
    41     31.3 MiB -43525.9 MiB       31041                   came_from[neighbor] = current
    42     31.3 MiB -43519.1 MiB       31041                   g_score[neighbor] = temp_g_score
    43     31.3 MiB -43519.0 MiB       31041                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     31.3 MiB -42464.6 MiB       30615           if draw is not None:
    46                                                     draw()
    47                                                     
    48     31.3 MiB -42464.7 MiB       30615           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.4 MiB      0.0 MiB           1       paths = {}
    53     29.7 MiB      0.0 MiB           2       for goal in goals:
    54     29.7 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.3 MiB     87.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.3 MiB  -1873.3 MiB         257       for row in grid:
     8     87.3 MiB -480508.8 MiB       65792           for spot in row:
     9     87.3 MiB -478641.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     77.5 MiB     -9.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     77.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     77.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     77.5 MiB      0.0 MiB           1       came_from = {}
    18     81.5 MiB -11482.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     81.3 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     81.3 MiB -743518.8 MiB       15847       while not open_set.empty():
    22     81.3 MiB -743524.8 MiB       15847           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.3 MiB -743525.3 MiB       15847           current = open_set.get()[1]
    28                                         
    29     81.3 MiB -743525.3 MiB       15847           if current in remaining_goals:
    30     41.7 MiB    -39.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     41.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.3 MiB -6668784.9 MiB      142185           for neighbor in current.neighbors:
    35     81.3 MiB -5925300.3 MiB      126339               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.3 MiB -5925301.4 MiB      126339               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.3 MiB -2958899.2 MiB       63098                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.3 MiB -5925302.8 MiB      126339               if temp_g_score < g_score[neighbor]:
    41     81.3 MiB -755764.1 MiB       16286                   came_from[neighbor] = current
    42     81.3 MiB -755764.2 MiB       16286                   g_score[neighbor] = temp_g_score
    43     81.3 MiB -755775.9 MiB       16286                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.3 MiB -743516.7 MiB       15846           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.3 MiB -743516.8 MiB       15846           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.7 MiB      0.0 MiB           1       paths = {}
    53     41.8 MiB      0.0 MiB           2       for goal in goals:
    54     41.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.5 MiB     85.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.5 MiB   -993.8 MiB         257       for row in grid:
     8     85.5 MiB -254429.2 MiB       65792           for spot in row:
     9     85.5 MiB -253441.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.2 MiB     -6.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.4 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     79.6 MiB      0.2 MiB           1       open_set.put((0, start))
    17     79.6 MiB      0.0 MiB           1       came_from = {}
    18     81.0 MiB -426366.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     75.1 MiB     -5.9 MiB           1       g_score[start] = 0
    20                                         
    21     75.6 MiB -2083079.1 MiB       49731       while not open_set.empty():
    22     75.6 MiB -2083079.8 MiB       49731           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     75.6 MiB -2083080.3 MiB       49731           current = open_set.get()[1]
    28                                         
    29     75.6 MiB -2083081.2 MiB       49731           if current in remaining_goals:
    30     37.5 MiB    -38.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     37.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     75.6 MiB -18680482.2 MiB      445883           for neighbor in current.neighbors:
    35     75.6 MiB -16597416.9 MiB      396153               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     75.6 MiB -16597421.8 MiB      396153               if current.row != neighbor.row and current.col != neighbor.col:
    38     75.6 MiB -8287607.8 MiB      197796                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     75.6 MiB -16597429.2 MiB      396153               if temp_g_score < g_score[neighbor]:
    41     75.6 MiB -2095871.0 MiB       50128                   came_from[neighbor] = current
    42     75.6 MiB -2095871.6 MiB       50128                   g_score[neighbor] = temp_g_score
    43     75.6 MiB -2095873.0 MiB       50128                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     75.6 MiB -2083077.8 MiB       49730           if draw is not None:
    46                                                     draw()
    47                                                     
    48     75.6 MiB -2083078.6 MiB       49730           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.5 MiB      0.0 MiB           1       paths = {}
    53     37.7 MiB      0.0 MiB           2       for goal in goals:
    54     37.7 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.2 MiB     86.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.2 MiB    -44.0 MiB         257       for row in grid:
     8     86.2 MiB -11261.6 MiB       65792           for spot in row:
     9     86.2 MiB -11218.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.5 MiB     -0.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.5 MiB      0.0 MiB           1       came_from = {}
    18     90.5 MiB   -650.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.5 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.7 MiB   -408.4 MiB        2193       while not open_set.empty():
    22     90.7 MiB   -408.5 MiB        2193           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.7 MiB   -408.5 MiB        2193           current = open_set.get()[1]
    28                                         
    29     90.7 MiB   -408.5 MiB        2193           if current in remaining_goals:
    30     89.6 MiB     -1.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     89.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     89.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.7 MiB  -3670.5 MiB       19728           for neighbor in current.neighbors:
    35     90.7 MiB  -3262.3 MiB       17536               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.7 MiB  -3262.6 MiB       17536               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.7 MiB  -1632.5 MiB        8768                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.7 MiB  -3262.8 MiB       17536               if temp_g_score < g_score[neighbor]:
    41     90.7 MiB   -428.3 MiB        2415                   came_from[neighbor] = current
    42     90.7 MiB   -428.5 MiB        2415                   g_score[neighbor] = temp_g_score
    43     90.7 MiB   -428.5 MiB        2415                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.7 MiB   -408.4 MiB        2192           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.7 MiB   -408.4 MiB        2192           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     89.6 MiB      0.0 MiB           1       paths = {}
    53     89.6 MiB      0.0 MiB           2       for goal in goals:
    54     89.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     89.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.4 MiB     91.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.4 MiB   -442.2 MiB         257       for row in grid:
     8     91.4 MiB -113102.9 MiB       65792           for spot in row:
     9     91.4 MiB -112662.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.2 MiB     -2.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.2 MiB      0.0 MiB           1       came_from = {}
    18     92.2 MiB  -1384.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.2 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.2 MiB -2301918.7 MiB       36876       while not open_set.empty():
    22     92.2 MiB -2301919.0 MiB       36876           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.2 MiB -2301922.3 MiB       36876           current = open_set.get()[1]
    28                                         
    29     92.2 MiB -2301923.9 MiB       36876           if current in remaining_goals:
    30     32.2 MiB    -60.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.2 MiB -20647810.1 MiB      330778           for neighbor in current.neighbors:
    35     92.2 MiB -18345926.6 MiB      293903               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.2 MiB -18345929.6 MiB      293903               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.2 MiB -9161527.9 MiB      146769                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.2 MiB -18345942.1 MiB      293903               if temp_g_score < g_score[neighbor]:
    41     92.2 MiB -2325061.3 MiB       37355                   came_from[neighbor] = current
    42     92.2 MiB -2325061.7 MiB       37355                   g_score[neighbor] = temp_g_score
    43     92.2 MiB -2325062.0 MiB       37355                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.2 MiB -2301905.1 MiB       36875           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.2 MiB -2301912.5 MiB       36875           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.2 MiB      0.0 MiB           1       paths = {}
    53     42.6 MiB      0.0 MiB           2       for goal in goals:
    54     42.6 MiB     10.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.2 MiB     92.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.2 MiB   -955.2 MiB         257       for row in grid:
     8     92.2 MiB -244896.3 MiB       65792           for spot in row:
     9     92.2 MiB -243944.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.4 MiB     -8.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.4 MiB      0.0 MiB           1       came_from = {}
    18     88.7 MiB   -819.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.2 MiB     -0.5 MiB           1       g_score[start] = 0
    20                                         
    21     88.4 MiB -2280677.4 MiB       42773       while not open_set.empty():
    22     88.4 MiB -2280678.2 MiB       42773           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.4 MiB -2280710.8 MiB       42773           current = open_set.get()[1]
    28                                         
    29     88.4 MiB -2280712.0 MiB       42773           if current in remaining_goals:
    30     30.6 MiB    -57.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     30.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.4 MiB -20465042.1 MiB      383830           for neighbor in current.neighbors:
    35     88.4 MiB -18184375.4 MiB      341058               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.4 MiB -18184377.3 MiB      341058               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.4 MiB -9082083.9 MiB      170343                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.4 MiB -18184398.9 MiB      341058               if temp_g_score < g_score[neighbor]:
    41     88.4 MiB -2299703.8 MiB       43313                   came_from[neighbor] = current
    42     88.4 MiB -2299704.4 MiB       43313                   g_score[neighbor] = temp_g_score
    43     88.4 MiB -2299705.0 MiB       43313                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.4 MiB -2280674.8 MiB       42772           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.4 MiB -2280675.9 MiB       42772           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.6 MiB      0.0 MiB           1       paths = {}
    53     30.7 MiB      0.0 MiB           2       for goal in goals:
    54     30.7 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.4 MiB     91.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.4 MiB     -3.9 MiB         257       for row in grid:
     8     91.4 MiB  -1006.7 MiB       65792           for spot in row:
     9     91.4 MiB  -1002.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.4 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.4 MiB      0.0 MiB           1       came_from = {}
    18     95.8 MiB -13355.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.4 MiB     -0.4 MiB           1       g_score[start] = 0
    20                                         
    21     95.6 MiB -937253.4 MiB       24180       while not open_set.empty():
    22     95.6 MiB -937254.5 MiB       24180           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.6 MiB -937257.8 MiB       24180           current = open_set.get()[1]
    28                                         
    29     95.6 MiB -937259.2 MiB       24180           if current in remaining_goals:
    30     29.7 MiB    -65.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     95.6 MiB -8386302.6 MiB      216897           for neighbor in current.neighbors:
    35     95.6 MiB -7449067.9 MiB      192718               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.6 MiB -7449074.9 MiB      192718               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.6 MiB -3716481.7 MiB       96240                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.6 MiB -7449091.6 MiB      192718               if temp_g_score < g_score[neighbor]:
    41     95.6 MiB -934738.6 MiB       24626                   came_from[neighbor] = current
    42     95.6 MiB -934741.4 MiB       24626                   g_score[neighbor] = temp_g_score
    43     95.6 MiB -934743.4 MiB       24626                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.6 MiB -937249.0 MiB       24179           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.6 MiB -937250.5 MiB       24179           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.7 MiB      0.0 MiB           1       paths = {}
    53     29.8 MiB      0.0 MiB           2       for goal in goals:
    54     29.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.8 MiB     90.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.8 MiB      0.0 MiB         257       for row in grid:
     8     90.8 MiB      0.0 MiB       65792           for spot in row:
     9     90.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.8 MiB      0.0 MiB           1       came_from = {}
    18     96.5 MiB      5.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.5 MiB -3362519.2 MiB       57601       while not open_set.empty():
    22     96.5 MiB -3362520.8 MiB       57601           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.5 MiB -3362534.2 MiB       57601           current = open_set.get()[1]
    28                                         
    29     96.5 MiB -3362535.1 MiB       57601           if current in remaining_goals:
    30     26.3 MiB    -70.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     26.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     26.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.5 MiB -30158222.1 MiB      516350           for neighbor in current.neighbors:
    35     96.5 MiB -26795717.7 MiB      458750               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.5 MiB -26795723.1 MiB      458750               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.5 MiB -13380610.2 MiB      229034                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.5 MiB -26795729.7 MiB      458750               if temp_g_score < g_score[neighbor]:
    41     96.5 MiB -3371862.9 MiB       57937                   came_from[neighbor] = current
    42     96.5 MiB -3371863.8 MiB       57937                   g_score[neighbor] = temp_g_score
    43     96.5 MiB -3371866.2 MiB       57937                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.5 MiB -3362513.8 MiB       57600           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.5 MiB -3362517.9 MiB       57600           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     26.3 MiB      0.0 MiB           1       paths = {}
    53     27.8 MiB      0.0 MiB           2       for goal in goals:
    54     27.8 MiB      1.5 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.5 MiB     89.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.5 MiB   -652.4 MiB         257       for row in grid:
     8     89.5 MiB -167163.1 MiB       65792           for spot in row:
     9     89.5 MiB -166514.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.0 MiB     -6.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.0 MiB      0.1 MiB           1       open_set = PriorityQueue()
    16     83.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.1 MiB      0.0 MiB           1       came_from = {}
    18     88.5 MiB      5.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.7 MiB -3271403.8 MiB       61994       while not open_set.empty():
    22     88.7 MiB -3271405.8 MiB       61994           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.7 MiB -3271408.6 MiB       61994           current = open_set.get()[1]
    28                                         
    29     88.7 MiB -3271411.1 MiB       61994           if current in remaining_goals:
    30     28.4 MiB    -60.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     28.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     28.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.7 MiB -29305956.0 MiB      555522           for neighbor in current.neighbors:
    35     88.7 MiB -26034574.1 MiB      493529               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.7 MiB -26034578.2 MiB      493529               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.7 MiB -12994680.2 MiB      246363                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.7 MiB -26034598.0 MiB      493529               if temp_g_score < g_score[neighbor]:
    41     88.7 MiB -3266640.6 MiB       62209                   came_from[neighbor] = current
    42     88.7 MiB -3266642.3 MiB       62209                   g_score[neighbor] = temp_g_score
    43     88.7 MiB -3266644.4 MiB       62209                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.7 MiB -3271401.0 MiB       61993           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.7 MiB -3271402.0 MiB       61993           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     28.5 MiB      0.0 MiB           1       paths = {}
    53     29.1 MiB      0.0 MiB           2       for goal in goals:
    54     29.1 MiB      0.6 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.6 MiB     88.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.6 MiB   -254.2 MiB         257       for row in grid:
     8     88.6 MiB -64463.4 MiB       65792           for spot in row:
     9     88.6 MiB -64212.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.1 MiB     -4.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.1 MiB      0.0 MiB           1       came_from = {}
    18     89.8 MiB    -59.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.8 MiB -1096308.5 MiB       26549       while not open_set.empty():
    22     89.8 MiB -1096308.9 MiB       26549           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.8 MiB -1096309.8 MiB       26549           current = open_set.get()[1]
    28                                         
    29     89.8 MiB -1096310.2 MiB       26549           if current in remaining_goals:
    30     45.6 MiB    -44.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     45.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.8 MiB -9828454.0 MiB      237925           for neighbor in current.neighbors:
    35     89.8 MiB -8732155.6 MiB      211377               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.8 MiB -8732157.8 MiB      211377               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.8 MiB -4359802.8 MiB      105521                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.8 MiB -8732170.5 MiB      211377               if temp_g_score < g_score[neighbor]:
    41     89.8 MiB -1103893.9 MiB       26960                   came_from[neighbor] = current
    42     89.8 MiB -1103894.9 MiB       26960                   g_score[neighbor] = temp_g_score
    43     89.8 MiB -1103896.2 MiB       26960                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.8 MiB -1096306.5 MiB       26548           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.8 MiB -1096307.3 MiB       26548           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.6 MiB      0.0 MiB           1       paths = {}
    53     45.8 MiB      0.0 MiB           2       for goal in goals:
    54     45.7 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.2 MiB     87.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.2 MiB    -69.4 MiB         257       for row in grid:
     8     87.2 MiB -17685.2 MiB       65792           for spot in row:
     9     87.2 MiB -17616.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.0 MiB     -1.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.0 MiB      0.0 MiB           1       came_from = {}
    18     86.9 MiB -1555358.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     32.0 MiB    -54.9 MiB           1       g_score[start] = 0
    20                                         
    21     33.2 MiB -166524.4 MiB       31403       while not open_set.empty():
    22     33.2 MiB -166525.4 MiB       31403           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     33.2 MiB -166526.2 MiB       31403           current = open_set.get()[1]
    28                                         
    29     33.2 MiB -166526.8 MiB       31403           if current in remaining_goals:
    30     26.6 MiB     -6.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     26.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     26.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     33.2 MiB -1493243.9 MiB      281590           for neighbor in current.neighbors:
    35     33.2 MiB -1326725.9 MiB      250188               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     33.2 MiB -1326719.2 MiB      250188               if current.row != neighbor.row and current.col != neighbor.col:
    38     33.2 MiB -662478.5 MiB      124923                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     33.2 MiB -1326727.5 MiB      250188               if temp_g_score < g_score[neighbor]:
    41     33.2 MiB -168499.1 MiB       31851                   came_from[neighbor] = current
    42     33.2 MiB -168499.5 MiB       31851                   g_score[neighbor] = temp_g_score
    43     33.2 MiB -168500.2 MiB       31851                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     33.2 MiB -166522.9 MiB       31402           if draw is not None:
    46                                                     draw()
    47                                                     
    48     33.2 MiB -166523.9 MiB       31402           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     26.6 MiB      0.0 MiB           1       paths = {}
    53     26.8 MiB      0.0 MiB           2       for goal in goals:
    54     26.8 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     26.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.5 MiB     85.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.5 MiB   -231.2 MiB         257       for row in grid:
     8     85.5 MiB -59150.1 MiB       65792           for spot in row:
     9     85.5 MiB -58920.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.4 MiB     -3.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.4 MiB      0.0 MiB           1       came_from = {}
    18     87.1 MiB  -9571.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.1 MiB -1446422.6 MiB       26558       while not open_set.empty():
    22     87.1 MiB -1446424.0 MiB       26558           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.1 MiB -1446425.8 MiB       26558           current = open_set.get()[1]
    28                                         
    29     87.1 MiB -1446426.1 MiB       26558           if current in remaining_goals:
    30     32.9 MiB    -54.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.1 MiB -12963159.4 MiB      238060           for neighbor in current.neighbors:
    35     87.1 MiB -11516759.4 MiB      211503               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.1 MiB -11516761.8 MiB      211503               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.1 MiB -5749405.9 MiB      105593                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.1 MiB -11516772.7 MiB      211503               if temp_g_score < g_score[neighbor]:
    41     87.1 MiB -1461017.0 MiB       26965                   came_from[neighbor] = current
    42     87.1 MiB -1461018.4 MiB       26965                   g_score[neighbor] = temp_g_score
    43     87.1 MiB -1461023.8 MiB       26965                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.1 MiB -1446416.4 MiB       26557           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.1 MiB -1446421.1 MiB       26557           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.9 MiB      0.0 MiB           1       paths = {}
    53     33.0 MiB      0.0 MiB           2       for goal in goals:
    54     33.0 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.5 MiB     86.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.5 MiB  -1102.2 MiB         257       for row in grid:
     8     86.5 MiB -282768.4 MiB       65792           for spot in row:
     9     86.5 MiB -281672.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     78.5 MiB     -8.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     78.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     79.0 MiB      0.2 MiB           1       open_set.put((0, start))
    17     79.0 MiB      0.0 MiB           1       came_from = {}
    18     83.0 MiB -40650.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     81.2 MiB     -1.8 MiB           1       g_score[start] = 0
    20                                         
    21     81.3 MiB -1620942.6 MiB       35884       while not open_set.empty():
    22     81.3 MiB -1620943.1 MiB       35884           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     81.3 MiB -1620946.1 MiB       35884           current = open_set.get()[1]
    28                                         
    29     81.3 MiB -1620946.2 MiB       35884           if current in remaining_goals:
    30     37.3 MiB    -44.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     37.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     81.3 MiB -14539241.3 MiB      321868           for neighbor in current.neighbors:
    35     81.3 MiB -12918303.0 MiB      285985               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     81.3 MiB -12918293.8 MiB      285985               if current.row != neighbor.row and current.col != neighbor.col:
    38     81.3 MiB -6450995.1 MiB      142813                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     81.3 MiB -12918345.3 MiB      285985               if temp_g_score < g_score[neighbor]:
    41     81.3 MiB -1639298.7 MiB       36381                   came_from[neighbor] = current
    42     81.3 MiB -1639299.9 MiB       36381                   g_score[neighbor] = temp_g_score
    43     81.3 MiB -1639300.2 MiB       36381                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     81.3 MiB -1620941.6 MiB       35883           if draw is not None:
    46                                                     draw()
    47                                                     
    48     81.3 MiB -1620942.3 MiB       35883           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.3 MiB      0.0 MiB           1       paths = {}
    53     37.5 MiB      0.0 MiB           2       for goal in goals:
    54     37.5 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.2 MiB     84.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.2 MiB    -73.3 MiB         257       for row in grid:
     8     84.2 MiB -18763.5 MiB       65792           for spot in row:
     9     84.2 MiB -18690.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.4 MiB     -0.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.4 MiB      0.0 MiB           1       came_from = {}
    18     87.4 MiB -16007.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.9 MiB     -0.5 MiB           1       g_score[start] = 0
    20                                         
    21     87.0 MiB -1330750.2 MiB       25728       while not open_set.empty():
    22     87.0 MiB -1330750.7 MiB       25728           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.0 MiB -1330751.9 MiB       25728           current = open_set.get()[1]
    28                                         
    29     87.0 MiB -1330753.2 MiB       25728           if current in remaining_goals:
    30     26.8 MiB    -60.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     26.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     26.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.0 MiB -11926715.7 MiB      230563           for neighbor in current.neighbors:
    35     87.0 MiB -10595971.0 MiB      204836               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.0 MiB -10595973.6 MiB      204836               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.0 MiB -5289760.6 MiB      102255                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.0 MiB -10595983.0 MiB      204836               if temp_g_score < g_score[neighbor]:
    41     87.0 MiB -1341087.5 MiB       26120                   came_from[neighbor] = current
    42     87.0 MiB -1341087.7 MiB       26120                   g_score[neighbor] = temp_g_score
    43     87.0 MiB -1341088.0 MiB       26120                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.0 MiB -1330748.7 MiB       25727           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.0 MiB -1330749.0 MiB       25727           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     26.8 MiB      0.0 MiB           1       paths = {}
    53     27.0 MiB      0.0 MiB           2       for goal in goals:
    54     27.0 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.5 MiB     91.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.6 MiB      0.0 MiB         257       for row in grid:
     8     91.6 MiB      0.0 MiB       65792           for spot in row:
     9     91.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.6 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.6 MiB      0.0 MiB           1       came_from = {}
    18     96.6 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     96.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.9 MiB -2157298.7 MiB       49336       while not open_set.empty():
    22     96.9 MiB -2157309.0 MiB       49336           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.9 MiB -2157309.3 MiB       49336           current = open_set.get()[1]
    28                                         
    29     96.9 MiB -2157309.6 MiB       49336           if current in remaining_goals:
    30     35.7 MiB    -61.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.9 MiB -19361106.0 MiB      442400           for neighbor in current.neighbors:
    35     96.9 MiB -17203824.3 MiB      393065               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.9 MiB -17203845.8 MiB      393065               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.9 MiB -8592960.3 MiB      196264                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.9 MiB -17203854.7 MiB      393065               if temp_g_score < g_score[neighbor]:
    41     96.9 MiB -2165751.6 MiB       49771                   came_from[neighbor] = current
    42     96.9 MiB -2165752.0 MiB       49771                   g_score[neighbor] = temp_g_score
    43     96.9 MiB -2165755.1 MiB       49771                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.9 MiB -2157296.5 MiB       49335           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.9 MiB -2157297.0 MiB       49335           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.7 MiB      0.0 MiB           1       paths = {}
    53     35.8 MiB      0.0 MiB           2       for goal in goals:
    54     35.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.5 MiB     92.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.5 MiB  -8834.1 MiB         257       for row in grid:
     8     92.5 MiB -2259216.0 MiB       65792           for spot in row:
     9     92.5 MiB -2250405.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     30.5 MiB    -61.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     30.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     31.1 MiB      0.2 MiB           1       open_set.put((0, start))
    17     31.1 MiB      0.0 MiB           1       came_from = {}
    18     40.9 MiB      5.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     40.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     42.2 MiB    -26.2 MiB         604       while not open_set.empty():
    22     42.2 MiB    -26.2 MiB         604           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     42.2 MiB    -26.2 MiB         604           current = open_set.get()[1]
    28                                         
    29     42.2 MiB    -26.2 MiB         604           if current in remaining_goals:
    30     42.2 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     42.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     42.2 MiB   -235.2 MiB        5427           for neighbor in current.neighbors:
    35     42.2 MiB   -209.3 MiB        4824               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     42.2 MiB   -208.8 MiB        4824               if current.row != neighbor.row and current.col != neighbor.col:
    38     42.2 MiB   -104.8 MiB        2412                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     42.2 MiB   -209.3 MiB        4824               if temp_g_score < g_score[neighbor]:
    41     42.2 MiB    -28.4 MiB         722                   came_from[neighbor] = current
    42     42.2 MiB    -28.7 MiB         722                   g_score[neighbor] = temp_g_score
    43     42.2 MiB    -28.6 MiB         722                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     42.2 MiB    -26.2 MiB         603           if draw is not None:
    46                                                     draw()
    47                                                     
    48     42.2 MiB    -26.2 MiB         603           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.2 MiB      0.0 MiB           1       paths = {}
    53     42.2 MiB      0.0 MiB           2       for goal in goals:
    54     42.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.9 MiB     89.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.9 MiB   -807.4 MiB         257       for row in grid:
     8     89.9 MiB -206103.6 MiB       65792           for spot in row:
     9     89.9 MiB -205305.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     73.6 MiB    -16.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     74.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     74.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     74.2 MiB      0.0 MiB           1       came_from = {}
    18     78.2 MiB -1421172.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     32.5 MiB    -45.7 MiB           1       g_score[start] = 0
    20                                         
    21     35.5 MiB -462112.2 MiB       63979       while not open_set.empty():
    22     35.5 MiB -462113.4 MiB       63979           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     35.5 MiB -462115.5 MiB       63979           current = open_set.get()[1]
    28                                         
    29     35.5 MiB -462116.2 MiB       63979           if current in remaining_goals:
    30     29.3 MiB     -6.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     35.5 MiB -4140936.6 MiB      573099           for neighbor in current.neighbors:
    35     35.5 MiB -3678836.8 MiB      509121               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     35.5 MiB -3678824.7 MiB      509121               if current.row != neighbor.row and current.col != neighbor.col:
    38     35.5 MiB -1836447.0 MiB      254111                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     35.5 MiB -3678836.8 MiB      509121               if temp_g_score < g_score[neighbor]:
    41     35.5 MiB -462191.3 MiB       64098                   came_from[neighbor] = current
    42     35.5 MiB -462191.8 MiB       64098                   g_score[neighbor] = temp_g_score
    43     35.5 MiB -462192.6 MiB       64098                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     35.5 MiB -462111.0 MiB       63978           if draw is not None:
    46                                                     draw()
    47                                                     
    48     35.5 MiB -462111.8 MiB       63978           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.3 MiB      0.0 MiB           1       paths = {}
    53     30.8 MiB      0.0 MiB           2       for goal in goals:
    54     30.8 MiB      1.5 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.5 MiB     88.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.5 MiB   -310.3 MiB         257       for row in grid:
     8     88.5 MiB -78982.0 MiB       65792           for spot in row:
     9     88.5 MiB -78677.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.3 MiB     -8.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     80.8 MiB      0.2 MiB           1       open_set.put((0, start))
    17     80.8 MiB      0.0 MiB           1       came_from = {}
    18     84.8 MiB -23192.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.7 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     84.7 MiB -2339132.3 MiB       41332       while not open_set.empty():
    22     84.7 MiB -2339134.3 MiB       41332           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.7 MiB -2339138.3 MiB       41332           current = open_set.get()[1]
    28                                         
    29     84.7 MiB -2339139.5 MiB       41332           if current in remaining_goals:
    30     32.2 MiB    -52.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.7 MiB -20974807.1 MiB      370579           for neighbor in current.neighbors:
    35     84.7 MiB -18635696.5 MiB      329248               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.7 MiB -18635699.7 MiB      329248               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.7 MiB -9305060.8 MiB      164391                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.7 MiB -18635724.7 MiB      329248               if temp_g_score < g_score[neighbor]:
    41     84.7 MiB -2363696.1 MiB       41814                   came_from[neighbor] = current
    42     84.7 MiB -2363698.0 MiB       41814                   g_score[neighbor] = temp_g_score
    43     84.7 MiB -2363703.3 MiB       41814                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.7 MiB -2339127.2 MiB       41331           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.7 MiB -2339129.0 MiB       41331           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.2 MiB      0.0 MiB           1       paths = {}
    53     32.4 MiB      0.0 MiB           2       for goal in goals:
    54     32.4 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     32.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.7 MiB     87.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.7 MiB  -2045.5 MiB         257       for row in grid:
     8     87.7 MiB -514927.2 MiB       65792           for spot in row:
     9     87.7 MiB -512926.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     22.6 MiB    -65.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     22.8 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     22.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     22.8 MiB      0.0 MiB           1       came_from = {}
    18     30.7 MiB -15854.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     30.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     31.6 MiB -217950.3 MiB       35548       while not open_set.empty():
    22     31.6 MiB -217950.6 MiB       35548           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     31.6 MiB -217953.4 MiB       35548           current = open_set.get()[1]
    28                                         
    29     31.6 MiB -217407.5 MiB       35548           if current in remaining_goals:
    30     28.3 MiB     -3.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     28.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     28.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     31.6 MiB -1950517.0 MiB      318844           for neighbor in current.neighbors:
    35     31.6 MiB -1736919.8 MiB      283297               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     31.6 MiB -1732558.9 MiB      283297               if current.row != neighbor.row and current.col != neighbor.col:
    38     31.6 MiB -865176.1 MiB      141469                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     31.6 MiB -1732564.1 MiB      283297               if temp_g_score < g_score[neighbor]:
    41     31.6 MiB -219722.6 MiB       36041                   came_from[neighbor] = current
    42     31.6 MiB -220275.4 MiB       36041                   g_score[neighbor] = temp_g_score
    43     31.6 MiB -220275.8 MiB       36041                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     31.6 MiB -217950.0 MiB       35547           if draw is not None:
    46                                                     draw()
    47                                                     
    48     31.6 MiB -217950.2 MiB       35547           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     28.3 MiB      0.0 MiB           1       paths = {}
    53     28.6 MiB      0.0 MiB           2       for goal in goals:
    54     28.6 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     28.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.4 MiB    -50.4 MiB         257       for row in grid:
     8     86.4 MiB -13010.4 MiB       65792           for spot in row:
     9     86.4 MiB -12960.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.7 MiB     -0.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.7 MiB      0.0 MiB           1       came_from = {}
    18     90.5 MiB   -211.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.5 MiB -40956.8 MiB        6333       while not open_set.empty():
    22     90.5 MiB -40956.8 MiB        6333           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.5 MiB -40956.9 MiB        6333           current = open_set.get()[1]
    28                                         
    29     90.5 MiB -40956.9 MiB        6333           if current in remaining_goals:
    30     85.5 MiB     -5.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     85.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     85.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.5 MiB -368580.7 MiB       56988           for neighbor in current.neighbors:
    35     90.5 MiB -327624.6 MiB       50656               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.5 MiB -327627.1 MiB       50656               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.5 MiB -163821.3 MiB       25328                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.5 MiB -327630.6 MiB       50656               if temp_g_score < g_score[neighbor]:
    41     90.5 MiB -43014.9 MiB        6715                   came_from[neighbor] = current
    42     90.5 MiB -43014.9 MiB        6715                   g_score[neighbor] = temp_g_score
    43     90.5 MiB -43014.9 MiB        6715                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.5 MiB -40956.6 MiB        6332           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.5 MiB -40956.6 MiB        6332           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     85.5 MiB      0.0 MiB           1       paths = {}
    53     85.5 MiB      0.0 MiB           2       for goal in goals:
    54     85.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     85.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.6 MiB     87.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.6 MiB  -6427.1 MiB         257       for row in grid:
     8     87.6 MiB -1644356.5 MiB       65792           for spot in row:
     9     87.6 MiB -1637936.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     35.6 MiB    -52.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     35.8 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     35.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     35.8 MiB      0.0 MiB           1       came_from = {}
    18     45.1 MiB      9.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     45.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     45.7 MiB -521774.6 MiB       46716       while not open_set.empty():
    22     45.7 MiB -521776.2 MiB       46716           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     45.7 MiB -521778.3 MiB       46716           current = open_set.get()[1]
    28                                         
    29     45.7 MiB -521779.0 MiB       46716           if current in remaining_goals:
    30     34.3 MiB    -11.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     45.7 MiB -4691270.9 MiB      420039           for neighbor in current.neighbors:
    35     45.7 MiB -4169503.0 MiB      373324               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     45.7 MiB -4169496.2 MiB      373324               if current.row != neighbor.row and current.col != neighbor.col:
    38     45.7 MiB -2083981.9 MiB      186596                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     45.7 MiB -4169507.6 MiB      373324               if temp_g_score < g_score[neighbor]:
    41     45.7 MiB -528708.4 MiB       47566                   came_from[neighbor] = current
    42     45.7 MiB -528708.9 MiB       47566                   g_score[neighbor] = temp_g_score
    43     45.7 MiB -528711.2 MiB       47566                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     45.7 MiB -521773.1 MiB       46715           if draw is not None:
    46                                                     draw()
    47                                                     
    48     45.7 MiB -521773.6 MiB       46715           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.3 MiB      0.0 MiB           1       paths = {}
    53     34.5 MiB      0.0 MiB           2       for goal in goals:
    54     34.5 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.4 MiB     85.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.9 MiB      0.0 MiB         257       for row in grid:
     8     85.9 MiB      0.0 MiB       65792           for spot in row:
     9     85.9 MiB      0.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.9 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.9 MiB      0.0 MiB           1       came_from = {}
    18     88.9 MiB   -141.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.0 MiB -2285008.6 MiB       42330       while not open_set.empty():
    22     89.0 MiB -2285009.3 MiB       42330           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.0 MiB -2285010.1 MiB       42330           current = open_set.get()[1]
    28                                         
    29     89.0 MiB -2285011.0 MiB       42330           if current in remaining_goals:
    30     36.2 MiB    -52.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     36.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     36.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.0 MiB -20494094.9 MiB      379609           for neighbor in current.neighbors:
    35     89.0 MiB -18209111.2 MiB      337280               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.0 MiB -18209106.8 MiB      337280               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.0 MiB -9092848.9 MiB      168415                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.0 MiB -18209128.6 MiB      337280               if temp_g_score < g_score[neighbor]:
    41     89.0 MiB -2299465.5 MiB       42794                   came_from[neighbor] = current
    42     89.0 MiB -2299467.6 MiB       42794                   g_score[neighbor] = temp_g_score
    43     89.0 MiB -2299468.9 MiB       42794                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.0 MiB -2285005.3 MiB       42329           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.0 MiB -2285007.2 MiB       42329           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     36.2 MiB      0.0 MiB           1       paths = {}
    53     36.5 MiB      0.0 MiB           2       for goal in goals:
    54     36.5 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     36.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.4 MiB     84.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.4 MiB    -12.7 MiB         257       for row in grid:
     8     84.4 MiB  -3251.5 MiB       65792           for spot in row:
     9     84.4 MiB  -3238.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.3 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.3 MiB      0.0 MiB           1       came_from = {}
    18     88.7 MiB  -4745.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.8 MiB -2218353.0 MiB       48631       while not open_set.empty():
    22     88.8 MiB -2218353.9 MiB       48631           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.8 MiB -2218355.3 MiB       48631           current = open_set.get()[1]
    28                                         
    29     88.8 MiB -2218355.9 MiB       48631           if current in remaining_goals:
    30     35.3 MiB    -53.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.8 MiB -19905402.8 MiB      436584           for neighbor in current.neighbors:
    35     88.8 MiB -17687090.0 MiB      387954               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.8 MiB -17687088.1 MiB      387954               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.8 MiB -8833698.8 MiB      193796                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.8 MiB -17687098.9 MiB      387954               if temp_g_score < g_score[neighbor]:
    41     88.8 MiB -2227321.4 MiB       49233                   came_from[neighbor] = current
    42     88.8 MiB -2227321.9 MiB       49233                   g_score[neighbor] = temp_g_score
    43     88.8 MiB -2227323.4 MiB       49233                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.8 MiB -2218350.6 MiB       48630           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.8 MiB -2218352.3 MiB       48630           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.3 MiB      0.0 MiB           1       paths = {}
    53     35.5 MiB      0.0 MiB           2       for goal in goals:
    54     35.5 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.4 MiB     92.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.4 MiB      0.0 MiB         257       for row in grid:
     8     92.4 MiB      0.0 MiB       65792           for spot in row:
     9     92.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.4 MiB      0.0 MiB           1       came_from = {}
    18     97.1 MiB   -313.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.1 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.2 MiB -2540395.0 MiB       49078       while not open_set.empty():
    22     97.2 MiB -2540397.0 MiB       49078           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.2 MiB -2540399.4 MiB       49078           current = open_set.get()[1]
    28                                         
    29     97.2 MiB -2540400.5 MiB       49078           if current in remaining_goals:
    30     24.8 MiB    -72.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     24.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     24.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     97.2 MiB -22759540.6 MiB      440111           for neighbor in current.neighbors:
    35     97.2 MiB -20219178.3 MiB      391034               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.2 MiB -20219188.2 MiB      391034               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.2 MiB -10092445.1 MiB      195254                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.2 MiB -20219211.9 MiB      391034               if temp_g_score < g_score[neighbor]:
    41     97.2 MiB -2537991.8 MiB       49500                   came_from[neighbor] = current
    42     97.2 MiB -2537994.8 MiB       49500                   g_score[neighbor] = temp_g_score
    43     97.2 MiB -2537998.4 MiB       49500                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.2 MiB -2540391.3 MiB       49077           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.2 MiB -2540393.2 MiB       49077           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     24.9 MiB      0.0 MiB           1       paths = {}
    53     25.6 MiB      0.0 MiB           2       for goal in goals:
    54     25.6 MiB      0.7 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     25.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.5 MiB     90.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.5 MiB     -3.9 MiB         257       for row in grid:
     8     90.5 MiB   -992.4 MiB       65792           for spot in row:
     9     90.5 MiB   -988.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.5 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.5 MiB      0.0 MiB           1       came_from = {}
    18     93.5 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.6 MiB -2299501.9 MiB       45616       while not open_set.empty():
    22     93.6 MiB -2299503.7 MiB       45616           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.6 MiB -2299504.9 MiB       45616           current = open_set.get()[1]
    28                                         
    29     93.6 MiB -2299506.1 MiB       45616           if current in remaining_goals:
    30     40.5 MiB    -53.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     40.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.6 MiB -20628142.3 MiB      409228           for neighbor in current.neighbors:
    35     93.6 MiB -18328667.1 MiB      363613               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.6 MiB -18328666.2 MiB      363613               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.6 MiB -9153225.7 MiB      181589                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.6 MiB -18328682.4 MiB      363613               if temp_g_score < g_score[neighbor]:
    41     93.6 MiB -2311164.5 MiB       46131                   came_from[neighbor] = current
    42     93.6 MiB -2311168.0 MiB       46131                   g_score[neighbor] = temp_g_score
    43     93.6 MiB -2311170.0 MiB       46131                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.6 MiB -2299500.1 MiB       45615           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.6 MiB -2299500.8 MiB       45615           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.5 MiB      0.0 MiB           1       paths = {}
    53     40.8 MiB      0.0 MiB           2       for goal in goals:
    54     40.8 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.6 MiB     91.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.6 MiB  -1045.2 MiB         257       for row in grid:
     8     91.6 MiB -267025.4 MiB       65792           for spot in row:
     9     91.6 MiB -265985.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.8 MiB     -7.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.8 MiB      0.0 MiB           1       came_from = {}
    18     88.3 MiB  -2708.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.8 MiB     -0.5 MiB           1       g_score[start] = 0
    20                                         
    21     87.9 MiB -1413531.5 MiB       37033       while not open_set.empty():
    22     87.9 MiB -1413531.5 MiB       37033           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.9 MiB -1413565.6 MiB       37033           current = open_set.get()[1]
    28                                         
    29     87.9 MiB -1413566.0 MiB       37033           if current in remaining_goals:
    30     45.8 MiB    -42.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     45.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.9 MiB -12685906.9 MiB      332095           for neighbor in current.neighbors:
    35     87.9 MiB -11272378.9 MiB      295063               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.9 MiB -11272376.2 MiB      295063               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.9 MiB -5630241.8 MiB      147333                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.9 MiB -11272384.9 MiB      295063               if temp_g_score < g_score[neighbor]:
    41     87.9 MiB -1424169.6 MiB       37494                   came_from[neighbor] = current
    42     87.9 MiB -1424171.0 MiB       37494                   g_score[neighbor] = temp_g_score
    43     87.9 MiB -1424173.0 MiB       37494                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.9 MiB -1413530.8 MiB       37032           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.9 MiB -1413531.0 MiB       37032           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.8 MiB      0.0 MiB           1       paths = {}
    53     46.0 MiB      0.0 MiB           2       for goal in goals:
    54     46.0 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.7 MiB     88.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.7 MiB   -503.4 MiB         257       for row in grid:
     8     88.7 MiB -128812.9 MiB       65792           for spot in row:
     9     88.7 MiB -128311.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.6 MiB     -4.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.6 MiB      0.0 MiB           1       came_from = {}
    18     86.9 MiB -88089.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     77.1 MiB     -9.9 MiB           1       g_score[start] = 0
    20                                         
    21     77.2 MiB -1864010.3 MiB       43569       while not open_set.empty():
    22     77.2 MiB -1864012.3 MiB       43569           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     77.2 MiB -1864014.6 MiB       43569           current = open_set.get()[1]
    28                                         
    29     77.2 MiB -1864015.7 MiB       43569           if current in remaining_goals:
    30     34.6 MiB    -42.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     77.2 MiB -16710460.4 MiB      390515           for neighbor in current.neighbors:
    35     77.2 MiB -14846465.0 MiB      346947               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     77.2 MiB -14846465.5 MiB      346947               if current.row != neighbor.row and current.col != neighbor.col:
    38     77.2 MiB -7412402.8 MiB      173208                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     77.2 MiB -14846481.9 MiB      346947               if temp_g_score < g_score[neighbor]:
    41     77.2 MiB -1869827.2 MiB       43938                   came_from[neighbor] = current
    42     77.2 MiB -1869827.9 MiB       43938                   g_score[neighbor] = temp_g_score
    43     77.2 MiB -1869829.9 MiB       43938                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     77.2 MiB -1864008.0 MiB       43568           if draw is not None:
    46                                                     draw()
    47                                                     
    48     77.2 MiB -1864009.1 MiB       43568           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.6 MiB      0.0 MiB           1       paths = {}
    53     34.8 MiB      0.0 MiB           2       for goal in goals:
    54     34.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.3 MiB     90.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.3 MiB   -561.5 MiB         257       for row in grid:
     8     90.3 MiB -144008.9 MiB       65792           for spot in row:
     9     90.3 MiB -143449.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.6 MiB     -2.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.6 MiB      0.0 MiB           1       came_from = {}
    18     92.0 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.1 MiB -59592.3 MiB       17057       while not open_set.empty():
    22     92.1 MiB -59592.4 MiB       17057           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.1 MiB -59592.5 MiB       17057           current = open_set.get()[1]
    28                                         
    29     92.1 MiB -59592.5 MiB       17057           if current in remaining_goals:
    30     82.1 MiB    -10.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     82.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     82.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.1 MiB -533995.9 MiB      152740           for neighbor in current.neighbors:
    35     92.1 MiB -474408.5 MiB      135684               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.1 MiB -474409.5 MiB      135684               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.1 MiB -236830.0 MiB       67715                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.1 MiB -474411.2 MiB      135684               if temp_g_score < g_score[neighbor]:
    41     92.1 MiB -60029.1 MiB       17381                   came_from[neighbor] = current
    42     92.1 MiB -60029.3 MiB       17381                   g_score[neighbor] = temp_g_score
    43     92.1 MiB -60029.3 MiB       17381                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.1 MiB -59592.2 MiB       17056           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.1 MiB -59592.2 MiB       17056           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     82.1 MiB      0.0 MiB           1       paths = {}
    53     82.1 MiB      0.0 MiB           2       for goal in goals:
    54     82.1 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     82.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.3 MiB     90.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.3 MiB  -1157.7 MiB         257       for row in grid:
     8     90.3 MiB -296912.7 MiB       65792           for spot in row:
     9     90.3 MiB -295757.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.3 MiB     -5.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.3 MiB      0.0 MiB           1       came_from = {}
    18     89.3 MiB  -2126.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.5 MiB -2306146.9 MiB       54422       while not open_set.empty():
    22     89.5 MiB -2306147.6 MiB       54422           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.5 MiB -2306148.5 MiB       54422           current = open_set.get()[1]
    28                                         
    29     89.5 MiB -2306149.5 MiB       54422           if current in remaining_goals:
    30     33.5 MiB    -56.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     33.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.5 MiB -20680988.4 MiB      488054           for neighbor in current.neighbors:
    35     89.5 MiB -18374856.8 MiB      433633               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.5 MiB -18374859.4 MiB      433633               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.5 MiB -9175173.5 MiB      216528                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.5 MiB -18374880.1 MiB      433633               if temp_g_score < g_score[neighbor]:
    41     89.5 MiB -2311442.8 MiB       54853                   came_from[neighbor] = current
    42     89.5 MiB -2311443.9 MiB       54853                   g_score[neighbor] = temp_g_score
    43     89.5 MiB -2311445.2 MiB       54853                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.5 MiB -2306144.0 MiB       54421           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.5 MiB -2306146.0 MiB       54421           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.5 MiB      0.0 MiB           1       paths = {}
    53     34.0 MiB      0.0 MiB           2       for goal in goals:
    54     34.0 MiB      0.5 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.4 MiB     85.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.4 MiB    -50.7 MiB         257       for row in grid:
     8     85.4 MiB -12944.3 MiB       65792           for spot in row:
     9     85.4 MiB -12894.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.5 MiB     -0.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.5 MiB      0.0 MiB           1       came_from = {}
    18     88.1 MiB    -15.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.3 MiB -19121.5 MiB        6260       while not open_set.empty():
    22     88.3 MiB -19121.7 MiB        6260           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.3 MiB -19122.3 MiB        6260           current = open_set.get()[1]
    28                                         
    29     88.3 MiB -19122.7 MiB        6260           if current in remaining_goals:
    30     82.2 MiB     -6.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     82.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     82.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.3 MiB -171376.1 MiB       55962           for neighbor in current.neighbors:
    35     88.3 MiB -152257.5 MiB       49703               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.3 MiB -152257.8 MiB       49703               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.3 MiB -76013.7 MiB       24790                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.3 MiB -152258.2 MiB       49703               if temp_g_score < g_score[neighbor]:
    41     88.3 MiB -19620.6 MiB        6527                   came_from[neighbor] = current
    42     88.3 MiB -19621.0 MiB        6527                   g_score[neighbor] = temp_g_score
    43     88.3 MiB -19621.1 MiB        6527                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.3 MiB -19121.1 MiB        6259           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.3 MiB -19121.2 MiB        6259           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     82.2 MiB      0.0 MiB           1       paths = {}
    53     82.2 MiB      0.0 MiB           2       for goal in goals:
    54     82.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     82.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.7 MiB     89.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.7 MiB   -737.5 MiB         257       for row in grid:
     8     89.7 MiB -189049.8 MiB       65792           for spot in row:
     9     89.7 MiB -188314.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.5 MiB     -3.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.5 MiB      0.0 MiB           1       came_from = {}
    18     88.4 MiB -886294.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     49.0 MiB    -39.5 MiB           1       g_score[start] = 0
    20                                         
    21     49.8 MiB -448900.4 MiB       31391       while not open_set.empty():
    22     49.8 MiB -448901.5 MiB       31391           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     49.8 MiB -448902.4 MiB       31391           current = open_set.get()[1]
    28                                         
    29     49.8 MiB -448902.8 MiB       31391           if current in remaining_goals:
    30     34.9 MiB    -14.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     49.8 MiB -4026999.7 MiB      281293           for neighbor in current.neighbors:
    35     49.8 MiB -3578103.8 MiB      249903               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     49.8 MiB -3578102.4 MiB      249903               if current.row != neighbor.row and current.col != neighbor.col:
    38     49.8 MiB -1786900.2 MiB      124749                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     49.8 MiB -3578111.2 MiB      249903               if temp_g_score < g_score[neighbor]:
    41     49.8 MiB -453218.7 MiB       31810                   came_from[neighbor] = current
    42     49.8 MiB -453220.3 MiB       31810                   g_score[neighbor] = temp_g_score
    43     49.8 MiB -453220.8 MiB       31810                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     49.8 MiB -448899.3 MiB       31390           if draw is not None:
    46                                                     draw()
    47                                                     
    48     49.8 MiB -448899.9 MiB       31390           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.9 MiB      0.0 MiB           1       paths = {}
    53     35.1 MiB      0.0 MiB           2       for goal in goals:
    54     35.1 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.8 MiB     92.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.8 MiB    -16.2 MiB         257       for row in grid:
     8     92.8 MiB  -4148.3 MiB       65792           for spot in row:
     9     92.8 MiB  -4132.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.7 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.7 MiB      0.0 MiB           1       came_from = {}
    18     98.0 MiB      5.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     98.1 MiB -865024.2 MiB       15305       while not open_set.empty():
    22     98.1 MiB -865026.8 MiB       15305           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     98.1 MiB -865031.9 MiB       15305           current = open_set.get()[1]
    28                                         
    29     98.1 MiB -865032.3 MiB       15305           if current in remaining_goals:
    30     27.9 MiB    -70.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     27.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     27.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     98.1 MiB -7748443.5 MiB      136957           for neighbor in current.neighbors:
    35     98.1 MiB -6883429.5 MiB      121653               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     98.1 MiB -6883440.8 MiB      121653               if current.row != neighbor.row and current.col != neighbor.col:
    38     98.1 MiB -3435480.3 MiB       60697                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     98.1 MiB -6883472.2 MiB      121653               if temp_g_score < g_score[neighbor]:
    41     98.1 MiB -873023.7 MiB       15606                   came_from[neighbor] = current
    42     98.1 MiB -873024.4 MiB       15606                   g_score[neighbor] = temp_g_score
    43     98.1 MiB -873025.1 MiB       15606                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     98.1 MiB -865221.5 MiB       15304           if draw is not None:
    46                                                     draw()
    47                                                     
    48     98.1 MiB -865023.0 MiB       15304           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.9 MiB      0.0 MiB           1       paths = {}
    53     28.0 MiB      0.0 MiB           2       for goal in goals:
    54     28.0 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     28.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.0 MiB     91.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.0 MiB   -104.1 MiB         257       for row in grid:
     8     91.0 MiB -26668.0 MiB       65792           for spot in row:
     9     91.0 MiB -26564.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.1 MiB     -0.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.1 MiB      0.0 MiB           1       came_from = {}
    18     93.1 MiB  -3501.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.0 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     93.3 MiB  -5264.5 MiB       11199       while not open_set.empty():
    22     93.3 MiB  -5265.4 MiB       11199           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.3 MiB  -5265.4 MiB       11199           current = open_set.get()[1]
    28                                         
    29     93.3 MiB  -5265.4 MiB       11199           if current in remaining_goals:
    30     91.3 MiB     -2.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     91.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     91.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.3 MiB -47375.2 MiB      100782           for neighbor in current.neighbors:
    35     93.3 MiB -42111.1 MiB       89584               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.3 MiB -42111.8 MiB       89584               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.3 MiB -21057.5 MiB       44792                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.3 MiB -42112.1 MiB       89584               if temp_g_score < g_score[neighbor]:
    41     93.3 MiB  -5390.3 MiB       11701                   came_from[neighbor] = current
    42     93.3 MiB  -5390.6 MiB       11701                   g_score[neighbor] = temp_g_score
    43     93.3 MiB  -5390.8 MiB       11701                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.3 MiB  -5264.4 MiB       11198           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.3 MiB  -5264.5 MiB       11198           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     91.3 MiB      0.0 MiB           1       paths = {}
    53     91.3 MiB      0.0 MiB           2       for goal in goals:
    54     91.3 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     91.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     94.2 MiB     94.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     94.2 MiB    -85.5 MiB         257       for row in grid:
     8     94.2 MiB -21751.5 MiB       65792           for spot in row:
     9     94.2 MiB -21666.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.1 MiB     -1.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.1 MiB      0.0 MiB           1       came_from = {}
    18     98.2 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     98.2 MiB -2170029.9 MiB       46097       while not open_set.empty():
    22     98.2 MiB -2170030.9 MiB       46097           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     98.2 MiB -2170033.2 MiB       46097           current = open_set.get()[1]
    28                                         
    29     98.2 MiB -2170034.4 MiB       46097           if current in remaining_goals:
    30     33.2 MiB    -65.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     33.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     98.2 MiB -19459561.2 MiB      413635           for neighbor in current.neighbors:
    35     98.2 MiB -17289564.2 MiB      367539               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     98.2 MiB -17289570.0 MiB      367539               if current.row != neighbor.row and current.col != neighbor.col:
    38     98.2 MiB -8633149.1 MiB      183565                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     98.2 MiB -17289586.0 MiB      367539               if temp_g_score < g_score[neighbor]:
    41     98.2 MiB -2177060.7 MiB       46630                   came_from[neighbor] = current
    42     98.2 MiB -2177062.3 MiB       46630                   g_score[neighbor] = temp_g_score
    43     98.2 MiB -2177064.5 MiB       46630                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     98.2 MiB -2170027.0 MiB       46096           if draw is not None:
    46                                                     draw()
    47                                                     
    48     98.2 MiB -2170027.7 MiB       46096           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.2 MiB      0.0 MiB           1       paths = {}
    53     33.5 MiB      0.0 MiB           2       for goal in goals:
    54     33.5 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.1 MiB     91.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.2 MiB   -471.8 MiB         257       for row in grid:
     8     91.2 MiB -120883.5 MiB       65792           for spot in row:
     9     91.2 MiB -120413.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.2 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.2 MiB      0.0 MiB           1       came_from = {}
    18     94.2 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.2 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.3 MiB -2827950.5 MiB       60930       while not open_set.empty():
    22     94.3 MiB -2827951.4 MiB       60930           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.3 MiB -2827953.5 MiB       60930           current = open_set.get()[1]
    28                                         
    29     94.3 MiB -2827954.7 MiB       60930           if current in remaining_goals:
    30     23.7 MiB    -70.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     23.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     23.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.3 MiB -25348272.4 MiB      546035           for neighbor in current.neighbors:
    35     94.3 MiB -22520338.7 MiB      485106               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.3 MiB -22520360.8 MiB      485106               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.3 MiB -11243126.8 MiB      242166                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.3 MiB -22520382.6 MiB      485106               if temp_g_score < g_score[neighbor]:
    41     94.3 MiB -2823617.3 MiB       61174                   came_from[neighbor] = current
    42     94.3 MiB -2823619.8 MiB       61174                   g_score[neighbor] = temp_g_score
    43     94.3 MiB -2823623.4 MiB       61174                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.3 MiB -2827948.4 MiB       60929           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.3 MiB -2827949.4 MiB       60929           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     23.7 MiB      0.0 MiB           1       paths = {}
    53     25.0 MiB      0.0 MiB           2       for goal in goals:
    54     25.0 MiB      1.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     25.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.5 MiB     86.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.5 MiB  -1097.6 MiB         257       for row in grid:
     8     86.5 MiB -281208.7 MiB       65792           for spot in row:
     9     86.5 MiB -280113.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.1 MiB     -5.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     81.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     81.5 MiB      0.0 MiB           1       came_from = {}
    18     86.5 MiB  -4829.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.3 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     86.4 MiB -1083909.9 MiB       20311       while not open_set.empty():
    22     86.4 MiB -1083910.4 MiB       20311           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.4 MiB -1083911.1 MiB       20311           current = open_set.get()[1]
    28                                         
    29     86.4 MiB -1083911.5 MiB       20311           if current in remaining_goals:
    30     44.2 MiB    -42.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     44.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.4 MiB -9755079.3 MiB      182790           for neighbor in current.neighbors:
    35     86.4 MiB -8671196.5 MiB      162480               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.4 MiB -8671193.3 MiB      162480               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.4 MiB -4335622.7 MiB       81240                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.4 MiB -8671215.8 MiB      162480               if temp_g_score < g_score[neighbor]:
    41     86.4 MiB -1116319.2 MiB       20989                   came_from[neighbor] = current
    42     86.4 MiB -1116319.5 MiB       20989                   g_score[neighbor] = temp_g_score
    43     86.4 MiB -1116320.1 MiB       20989                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.4 MiB -1083908.8 MiB       20310           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.4 MiB -1083909.3 MiB       20310           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.2 MiB      0.0 MiB           1       paths = {}
    53     44.3 MiB      0.0 MiB           2       for goal in goals:
    54     44.3 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.4 MiB      0.0 MiB         257       for row in grid:
     8     86.4 MiB      0.0 MiB       65792           for spot in row:
     9     86.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.4 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.4 MiB      0.0 MiB           1       came_from = {}
    18     89.7 MiB   -141.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.8 MiB -1953924.5 MiB       36186       while not open_set.empty():
    22     89.8 MiB -1953926.0 MiB       36186           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.8 MiB -1953926.8 MiB       36186           current = open_set.get()[1]
    28                                         
    29     89.8 MiB -1953927.3 MiB       36186           if current in remaining_goals:
    30     38.3 MiB    -51.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     38.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     38.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.8 MiB -17527129.9 MiB      324622           for neighbor in current.neighbors:
    35     89.8 MiB -15573236.4 MiB      288437               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.8 MiB -15573233.8 MiB      288437               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.8 MiB -7777082.7 MiB      144045                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.8 MiB -15573255.2 MiB      288437               if temp_g_score < g_score[neighbor]:
    41     89.8 MiB -1970101.0 MiB       36673                   came_from[neighbor] = current
    42     89.8 MiB -1970101.9 MiB       36673                   g_score[neighbor] = temp_g_score
    43     89.8 MiB -1970102.6 MiB       36673                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.8 MiB -1953922.2 MiB       36185           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.8 MiB -1953922.5 MiB       36185           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     38.3 MiB      0.0 MiB           1       paths = {}
    53     38.4 MiB      0.0 MiB           2       for goal in goals:
    54     38.4 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     38.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.1 MiB     86.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.1 MiB    -40.0 MiB         257       for row in grid:
     8     86.1 MiB -10241.0 MiB       65792           for spot in row:
     9     86.1 MiB -10201.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB     -0.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     90.6 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.9 MiB -495988.6 MiB       40972       while not open_set.empty():
    22     90.9 MiB -495989.5 MiB       40972           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.9 MiB -495991.1 MiB       40972           current = open_set.get()[1]
    28                                         
    29     90.9 MiB -495991.7 MiB       40972           if current in remaining_goals:
    30     49.1 MiB    -41.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     49.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     49.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.9 MiB -4454092.8 MiB      367438           for neighbor in current.neighbors:
    35     90.9 MiB -3958117.6 MiB      326467               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.9 MiB -3958124.4 MiB      326467               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.9 MiB -1977500.0 MiB      163017                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.9 MiB -3958135.6 MiB      326467               if temp_g_score < g_score[neighbor]:
    41     90.9 MiB -499261.6 MiB       41459                   came_from[neighbor] = current
    42     90.9 MiB -499263.0 MiB       41459                   g_score[neighbor] = temp_g_score
    43     90.9 MiB -499264.8 MiB       41459                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.9 MiB -495986.5 MiB       40971           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.9 MiB -495987.5 MiB       40971           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     49.1 MiB      0.0 MiB           1       paths = {}
    53     49.3 MiB      0.0 MiB           2       for goal in goals:
    54     49.3 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     49.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.9 MiB     86.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.9 MiB   -118.1 MiB         257       for row in grid:
     8     86.9 MiB -29843.9 MiB       65792           for spot in row:
     9     86.9 MiB -29727.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.4 MiB     -2.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.4 MiB      0.0 MiB           1       came_from = {}
    18     89.3 MiB  -1269.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.4 MiB -636375.3 MiB       45476       while not open_set.empty():
    22     89.4 MiB -636379.5 MiB       45476           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.4 MiB -636380.8 MiB       45476           current = open_set.get()[1]
    28                                         
    29     89.4 MiB -636381.5 MiB       45476           if current in remaining_goals:
    30     35.3 MiB    -54.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.4 MiB -5715081.8 MiB      407890           for neighbor in current.neighbors:
    35     89.4 MiB -5078730.9 MiB      362415               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.4 MiB -5078734.7 MiB      362415               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.4 MiB -2537409.2 MiB      180977                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.4 MiB -5078749.1 MiB      362415               if temp_g_score < g_score[neighbor]:
    41     89.4 MiB -640249.3 MiB       45983                   came_from[neighbor] = current
    42     89.4 MiB -640251.3 MiB       45983                   g_score[neighbor] = temp_g_score
    43     89.4 MiB -640253.7 MiB       45983                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.4 MiB -636372.9 MiB       45475           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.4 MiB -636374.0 MiB       45475           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.3 MiB      0.0 MiB           1       paths = {}
    53     35.6 MiB      0.0 MiB           2       for goal in goals:
    54     35.6 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.6 MiB     87.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.6 MiB   -344.5 MiB         257       for row in grid:
     8     87.6 MiB -86752.2 MiB       65792           for spot in row:
     9     87.6 MiB -86414.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     77.7 MiB     -9.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     77.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     77.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     77.7 MiB      0.0 MiB           1       came_from = {}
    18     84.5 MiB      6.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     84.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     84.7 MiB -2629482.5 MiB       61022       while not open_set.empty():
    22     84.7 MiB -2629483.5 MiB       61022           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     84.7 MiB -2629486.0 MiB       61022           current = open_set.get()[1]
    28                                         
    29     84.7 MiB -2629487.9 MiB       61022           if current in remaining_goals:
    30     31.0 MiB    -53.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     31.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     31.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     84.7 MiB -23555513.6 MiB      547010           for neighbor in current.neighbors:
    35     84.7 MiB -20926051.5 MiB      485989               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     84.7 MiB -20926045.9 MiB      485989               if current.row != neighbor.row and current.col != neighbor.col:
    38     84.7 MiB -10444821.8 MiB      242632                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     84.7 MiB -20926062.3 MiB      485989               if temp_g_score < g_score[neighbor]:
    41     84.7 MiB -2621957.1 MiB       61315                   came_from[neighbor] = current
    42     84.7 MiB -2621957.9 MiB       61315                   g_score[neighbor] = temp_g_score
    43     84.7 MiB -2621960.1 MiB       61315                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     84.7 MiB -2629469.4 MiB       61021           if draw is not None:
    46                                                     draw()
    47                                                     
    48     84.7 MiB -2629473.5 MiB       61021           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     31.0 MiB      0.0 MiB           1       paths = {}
    53     31.5 MiB      0.0 MiB           2       for goal in goals:
    54     31.5 MiB      0.5 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     31.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.2 MiB     92.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.2 MiB     -9.1 MiB         257       for row in grid:
     8     92.2 MiB  -2337.9 MiB       65792           for spot in row:
     9     92.2 MiB  -2328.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.1 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.1 MiB      0.0 MiB           1       came_from = {}
    18     97.1 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     97.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     97.7 MiB -1387760.5 MiB       45218       while not open_set.empty():
    22     97.7 MiB -1387761.2 MiB       45218           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     97.7 MiB -1387763.9 MiB       45218           current = open_set.get()[1]
    28                                         
    29     97.7 MiB -1387764.9 MiB       45218           if current in remaining_goals:
    30     46.9 MiB    -50.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     46.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     46.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     97.7 MiB -12441725.0 MiB      405750           for neighbor in current.neighbors:
    35     97.7 MiB -11053982.5 MiB      360533               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     97.7 MiB -11053995.0 MiB      360533               if current.row != neighbor.row and current.col != neighbor.col:
    38     97.7 MiB -5519071.0 MiB      180066                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     97.7 MiB -11054012.3 MiB      360533               if temp_g_score < g_score[neighbor]:
    41     97.7 MiB -1387612.9 MiB       45741                   came_from[neighbor] = current
    42     97.7 MiB -1387614.4 MiB       45741                   g_score[neighbor] = temp_g_score
    43     97.7 MiB -1387616.1 MiB       45741                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     97.7 MiB -1387758.2 MiB       45217           if draw is not None:
    46                                                     draw()
    47                                                     
    48     97.7 MiB -1387759.1 MiB       45217           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.9 MiB      0.0 MiB           1       paths = {}
    53     47.2 MiB      0.0 MiB           2       for goal in goals:
    54     47.2 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.5 MiB     93.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.5 MiB    -97.4 MiB         257       for row in grid:
     8     93.5 MiB -24938.0 MiB       65792           for spot in row:
     9     93.5 MiB -24841.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.2 MiB     -1.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.2 MiB      0.0 MiB           1       came_from = {}
    18     94.1 MiB -44787.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.2 MiB -1026818.0 MiB       44685       while not open_set.empty():
    22     94.2 MiB -1026818.9 MiB       44685           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.2 MiB -1026830.0 MiB       44685           current = open_set.get()[1]
    28                                         
    29     94.2 MiB -1026834.4 MiB       44685           if current in remaining_goals:
    30     48.5 MiB    -45.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     48.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     48.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.2 MiB -9211797.3 MiB      401193           for neighbor in current.neighbors:
    35     94.2 MiB -8184988.5 MiB      356509               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.2 MiB -8184991.4 MiB      356509               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.2 MiB -4087614.8 MiB      178094                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.2 MiB -8185011.9 MiB      356509               if temp_g_score < g_score[neighbor]:
    41     94.2 MiB -1030645.7 MiB       45296                   came_from[neighbor] = current
    42     94.2 MiB -1030646.2 MiB       45296                   g_score[neighbor] = temp_g_score
    43     94.2 MiB -1030646.5 MiB       45296                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.2 MiB -1026816.1 MiB       44684           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.2 MiB -1026817.0 MiB       44684           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     48.5 MiB      0.0 MiB           1       paths = {}
    53     48.6 MiB      0.0 MiB           2       for goal in goals:
    54     48.6 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     48.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.6 MiB     93.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.6 MiB   -187.9 MiB         257       for row in grid:
     8     93.6 MiB -47631.4 MiB       65792           for spot in row:
     9     93.6 MiB -47447.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.6 MiB     -4.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.6 MiB      0.0 MiB           1       came_from = {}
    18     94.6 MiB  -1218.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.6 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.8 MiB -47152.8 MiB       18127       while not open_set.empty():
    22     94.8 MiB -47152.9 MiB       18127           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.8 MiB -47154.3 MiB       18127           current = open_set.get()[1]
    28                                         
    29     94.8 MiB -47154.9 MiB       18127           if current in remaining_goals:
    30     68.7 MiB    -26.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     68.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     68.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.8 MiB -422929.0 MiB      162295           for neighbor in current.neighbors:
    35     94.8 MiB -375780.3 MiB      144169               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.8 MiB -375782.3 MiB      144169               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.8 MiB -187692.6 MiB       71945                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.8 MiB -375790.1 MiB      144169               if temp_g_score < g_score[neighbor]:
    41     94.8 MiB -47598.4 MiB       18454                   came_from[neighbor] = current
    42     94.8 MiB -47598.9 MiB       18454                   g_score[neighbor] = temp_g_score
    43     94.8 MiB -47602.5 MiB       18454                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.8 MiB -47152.5 MiB       18126           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.8 MiB -47152.6 MiB       18126           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     68.7 MiB      0.0 MiB           1       paths = {}
    53     68.7 MiB      0.0 MiB           2       for goal in goals:
    54     68.7 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     68.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.9 MiB     90.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.9 MiB      0.0 MiB         257       for row in grid:
     8     90.9 MiB      0.0 MiB       65792           for spot in row:
     9     90.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.9 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.9 MiB      0.0 MiB           1       came_from = {}
    18     94.7 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.7 MiB -1877782.2 MiB       42499       while not open_set.empty():
    22     94.7 MiB -1877784.0 MiB       42499           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.7 MiB -1877788.0 MiB       42499           current = open_set.get()[1]
    28                                         
    29     94.7 MiB -1877789.5 MiB       42499           if current in remaining_goals:
    30     40.8 MiB    -53.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     40.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.7 MiB -16836188.3 MiB      381277           for neighbor in current.neighbors:
    35     94.7 MiB -14958425.0 MiB      338779               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.7 MiB -14958426.2 MiB      338779               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.7 MiB -7468677.4 MiB      169189                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.7 MiB -14958444.1 MiB      338779               if temp_g_score < g_score[neighbor]:
    41     94.7 MiB -1883215.8 MiB       43008                   came_from[neighbor] = current
    42     94.7 MiB -1883217.3 MiB       43008                   g_score[neighbor] = temp_g_score
    43     94.7 MiB -1883218.8 MiB       43008                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.7 MiB -1877778.4 MiB       42498           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.7 MiB -1877780.4 MiB       42498           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.8 MiB      0.0 MiB           1       paths = {}
    53     41.0 MiB      0.0 MiB           2       for goal in goals:
    54     41.0 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.0 MiB      0.0 MiB           1       return paths


