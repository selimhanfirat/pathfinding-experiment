Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     67.3 MiB     67.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     68.8 MiB  -3360.8 MiB         257       for row in grid:
     8     68.8 MiB -859986.1 MiB       65792           for spot in row:
     9     68.8 MiB -856626.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     49.3 MiB    -19.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     49.4 MiB      0.1 MiB           1       open_set = PriorityQueue()
    16     49.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     49.5 MiB      0.0 MiB           1       came_from = {}
    18     55.9 MiB  -1069.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     55.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     56.4 MiB -264736.8 MiB       13110       while not open_set.empty():
    22     56.4 MiB -264736.9 MiB       13110           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     56.4 MiB -264737.0 MiB       13110           current = open_set.get()[1]
    28                                         
    29     56.4 MiB -264737.0 MiB       13110           if current in remaining_goals:
    30     34.3 MiB    -22.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     56.4 MiB -2148606.2 MiB      106492           for neighbor in current.neighbors:
    35     56.4 MiB -1883873.0 MiB       93383               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     56.4 MiB -1883871.1 MiB       93383               if current.row != neighbor.row and current.col != neighbor.col:
    38     56.4 MiB -935332.2 MiB       46373                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     56.4 MiB -1883881.2 MiB       93383               if temp_g_score < g_score[neighbor]:
    41     56.4 MiB -268924.6 MiB       13466                   came_from[neighbor] = current
    42     56.4 MiB -268924.7 MiB       13466                   g_score[neighbor] = temp_g_score
    43     56.4 MiB -268924.8 MiB       13466                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     56.4 MiB -264736.8 MiB       13109           if draw is not None:
    46                                                     draw()
    47                                                     
    48     56.4 MiB -264736.7 MiB       13109           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.3 MiB      0.0 MiB           1       paths = {}
    53     34.4 MiB      0.0 MiB           2       for goal in goals:
    54     34.4 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.9 MiB     87.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.9 MiB  -2000.6 MiB         257       for row in grid:
     8     87.9 MiB -512450.7 MiB       65792           for spot in row:
     9     87.9 MiB -510442.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     80.0 MiB     -7.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     80.1 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     80.3 MiB      0.2 MiB           1       open_set.put((0, start))
    17     80.3 MiB      0.0 MiB           1       came_from = {}
    18     86.7 MiB  -5653.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.4 MiB     -0.3 MiB           1       g_score[start] = 0
    20                                         
    21     86.9 MiB -131603.3 MiB        6468       while not open_set.empty():
    22     86.9 MiB -131603.3 MiB        6468           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.9 MiB -131606.1 MiB        6468           current = open_set.get()[1]
    28                                         
    29     86.9 MiB -131606.3 MiB        6468           if current in remaining_goals:
    30     41.5 MiB    -45.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     41.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.9 MiB -1077398.5 MiB       52629           for neighbor in current.neighbors:
    35     86.9 MiB -945833.5 MiB       46162               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.9 MiB -945834.3 MiB       46162               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.9 MiB -470340.4 MiB       22936                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.9 MiB -945836.5 MiB       46162               if temp_g_score < g_score[neighbor]:
    41     86.9 MiB -136969.7 MiB        6844                   came_from[neighbor] = current
    42     86.9 MiB -136969.9 MiB        6844                   g_score[neighbor] = temp_g_score
    43     86.9 MiB -136970.1 MiB        6844                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.9 MiB -131601.6 MiB        6467           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.9 MiB -131602.3 MiB        6467           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.5 MiB      0.0 MiB           1       paths = {}
    53     41.6 MiB      0.0 MiB           2       for goal in goals:
    54     41.6 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     93.9 MiB     93.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     93.9 MiB    -11.2 MiB         257       for row in grid:
     8     93.9 MiB  -2849.3 MiB       65792           for spot in row:
     9     93.9 MiB  -2838.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     93.8 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     93.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     93.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     93.8 MiB      0.0 MiB           1       came_from = {}
    18     99.7 MiB  -8671.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     98.3 MiB     -1.4 MiB           1       g_score[start] = 0
    20                                         
    21     98.4 MiB -1738978.5 MiB       30311       while not open_set.empty():
    22     98.4 MiB -1738980.7 MiB       30311           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     98.4 MiB -1738982.7 MiB       30311           current = open_set.get()[1]
    28                                         
    29     98.4 MiB -1738984.4 MiB       30311           if current in remaining_goals:
    30     32.9 MiB    -65.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     32.9 MiB      0.0 MiB           1               if not remaining_goals:
    32     32.9 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     98.4 MiB -14104193.5 MiB      245689           for neighbor in current.neighbors:
    35     98.4 MiB -12365237.8 MiB      215379               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     98.4 MiB -12365222.3 MiB      215379               if current.row != neighbor.row and current.col != neighbor.col:
    38     98.4 MiB -6138474.4 MiB      106886                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     98.4 MiB -12365296.4 MiB      215379               if temp_g_score < g_score[neighbor]:
    41     98.4 MiB -1754927.8 MiB       30702                   came_from[neighbor] = current
    42     98.4 MiB -1754932.7 MiB       30702                   g_score[neighbor] = temp_g_score
    43     98.4 MiB -1754944.8 MiB       30702                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     98.4 MiB -1738971.2 MiB       30310           if draw is not None:
    46                                                     draw()
    47                                                     
    48     98.4 MiB -1738976.0 MiB       30310           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     32.9 MiB      0.0 MiB           1       paths = {}
    53     33.2 MiB      0.0 MiB           2       for goal in goals:
    54     33.2 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.5 MiB     91.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.5 MiB  -9703.3 MiB         257       for row in grid:
     8     91.5 MiB -2482338.4 MiB       65792           for spot in row:
     9     91.5 MiB -2472675.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     16.1 MiB    -75.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     16.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    16     16.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     16.7 MiB      0.0 MiB           1       came_from = {}
    18     33.9 MiB   -330.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     33.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     34.2 MiB -106861.2 MiB        9247       while not open_set.empty():
    22     34.2 MiB -106861.6 MiB        9247           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     34.2 MiB -106862.4 MiB        9247           current = open_set.get()[1]
    28                                         
    29     34.2 MiB -106863.2 MiB        9247           if current in remaining_goals:
    30     22.3 MiB    -11.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     22.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     22.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     34.2 MiB -864020.9 MiB       74636           for neighbor in current.neighbors:
    35     34.2 MiB -757162.1 MiB       65390               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     34.2 MiB -757159.6 MiB       65390               if current.row != neighbor.row and current.col != neighbor.col:
    38     34.2 MiB -375656.4 MiB       32410                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     34.2 MiB -757167.2 MiB       65390               if temp_g_score < g_score[neighbor]:
    41     34.2 MiB -108585.6 MiB        9451                   came_from[neighbor] = current
    42     34.2 MiB -108586.0 MiB        9451                   g_score[neighbor] = temp_g_score
    43     34.2 MiB -108586.8 MiB        9451                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     34.2 MiB -106860.3 MiB        9246           if draw is not None:
    46                                                     draw()
    47                                                     
    48     34.2 MiB -106860.7 MiB        9246           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     22.3 MiB      0.0 MiB           1       paths = {}
    53     22.5 MiB      0.0 MiB           2       for goal in goals:
    54     22.5 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     22.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.0 MiB     89.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.0 MiB  -2745.1 MiB         257       for row in grid:
     8     89.0 MiB -701502.0 MiB       65792           for spot in row:
     9     89.0 MiB -698800.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     26.4 MiB    -62.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     26.8 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     27.0 MiB      0.2 MiB           1       open_set.put((0, start))
    17     27.0 MiB      0.0 MiB           1       came_from = {}
    18     40.5 MiB -34458.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     30.6 MiB     -9.9 MiB           1       g_score[start] = 0
    20                                         
    21     33.7 MiB -115653.9 MiB       28887       while not open_set.empty():
    22     33.7 MiB -115654.8 MiB       28887           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     33.7 MiB -115657.5 MiB       28887           current = open_set.get()[1]
    28                                         
    29     33.7 MiB -115659.3 MiB       28887           if current in remaining_goals:
    30     29.4 MiB     -4.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     33.7 MiB -942479.1 MiB      235220           for neighbor in current.neighbors:
    35     33.7 MiB -826840.4 MiB      206334               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     33.7 MiB -826831.7 MiB      206334               if current.row != neighbor.row and current.col != neighbor.col:
    38     33.7 MiB -410805.5 MiB      102474                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     33.7 MiB -826842.4 MiB      206334               if temp_g_score < g_score[neighbor]:
    41     33.7 MiB -117163.6 MiB       29271                   came_from[neighbor] = current
    42     33.7 MiB -117164.5 MiB       29271                   g_score[neighbor] = temp_g_score
    43     33.7 MiB -117167.9 MiB       29271                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     33.7 MiB -115652.1 MiB       28886           if draw is not None:
    46                                                     draw()
    47                                                     
    48     33.7 MiB -115653.1 MiB       28886           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.4 MiB      0.0 MiB           1       paths = {}
    53     29.5 MiB      0.0 MiB           2       for goal in goals:
    54     29.5 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.3 MiB     88.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.3 MiB  -2817.5 MiB         257       for row in grid:
     8     88.3 MiB -714134.2 MiB       65792           for spot in row:
     9     88.3 MiB -711366.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     20.3 MiB    -68.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     20.7 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     20.9 MiB      0.2 MiB           1       open_set.put((0, start))
    17     20.9 MiB      0.0 MiB           1       came_from = {}
    18     36.2 MiB  -3508.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     36.0 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     40.7 MiB -306745.1 MiB       47013       while not open_set.empty():
    22     40.7 MiB -306745.6 MiB       47013           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     40.7 MiB -306746.9 MiB       47013           current = open_set.get()[1]
    28                                         
    29     40.7 MiB -306747.8 MiB       47013           if current in remaining_goals:
    30     35.6 MiB     -5.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     40.7 MiB -2491172.1 MiB      381947           for neighbor in current.neighbors:
    35     40.7 MiB -2184438.9 MiB      334935               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     40.7 MiB -2184426.9 MiB      334935               if current.row != neighbor.row and current.col != neighbor.col:
    38     40.7 MiB -1084242.5 MiB      166303                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     40.7 MiB -2184439.9 MiB      334935               if temp_g_score < g_score[neighbor]:
    41     40.7 MiB -307887.8 MiB       47491                   came_from[neighbor] = current
    42     40.7 MiB -307891.2 MiB       47491                   g_score[neighbor] = temp_g_score
    43     40.7 MiB -307892.7 MiB       47491                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     40.7 MiB -306743.9 MiB       47012           if draw is not None:
    46                                                     draw()
    47                                                     
    48     40.7 MiB -306744.6 MiB       47012           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.6 MiB      0.0 MiB           1       paths = {}
    53     35.7 MiB      0.0 MiB           2       for goal in goals:
    54     35.7 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.8 MiB     87.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.8 MiB   -433.8 MiB         257       for row in grid:
     8     87.8 MiB -110500.3 MiB       65792           for spot in row:
     9     87.8 MiB -110071.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.8 MiB     -6.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.0 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     82.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     82.2 MiB      0.0 MiB           1       came_from = {}
    18     85.0 MiB -52928.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     82.9 MiB     -2.1 MiB           1       g_score[start] = 0
    20                                         
    21     83.1 MiB -1866226.1 MiB       39714       while not open_set.empty():
    22     83.1 MiB -1866227.4 MiB       39714           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     83.1 MiB -1866230.1 MiB       39714           current = open_set.get()[1]
    28                                         
    29     83.1 MiB -1866232.7 MiB       39714           if current in remaining_goals:
    30     33.5 MiB    -49.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     33.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     83.1 MiB -15189061.7 MiB      323190           for neighbor in current.neighbors:
    35     83.1 MiB -13322875.8 MiB      283477               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     83.1 MiB -13322869.7 MiB      283477               if current.row != neighbor.row and current.col != neighbor.col:
    38     83.1 MiB -6619546.4 MiB      140830                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     83.1 MiB -13322875.7 MiB      283477               if temp_g_score < g_score[neighbor]:
    41     83.1 MiB -1886327.8 MiB       40177                   came_from[neighbor] = current
    42     83.1 MiB -1886328.8 MiB       40177                   g_score[neighbor] = temp_g_score
    43     83.1 MiB -1886329.1 MiB       40177                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     83.1 MiB -1866223.1 MiB       39713           if draw is not None:
    46                                                     draw()
    47                                                     
    48     83.1 MiB -1866224.3 MiB       39713           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.6 MiB      0.0 MiB           1       paths = {}
    53     33.7 MiB      0.0 MiB           2       for goal in goals:
    54     33.7 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.3 MiB     87.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.3 MiB  -5006.1 MiB         257       for row in grid:
     8     87.3 MiB -1283063.5 MiB       65792           for spot in row:
     9     87.3 MiB -1278068.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     34.0 MiB    -53.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     34.5 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     34.7 MiB      0.2 MiB           1       open_set.put((0, start))
    17     34.7 MiB      0.0 MiB           1       came_from = {}
    18     47.8 MiB  -1504.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     47.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     51.9 MiB -435668.0 MiB       31776       while not open_set.empty():
    22     51.9 MiB -435676.4 MiB       31776           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     51.9 MiB -435676.4 MiB       31776           current = open_set.get()[1]
    28                                         
    29     51.9 MiB -435677.5 MiB       31776           if current in remaining_goals:
    30     40.5 MiB    -11.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     40.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     51.9 MiB -3565063.1 MiB      260071           for neighbor in current.neighbors:
    35     51.9 MiB -3129421.9 MiB      228296               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     51.9 MiB -3129421.2 MiB      228296               if current.row != neighbor.row and current.col != neighbor.col:
    38     51.9 MiB -1556388.6 MiB      113531                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     51.9 MiB -3129423.9 MiB      228296               if temp_g_score < g_score[neighbor]:
    41     51.9 MiB -447521.1 MiB       32525                   came_from[neighbor] = current
    42     51.9 MiB -447523.0 MiB       32525                   g_score[neighbor] = temp_g_score
    43     51.9 MiB -447523.4 MiB       32525                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     51.9 MiB -435666.4 MiB       31775           if draw is not None:
    46                                                     draw()
    47                                                     
    48     51.9 MiB -435667.8 MiB       31775           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.5 MiB      0.0 MiB           1       paths = {}
    53     40.7 MiB      0.0 MiB           2       for goal in goals:
    54     40.7 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.0 MiB     85.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.0 MiB  -2785.8 MiB         257       for row in grid:
     8     85.0 MiB -709431.8 MiB       65792           for spot in row:
     9     85.0 MiB -706682.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     29.8 MiB    -55.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     30.3 MiB      0.5 MiB           1       open_set = PriorityQueue()
    16     30.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     30.5 MiB      0.0 MiB           1       came_from = {}
    18     43.1 MiB  -8301.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     43.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     45.0 MiB -374594.1 MiB       35324       while not open_set.empty():
    22     45.0 MiB -374594.9 MiB       35324           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     45.0 MiB -374597.9 MiB       35324           current = open_set.get()[1]
    28                                         
    29     45.0 MiB -374599.3 MiB       35324           if current in remaining_goals:
    30     37.2 MiB     -7.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     37.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     45.0 MiB -3044669.9 MiB      287564           for neighbor in current.neighbors:
    35     45.0 MiB -2670095.8 MiB      252241               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     45.0 MiB -2670083.5 MiB      252241               if current.row != neighbor.row and current.col != neighbor.col:
    38     45.0 MiB -1325701.3 MiB      125292                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     45.0 MiB -2670089.8 MiB      252241               if temp_g_score < g_score[neighbor]:
    41     45.0 MiB -376362.3 MiB       35784                   came_from[neighbor] = current
    42     45.0 MiB -376363.0 MiB       35784                   g_score[neighbor] = temp_g_score
    43     45.0 MiB -376363.5 MiB       35784                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     45.0 MiB -374582.7 MiB       35323           if draw is not None:
    46                                                     draw()
    47                                                     
    48     45.0 MiB -374587.7 MiB       35323           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.2 MiB      0.0 MiB           1       paths = {}
    53     37.4 MiB      0.0 MiB           2       for goal in goals:
    54     37.4 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.7 MiB     84.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.7 MiB    -15.3 MiB         257       for row in grid:
     8     84.7 MiB  -3839.9 MiB       65792           for spot in row:
     9     84.7 MiB  -3825.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.3 MiB     -1.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.3 MiB      0.0 MiB           1       came_from = {}
    18     87.9 MiB  -6689.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     87.9 MiB     -0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.9 MiB -2821211.8 MiB       58355       while not open_set.empty():
    22     87.9 MiB -2822125.1 MiB       58355           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.9 MiB -2822128.7 MiB       58355           current = open_set.get()[1]
    28                                         
    29     87.9 MiB -2822130.1 MiB       58355           if current in remaining_goals:
    30     39.6 MiB    -48.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     39.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     39.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.9 MiB -22922600.1 MiB      473696           for neighbor in current.neighbors:
    35     87.9 MiB -20100497.2 MiB      415342               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.9 MiB -20100494.6 MiB      415342               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.9 MiB -9979121.0 MiB      206131                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.9 MiB -20097289.6 MiB      415342               if temp_g_score < g_score[neighbor]:
    41     87.9 MiB -2824063.0 MiB       58450                   came_from[neighbor] = current
    42     87.9 MiB -2824065.0 MiB       58450                   g_score[neighbor] = temp_g_score
    43     87.9 MiB -2824067.3 MiB       58450                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.9 MiB -2822119.2 MiB       58354           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.9 MiB -2821208.8 MiB       58354           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.6 MiB      0.0 MiB           1       paths = {}
    53     40.0 MiB      0.0 MiB           2       for goal in goals:
    54     40.0 MiB      0.4 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.1 MiB     85.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.1 MiB    -13.6 MiB         257       for row in grid:
     8     85.1 MiB  -3478.8 MiB       65792           for spot in row:
     9     85.1 MiB  -3465.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.0 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.0 MiB      0.0 MiB           1       came_from = {}
    18     90.0 MiB     -5.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.0 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.1 MiB -229071.6 MiB       13686       while not open_set.empty():
    22     90.1 MiB -229072.2 MiB       13686           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.1 MiB -229076.0 MiB       13686           current = open_set.get()[1]
    28                                         
    29     90.1 MiB -229076.8 MiB       13686           if current in remaining_goals:
    30     30.1 MiB    -60.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     30.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.1 MiB -1860110.7 MiB      110884           for neighbor in current.neighbors:
    35     90.1 MiB -1631049.8 MiB       97199               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.1 MiB -1631059.3 MiB       97199               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.1 MiB -809995.1 MiB       48208                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.1 MiB -1631086.1 MiB       97199               if temp_g_score < g_score[neighbor]:
    41     90.1 MiB -232042.3 MiB       13947                   came_from[neighbor] = current
    42     90.1 MiB -232042.9 MiB       13947                   g_score[neighbor] = temp_g_score
    43     90.1 MiB -232043.8 MiB       13947                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.1 MiB -229069.5 MiB       13685           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.1 MiB -229070.3 MiB       13685           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.1 MiB      0.0 MiB           1       paths = {}
    53     30.2 MiB      0.0 MiB           2       for goal in goals:
    54     30.2 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.0 MiB     84.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.0 MiB    -66.7 MiB         257       for row in grid:
     8     84.0 MiB -17008.5 MiB       65792           for spot in row:
     9     84.0 MiB -16941.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     83.1 MiB     -0.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     83.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     83.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     83.1 MiB      0.0 MiB           1       came_from = {}
    18     85.8 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     86.1 MiB -15564.9 MiB        9306       while not open_set.empty():
    22     86.1 MiB -15564.9 MiB        9306           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.1 MiB -15565.3 MiB        9306           current = open_set.get()[1]
    28                                         
    29     86.1 MiB -15565.5 MiB        9306           if current in remaining_goals:
    30     76.7 MiB     -9.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     76.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     76.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.1 MiB -126771.2 MiB       75907           for neighbor in current.neighbors:
    35     86.1 MiB -111210.8 MiB       66602               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.1 MiB -111211.5 MiB       66602               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.1 MiB -55226.2 MiB       33060                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.1 MiB -111213.4 MiB       66602               if temp_g_score < g_score[neighbor]:
    41     86.1 MiB -15895.0 MiB        9606                   came_from[neighbor] = current
    42     86.1 MiB -15895.3 MiB        9606                   g_score[neighbor] = temp_g_score
    43     86.1 MiB -15895.5 MiB        9606                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.1 MiB -15564.8 MiB        9305           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.1 MiB -15564.9 MiB        9305           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     76.7 MiB      0.0 MiB           1       paths = {}
    53     76.7 MiB      0.0 MiB           2       for goal in goals:
    54     76.7 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     76.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.9 MiB     88.9 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.9 MiB   -462.0 MiB         257       for row in grid:
     8     88.9 MiB -118335.5 MiB       65792           for spot in row:
     9     88.9 MiB -117876.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB     -3.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     91.3 MiB      5.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     91.4 MiB -519293.5 MiB        9926       while not open_set.empty():
    22     91.4 MiB -519293.8 MiB        9926           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.4 MiB -519296.0 MiB        9926           current = open_set.get()[1]
    28                                         
    29     91.4 MiB -519296.1 MiB        9926           if current in remaining_goals:
    30     25.6 MiB    -65.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     25.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     25.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.4 MiB -4230578.4 MiB       80866           for neighbor in current.neighbors:
    35     91.4 MiB -3711292.2 MiB       70941               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.4 MiB -3711294.7 MiB       70941               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.4 MiB -1845876.8 MiB       35277                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.4 MiB -3711301.6 MiB       70941               if temp_g_score < g_score[neighbor]:
    41     91.4 MiB -534030.9 MiB       10352                   came_from[neighbor] = current
    42     91.4 MiB -534031.1 MiB       10352                   g_score[neighbor] = temp_g_score
    43     91.4 MiB -534031.6 MiB       10352                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.4 MiB -519292.0 MiB        9925           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.4 MiB -519292.6 MiB        9925           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     25.6 MiB      0.0 MiB           1       paths = {}
    53     25.8 MiB      0.0 MiB           2       for goal in goals:
    54     25.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     25.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.3 MiB     88.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.3 MiB   -162.8 MiB         257       for row in grid:
     8     88.3 MiB -41660.6 MiB       65792           for spot in row:
     9     88.3 MiB -41499.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.8 MiB     -1.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.8 MiB      0.0 MiB           1       came_from = {}
    18     91.1 MiB  -2150.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.9 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     90.9 MiB -2175574.5 MiB       45584       while not open_set.empty():
    22     90.9 MiB -2175575.4 MiB       45584           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.9 MiB -2175596.5 MiB       45584           current = open_set.get()[1]
    28                                         
    29     90.9 MiB -2175598.2 MiB       45584           if current in remaining_goals:
    30     42.8 MiB    -48.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     42.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.9 MiB -17660945.3 MiB      370437           for neighbor in current.neighbors:
    35     90.9 MiB -15485388.5 MiB      324854               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.9 MiB -15485394.4 MiB      324854               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.9 MiB -7687267.4 MiB      161280                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.9 MiB -15485403.9 MiB      324854               if temp_g_score < g_score[neighbor]:
    41     90.9 MiB -2184963.9 MiB       46059                   came_from[neighbor] = current
    42     90.9 MiB -2184965.2 MiB       46059                   g_score[neighbor] = temp_g_score
    43     90.9 MiB -2184966.2 MiB       46059                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.9 MiB -2175571.0 MiB       45583           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.9 MiB -2175573.9 MiB       45583           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.8 MiB      0.0 MiB           1       paths = {}
    53     43.0 MiB      0.0 MiB           2       for goal in goals:
    54     43.0 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     43.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.2 MiB     91.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.2 MiB  -2731.4 MiB         257       for row in grid:
     8     91.2 MiB -699065.0 MiB       65792           for spot in row:
     9     91.2 MiB -696346.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     29.6 MiB    -61.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     30.0 MiB      0.4 MiB           1       open_set = PriorityQueue()
    16     30.2 MiB      0.2 MiB           1       open_set.put((0, start))
    17     30.2 MiB      0.0 MiB           1       came_from = {}
    18     42.0 MiB -34684.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     41.3 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21     43.7 MiB -191067.2 MiB       18216       while not open_set.empty():
    22     43.7 MiB -191068.4 MiB       18216           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     43.7 MiB -191068.8 MiB       18216           current = open_set.get()[1]
    28                                         
    29     43.7 MiB -191069.0 MiB       18216           if current in remaining_goals:
    30     33.7 MiB    -10.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     33.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     33.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     43.7 MiB -1555163.1 MiB      148503           for neighbor in current.neighbors:
    35     43.7 MiB -1364100.6 MiB      130288               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     43.7 MiB -1364094.2 MiB      130288               if current.row != neighbor.row and current.col != neighbor.col:
    38     43.7 MiB -677555.0 MiB       64737                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     43.7 MiB -1364104.8 MiB      130288               if temp_g_score < g_score[neighbor]:
    41     43.7 MiB -193021.4 MiB       18668                   came_from[neighbor] = current
    42     43.7 MiB -193022.0 MiB       18668                   g_score[neighbor] = temp_g_score
    43     43.7 MiB -193025.2 MiB       18668                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     43.7 MiB -191065.7 MiB       18215           if draw is not None:
    46                                                     draw()
    47                                                     
    48     43.7 MiB -191065.8 MiB       18215           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     33.7 MiB      0.0 MiB           1       paths = {}
    53     33.8 MiB      0.0 MiB           2       for goal in goals:
    54     33.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     33.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.5 MiB     87.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.5 MiB   -450.3 MiB         257       for row in grid:
     8     87.5 MiB -113822.9 MiB       65792           for spot in row:
     9     87.5 MiB -113383.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     74.1 MiB    -13.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     74.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     74.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     74.1 MiB      0.0 MiB           1       came_from = {}
    18     75.0 MiB -1569464.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     37.6 MiB    -37.4 MiB           1       g_score[start] = 0
    20                                         
    21     44.1 MiB -140519.0 MiB       33930       while not open_set.empty():
    22     44.1 MiB -140519.3 MiB       33930           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     44.1 MiB -140521.7 MiB       33930           current = open_set.get()[1]
    28                                         
    29     44.1 MiB -140523.7 MiB       33930           if current in remaining_goals:
    30     30.0 MiB    -14.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     30.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     30.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     44.1 MiB -1138238.9 MiB      275445           for neighbor in current.neighbors:
    35     44.1 MiB -997843.2 MiB      241516               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     44.1 MiB -997837.3 MiB      241516               if current.row != neighbor.row and current.col != neighbor.col:
    38     44.1 MiB -495430.6 MiB      119917                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     44.1 MiB -997845.5 MiB      241516               if temp_g_score < g_score[neighbor]:
    41     44.1 MiB -141368.2 MiB       34340                   came_from[neighbor] = current
    42     44.1 MiB -141257.0 MiB       34340                   g_score[neighbor] = temp_g_score
    43     44.1 MiB -141258.8 MiB       34340                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     44.1 MiB -140517.2 MiB       33929           if draw is not None:
    46                                                     draw()
    47                                                     
    48     44.1 MiB -140518.4 MiB       33929           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     30.0 MiB      0.0 MiB           1       paths = {}
    53     30.2 MiB      0.0 MiB           2       for goal in goals:
    54     30.2 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.1 MiB     85.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.1 MiB  -2094.1 MiB         257       for row in grid:
     8     85.1 MiB -537323.2 MiB       65792           for spot in row:
     9     85.1 MiB -535233.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     76.2 MiB     -8.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     76.2 MiB      0.1 MiB           1       open_set = PriorityQueue()
    16     76.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     76.3 MiB      0.0 MiB           1       came_from = {}
    18     77.1 MiB -1221800.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     47.8 MiB    -29.2 MiB           1       g_score[start] = 0
    20                                         
    21     48.1 MiB -611587.9 MiB       54164       while not open_set.empty():
    22     48.1 MiB -611588.1 MiB       54164           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     48.1 MiB -611588.9 MiB       54164           current = open_set.get()[1]
    28                                         
    29     48.1 MiB -611590.6 MiB       54164           if current in remaining_goals:
    30     46.0 MiB     -2.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     46.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     46.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     48.1 MiB -4965710.2 MiB      439825           for neighbor in current.neighbors:
    35     48.1 MiB -4354135.8 MiB      385662               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     48.1 MiB -4354126.2 MiB      385662               if current.row != neighbor.row and current.col != neighbor.col:
    38     48.1 MiB -2161485.8 MiB      191455                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     48.1 MiB -4354136.3 MiB      385662               if temp_g_score < g_score[neighbor]:
    41     48.1 MiB -613097.1 MiB       54430                   came_from[neighbor] = current
    42     48.1 MiB -613097.9 MiB       54430                   g_score[neighbor] = temp_g_score
    43     48.1 MiB -613098.9 MiB       54430                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     48.1 MiB -611585.1 MiB       54163           if draw is not None:
    46                                                     draw()
    47                                                     
    48     48.1 MiB -611586.2 MiB       54163           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     46.0 MiB      0.0 MiB           1       paths = {}
    53     46.2 MiB      0.0 MiB           2       for goal in goals:
    54     46.2 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     46.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.6 MiB    -60.3 MiB         257       for row in grid:
     8     86.6 MiB -15457.4 MiB       65792           for spot in row:
     9     86.6 MiB -15397.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.3 MiB     -0.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.3 MiB      0.0 MiB           1       came_from = {}
    18     90.9 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.9 MiB -1768471.5 MiB       38400       while not open_set.empty():
    22     90.9 MiB -1768472.6 MiB       38400           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.9 MiB -1768475.1 MiB       38400           current = open_set.get()[1]
    28                                         
    29     90.9 MiB -1768475.7 MiB       38400           if current in remaining_goals:
    30     34.7 MiB    -56.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.9 MiB -14404627.8 MiB      313049           for neighbor in current.neighbors:
    35     90.9 MiB -12636200.6 MiB      274650               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.9 MiB -12636200.4 MiB      274650               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.9 MiB -6276359.0 MiB      136426                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.9 MiB -12636210.9 MiB      274650               if temp_g_score < g_score[neighbor]:
    41     90.9 MiB -1776301.1 MiB       38830                   came_from[neighbor] = current
    42     90.9 MiB -1776301.8 MiB       38830                   g_score[neighbor] = temp_g_score
    43     90.9 MiB -1776303.0 MiB       38830                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.9 MiB -1768469.0 MiB       38399           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.9 MiB -1768470.4 MiB       38399           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.7 MiB      0.0 MiB           1       paths = {}
    53     35.0 MiB      0.0 MiB           2       for goal in goals:
    54     35.0 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.0 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.6 MiB     84.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.6 MiB    -11.7 MiB         257       for row in grid:
     8     84.6 MiB  -2994.3 MiB       65792           for spot in row:
     9     84.6 MiB  -2982.6 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.5 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.5 MiB      0.0 MiB           1       came_from = {}
    18     86.8 MiB -40928.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     85.5 MiB     -1.3 MiB           1       g_score[start] = 0
    20                                         
    21     85.6 MiB -2714188.1 MiB       59161       while not open_set.empty():
    22     85.6 MiB -2714189.2 MiB       59161           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     85.6 MiB -2714190.0 MiB       59161           current = open_set.get()[1]
    28                                         
    29     85.6 MiB -2714191.6 MiB       59161           if current in remaining_goals:
    30     29.6 MiB    -56.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     85.6 MiB -22028910.6 MiB      480478           for neighbor in current.neighbors:
    35     85.6 MiB -19314736.7 MiB      421318               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     85.6 MiB -19314730.1 MiB      421318               if current.row != neighbor.row and current.col != neighbor.col:
    38     85.6 MiB -9582741.8 MiB      209058                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     85.6 MiB -19314738.2 MiB      421318               if temp_g_score < g_score[neighbor]:
    41     85.6 MiB -2705124.2 MiB       59218                   came_from[neighbor] = current
    42     85.6 MiB -2705125.6 MiB       59218                   g_score[neighbor] = temp_g_score
    43     85.6 MiB -2705128.3 MiB       59218                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     85.6 MiB -2714185.0 MiB       59160           if draw is not None:
    46                                                     draw()
    47                                                     
    48     85.6 MiB -2714187.0 MiB       59160           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.6 MiB      0.0 MiB           1       paths = {}
    53     30.6 MiB      0.0 MiB           2       for goal in goals:
    54     30.6 MiB      1.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.7 MiB     87.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.7 MiB   -549.2 MiB         257       for row in grid:
     8     87.7 MiB -140212.1 MiB       65792           for spot in row:
     9     87.7 MiB -139667.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.6 MiB     -8.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     79.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     79.6 MiB      0.0 MiB           1       came_from = {}
    18     83.4 MiB -126010.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     33.1 MiB    -50.2 MiB           1       g_score[start] = 0
    20                                         
    21     47.0 MiB  -5557.1 MiB       13088       while not open_set.empty():
    22     47.0 MiB  -5558.3 MiB       13088           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     47.0 MiB  -5558.4 MiB       13088           current = open_set.get()[1]
    28                                         
    29     47.0 MiB  -5558.5 MiB       13088           if current in remaining_goals:
    30     45.0 MiB     -2.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     45.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     47.0 MiB -44854.1 MiB      105804           for neighbor in current.neighbors:
    35     47.0 MiB -39306.0 MiB       92717               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     47.0 MiB -39300.8 MiB       92717               if current.row != neighbor.row and current.col != neighbor.col:
    38     47.0 MiB -19502.0 MiB       45968                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     47.0 MiB -39302.6 MiB       92717               if temp_g_score < g_score[neighbor]:
    41     47.0 MiB  -5645.6 MiB       13338                   came_from[neighbor] = current
    42     47.0 MiB  -5646.2 MiB       13338                   g_score[neighbor] = temp_g_score
    43     47.0 MiB  -5646.2 MiB       13338                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     47.0 MiB  -5556.4 MiB       13087           if draw is not None:
    46                                                     draw()
    47                                                     
    48     47.0 MiB  -5556.4 MiB       13087           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.0 MiB      0.0 MiB           1       paths = {}
    53     45.1 MiB      0.0 MiB           2       for goal in goals:
    54     45.1 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.1 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.5 MiB     90.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.5 MiB   -138.0 MiB         257       for row in grid:
     8     90.5 MiB -35212.3 MiB       65792           for spot in row:
     9     90.5 MiB -35075.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.6 MiB     -1.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.6 MiB      0.0 MiB           1       came_from = {}
    18     93.9 MiB  -3231.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.9 MiB -1582312.9 MiB       31335       while not open_set.empty():
    22     93.9 MiB -1582314.1 MiB       31335           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.9 MiB -1582316.1 MiB       31335           current = open_set.get()[1]
    28                                         
    29     93.9 MiB -1582318.4 MiB       31335           if current in remaining_goals:
    30     29.6 MiB    -64.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.9 MiB -12840908.3 MiB      254130           for neighbor in current.neighbors:
    35     93.9 MiB -11258608.2 MiB      222796               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.9 MiB -11258608.0 MiB      222796               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.9 MiB -5590594.6 MiB      110596                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.9 MiB -11258618.1 MiB      222796               if temp_g_score < g_score[neighbor]:
    41     93.9 MiB -1593331.4 MiB       31728                   came_from[neighbor] = current
    42     93.9 MiB -1593350.5 MiB       31728                   g_score[neighbor] = temp_g_score
    43     93.9 MiB -1593352.4 MiB       31728                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.9 MiB -1582309.8 MiB       31334           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.9 MiB -1582310.9 MiB       31334           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.6 MiB      0.0 MiB           1       paths = {}
    53     29.8 MiB      0.0 MiB           2       for goal in goals:
    54     29.8 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.8 MiB     89.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.8 MiB   -559.6 MiB         257       for row in grid:
     8     89.8 MiB -143508.9 MiB       65792           for spot in row:
     9     89.8 MiB -142954.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.1 MiB     -5.7 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     84.5 MiB      0.2 MiB           1       open_set.put((0, start))
    17     84.5 MiB      0.0 MiB           1       came_from = {}
    18     89.0 MiB -50975.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.7 MiB     -2.3 MiB           1       g_score[start] = 0
    20                                         
    21     86.7 MiB -779027.6 MiB       15003       while not open_set.empty():
    22     86.7 MiB -779027.9 MiB       15003           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.7 MiB -779028.6 MiB       15003           current = open_set.get()[1]
    28                                         
    29     86.7 MiB -779029.5 MiB       15003           if current in remaining_goals:
    30     34.1 MiB    -52.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     86.7 MiB -6323490.3 MiB      121864           for neighbor in current.neighbors:
    35     86.7 MiB -5544465.5 MiB      106862               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.7 MiB -5544464.4 MiB      106862               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.7 MiB -2753665.3 MiB       53078                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.7 MiB -5544516.5 MiB      106862               if temp_g_score < g_score[neighbor]:
    41     86.7 MiB -796241.6 MiB       15464                   came_from[neighbor] = current
    42     86.7 MiB -796242.3 MiB       15464                   g_score[neighbor] = temp_g_score
    43     86.7 MiB -796243.5 MiB       15464                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.7 MiB -779027.0 MiB       15002           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.7 MiB -779027.1 MiB       15002           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.1 MiB      0.0 MiB           1       paths = {}
    53     34.2 MiB      0.0 MiB           2       for goal in goals:
    54     34.2 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.2 MiB     89.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.2 MiB    -94.5 MiB         257       for row in grid:
     8     89.2 MiB -23925.0 MiB       65792           for spot in row:
     9     89.2 MiB -23831.7 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.1 MiB     -2.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.1 MiB      0.0 MiB           1       came_from = {}
    18     90.9 MiB -19635.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.7 MiB     -0.2 MiB           1       g_score[start] = 0
    20                                         
    21     90.8 MiB -1687126.2 MiB       37798       while not open_set.empty():
    22     90.8 MiB -1687127.1 MiB       37798           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.8 MiB -1687127.8 MiB       37798           current = open_set.get()[1]
    28                                         
    29     90.8 MiB -1687132.5 MiB       37798           if current in remaining_goals:
    30     41.3 MiB    -49.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     41.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.8 MiB -13723827.7 MiB      307536           for neighbor in current.neighbors:
    35     90.8 MiB -12036734.7 MiB      269739               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.8 MiB -12036729.4 MiB      269739               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.8 MiB -5980187.5 MiB      134019                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.8 MiB -12036732.9 MiB      269739               if temp_g_score < g_score[neighbor]:
    41     90.8 MiB -1700991.3 MiB       38379                   came_from[neighbor] = current
    42     90.8 MiB -1700991.5 MiB       38379                   g_score[neighbor] = temp_g_score
    43     90.8 MiB -1700992.2 MiB       38379                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.8 MiB -1687124.1 MiB       37797           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.8 MiB -1687125.5 MiB       37797           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.3 MiB      0.0 MiB           1       paths = {}
    53     41.5 MiB      0.0 MiB           2       for goal in goals:
    54     41.5 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.1 MiB     88.1 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.1 MiB     -1.5 MiB         257       for row in grid:
     8     88.1 MiB   -380.0 MiB       65792           for spot in row:
     9     88.1 MiB   -378.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.1 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.1 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.1 MiB      0.0 MiB           1       came_from = {}
    18     93.1 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.4 MiB -1353196.5 MiB       29790       while not open_set.empty():
    22     93.4 MiB -1353197.1 MiB       29790           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.4 MiB -1353198.0 MiB       29790           current = open_set.get()[1]
    28                                         
    29     93.4 MiB -1353224.1 MiB       29790           if current in remaining_goals:
    30     37.1 MiB    -56.3 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     37.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     37.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.4 MiB -11024228.6 MiB      242403           for neighbor in current.neighbors:
    35     93.4 MiB -9671042.8 MiB      212614               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.4 MiB -9671046.0 MiB      212614               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.4 MiB -4802838.3 MiB      105579                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.4 MiB -9671054.2 MiB      212614               if temp_g_score < g_score[neighbor]:
    41     93.4 MiB -1359188.5 MiB       30190                   came_from[neighbor] = current
    42     93.4 MiB -1359189.4 MiB       30190                   g_score[neighbor] = temp_g_score
    43     93.4 MiB -1359190.5 MiB       30190                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.4 MiB -1353195.6 MiB       29789           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.4 MiB -1353196.0 MiB       29789           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     37.1 MiB      0.0 MiB           1       paths = {}
    53     37.2 MiB      0.0 MiB           2       for goal in goals:
    54     37.2 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     37.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.8 MiB     86.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.8 MiB   -374.8 MiB         257       for row in grid:
     8     86.8 MiB -96145.4 MiB       65792           for spot in row:
     9     86.8 MiB -95771.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.3 MiB     -1.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.3 MiB      0.0 MiB           1       came_from = {}
    18     90.1 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     90.1 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     90.3 MiB -2586795.6 MiB       51733       while not open_set.empty():
    22     90.3 MiB -2586796.8 MiB       51733           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.3 MiB -2586801.0 MiB       51733           current = open_set.get()[1]
    28                                         
    29     90.3 MiB -2586803.3 MiB       51733           if current in remaining_goals:
    30     39.3 MiB    -51.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     39.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     39.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.3 MiB -20981934.8 MiB      419902           for neighbor in current.neighbors:
    35     90.3 MiB -18395186.6 MiB      368170               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.3 MiB -18395173.7 MiB      368170               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.3 MiB -9130525.1 MiB      182769                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.3 MiB -18395196.4 MiB      368170               if temp_g_score < g_score[neighbor]:
    41     90.3 MiB -2590504.5 MiB       52089                   came_from[neighbor] = current
    42     90.3 MiB -2590505.8 MiB       52089                   g_score[neighbor] = temp_g_score
    43     90.3 MiB -2590508.9 MiB       52089                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.3 MiB -2586793.7 MiB       51732           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.3 MiB -2586794.8 MiB       51732           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.3 MiB      0.0 MiB           1       paths = {}
    53     39.5 MiB      0.0 MiB           2       for goal in goals:
    54     39.5 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     39.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.8 MiB     84.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.8 MiB  -2371.0 MiB         257       for row in grid:
     8     84.8 MiB -603558.3 MiB       65792           for spot in row:
     9     84.8 MiB -601210.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     47.4 MiB    -37.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     47.6 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     47.6 MiB      0.0 MiB           1       open_set.put((0, start))
    17     47.6 MiB      0.0 MiB           1       came_from = {}
    18     56.0 MiB -46987.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     49.8 MiB     -6.2 MiB           1       g_score[start] = 0
    20                                         
    21     53.5 MiB -742119.0 MiB       49645       while not open_set.empty():
    22     53.5 MiB -742120.7 MiB       49645           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     53.5 MiB -742124.2 MiB       49645           current = open_set.get()[1]
    28                                         
    29     53.5 MiB -742130.1 MiB       49645           if current in remaining_goals:
    30     29.3 MiB    -24.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     53.5 MiB -6033557.5 MiB      403649           for neighbor in current.neighbors:
    35     53.5 MiB -5291452.5 MiB      354005               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     53.5 MiB -5291446.1 MiB      354005               if current.row != neighbor.row and current.col != neighbor.col:
    38     53.5 MiB -2627099.4 MiB      175784                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     53.5 MiB -5291458.6 MiB      354005               if temp_g_score < g_score[neighbor]:
    41     53.5 MiB -742408.0 MiB       50014                   came_from[neighbor] = current
    42     53.5 MiB -742417.2 MiB       50014                   g_score[neighbor] = temp_g_score
    43     53.5 MiB -742419.8 MiB       50014                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     53.5 MiB -742115.9 MiB       49644           if draw is not None:
    46                                                     draw()
    47                                                     
    48     53.5 MiB -742117.8 MiB       49644           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.3 MiB      0.0 MiB           1       paths = {}
    53     30.3 MiB      0.0 MiB           2       for goal in goals:
    54     30.3 MiB      1.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     30.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.6 MiB     85.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.6 MiB   -529.3 MiB         257       for row in grid:
     8     85.6 MiB -135497.2 MiB       65792           for spot in row:
     9     85.6 MiB -134970.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.8 MiB     -3.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     81.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     81.8 MiB      0.0 MiB           1       came_from = {}
    18     83.8 MiB -262910.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     70.7 MiB    -13.2 MiB           1       g_score[start] = 0
    20                                         
    21     71.0 MiB -225118.3 MiB        5967       while not open_set.empty():
    22     71.0 MiB -225118.9 MiB        5967           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     71.0 MiB -225120.2 MiB        5967           current = open_set.get()[1]
    28                                         
    29     71.0 MiB -225120.7 MiB        5967           if current in remaining_goals:
    30     29.5 MiB    -41.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     29.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     29.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     71.0 MiB -1841288.4 MiB       48778           for neighbor in current.neighbors:
    35     71.0 MiB -1616175.3 MiB       42812               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     71.0 MiB -1616175.5 MiB       42812               if current.row != neighbor.row and current.col != neighbor.col:
    38     71.0 MiB -802639.9 MiB       21263                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     71.0 MiB -1616180.6 MiB       42812               if temp_g_score < g_score[neighbor]:
    41     71.0 MiB -230774.0 MiB        6198                   came_from[neighbor] = current
    42     71.0 MiB -230774.2 MiB        6198                   g_score[neighbor] = temp_g_score
    43     71.0 MiB -230774.7 MiB        6198                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     71.0 MiB -225117.4 MiB        5966           if draw is not None:
    46                                                     draw()
    47                                                     
    48     71.0 MiB -225118.0 MiB        5966           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     29.5 MiB      0.0 MiB           1       paths = {}
    53     29.5 MiB      0.0 MiB           2       for goal in goals:
    54     29.5 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     29.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     84.2 MiB     84.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     84.2 MiB   -546.2 MiB         257       for row in grid:
     8     84.2 MiB -139818.3 MiB       65792           for spot in row:
     9     84.2 MiB -139274.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     79.3 MiB     -4.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     79.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     79.3 MiB      0.0 MiB           1       open_set.put((0, start))
    17     79.3 MiB      0.0 MiB           1       came_from = {}
    18     82.3 MiB -1293029.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     35.7 MiB    -46.6 MiB           1       g_score[start] = 0
    20                                         
    21     52.4 MiB -630889.8 MiB       54093       while not open_set.empty():
    22     52.4 MiB -630891.9 MiB       54093           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     52.4 MiB -630893.8 MiB       54093           current = open_set.get()[1]
    28                                         
    29     52.4 MiB -630895.0 MiB       54093           if current in remaining_goals:
    30     39.8 MiB    -12.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     39.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     39.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     52.4 MiB -5126609.4 MiB      439656           for neighbor in current.neighbors:
    35     52.4 MiB -4495746.3 MiB      385564               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     52.4 MiB -4495733.1 MiB      385564               if current.row != neighbor.row and current.col != neighbor.col:
    38     52.4 MiB -2232147.2 MiB      191474                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     52.4 MiB -4495753.9 MiB      385564               if temp_g_score < g_score[neighbor]:
    41     52.4 MiB -632467.8 MiB       54446                   came_from[neighbor] = current
    42     52.4 MiB -632469.5 MiB       54446                   g_score[neighbor] = temp_g_score
    43     52.4 MiB -632471.5 MiB       54446                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     52.4 MiB -630891.8 MiB       54092           if draw is not None:
    46                                                     draw()
    47                                                     
    48     52.4 MiB -630888.2 MiB       54092           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     39.8 MiB      0.0 MiB           1       paths = {}
    53     40.2 MiB      0.0 MiB           2       for goal in goals:
    54     40.2 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.6 MiB     87.6 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.6 MiB   -152.2 MiB         257       for row in grid:
     8     87.6 MiB -39047.0 MiB       65792           for spot in row:
     9     87.6 MiB -38895.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     86.5 MiB     -1.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     86.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     86.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     86.5 MiB      0.0 MiB           1       came_from = {}
    18     89.5 MiB -43868.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.2 MiB     -0.3 MiB           1       g_score[start] = 0
    20                                         
    21     89.2 MiB -1750076.7 MiB       43479       while not open_set.empty():
    22     89.2 MiB -1750077.2 MiB       43479           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.2 MiB -1750084.8 MiB       43479           current = open_set.get()[1]
    28                                         
    29     89.2 MiB -1750085.3 MiB       43479           if current in remaining_goals:
    30     35.4 MiB    -53.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.2 MiB -14210852.4 MiB      352524           for neighbor in current.neighbors:
    35     89.2 MiB -12460795.5 MiB      309046               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.2 MiB -12460806.9 MiB      309046               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.2 MiB -6187720.8 MiB      153436                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.2 MiB -12460823.5 MiB      309046               if temp_g_score < g_score[neighbor]:
    41     89.2 MiB -1760409.2 MiB       43937                   came_from[neighbor] = current
    42     89.2 MiB -1760410.8 MiB       43937                   g_score[neighbor] = temp_g_score
    43     89.2 MiB -1760411.9 MiB       43937                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.2 MiB -1750073.3 MiB       43478           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.2 MiB -1750075.8 MiB       43478           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.4 MiB      0.0 MiB           1       paths = {}
    53     35.5 MiB      0.0 MiB           2       for goal in goals:
    54     35.5 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.5 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.4 MiB     89.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.4 MiB  -1435.0 MiB         257       for row in grid:
     8     89.4 MiB -368089.8 MiB       65792           for spot in row:
     9     89.4 MiB -366658.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.5 MiB     -7.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.5 MiB      0.0 MiB           1       came_from = {}
    18     86.9 MiB -22645.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     87.1 MiB -407116.8 MiB        9464       while not open_set.empty():
    22     87.1 MiB -407117.2 MiB        9464           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     87.1 MiB -407117.5 MiB        9464           current = open_set.get()[1]
    28                                         
    29     87.1 MiB -407121.4 MiB        9464           if current in remaining_goals:
    30     27.1 MiB    -60.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     27.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     27.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     87.1 MiB -3315030.9 MiB       77250           for neighbor in current.neighbors:
    35     87.1 MiB -2907936.8 MiB       67787               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     87.1 MiB -2907939.5 MiB       67787               if current.row != neighbor.row and current.col != neighbor.col:
    38     87.1 MiB -1445889.9 MiB       33706                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     87.1 MiB -2907968.4 MiB       67787               if temp_g_score < g_score[neighbor]:
    41     87.1 MiB -419169.0 MiB        9885                   came_from[neighbor] = current
    42     87.1 MiB -419170.5 MiB        9885                   g_score[neighbor] = temp_g_score
    43     87.1 MiB -419171.8 MiB        9885                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     87.1 MiB -407096.7 MiB        9463           if draw is not None:
    46                                                     draw()
    47                                                     
    48     87.1 MiB -407116.6 MiB        9463           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     27.1 MiB      0.0 MiB           1       paths = {}
    53     27.2 MiB      0.0 MiB           2       for goal in goals:
    54     27.2 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     27.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.8 MiB    -36.9 MiB         257       for row in grid:
     8     88.8 MiB  -7979.9 MiB       65792           for spot in row:
     9     88.8 MiB  -7954.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     74.7 MiB    -14.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     74.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     74.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     74.7 MiB      0.0 MiB           1       came_from = {}
    18     74.9 MiB -2944896.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     32.5 MiB    -42.4 MiB           1       g_score[start] = 0
    20                                         
    21     41.4 MiB -71451.1 MiB       38206       while not open_set.empty():
    22     41.4 MiB -71451.8 MiB       38206           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     41.4 MiB -71452.6 MiB       38206           current = open_set.get()[1]
    28                                         
    29     41.4 MiB -71454.6 MiB       38206           if current in remaining_goals:
    30     41.4 MiB      0.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     41.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     41.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     41.4 MiB -580410.2 MiB      310451           for neighbor in current.neighbors:
    35     41.4 MiB -508969.4 MiB      272246               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     41.4 MiB -508956.2 MiB      272246               if current.row != neighbor.row and current.col != neighbor.col:
    38     41.4 MiB -252629.0 MiB      135163                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     41.4 MiB -508963.3 MiB      272246               if temp_g_score < g_score[neighbor]:
    41     41.4 MiB -72233.0 MiB       38640                   came_from[neighbor] = current
    42     41.4 MiB -72233.7 MiB       38640                   g_score[neighbor] = temp_g_score
    43     41.4 MiB -72235.0 MiB       38640                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     41.4 MiB -71449.4 MiB       38205           if draw is not None:
    46                                                     draw()
    47                                                     
    48     41.4 MiB -71450.5 MiB       38205           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     41.4 MiB      0.0 MiB           1       paths = {}
    53     41.7 MiB      0.0 MiB           2       for goal in goals:
    54     41.6 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     41.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.2 MiB     89.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.2 MiB    -20.0 MiB         257       for row in grid:
     8     89.2 MiB  -4860.6 MiB       65792           for spot in row:
     9     89.2 MiB  -4841.5 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     87.9 MiB     -1.3 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     87.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     87.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     87.9 MiB      0.0 MiB           1       came_from = {}
    18     92.5 MiB   -595.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.7 MiB -532083.5 MiB       29898       while not open_set.empty():
    22     92.7 MiB -532086.0 MiB       29898           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.7 MiB -532086.6 MiB       29898           current = open_set.get()[1]
    28                                         
    29     92.7 MiB -532087.5 MiB       29898           if current in remaining_goals:
    30     34.7 MiB    -58.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     34.7 MiB      0.0 MiB           1               if not remaining_goals:
    32     34.7 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.7 MiB -4323233.4 MiB      243622           for neighbor in current.neighbors:
    35     92.7 MiB -3791176.6 MiB      213725               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.7 MiB -3791190.7 MiB      213725               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.7 MiB -1883346.8 MiB      106232                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.7 MiB -3791200.9 MiB      213725               if temp_g_score < g_score[neighbor]:
    41     92.7 MiB -533002.5 MiB       30489                   came_from[neighbor] = current
    42     92.7 MiB -533003.4 MiB       30489                   g_score[neighbor] = temp_g_score
    43     92.7 MiB -533004.3 MiB       30489                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.7 MiB -532063.6 MiB       29897           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.7 MiB -532082.7 MiB       29897           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     34.7 MiB      0.0 MiB           1       paths = {}
    53     34.8 MiB      0.0 MiB           2       for goal in goals:
    54     34.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     34.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.4 MiB     88.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.4 MiB    -76.4 MiB         257       for row in grid:
     8     88.4 MiB -18850.5 MiB       65792           for spot in row:
     9     88.4 MiB -18776.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.6 MiB     -3.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.8 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     85.0 MiB      0.2 MiB           1       open_set.put((0, start))
    17     85.0 MiB      0.0 MiB           1       came_from = {}
    18     85.7 MiB -853546.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     49.8 MiB    -35.9 MiB           1       g_score[start] = 0
    20                                         
    21     51.1 MiB -170839.9 MiB       10076       while not open_set.empty():
    22     51.1 MiB -170840.2 MiB       10076           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     51.1 MiB -170843.7 MiB       10076           current = open_set.get()[1]
    28                                         
    29     51.1 MiB -170690.0 MiB       10076           if current in remaining_goals:
    30     24.1 MiB    -27.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     24.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     24.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     51.1 MiB -1396902.7 MiB       82474           for neighbor in current.neighbors:
    35     51.1 MiB -1226223.5 MiB       72399               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     51.1 MiB -1226224.1 MiB       72399               if current.row != neighbor.row and current.col != neighbor.col:
    38     51.1 MiB -609133.5 MiB       35970                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     51.1 MiB -1226230.5 MiB       72399               if temp_g_score < g_score[neighbor]:
    41     51.1 MiB -174493.2 MiB       10376                   came_from[neighbor] = current
    42     51.1 MiB -174494.6 MiB       10376                   g_score[neighbor] = temp_g_score
    43     51.1 MiB -174498.2 MiB       10376                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     51.1 MiB -170838.9 MiB       10075           if draw is not None:
    46                                                     draw()
    47                                                     
    48     51.1 MiB -170839.7 MiB       10075           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     24.1 MiB      0.0 MiB           1       paths = {}
    53     24.2 MiB      0.0 MiB           2       for goal in goals:
    54     24.2 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     24.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.4 MiB   -678.3 MiB         257       for row in grid:
     8     86.4 MiB -174026.5 MiB       65792           for spot in row:
     9     86.4 MiB -173348.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.8 MiB     -3.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.8 MiB      0.0 MiB           1       came_from = {}
    18     88.3 MiB      5.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.3 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.4 MiB -2000335.2 MiB       48744       while not open_set.empty():
    22     88.4 MiB -2000335.4 MiB       48744           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.4 MiB -2000337.4 MiB       48744           current = open_set.get()[1]
    28                                         
    29     88.4 MiB -2000338.2 MiB       48744           if current in remaining_goals:
    30     48.5 MiB    -40.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     48.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     48.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.4 MiB -16299730.0 MiB      397100           for neighbor in current.neighbors:
    35     88.4 MiB -14299407.7 MiB      348357               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.4 MiB -14299403.7 MiB      348357               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.4 MiB -7102372.9 MiB      173030                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.4 MiB -14299438.9 MiB      348357               if temp_g_score < g_score[neighbor]:
    41     88.4 MiB -2007880.1 MiB       49209                   came_from[neighbor] = current
    42     88.4 MiB -2007881.4 MiB       49209                   g_score[neighbor] = temp_g_score
    43     88.4 MiB -2007881.9 MiB       49209                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.4 MiB -2000333.3 MiB       48743           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.4 MiB -2000333.7 MiB       48743           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     48.5 MiB      0.0 MiB           1       paths = {}
    53     48.7 MiB      0.0 MiB           2       for goal in goals:
    54     48.7 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     48.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.7 MiB     88.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.7 MiB  -3152.2 MiB         257       for row in grid:
     8     88.7 MiB -806889.3 MiB       65792           for spot in row:
     9     88.7 MiB -803745.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     72.2 MiB    -16.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     72.4 MiB      0.2 MiB           1       open_set = PriorityQueue()
    16     72.6 MiB      0.2 MiB           1       open_set.put((0, start))
    17     72.6 MiB      0.0 MiB           1       came_from = {}
    18     76.0 MiB -936741.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     42.4 MiB    -33.6 MiB           1       g_score[start] = 0
    20                                         
    21     54.5 MiB -386435.3 MiB       55908       while not open_set.empty():
    22     54.5 MiB -386437.7 MiB       55908           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     54.5 MiB -386438.4 MiB       55908           current = open_set.get()[1]
    28                                         
    29     54.5 MiB -386439.2 MiB       55908           if current in remaining_goals:
    30     45.6 MiB     -8.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     45.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     54.5 MiB -3151030.1 MiB      454621           for neighbor in current.neighbors:
    35     54.5 MiB -2764617.5 MiB      398714               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     54.5 MiB -2764608.6 MiB      398714               if current.row != neighbor.row and current.col != neighbor.col:
    38     54.5 MiB -1373882.6 MiB      197967                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     54.5 MiB -2764622.2 MiB      398714               if temp_g_score < g_score[neighbor]:
    41     54.5 MiB -390808.3 MiB       56146                   came_from[neighbor] = current
    42     54.5 MiB -390810.5 MiB       56146                   g_score[neighbor] = temp_g_score
    43     54.5 MiB -390812.7 MiB       56146                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     54.5 MiB -386432.8 MiB       55907           if draw is not None:
    46                                                     draw()
    47                                                     
    48     54.5 MiB -386434.5 MiB       55907           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.6 MiB      0.0 MiB           1       paths = {}
    53     45.8 MiB      0.0 MiB           2       for goal in goals:
    54     45.8 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     86.3 MiB     86.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     86.3 MiB   -178.2 MiB         257       for row in grid:
     8     86.3 MiB -45659.7 MiB       65792           for spot in row:
     9     86.3 MiB -45482.8 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     84.8 MiB     -1.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     84.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     84.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     84.8 MiB      0.0 MiB           1       came_from = {}
    18     89.7 MiB   -236.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.7 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     89.8 MiB -1890985.5 MiB       55889       while not open_set.empty():
    22     89.8 MiB -1890986.3 MiB       55889           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     89.8 MiB -1890987.3 MiB       55889           current = open_set.get()[1]
    28                                         
    29     89.8 MiB -1890987.8 MiB       55889           if current in remaining_goals:
    30     49.5 MiB    -40.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     49.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     49.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     89.8 MiB -15362791.6 MiB      454337           for neighbor in current.neighbors:
    35     89.8 MiB -13471824.1 MiB      398449               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     89.8 MiB -13471823.4 MiB      398449               if current.row != neighbor.row and current.col != neighbor.col:
    38     89.8 MiB -6685913.1 MiB      197769                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     89.8 MiB -13471838.7 MiB      398449               if temp_g_score < g_score[neighbor]:
    41     89.8 MiB -1887171.3 MiB       56110                   came_from[neighbor] = current
    42     89.8 MiB -1887171.8 MiB       56110                   g_score[neighbor] = temp_g_score
    43     89.8 MiB -1887175.1 MiB       56110                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     89.8 MiB -1890979.5 MiB       55888           if draw is not None:
    46                                                     draw()
    47                                                     
    48     89.8 MiB -1890980.2 MiB       55888           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     49.5 MiB      0.0 MiB           1       paths = {}
    53     49.8 MiB      0.0 MiB           2       for goal in goals:
    54     49.8 MiB      0.3 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     49.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.2 MiB     87.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.2 MiB   -113.5 MiB         257       for row in grid:
     8     87.2 MiB -28776.8 MiB       65792           for spot in row:
     9     87.2 MiB -28667.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     81.8 MiB     -5.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     81.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     81.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     81.8 MiB      0.0 MiB           1       came_from = {}
    18     86.4 MiB  -1148.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     86.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     86.6 MiB -2293608.8 MiB       56816       while not open_set.empty():
    22     86.6 MiB -2293611.4 MiB       56816           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     86.6 MiB -2293613.8 MiB       56816           current = open_set.get()[1]
    28                                         
    29     86.6 MiB -2293615.2 MiB       56816           if current in remaining_goals:
    30     45.2 MiB    -41.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     55.6 MiB     10.4 MiB           1                   break  # All goals found
    33                                         
    34     86.6 MiB -18592171.1 MiB      460979           for neighbor in current.neighbors:
    35     86.6 MiB -16298582.2 MiB      404164               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     86.6 MiB -16298594.6 MiB      404164               if current.row != neighbor.row and current.col != neighbor.col:
    38     86.6 MiB -8088663.0 MiB      200607                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     86.6 MiB -16298604.7 MiB      404164               if temp_g_score < g_score[neighbor]:
    41     86.6 MiB -2290057.9 MiB       57028                   came_from[neighbor] = current
    42     86.6 MiB -2290059.3 MiB       57028                   g_score[neighbor] = temp_g_score
    43     86.6 MiB -2290063.0 MiB       57028                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     86.6 MiB -2293602.3 MiB       56815           if draw is not None:
    46                                                     draw()
    47                                                     
    48     86.6 MiB -2293606.4 MiB       56815           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     55.6 MiB      0.0 MiB           1       paths = {}
    53     55.6 MiB      0.0 MiB           2       for goal in goals:
    54     55.6 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     55.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.8 MiB     85.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.8 MiB      0.0 MiB         257       for row in grid:
     8     85.8 MiB      0.0 MiB       65792           for spot in row:
     9     85.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     91.8 MiB      6.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     92.1 MiB -150120.6 MiB       19818       while not open_set.empty():
    22     92.1 MiB -150121.5 MiB       19818           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     92.1 MiB -150124.0 MiB       19818           current = open_set.get()[1]
    28                                         
    29     92.1 MiB -150125.0 MiB       19818           if current in remaining_goals:
    30     40.5 MiB    -51.5 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.5 MiB      0.0 MiB           1               if not remaining_goals:
    32     40.5 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     92.1 MiB -1222445.0 MiB      161188           for neighbor in current.neighbors:
    35     92.1 MiB -1072337.2 MiB      141371               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     92.1 MiB -1072345.3 MiB      141371               if current.row != neighbor.row and current.col != neighbor.col:
    38     92.1 MiB -532748.3 MiB       70194                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     92.1 MiB -1072359.2 MiB      141371               if temp_g_score < g_score[neighbor]:
    41     92.1 MiB -151576.5 MiB       20261                   came_from[neighbor] = current
    42     92.1 MiB -151578.0 MiB       20261                   g_score[neighbor] = temp_g_score
    43     92.1 MiB -151580.3 MiB       20261                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     92.1 MiB -150116.1 MiB       19817           if draw is not None:
    46                                                     draw()
    47                                                     
    48     92.1 MiB -150119.4 MiB       19817           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.5 MiB      0.0 MiB           1       paths = {}
    53     40.7 MiB      0.0 MiB           2       for goal in goals:
    54     40.7 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.7 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.8 MiB     -9.8 MiB         257       for row in grid:
     8     88.8 MiB  -2483.0 MiB       65792           for spot in row:
     9     88.8 MiB  -2473.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.7 MiB     -0.2 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.7 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.7 MiB      0.0 MiB           1       came_from = {}
    18     91.8 MiB -30338.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     91.2 MiB     -0.6 MiB           1       g_score[start] = 0
    20                                         
    21     91.3 MiB -718030.4 MiB       25906       while not open_set.empty():
    22     91.3 MiB -718031.5 MiB       25906           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     91.3 MiB -718036.5 MiB       25906           current = open_set.get()[1]
    28                                         
    29     91.3 MiB -718037.5 MiB       25906           if current in remaining_goals:
    30     40.3 MiB    -51.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     40.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     40.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     91.3 MiB -5845041.7 MiB      210808           for neighbor in current.neighbors:
    35     91.3 MiB -5127027.1 MiB      184903               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     91.3 MiB -5127034.8 MiB      184903               if current.row != neighbor.row and current.col != neighbor.col:
    38     91.3 MiB -2546888.4 MiB       91835                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     91.3 MiB -5127047.0 MiB      184903               if temp_g_score < g_score[neighbor]:
    41     91.3 MiB -722333.1 MiB       26271                   came_from[neighbor] = current
    42     91.3 MiB -722333.8 MiB       26271                   g_score[neighbor] = temp_g_score
    43     91.3 MiB -722335.2 MiB       26271                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     91.3 MiB -718025.0 MiB       25905           if draw is not None:
    46                                                     draw()
    47                                                     
    48     91.3 MiB -718026.0 MiB       25905           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     40.3 MiB      0.0 MiB           1       paths = {}
    53     40.6 MiB      0.0 MiB           2       for goal in goals:
    54     40.6 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     40.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.8 MiB     90.8 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.8 MiB     -8.0 MiB         257       for row in grid:
     8     90.8 MiB  -2051.1 MiB       65792           for spot in row:
     9     90.8 MiB  -2043.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.8 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.8 MiB      0.0 MiB           1       came_from = {}
    18     95.5 MiB   -133.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.5 MiB -1561553.8 MiB       40766       while not open_set.empty():
    22     95.5 MiB -1561566.6 MiB       40766           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.5 MiB -1561573.1 MiB       40766           current = open_set.get()[1]
    28                                         
    29     95.5 MiB -1561577.0 MiB       40766           if current in remaining_goals:
    30     35.0 MiB    -60.4 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     35.0 MiB      0.0 MiB           1               if not remaining_goals:
    32     35.0 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     95.5 MiB -12679752.2 MiB      330860           for neighbor in current.neighbors:
    35     95.5 MiB -11118211.6 MiB      290095               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.5 MiB -11118216.0 MiB      290095               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.5 MiB -5522655.0 MiB      144036                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.5 MiB -11118230.8 MiB      290095               if temp_g_score < g_score[neighbor]:
    41     95.5 MiB -1571642.5 MiB       41216                   came_from[neighbor] = current
    42     95.5 MiB -1571643.2 MiB       41216                   g_score[neighbor] = temp_g_score
    43     95.5 MiB -1571644.3 MiB       41216                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.5 MiB -1561550.2 MiB       40765           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.5 MiB -1561551.3 MiB       40765           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     35.0 MiB      0.0 MiB           1       paths = {}
    53     35.2 MiB      0.0 MiB           2       for goal in goals:
    54     35.2 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     35.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     88.5 MiB     88.5 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     88.6 MiB     -0.2 MiB         257       for row in grid:
     8     88.6 MiB    -37.2 MiB       65792           for spot in row:
     9     88.6 MiB    -37.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.5 MiB     -0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.5 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.5 MiB      0.0 MiB           1       came_from = {}
    18     92.9 MiB   -124.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     92.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     93.2 MiB  -4521.0 MiB        6726       while not open_set.empty():
    22     93.2 MiB  -4521.1 MiB        6726           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     93.2 MiB  -4521.2 MiB        6726           current = open_set.get()[1]
    28                                         
    29     93.2 MiB  -4521.2 MiB        6726           if current in remaining_goals:
    30     90.6 MiB     -2.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     90.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     90.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     93.2 MiB -36788.8 MiB       54696           for neighbor in current.neighbors:
    35     93.2 MiB -32268.5 MiB       47971               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     93.2 MiB -32269.0 MiB       47971               if current.row != neighbor.row and current.col != neighbor.col:
    38     93.2 MiB -16014.7 MiB       23802                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     93.2 MiB -32269.4 MiB       47971               if temp_g_score < g_score[neighbor]:
    41     93.2 MiB  -4578.5 MiB        6976                   came_from[neighbor] = current
    42     93.2 MiB  -4578.9 MiB        6976                   g_score[neighbor] = temp_g_score
    43     93.2 MiB  -4579.0 MiB        6976                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     93.2 MiB  -4521.0 MiB        6725           if draw is not None:
    46                                                     draw()
    47                                                     
    48     93.2 MiB  -4521.0 MiB        6725           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     90.6 MiB      0.0 MiB           1       paths = {}
    53     90.6 MiB      0.0 MiB           2       for goal in goals:
    54     90.6 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     90.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     90.4 MiB     90.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     90.4 MiB   -249.6 MiB         257       for row in grid:
     8     90.4 MiB -64064.1 MiB       65792           for spot in row:
     9     90.4 MiB -63815.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     88.9 MiB     -1.5 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     88.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     88.9 MiB      0.0 MiB           1       open_set.put((0, start))
    17     88.9 MiB      0.0 MiB           1       came_from = {}
    18     93.9 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     95.0 MiB -2059464.4 MiB       52658       while not open_set.empty():
    22     95.0 MiB -2059464.8 MiB       52658           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     95.0 MiB -2059466.5 MiB       52658           current = open_set.get()[1]
    28                                         
    29     95.0 MiB -2059467.7 MiB       52658           if current in remaining_goals:
    30     44.2 MiB    -50.8 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     44.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     95.0 MiB -16741652.0 MiB      427658           for neighbor in current.neighbors:
    35     95.0 MiB -14682218.4 MiB      375001               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     95.0 MiB -14682218.9 MiB      375001               if current.row != neighbor.row and current.col != neighbor.col:
    38     95.0 MiB -7290335.9 MiB      186158                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     95.0 MiB -14682230.1 MiB      375001               if temp_g_score < g_score[neighbor]:
    41     95.0 MiB -2058196.6 MiB       52996                   came_from[neighbor] = current
    42     95.0 MiB -2058199.9 MiB       52996                   g_score[neighbor] = temp_g_score
    43     95.0 MiB -2058209.4 MiB       52996                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     95.0 MiB -2059450.1 MiB       52657           if draw is not None:
    46                                                     draw()
    47                                                     
    48     95.0 MiB -2059451.2 MiB       52657           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.2 MiB      0.0 MiB           1       paths = {}
    53     44.3 MiB      0.0 MiB           2       for goal in goals:
    54     44.3 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     89.4 MiB     89.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     89.4 MiB    -26.6 MiB         257       for row in grid:
     8     89.4 MiB  -6799.8 MiB       65792           for spot in row:
     9     89.4 MiB  -6773.4 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.2 MiB     -0.1 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.2 MiB      0.0 MiB           1       came_from = {}
    18     93.9 MiB  -2150.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     93.8 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     94.0 MiB  -5088.5 MiB        4129       while not open_set.empty():
    22     94.0 MiB  -5088.6 MiB        4129           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.0 MiB  -5088.6 MiB        4129           current = open_set.get()[1]
    28                                         
    29     94.0 MiB  -5088.7 MiB        4129           if current in remaining_goals:
    30     87.8 MiB     -6.1 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     87.8 MiB      0.0 MiB           1               if not remaining_goals:
    32     87.8 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.0 MiB -41077.1 MiB       33709           for neighbor in current.neighbors:
    35     94.0 MiB -35989.8 MiB       29581               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.0 MiB -35990.3 MiB       29581               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.0 MiB -17881.0 MiB       14705                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.0 MiB -35991.8 MiB       29581               if temp_g_score < g_score[neighbor]:
    41     94.0 MiB  -5234.3 MiB        4397                   came_from[neighbor] = current
    42     94.0 MiB  -5234.7 MiB        4397                   g_score[neighbor] = temp_g_score
    43     94.0 MiB  -5235.2 MiB        4397                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.0 MiB  -5088.2 MiB        4128           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.0 MiB  -5088.3 MiB        4128           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     87.8 MiB      0.0 MiB           1       paths = {}
    53     87.8 MiB      0.0 MiB           2       for goal in goals:
    54     87.8 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     87.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.3 MiB     92.3 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.3 MiB   -659.7 MiB         257       for row in grid:
     8     92.3 MiB -169017.9 MiB       65792           for spot in row:
     9     92.3 MiB -168360.3 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     89.2 MiB     -3.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     89.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     89.2 MiB      0.0 MiB           1       open_set.put((0, start))
    17     89.2 MiB      0.0 MiB           1       came_from = {}
    18     94.4 MiB      5.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.4 MiB -2331689.2 MiB       47803       while not open_set.empty():
    22     94.4 MiB -2331690.6 MiB       47803           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.4 MiB -2331698.5 MiB       47803           current = open_set.get()[1]
    28                                         
    29     94.4 MiB -2331700.0 MiB       47803           if current in remaining_goals:
    30     44.1 MiB    -50.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     44.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.4 MiB -18922609.3 MiB      388271           for neighbor in current.neighbors:
    35     94.4 MiB -16590931.5 MiB      340469               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.4 MiB -16590932.1 MiB      340469               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.4 MiB -8236664.7 MiB      169070                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.4 MiB -16590942.9 MiB      340469               if temp_g_score < g_score[neighbor]:
    41     94.4 MiB -2341223.3 MiB       48292                   came_from[neighbor] = current
    42     94.4 MiB -2341225.1 MiB       48292                   g_score[neighbor] = temp_g_score
    43     94.4 MiB -2341227.8 MiB       48292                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.4 MiB -2331686.8 MiB       47802           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.4 MiB -2331687.7 MiB       47802           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.1 MiB      0.0 MiB           1       paths = {}
    53     44.3 MiB      0.0 MiB           2       for goal in goals:
    54     44.3 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.3 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.7 MiB     87.7 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.7 MiB   -198.1 MiB         257       for row in grid:
     8     87.7 MiB -50697.0 MiB       65792           for spot in row:
     9     87.7 MiB -50499.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     85.8 MiB     -2.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     85.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     85.8 MiB      0.0 MiB           1       came_from = {}
    18     90.0 MiB   -198.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     89.8 MiB     -0.1 MiB           1       g_score[start] = 0
    20                                         
    21     90.0 MiB -1734042.1 MiB       46766       while not open_set.empty():
    22     90.0 MiB -1734045.2 MiB       46766           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     90.0 MiB -1734045.9 MiB       46766           current = open_set.get()[1]
    28                                         
    29     90.0 MiB -1734047.6 MiB       46766           if current in remaining_goals:
    30     44.4 MiB    -45.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     44.4 MiB      0.0 MiB           1               if not remaining_goals:
    32     44.4 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     90.0 MiB -14129612.7 MiB      381160           for neighbor in current.neighbors:
    35     90.0 MiB -12395608.6 MiB      334395               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     90.0 MiB -12395609.0 MiB      334395               if current.row != neighbor.row and current.col != neighbor.col:
    38     90.0 MiB -6155292.1 MiB      166105                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     90.0 MiB -12395615.5 MiB      334395               if temp_g_score < g_score[neighbor]:
    41     90.0 MiB -1735975.0 MiB       47244                   came_from[neighbor] = current
    42     90.0 MiB -1735975.6 MiB       47244                   g_score[neighbor] = temp_g_score
    43     90.0 MiB -1735976.3 MiB       47244                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     90.0 MiB -1734038.6 MiB       46765           if draw is not None:
    46                                                     draw()
    47                                                     
    48     90.0 MiB -1734039.5 MiB       46765           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     44.4 MiB      0.0 MiB           1       paths = {}
    53     44.6 MiB      0.0 MiB           2       for goal in goals:
    54     44.6 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     44.6 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     87.4 MiB     87.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     87.4 MiB   -854.3 MiB         257       for row in grid:
     8     87.4 MiB -218690.2 MiB       65792           for spot in row:
     9     87.4 MiB -217837.9 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     82.8 MiB     -4.6 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     82.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     82.8 MiB      0.0 MiB           1       open_set.put((0, start))
    17     82.8 MiB      0.0 MiB           1       came_from = {}
    18     88.8 MiB      6.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     88.8 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     88.8 MiB -1687928.8 MiB       40076       while not open_set.empty():
    22     88.8 MiB -1687931.5 MiB       40076           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     88.8 MiB -1687935.0 MiB       40076           current = open_set.get()[1]
    28                                         
    29     88.8 MiB -1687935.9 MiB       40076           if current in remaining_goals:
    30     54.2 MiB    -34.6 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     54.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     54.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     88.8 MiB -13763214.3 MiB      326661           for neighbor in current.neighbors:
    35     88.8 MiB -12075303.5 MiB      286586               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     88.8 MiB -12075314.3 MiB      286586               if current.row != neighbor.row and current.col != neighbor.col:
    38     88.8 MiB -5998983.3 MiB      142362                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     88.8 MiB -12075332.6 MiB      286586               if temp_g_score < g_score[neighbor]:
    41     88.8 MiB -1706687.2 MiB       40617                   came_from[neighbor] = current
    42     88.8 MiB -1706688.2 MiB       40617                   g_score[neighbor] = temp_g_score
    43     88.8 MiB -1706690.0 MiB       40617                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     88.8 MiB -1687926.0 MiB       40075           if draw is not None:
    46                                                     draw()
    47                                                     
    48     88.8 MiB -1687927.4 MiB       40075           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     54.2 MiB      0.0 MiB           1       paths = {}
    53     54.4 MiB      0.0 MiB           2       for goal in goals:
    54     54.4 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     54.4 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     85.4 MiB     85.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     85.4 MiB  -2782.3 MiB         257       for row in grid:
     8     85.4 MiB -712784.0 MiB       65792           for spot in row:
     9     85.4 MiB -710004.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     65.4 MiB    -19.9 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     65.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     65.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     65.5 MiB      0.0 MiB           1       came_from = {}
    18     71.4 MiB -761320.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     52.5 MiB    -18.9 MiB           1       g_score[start] = 0
    20                                         
    21     53.2 MiB -56805.2 MiB       27021       while not open_set.empty():
    22     53.2 MiB -56805.2 MiB       27021           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     53.2 MiB -56806.2 MiB       27021           current = open_set.get()[1]
    28                                         
    29     53.2 MiB -56806.4 MiB       27021           if current in remaining_goals:
    30     47.1 MiB     -6.2 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     47.1 MiB      0.0 MiB           1               if not remaining_goals:
    32     47.1 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     53.2 MiB -460997.4 MiB      219141           for neighbor in current.neighbors:
    35     53.2 MiB -404194.0 MiB      192121               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     53.2 MiB -404193.9 MiB      192121               if current.row != neighbor.row and current.col != neighbor.col:
    38     53.2 MiB -200676.0 MiB       95339                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     53.2 MiB -404196.2 MiB      192121               if temp_g_score < g_score[neighbor]:
    41     53.2 MiB -56922.3 MiB       27402                   came_from[neighbor] = current
    42     53.2 MiB -56923.3 MiB       27402                   g_score[neighbor] = temp_g_score
    43     53.2 MiB -56923.5 MiB       27402                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     53.2 MiB -56804.6 MiB       27020           if draw is not None:
    46                                                     draw()
    47                                                     
    48     53.2 MiB -56804.9 MiB       27020           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     47.1 MiB      0.0 MiB           1       paths = {}
    53     47.2 MiB      0.0 MiB           2       for goal in goals:
    54     47.2 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     47.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.4 MiB     91.4 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.4 MiB    -86.3 MiB         257       for row in grid:
     8     91.4 MiB -22117.3 MiB       65792           for spot in row:
     9     91.4 MiB -22031.1 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     91.0 MiB     -0.4 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     91.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     91.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     91.0 MiB      0.0 MiB           1       came_from = {}
    18     94.5 MiB  -4227.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.5 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.5 MiB -531129.5 MiB       32130       while not open_set.empty():
    22     94.5 MiB -531130.0 MiB       32130           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.5 MiB -531131.2 MiB       32130           current = open_set.get()[1]
    28                                         
    29     94.5 MiB -531131.5 MiB       32130           if current in remaining_goals:
    30     45.6 MiB    -48.9 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     45.6 MiB      0.0 MiB           1               if not remaining_goals:
    32     45.6 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.5 MiB -4323682.3 MiB      260917           for neighbor in current.neighbors:
    35     94.5 MiB -3792565.1 MiB      228788               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.5 MiB -3792576.6 MiB      228788               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.5 MiB -1883672.5 MiB      113573                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.5 MiB -3792589.0 MiB      228788               if temp_g_score < g_score[neighbor]:
    41     94.5 MiB -534728.6 MiB       32510                   came_from[neighbor] = current
    42     94.5 MiB -534733.8 MiB       32510                   g_score[neighbor] = temp_g_score
    43     94.5 MiB -534734.5 MiB       32510                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.5 MiB -531127.0 MiB       32129           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.5 MiB -531129.0 MiB       32129           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     45.6 MiB      0.0 MiB           1       paths = {}
    53     45.8 MiB      0.0 MiB           2       for goal in goals:
    54     45.8 MiB      0.2 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     45.8 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     91.2 MiB     91.2 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     91.2 MiB    -78.9 MiB         257       for row in grid:
     8     91.2 MiB -20226.3 MiB       65792           for spot in row:
     9     91.2 MiB -20148.2 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     90.4 MiB     -0.8 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     90.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     90.4 MiB      0.0 MiB           1       open_set.put((0, start))
    17     90.4 MiB      0.0 MiB           1       came_from = {}
    18     94.4 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     94.4 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     94.8 MiB -105868.6 MiB       40633       while not open_set.empty():
    22     94.8 MiB -105868.6 MiB       40633           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     94.8 MiB -105868.7 MiB       40633           current = open_set.get()[1]
    28                                         
    29     94.8 MiB -105868.7 MiB       40633           if current in remaining_goals:
    30     87.2 MiB     -7.7 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     87.2 MiB      0.0 MiB           1               if not remaining_goals:
    32     87.2 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     94.8 MiB -857575.3 MiB      329221           for neighbor in current.neighbors:
    35     94.8 MiB -751708.4 MiB      288589               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     94.8 MiB -751708.8 MiB      288589               if current.row != neighbor.row and current.col != neighbor.col:
    38     94.8 MiB -373104.4 MiB      143263                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     94.8 MiB -751713.8 MiB      288589               if temp_g_score < g_score[neighbor]:
    41     94.8 MiB -105852.5 MiB       41100                   came_from[neighbor] = current
    42     94.8 MiB -105853.1 MiB       41100                   g_score[neighbor] = temp_g_score
    43     94.8 MiB -105853.7 MiB       41100                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     94.8 MiB -105868.5 MiB       40632           if draw is not None:
    46                                                     draw()
    47                                                     
    48     94.8 MiB -105868.6 MiB       40632           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     87.2 MiB      0.0 MiB           1       paths = {}
    53     87.2 MiB      0.0 MiB           2       for goal in goals:
    54     87.2 MiB      0.0 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     87.2 MiB      0.0 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5     92.0 MiB     92.0 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7     92.0 MiB      0.0 MiB         257       for row in grid:
     8     92.0 MiB      0.0 MiB       65792           for spot in row:
     9     92.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12     92.0 MiB      0.0 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15     92.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    16     92.0 MiB      0.0 MiB           1       open_set.put((0, start))
    17     92.0 MiB      0.0 MiB           1       came_from = {}
    18     95.9 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19     95.9 MiB      0.0 MiB           1       g_score[start] = 0
    20                                         
    21     96.3 MiB -2410594.3 MiB       56851       while not open_set.empty():
    22     96.3 MiB -2410605.3 MiB       56851           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27     96.3 MiB -2410606.5 MiB       56851           current = open_set.get()[1]
    28                                         
    29     96.3 MiB -2410609.1 MiB       56851           if current in remaining_goals:
    30     42.3 MiB    -54.0 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31     42.3 MiB      0.0 MiB           1               if not remaining_goals:
    32     42.3 MiB      0.0 MiB           1                   break  # All goals found
    33                                         
    34     96.3 MiB -19540129.5 MiB      461432           for neighbor in current.neighbors:
    35     96.3 MiB -17129559.1 MiB      404582               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37     96.3 MiB -17129555.8 MiB      404582               if current.row != neighbor.row and current.col != neighbor.col:
    38     96.3 MiB -8502301.7 MiB      200843                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40     96.3 MiB -17129574.2 MiB      404582               if temp_g_score < g_score[neighbor]:
    41     96.3 MiB -2403329.5 MiB       57029                   came_from[neighbor] = current
    42     96.3 MiB -2403330.2 MiB       57029                   g_score[neighbor] = temp_g_score
    43     96.3 MiB -2403336.6 MiB       57029                   open_set.put((temp_g_score, neighbor))
    44                                         
    45     96.3 MiB -2410580.6 MiB       56850           if draw is not None:
    46                                                     draw()
    47                                                     
    48     96.3 MiB -2410591.2 MiB       56850           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52     42.3 MiB      0.0 MiB           1       paths = {}
    53     42.4 MiB      0.0 MiB           2       for goal in goals:
    54     42.4 MiB      0.1 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56     42.4 MiB      0.0 MiB           1       return paths


