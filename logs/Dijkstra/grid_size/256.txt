Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  67.4531 MiB  67.4531 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/256.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  71.3750 MiB   0.0000 MiB         257       for row in grid:
     8  71.3750 MiB   0.0000 MiB       65792           for spot in row:
     9  71.3750 MiB   3.9219 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  71.3750 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  71.3750 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  71.3750 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  71.3750 MiB   0.0000 MiB           1       came_from = {}
    18  78.0625 MiB   6.6875 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  78.0625 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  78.0938 MiB -36325.5156 MiB        8260       while not open_set.empty():
    22  78.0938 MiB -36325.6875 MiB        8260           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  78.0938 MiB -36325.9375 MiB        8260           current = open_set.get()[1]
    28                                         
    29  78.0938 MiB -36326.2031 MiB        8260           if current in remaining_goals:
    30  66.3438 MiB -11.7500 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  66.3438 MiB   0.0000 MiB           1               if not remaining_goals:
    32  66.3438 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  78.0938 MiB -326869.1875 MiB       74331           for neighbor in current.neighbors:
    35  78.0938 MiB -290546.6406 MiB       66072               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  78.0938 MiB -290548.5156 MiB       66072               if current.row != neighbor.row and current.col != neighbor.col:
    38  78.0938 MiB -145283.8750 MiB       33036                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  78.0938 MiB -290551.0938 MiB       66072               if temp_g_score < g_score[neighbor]:
    41  78.0938 MiB -37389.9219 MiB        8690                   came_from[neighbor] = current
    42  78.0938 MiB -37390.7344 MiB        8690                   g_score[neighbor] = temp_g_score
    43  78.0938 MiB -37391.0312 MiB        8690                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  78.0938 MiB -36324.9531 MiB        8259           if draw is not None:
    46                                                     draw()
    47                                                     
    48  78.0938 MiB -36325.1719 MiB        8259           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  66.3438 MiB   0.0000 MiB           1       paths = {}
    53  66.3438 MiB   0.0000 MiB           2       for goal in goals:
    54  66.3438 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  66.3438 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  91.5781 MiB  91.5781 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/256.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  95.5781 MiB   0.0000 MiB         257       for row in grid:
     8  95.5781 MiB   0.0000 MiB       65792           for spot in row:
     9  95.5781 MiB   4.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  95.5781 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  95.5781 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  95.5781 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  95.5781 MiB   0.0000 MiB           1       came_from = {}
    18 101.4531 MiB   5.8750 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 101.4531 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 101.8438 MiB   0.0000 MiB        9398       while not open_set.empty():
    22 101.8438 MiB   0.0000 MiB        9398           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 101.8438 MiB   0.0000 MiB        9398           current = open_set.get()[1]
    28                                         
    29 101.8438 MiB   0.0000 MiB        9398           if current in remaining_goals:
    30 101.8438 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 101.8438 MiB   0.0000 MiB           1               if not remaining_goals:
    32 101.8438 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 101.8438 MiB   0.0312 MiB       84552           for neighbor in current.neighbors:
    35 101.8438 MiB   0.0000 MiB       75155               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 101.8438 MiB   0.0000 MiB       75155               if current.row != neighbor.row and current.col != neighbor.col:
    38 101.8438 MiB   0.0000 MiB       37574                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 101.8438 MiB   0.0000 MiB       75155               if temp_g_score < g_score[neighbor]:
    41 101.8438 MiB   0.3594 MiB        9849                   came_from[neighbor] = current
    42 101.8438 MiB   0.0000 MiB        9849                   g_score[neighbor] = temp_g_score
    43 101.8438 MiB   0.0000 MiB        9849                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 101.8438 MiB   0.0000 MiB        9397           if draw is not None:
    46                                                     draw()
    47                                                     
    48 101.8438 MiB   0.0000 MiB        9397           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 101.8438 MiB   0.0000 MiB           1       paths = {}
    53 101.8438 MiB   0.0000 MiB           2       for goal in goals:
    54 101.8438 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 101.8438 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 101.2344 MiB 101.2344 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/256.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 101.5000 MiB  -1.8438 MiB         257       for row in grid:
     8 101.5000 MiB -472.4062 MiB       65792           for spot in row:
     9 101.5000 MiB -470.2969 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 101.5000 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 101.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 101.5000 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 101.5000 MiB   0.0000 MiB           1       came_from = {}
    18 102.8906 MiB   1.3906 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 102.8906 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 103.0938 MiB -215546.7031 MiB       51422       while not open_set.empty():
    22 103.0938 MiB -215546.9688 MiB       51422           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 103.0938 MiB -215547.5469 MiB       51422           current = open_set.get()[1]
    28                                         
    29 103.0938 MiB -215547.7500 MiB       51422           if current in remaining_goals:
    30 100.3281 MiB  -2.7656 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 100.3281 MiB   0.0000 MiB           1               if not remaining_goals:
    32 100.3281 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 103.0938 MiB -1932822.9688 MiB      460970           for neighbor in current.neighbors:
    35 103.0938 MiB -1717277.5469 MiB      409549               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 103.0938 MiB -1717278.1875 MiB      409549               if current.row != neighbor.row and current.col != neighbor.col:
    38 103.0938 MiB -857462.5938 MiB      204472                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 103.0938 MiB -1717279.7188 MiB      409549               if temp_g_score < g_score[neighbor]:
    41 103.0938 MiB -215999.1875 MiB       51777                   came_from[neighbor] = current
    42 103.0938 MiB -215999.7969 MiB       51777                   g_score[neighbor] = temp_g_score
    43 103.0938 MiB -216000.3594 MiB       51777                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 103.0938 MiB -215546.3438 MiB       51421           if draw is not None:
    46                                                     draw()
    47                                                     
    48 103.0938 MiB -215546.7031 MiB       51421           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 100.3281 MiB   0.0000 MiB           1       paths = {}
    53 100.3281 MiB   0.0000 MiB           2       for goal in goals:
    54 100.3281 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 100.3281 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 107.4219 MiB 107.4219 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 107.4219 MiB   0.0000 MiB         257       for row in grid:
     8 107.4219 MiB   0.0000 MiB       65792           for spot in row:
     9 107.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 107.4219 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 107.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 107.4219 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 107.4219 MiB   0.0000 MiB           1       came_from = {}
    18 109.0156 MiB -56438.8906 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 106.8750 MiB  -2.1406 MiB           1       g_score[start] = 0
    20                                         
    21 106.9531 MiB -1161098.1094 MiB       32113       while not open_set.empty():
    22 106.9531 MiB -1161098.9062 MiB       32113           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 106.9531 MiB -1161100.0938 MiB       32113           current = open_set.get()[1]
    28                                         
    29 106.9531 MiB -1161100.7812 MiB       32113           if current in remaining_goals:
    30  49.7969 MiB -57.1562 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  49.7969 MiB   0.0000 MiB           1               if not remaining_goals:
    32  49.7969 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 106.9531 MiB -10414320.9844 MiB      287923           for neighbor in current.neighbors:
    35 106.9531 MiB -9253238.6562 MiB      255811               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 106.9531 MiB -9253246.8906 MiB      255811               if current.row != neighbor.row and current.col != neighbor.col:
    38 106.9531 MiB -4620821.3438 MiB      127725                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 106.9531 MiB -9253265.2344 MiB      255811               if temp_g_score < g_score[neighbor]:
    41 106.9531 MiB -1169282.3594 MiB       32558                   came_from[neighbor] = current
    42 106.9531 MiB -1169284.3594 MiB       32558                   g_score[neighbor] = temp_g_score
    43 106.9531 MiB -1169288.7031 MiB       32558                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 106.9531 MiB -1161095.7812 MiB       32112           if draw is not None:
    46                                                     draw()
    47                                                     
    48 106.9531 MiB -1161096.8438 MiB       32112           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  49.7969 MiB   0.0000 MiB           1       paths = {}
    53  49.9531 MiB   0.0156 MiB           2       for goal in goals:
    54  49.9531 MiB   0.1406 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  49.9688 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 101.6406 MiB 101.6406 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 101.6406 MiB -704.8906 MiB         257       for row in grid:
     8 101.6406 MiB -180191.5312 MiB       65792           for spot in row:
     9 101.6406 MiB -179495.5156 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  91.7656 MiB  -9.8750 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  91.7656 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  91.7656 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  91.7656 MiB   0.0000 MiB           1       came_from = {}
    18  96.8281 MiB -16.5938 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  96.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  96.8906 MiB -1342728.7500 MiB       42340       while not open_set.empty():
    22  96.8906 MiB -1342729.7656 MiB       42340           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  96.8906 MiB -1342731.5781 MiB       42340           current = open_set.get()[1]
    28                                         
    29  96.8906 MiB -1342732.3125 MiB       42340           if current in remaining_goals:
    30  52.2031 MiB -44.6875 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  52.2031 MiB   0.0000 MiB           1               if not remaining_goals:
    32  52.2031 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  96.8906 MiB -12037899.3438 MiB      380013           for neighbor in current.neighbors:
    35  96.8906 MiB -10695187.2188 MiB      337674               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  96.8906 MiB -10695190.8750 MiB      337674               if current.row != neighbor.row and current.col != neighbor.col:
    38  96.8906 MiB -5339902.1094 MiB      168664                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  96.8906 MiB -10695198.3281 MiB      337674               if temp_g_score < g_score[neighbor]:
    41  96.8906 MiB -1344408.4375 MiB       42896                   came_from[neighbor] = current
    42  96.8906 MiB -1344409.5000 MiB       42896                   g_score[neighbor] = temp_g_score
    43  96.8906 MiB -1344420.5469 MiB       42896                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  96.8906 MiB -1342727.1094 MiB       42339           if draw is not None:
    46                                                     draw()
    47                                                     
    48  96.8906 MiB -1342727.7969 MiB       42339           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  52.2031 MiB   0.0000 MiB           1       paths = {}
    53  52.3125 MiB   0.0156 MiB           2       for goal in goals:
    54  52.3125 MiB   0.0938 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  52.3438 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  99.5781 MiB  99.5781 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  99.5781 MiB  -3.6875 MiB         257       for row in grid:
     8  99.5781 MiB -943.7500 MiB       65792           for spot in row:
     9  99.5781 MiB -940.0625 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  99.5625 MiB  -0.0156 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  99.5625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  99.5625 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  99.5625 MiB   0.0000 MiB           1       came_from = {}
    18 104.5000 MiB   4.9375 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 104.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 104.5469 MiB -454909.6250 MiB       31029       while not open_set.empty():
    22 104.5469 MiB -454910.4844 MiB       31029           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 104.5469 MiB -454912.0469 MiB       31029           current = open_set.get()[1]
    28                                         
    29 104.5469 MiB -454912.6406 MiB       31029           if current in remaining_goals:
    30  89.1094 MiB -15.4375 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  89.1094 MiB   0.0000 MiB           1               if not remaining_goals:
    32  89.1094 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 104.5469 MiB -4080784.7031 MiB      278382           for neighbor in current.neighbors:
    35 104.5469 MiB -3625880.6250 MiB      247354               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 104.5469 MiB -3625883.4688 MiB      247354               if current.row != neighbor.row and current.col != neighbor.col:
    38 104.5469 MiB -1810738.3594 MiB      123532                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 104.5469 MiB -3625889.3750 MiB      247354               if temp_g_score < g_score[neighbor]:
    41 104.5469 MiB -459368.7969 MiB       31543                   came_from[neighbor] = current
    42 104.5469 MiB -459368.8438 MiB       31543                   g_score[neighbor] = temp_g_score
    43 104.5469 MiB -459369.1719 MiB       31543                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 104.5469 MiB -454908.4062 MiB       31028           if draw is not None:
    46                                                     draw()
    47                                                     
    48 104.5469 MiB -454908.8594 MiB       31028           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  89.1094 MiB   0.0000 MiB           1       paths = {}
    53  89.1562 MiB   0.0000 MiB           2       for goal in goals:
    54  89.1562 MiB   0.0469 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  89.1562 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 103.3906 MiB 103.3906 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 103.3906 MiB   0.0000 MiB         257       for row in grid:
     8 103.3906 MiB   0.0000 MiB       65792           for spot in row:
     9 103.3906 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 103.3906 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 103.3906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 103.3906 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 103.3906 MiB   0.0000 MiB           1       came_from = {}
    18 106.7969 MiB   3.4062 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 106.7969 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 106.9062 MiB -1572396.3281 MiB       46142       while not open_set.empty():
    22 106.9062 MiB -1572397.1562 MiB       46142           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 106.9062 MiB -1572398.1406 MiB       46142           current = open_set.get()[1]
    28                                         
    29 106.9062 MiB -1572399.2188 MiB       46142           if current in remaining_goals:
    30  60.4062 MiB -46.5000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  60.4062 MiB   0.0000 MiB           1               if not remaining_goals:
    32  60.4062 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 106.9062 MiB -14114882.7500 MiB      414468           for neighbor in current.neighbors:
    35 106.9062 MiB -12542494.6875 MiB      368327               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 106.9062 MiB -12542503.3281 MiB      368327               if current.row != neighbor.row and current.col != neighbor.col:
    38 106.9062 MiB -6265218.5469 MiB      184030                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 106.9062 MiB -12542521.4844 MiB      368327               if temp_g_score < g_score[neighbor]:
    41 106.9062 MiB -1580729.2344 MiB       46827                   came_from[neighbor] = current
    42 106.9062 MiB -1580730.0781 MiB       46827                   g_score[neighbor] = temp_g_score
    43 106.9062 MiB -1580731.2812 MiB       46827                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 106.9062 MiB -1572395.0156 MiB       46141           if draw is not None:
    46                                                     draw()
    47                                                     
    48 106.9062 MiB -1572395.5781 MiB       46141           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  60.4062 MiB   0.0000 MiB           1       paths = {}
    53  60.4375 MiB   0.0156 MiB           2       for goal in goals:
    54  60.4375 MiB   0.0156 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  60.4531 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 103.3125 MiB 103.3125 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 103.3125 MiB  -2.0625 MiB         257       for row in grid:
     8 103.3125 MiB -519.9219 MiB       65792           for spot in row:
     9 103.3125 MiB -517.8594 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 103.1406 MiB  -0.1719 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 103.1406 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 103.1406 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 103.1406 MiB   0.0000 MiB           1       came_from = {}
    18 106.7656 MiB -910.5625 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 106.6406 MiB  -0.1250 MiB           1       g_score[start] = 0
    20                                         
    21 106.6406 MiB -97290.0000 MiB        7007       while not open_set.empty():
    22 106.6406 MiB -97290.1094 MiB        7007           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 106.6406 MiB -97290.3750 MiB        7007           current = open_set.get()[1]
    28                                         
    29 106.6406 MiB -97290.5156 MiB        7007           if current in remaining_goals:
    30  84.6562 MiB -21.9844 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  84.6562 MiB   0.0000 MiB           1               if not remaining_goals:
    32  84.6562 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 106.6406 MiB -871552.3594 MiB       62745           for neighbor in current.neighbors:
    35 106.6406 MiB -774266.8594 MiB       55739               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 106.6406 MiB -774270.4844 MiB       55739               if current.row != neighbor.row and current.col != neighbor.col:
    38 106.6406 MiB -386501.6875 MiB       27818                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 106.6406 MiB -774280.5000 MiB       55739               if temp_g_score < g_score[neighbor]:
    41 106.6406 MiB -100130.4375 MiB        7292                   came_from[neighbor] = current
    42 106.6406 MiB -100130.5781 MiB        7292                   g_score[neighbor] = temp_g_score
    43 106.6406 MiB -100130.6250 MiB        7292                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 106.6406 MiB -97289.5312 MiB        7006           if draw is not None:
    46                                                     draw()
    47                                                     
    48 106.6406 MiB -97289.6719 MiB        7006           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  84.6562 MiB   0.0000 MiB           1       paths = {}
    53  84.6875 MiB   0.0000 MiB           2       for goal in goals:
    54  84.6875 MiB   0.0312 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  84.6875 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 100.2188 MiB 100.2188 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 100.2188 MiB -307.2656 MiB         257       for row in grid:
     8 100.2188 MiB -78686.9375 MiB       65792           for spot in row:
     9 100.2188 MiB -78380.9219 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  97.1562 MiB  -3.0625 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  97.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  97.1562 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  97.1562 MiB   0.0000 MiB           1       came_from = {}
    18 100.5625 MiB -10324.3281 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 100.5625 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 101.0625 MiB -1563427.6250 MiB       51113       while not open_set.empty():
    22 101.0625 MiB -1563428.5938 MiB       51113           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 101.0625 MiB -1563430.2031 MiB       51113           current = open_set.get()[1]
    28                                         
    29 101.0625 MiB -1563431.0000 MiB       51113           if current in remaining_goals:
    30  54.8750 MiB -46.1875 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  54.8750 MiB   0.0000 MiB           1               if not remaining_goals:
    32  54.8750 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 101.0625 MiB -14010552.5000 MiB      458620           for neighbor in current.neighbors:
    35 101.0625 MiB -12447136.9844 MiB      407508               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 101.0625 MiB -12447156.1719 MiB      407508               if current.row != neighbor.row and current.col != neighbor.col:
    38 101.0625 MiB -6213611.2969 MiB      203523                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 101.0625 MiB -12447168.1094 MiB      407508               if temp_g_score < g_score[neighbor]:
    41 101.0625 MiB -1560473.1875 MiB       51623                   came_from[neighbor] = current
    42 101.0625 MiB -1560474.2969 MiB       51623                   g_score[neighbor] = temp_g_score
    43 101.0625 MiB -1560475.4375 MiB       51623                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 101.0625 MiB -1563425.2500 MiB       51112           if draw is not None:
    46                                                     draw()
    47                                                     
    48 101.0625 MiB -1563426.4375 MiB       51112           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  54.8750 MiB   0.0000 MiB           1       paths = {}
    53  55.0312 MiB   0.0156 MiB           2       for goal in goals:
    54  55.0312 MiB   0.1406 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  55.0625 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  97.0781 MiB  97.0781 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  97.0938 MiB   0.0000 MiB         257       for row in grid:
     8  97.0938 MiB   0.0000 MiB       65792           for spot in row:
     9  97.0938 MiB   0.0156 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  97.0938 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  97.0938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  97.0938 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  97.0938 MiB   0.0000 MiB           1       came_from = {}
    18 101.7031 MiB   4.6094 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 101.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 101.9375 MiB -455853.5312 MiB       50514       while not open_set.empty():
    22 101.9375 MiB -455854.1719 MiB       50514           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 101.9375 MiB -455855.7969 MiB       50514           current = open_set.get()[1]
    28                                         
    29 101.9375 MiB -455857.0781 MiB       50514           if current in remaining_goals:
    30  63.7344 MiB -38.2031 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.7344 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.7344 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 101.9375 MiB -4079126.2344 MiB      452882           for neighbor in current.neighbors:
    35 101.9375 MiB -3623282.4375 MiB      402369               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 101.9375 MiB -3623292.0781 MiB      402369               if current.row != neighbor.row and current.col != neighbor.col:
    38 101.9375 MiB -1807799.0312 MiB      200896                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 101.9375 MiB -3623305.4375 MiB      402369               if temp_g_score < g_score[neighbor]:
    41 101.9375 MiB -451982.4062 MiB       50893                   came_from[neighbor] = current
    42 101.9375 MiB -451983.6719 MiB       50893                   g_score[neighbor] = temp_g_score
    43 101.9375 MiB -451985.4375 MiB       50893                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 101.9375 MiB -455852.1719 MiB       50513           if draw is not None:
    46                                                     draw()
    47                                                     
    48 101.9375 MiB -455853.0156 MiB       50513           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.7344 MiB   0.0000 MiB           1       paths = {}
    53  63.9531 MiB   0.0000 MiB           2       for goal in goals:
    54  63.9531 MiB   0.2188 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.9844 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  99.1562 MiB  99.1562 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  99.1562 MiB -396.8438 MiB         257       for row in grid:
     8  99.1562 MiB -101674.7344 MiB       65792           for spot in row:
     9  99.1562 MiB -101278.9375 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  97.5938 MiB  -1.5625 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  97.5938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  97.5938 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  97.5938 MiB   0.0000 MiB           1       came_from = {}
    18 100.8750 MiB   3.2812 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 100.8750 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 100.8750 MiB   0.0000 MiB         262       while not open_set.empty():
    22 100.8750 MiB   0.0000 MiB         262           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 100.8750 MiB   0.0000 MiB         262           current = open_set.get()[1]
    28                                         
    29 100.8750 MiB   0.0000 MiB         262           if current in remaining_goals:
    30 100.8750 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 100.8750 MiB   0.0000 MiB           1               if not remaining_goals:
    32 100.8750 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 100.8750 MiB   0.0000 MiB        2349           for neighbor in current.neighbors:
    35 100.8750 MiB   0.0000 MiB        2088               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 100.8750 MiB   0.0000 MiB        2088               if current.row != neighbor.row and current.col != neighbor.col:
    38 100.8750 MiB   0.0000 MiB        1044                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 100.8750 MiB   0.0000 MiB        2088               if temp_g_score < g_score[neighbor]:
    41 100.8750 MiB   0.0000 MiB         340                   came_from[neighbor] = current
    42 100.8750 MiB   0.0000 MiB         340                   g_score[neighbor] = temp_g_score
    43 100.8750 MiB   0.0000 MiB         340                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 100.8750 MiB   0.0000 MiB         261           if draw is not None:
    46                                                     draw()
    47                                                     
    48 100.8750 MiB   0.0000 MiB         261           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 100.8750 MiB   0.0000 MiB           1       paths = {}
    53 100.8750 MiB   0.0000 MiB           2       for goal in goals:
    54 100.8750 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 100.8750 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 109.0156 MiB 109.0156 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 109.0156 MiB -336.3750 MiB         257       for row in grid:
     8 109.0156 MiB -86231.1250 MiB       65792           for spot in row:
     9 109.0156 MiB -85896.0469 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 107.3906 MiB  -1.6250 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 107.3906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 107.3906 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 107.3906 MiB   0.0000 MiB           1       came_from = {}
    18 108.4531 MiB   1.0625 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 108.4531 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 108.5156 MiB -48004.5156 MiB       37302       while not open_set.empty():
    22 108.5156 MiB -48004.5156 MiB       37302           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 108.5156 MiB -48004.7344 MiB       37302           current = open_set.get()[1]
    28                                         
    29 108.5156 MiB -48004.9375 MiB       37302           if current in remaining_goals:
    30 105.0469 MiB  -3.4688 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 105.0469 MiB   0.0000 MiB           1               if not remaining_goals:
    32 105.0469 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 108.5156 MiB -430791.8281 MiB      334432           for neighbor in current.neighbors:
    35 108.5156 MiB -382789.1250 MiB      297131               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 108.5156 MiB -382789.4844 MiB      297131               if current.row != neighbor.row and current.col != neighbor.col:
    38 108.5156 MiB -191190.2344 MiB      148353                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 108.5156 MiB -382790.4062 MiB      297131               if temp_g_score < g_score[neighbor]:
    41 108.5156 MiB -48424.4531 MiB       37763                   came_from[neighbor] = current
    42 108.5156 MiB -48424.7031 MiB       37763                   g_score[neighbor] = temp_g_score
    43 108.5156 MiB -48424.9688 MiB       37763                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 108.5156 MiB -48004.2031 MiB       37301           if draw is not None:
    46                                                     draw()
    47                                                     
    48 108.5156 MiB -48004.4375 MiB       37301           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 105.0469 MiB   0.0000 MiB           1       paths = {}
    53 105.0625 MiB   0.0156 MiB           2       for goal in goals:
    54 105.0625 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 105.0625 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 106.0469 MiB 106.0469 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 106.0469 MiB   0.0000 MiB         257       for row in grid:
     8 106.0469 MiB   0.0000 MiB       65792           for spot in row:
     9 106.0469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 106.0469 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 106.0469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 106.0469 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 106.0469 MiB   0.0000 MiB           1       came_from = {}
    18 110.1094 MiB -1500.2812 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 110.1094 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 110.3750 MiB   0.0000 MiB        7581       while not open_set.empty():
    22 110.3750 MiB   0.0000 MiB        7581           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 110.3750 MiB   0.0000 MiB        7581           current = open_set.get()[1]
    28                                         
    29 110.3750 MiB   0.0000 MiB        7581           if current in remaining_goals:
    30 110.3750 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 110.3750 MiB   0.0000 MiB           1               if not remaining_goals:
    32 110.3750 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 110.3750 MiB   0.0000 MiB       68220           for neighbor in current.neighbors:
    35 110.3750 MiB   0.0000 MiB       60640               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 110.3750 MiB   0.0000 MiB       60640               if current.row != neighbor.row and current.col != neighbor.col:
    38 110.3750 MiB   0.0000 MiB       30320                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 110.3750 MiB   0.0000 MiB       60640               if temp_g_score < g_score[neighbor]:
    41 110.3750 MiB   0.2656 MiB        7995                   came_from[neighbor] = current
    42 110.3750 MiB   0.0000 MiB        7995                   g_score[neighbor] = temp_g_score
    43 110.3750 MiB   0.0000 MiB        7995                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 110.3750 MiB   0.0000 MiB        7580           if draw is not None:
    46                                                     draw()
    47                                                     
    48 110.3750 MiB   0.0000 MiB        7580           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 110.3750 MiB   0.0000 MiB           1       paths = {}
    53 110.3750 MiB   0.0000 MiB           2       for goal in goals:
    54 110.3750 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 110.3750 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 110.4688 MiB 110.4688 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 110.4688 MiB -282.1406 MiB         257       for row in grid:
     8 110.4688 MiB -72005.0625 MiB       65792           for spot in row:
     9 110.4688 MiB -71724.8906 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 106.3750 MiB  -4.0938 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 106.3750 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 106.3750 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 106.3750 MiB   0.0000 MiB           1       came_from = {}
    18 109.9375 MiB   3.5625 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 109.9375 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 110.3125 MiB -1649120.9062 MiB       44652       while not open_set.empty():
    22 110.3125 MiB -1649122.3281 MiB       44652           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 110.3125 MiB -1649125.0469 MiB       44652           current = open_set.get()[1]
    28                                         
    29 110.3125 MiB -1649125.9062 MiB       44652           if current in remaining_goals:
    30  63.7500 MiB -46.5625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.7500 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.7500 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 110.3125 MiB -14790664.1875 MiB      400612           for neighbor in current.neighbors:
    35 110.3125 MiB -13141556.5469 MiB      355961               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 110.3125 MiB -13141563.0469 MiB      355961               if current.row != neighbor.row and current.col != neighbor.col:
    38 110.3125 MiB -6562302.6875 MiB      177773                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 110.3125 MiB -13141575.7656 MiB      355961               if temp_g_score < g_score[neighbor]:
    41 110.3125 MiB -1655824.3125 MiB       45173                   came_from[neighbor] = current
    42 110.3125 MiB -1655825.7344 MiB       45173                   g_score[neighbor] = temp_g_score
    43 110.3125 MiB -1655827.7031 MiB       45173                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 110.3125 MiB -1649117.6562 MiB       44651           if draw is not None:
    46                                                     draw()
    47                                                     
    48 110.3125 MiB -1649119.2344 MiB       44651           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.7500 MiB   0.0000 MiB           1       paths = {}
    53  63.7812 MiB   0.0000 MiB           2       for goal in goals:
    54  63.7812 MiB   0.0312 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.7969 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 104.5938 MiB 104.5938 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 104.5938 MiB -134.1406 MiB         257       for row in grid:
     8 104.5938 MiB -34244.3125 MiB       65792           for spot in row:
     9 104.5938 MiB -34111.3438 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 103.0156 MiB  -1.5781 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 103.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 103.0156 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 103.0156 MiB   0.0000 MiB           1       came_from = {}
    18 104.5625 MiB -176.0312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 104.5625 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 105.0469 MiB   0.0000 MiB        5686       while not open_set.empty():
    22 105.0469 MiB   0.0000 MiB        5686           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 105.0469 MiB   0.0000 MiB        5686           current = open_set.get()[1]
    28                                         
    29 105.0469 MiB   0.0000 MiB        5686           if current in remaining_goals:
    30 105.0469 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 105.0469 MiB   0.0000 MiB           1               if not remaining_goals:
    32 105.0469 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 105.0469 MiB   0.0000 MiB       50790           for neighbor in current.neighbors:
    35 105.0469 MiB   0.0000 MiB       45105               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 105.0469 MiB   0.0000 MiB       45105               if current.row != neighbor.row and current.col != neighbor.col:
    38 105.0469 MiB   0.0000 MiB       22490                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 105.0469 MiB   0.0000 MiB       45105               if temp_g_score < g_score[neighbor]:
    41 105.0469 MiB   0.4844 MiB        5889                   came_from[neighbor] = current
    42 105.0469 MiB   0.0000 MiB        5889                   g_score[neighbor] = temp_g_score
    43 105.0469 MiB   0.0000 MiB        5889                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 105.0469 MiB   0.0000 MiB        5685           if draw is not None:
    46                                                     draw()
    47                                                     
    48 105.0469 MiB   0.0000 MiB        5685           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 105.0469 MiB   0.0000 MiB           1       paths = {}
    53 105.0469 MiB   0.0000 MiB           2       for goal in goals:
    54 105.0469 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 105.0469 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 105.7656 MiB 105.7656 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 105.7656 MiB -304.9375 MiB         257       for row in grid:
     8 105.7656 MiB -78205.2031 MiB       65792           for spot in row:
     9 105.7656 MiB -77902.9688 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 102.0469 MiB  -3.7188 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 102.0469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 102.0469 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 102.0469 MiB   0.0000 MiB           1       came_from = {}
    18 104.5000 MiB   2.4531 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 104.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 104.5312 MiB -83393.1094 MiB       29640       while not open_set.empty():
    22 104.5312 MiB -83393.5469 MiB       29640           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 104.5312 MiB -83393.8125 MiB       29640           current = open_set.get()[1]
    28                                         
    29 104.5312 MiB -83393.8125 MiB       29640           if current in remaining_goals:
    30  91.7031 MiB -12.8281 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  91.7031 MiB   0.0000 MiB           1               if not remaining_goals:
    32  91.7031 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 104.5312 MiB -748359.6250 MiB      265741           for neighbor in current.neighbors:
    35 104.5312 MiB -664969.8594 MiB      236102               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 104.5312 MiB -664971.6875 MiB      236102               if current.row != neighbor.row and current.col != neighbor.col:
    38 104.5312 MiB -332145.5781 MiB      117883                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 104.5312 MiB -664975.9219 MiB      236102               if temp_g_score < g_score[neighbor]:
    41 104.5312 MiB -83951.3438 MiB       30062                   came_from[neighbor] = current
    42 104.5312 MiB -83951.5938 MiB       30062                   g_score[neighbor] = temp_g_score
    43 104.5312 MiB -83952.0469 MiB       30062                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 104.5312 MiB -83392.2500 MiB       29639           if draw is not None:
    46                                                     draw()
    47                                                     
    48 104.5312 MiB -83392.5781 MiB       29639           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  91.7031 MiB   0.0000 MiB           1       paths = {}
    53  91.7812 MiB   0.0156 MiB           2       for goal in goals:
    54  91.7812 MiB   0.0625 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  91.7812 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 100.9531 MiB 100.9531 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 100.9531 MiB  -1.3750 MiB         257       for row in grid:
     8 100.9531 MiB -353.2812 MiB       65792           for spot in row:
     9 100.9531 MiB -351.9219 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 100.9375 MiB  -0.0156 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 100.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 100.9375 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 100.9375 MiB   0.0000 MiB           1       came_from = {}
    18 104.1094 MiB   3.1719 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 104.1094 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 104.1094 MiB -49.7812 MiB        5280       while not open_set.empty():
    22 104.1094 MiB -49.7812 MiB        5280           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 104.1094 MiB -49.7812 MiB        5280           current = open_set.get()[1]
    28                                         
    29 104.1094 MiB -49.7812 MiB        5280           if current in remaining_goals:
    30 104.1094 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 104.1094 MiB   0.0000 MiB           1               if not remaining_goals:
    32 104.1094 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 104.1094 MiB -445.9062 MiB       47148           for neighbor in current.neighbors:
    35 104.1094 MiB -396.1406 MiB       41869               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 104.1094 MiB -396.1406 MiB       41869               if current.row != neighbor.row and current.col != neighbor.col:
    38 104.1094 MiB -197.7344 MiB       20874                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 104.1094 MiB -396.1406 MiB       41869               if temp_g_score < g_score[neighbor]:
    41 104.1094 MiB -51.2188 MiB        5523                   came_from[neighbor] = current
    42 104.1094 MiB -51.2188 MiB        5523                   g_score[neighbor] = temp_g_score
    43 104.1094 MiB -51.2188 MiB        5523                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 104.1094 MiB -49.7812 MiB        5279           if draw is not None:
    46                                                     draw()
    47                                                     
    48 104.1094 MiB -49.7812 MiB        5279           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 104.1094 MiB   0.0000 MiB           1       paths = {}
    53 104.1094 MiB   0.0000 MiB           2       for goal in goals:
    54 104.1094 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 104.1094 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 104.4062 MiB 104.4062 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 104.4062 MiB  -5.2500 MiB         257       for row in grid:
     8 104.4062 MiB -1326.7500 MiB       65792           for spot in row:
     9 104.4062 MiB -1321.5781 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 104.3125 MiB  -0.0938 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 104.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 104.3125 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 104.3125 MiB   0.0000 MiB           1       came_from = {}
    18 105.7188 MiB   1.4062 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 105.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 106.0938 MiB -762555.2812 MiB       39407       while not open_set.empty():
    22 106.0938 MiB -762556.6406 MiB       39407           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 106.0938 MiB -762558.8594 MiB       39407           current = open_set.get()[1]
    28                                         
    29 106.0938 MiB -762559.9688 MiB       39407           if current in remaining_goals:
    30  58.6406 MiB -47.4531 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  58.6406 MiB   0.0000 MiB           1               if not remaining_goals:
    32  58.6406 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 106.0938 MiB -6845774.1406 MiB      353330           for neighbor in current.neighbors:
    35 106.0938 MiB -6083230.4844 MiB      313924               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 106.0938 MiB -6083235.0000 MiB      313924               if current.row != neighbor.row and current.col != neighbor.col:
    38 106.0938 MiB -3038840.7969 MiB      156742                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 106.0938 MiB -6083252.0000 MiB      313924               if temp_g_score < g_score[neighbor]:
    41 106.0938 MiB -766059.2812 MiB       39863                   came_from[neighbor] = current
    42 106.0938 MiB -766060.0312 MiB       39863                   g_score[neighbor] = temp_g_score
    43 106.0938 MiB -766061.0000 MiB       39863                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 106.0938 MiB -762553.1094 MiB       39406           if draw is not None:
    46                                                     draw()
    47                                                     
    48 106.0938 MiB -762554.0469 MiB       39406           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  58.6406 MiB   0.0000 MiB           1       paths = {}
    53  58.6719 MiB   0.0000 MiB           2       for goal in goals:
    54  58.6719 MiB   0.0312 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  58.6875 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 100.0000 MiB 100.0000 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 100.0000 MiB -221.6562 MiB         257       for row in grid:
     8 100.0000 MiB -56763.5781 MiB       65792           for spot in row:
     9 100.0000 MiB -56542.7031 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  98.7188 MiB  -1.2812 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  98.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  98.7188 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  98.7188 MiB   0.0000 MiB           1       came_from = {}
    18 101.1875 MiB   2.4688 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 101.1875 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 101.5781 MiB -866465.8125 MiB       49347       while not open_set.empty():
    22 101.5781 MiB -866467.0156 MiB       49347           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 101.5781 MiB -866469.1875 MiB       49347           current = open_set.get()[1]
    28                                         
    29 101.5781 MiB -866469.8438 MiB       49347           if current in remaining_goals:
    30  51.5156 MiB -50.0625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  51.5156 MiB   0.0000 MiB           1               if not remaining_goals:
    32  51.5156 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 101.5781 MiB -7752622.4375 MiB      442693           for neighbor in current.neighbors:
    35 101.5781 MiB -6886169.7969 MiB      393347               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 101.5781 MiB -6886176.5781 MiB      393347               if current.row != neighbor.row and current.col != neighbor.col:
    38 101.5781 MiB -3435604.4219 MiB      196437                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 101.5781 MiB -6886192.8750 MiB      393347               if temp_g_score < g_score[neighbor]:
    41 101.5781 MiB -858542.0469 MiB       49830                   came_from[neighbor] = current
    42 101.5781 MiB -858543.5312 MiB       49830                   g_score[neighbor] = temp_g_score
    43 101.5781 MiB -858544.5938 MiB       49830                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 101.5781 MiB -866462.8438 MiB       49346           if draw is not None:
    46                                                     draw()
    47                                                     
    48 101.5781 MiB -866463.6719 MiB       49346           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  51.5156 MiB   0.0000 MiB           1       paths = {}
    53  51.6406 MiB   0.0156 MiB           2       for goal in goals:
    54  51.6406 MiB   0.1094 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  51.6406 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  97.0625 MiB  97.0625 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  97.0625 MiB -80.9062 MiB         257       for row in grid:
     8  97.0625 MiB -20700.2656 MiB       65792           for spot in row:
     9  97.0625 MiB -20619.4219 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  96.8750 MiB  -0.1875 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  96.8750 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  96.8750 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  96.8750 MiB   0.0000 MiB           1       came_from = {}
    18 101.2969 MiB -36538.2969 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  98.7812 MiB  -2.5156 MiB           1       g_score[start] = 0
    20                                         
    21 100.0312 MiB -800061.7812 MiB       62893       while not open_set.empty():
    22 100.0312 MiB -800062.5625 MiB       62893           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 100.0312 MiB -800063.8125 MiB       62893           current = open_set.get()[1]
    28                                         
    29 100.0312 MiB -800064.3438 MiB       62893           if current in remaining_goals:
    30  49.7969 MiB -50.2344 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  49.7969 MiB   0.0000 MiB           1               if not remaining_goals:
    32  49.7969 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 100.0312 MiB -7151689.0938 MiB      563442           for neighbor in current.neighbors:
    35 100.0312 MiB -6351641.6562 MiB      500550               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 100.0312 MiB -6351648.7812 MiB      500550               if current.row != neighbor.row and current.col != neighbor.col:
    38 100.0312 MiB -3167792.4844 MiB      249845                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 100.0312 MiB -6351664.0156 MiB      500550               if temp_g_score < g_score[neighbor]:
    41 100.0312 MiB -788762.1406 MiB       63051                   came_from[neighbor] = current
    42 100.0312 MiB -788764.2031 MiB       63051                   g_score[neighbor] = temp_g_score
    43 100.0312 MiB -788766.6094 MiB       63051                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 100.0312 MiB -800059.3125 MiB       62892           if draw is not None:
    46                                                     draw()
    47                                                     
    48 100.0312 MiB -800060.3125 MiB       62892           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  49.7969 MiB   0.0000 MiB           1       paths = {}
    53  50.5312 MiB   0.0156 MiB           2       for goal in goals:
    54  50.5312 MiB   0.7188 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  50.5469 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 104.2188 MiB 104.2188 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 104.2188 MiB   0.0000 MiB         257       for row in grid:
     8 104.2188 MiB   0.0000 MiB       65792           for spot in row:
     9 104.2188 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 104.2188 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 104.2188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 104.2188 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 104.2188 MiB   0.0000 MiB           1       came_from = {}
    18 108.5000 MiB   4.2812 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 108.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 108.5312 MiB   0.0000 MiB        8581       while not open_set.empty():
    22 108.5312 MiB   0.0000 MiB        8581           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 108.5312 MiB   0.0000 MiB        8581           current = open_set.get()[1]
    28                                         
    29 108.5312 MiB   0.0000 MiB        8581           if current in remaining_goals:
    30 108.5312 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 108.5312 MiB   0.0000 MiB           1               if not remaining_goals:
    32 108.5312 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 108.5312 MiB   0.0000 MiB       76630           for neighbor in current.neighbors:
    35 108.5312 MiB   0.0000 MiB       68050               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 108.5312 MiB   0.0000 MiB       68050               if current.row != neighbor.row and current.col != neighbor.col:
    38 108.5312 MiB   0.0000 MiB       33927                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 108.5312 MiB   0.0000 MiB       68050               if temp_g_score < g_score[neighbor]:
    41 108.5312 MiB   0.0312 MiB        8801                   came_from[neighbor] = current
    42 108.5312 MiB   0.0000 MiB        8801                   g_score[neighbor] = temp_g_score
    43 108.5312 MiB   0.0000 MiB        8801                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 108.5312 MiB   0.0000 MiB        8580           if draw is not None:
    46                                                     draw()
    47                                                     
    48 108.5312 MiB   0.0000 MiB        8580           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 108.5312 MiB   0.0000 MiB           1       paths = {}
    53 108.5312 MiB   0.0000 MiB           2       for goal in goals:
    54 108.5312 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 108.5312 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 108.9375 MiB 108.9375 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 108.9375 MiB   0.0000 MiB         257       for row in grid:
     8 108.9375 MiB   0.0000 MiB       65792           for spot in row:
     9 108.9375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 108.9375 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 108.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 108.9375 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 108.9375 MiB   0.0000 MiB           1       came_from = {}
    18 113.7656 MiB   4.8281 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 113.7656 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 113.7656 MiB -235844.5781 MiB       30164       while not open_set.empty():
    22 113.7656 MiB -235845.0156 MiB       30164           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 113.7656 MiB -235845.8906 MiB       30164           current = open_set.get()[1]
    28                                         
    29 113.7656 MiB -235846.7500 MiB       30164           if current in remaining_goals:
    30  99.5156 MiB -14.2500 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  99.5156 MiB   0.0000 MiB           1               if not remaining_goals:
    32  99.5312 MiB   0.0156 MiB           1                   break  # All goals found
    33                                         
    34 113.7656 MiB -2115518.8906 MiB      270452           for neighbor in current.neighbors:
    35 113.7656 MiB -1879679.8594 MiB      240289               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 113.7656 MiB -1879680.8438 MiB      240289               if current.row != neighbor.row and current.col != neighbor.col:
    38 113.7656 MiB -938692.4375 MiB      119976                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 113.7656 MiB -1879684.4062 MiB      240289               if temp_g_score < g_score[neighbor]:
    41 113.7656 MiB -237065.5625 MiB       30635                   came_from[neighbor] = current
    42 113.7656 MiB -237065.7812 MiB       30635                   g_score[neighbor] = temp_g_score
    43 113.7656 MiB -237066.0938 MiB       30635                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 113.7656 MiB -235843.6562 MiB       30163           if draw is not None:
    46                                                     draw()
    47                                                     
    48 113.7656 MiB -235843.9688 MiB       30163           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  99.5312 MiB   0.0000 MiB           1       paths = {}
    53  99.5469 MiB   0.0000 MiB           2       for goal in goals:
    54  99.5469 MiB   0.0156 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  99.5469 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 103.7031 MiB 103.7031 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 103.7031 MiB -407.7031 MiB         257       for row in grid:
     8 103.7031 MiB -104391.5156 MiB       65792           for spot in row:
     9 103.7031 MiB -103986.5469 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 100.0000 MiB  -3.7031 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 100.0000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 100.0000 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 100.0000 MiB   0.0000 MiB           1       came_from = {}
    18 104.2188 MiB -649.1562 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 104.2188 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 104.2344 MiB -85953.1719 MiB       35089       while not open_set.empty():
    22 104.2344 MiB -85953.3125 MiB       35089           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 104.2344 MiB -85953.6875 MiB       35089           current = open_set.get()[1]
    28                                         
    29 104.2344 MiB -85953.7500 MiB       35089           if current in remaining_goals:
    30  99.2344 MiB  -5.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  99.2344 MiB   0.0000 MiB           1               if not remaining_goals:
    32  99.2344 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 104.2344 MiB -770562.5469 MiB      314713           for neighbor in current.neighbors:
    35 104.2344 MiB -684610.7656 MiB      279625               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 104.2344 MiB -684611.4219 MiB      279625               if current.row != neighbor.row and current.col != neighbor.col:
    38 104.2344 MiB -341811.4531 MiB      139633                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 104.2344 MiB -684612.4688 MiB      279625               if temp_g_score < g_score[neighbor]:
    41 104.2344 MiB -86186.6562 MiB       35556                   came_from[neighbor] = current
    42 104.2344 MiB -86186.9219 MiB       35556                   g_score[neighbor] = temp_g_score
    43 104.2344 MiB -86187.3125 MiB       35556                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 104.2344 MiB -85952.6719 MiB       35088           if draw is not None:
    46                                                     draw()
    47                                                     
    48 104.2344 MiB -85952.9375 MiB       35088           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  99.2344 MiB   0.0000 MiB           1       paths = {}
    53  99.2656 MiB   0.0000 MiB           2       for goal in goals:
    54  99.2656 MiB   0.0312 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  99.2656 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 103.1406 MiB 103.1406 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 103.1406 MiB   0.0000 MiB         257       for row in grid:
     8 103.1406 MiB   0.0000 MiB       65792           for spot in row:
     9 103.1406 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 103.1406 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 103.1562 MiB   0.0156 MiB           1       open_set = PriorityQueue()
    16 103.1562 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 103.1562 MiB   0.0000 MiB           1       came_from = {}
    18 105.6562 MiB -530.8750 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 105.3750 MiB  -0.2812 MiB           1       g_score[start] = 0
    20                                         
    21 105.5156 MiB -946243.5156 MiB       50686       while not open_set.empty():
    22 105.5156 MiB -946244.3125 MiB       50686           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 105.5156 MiB -946246.2188 MiB       50686           current = open_set.get()[1]
    28                                         
    29 105.5156 MiB -946246.9688 MiB       50686           if current in remaining_goals:
    30  83.3594 MiB -22.1562 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  83.3594 MiB   0.0000 MiB           1               if not remaining_goals:
    32  83.3594 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 105.5156 MiB -8478056.7500 MiB      454418           for neighbor in current.neighbors:
    35 105.5156 MiB -7531819.7969 MiB      403733               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 105.5156 MiB -7531823.7188 MiB      403733               if current.row != neighbor.row and current.col != neighbor.col:
    38 105.5156 MiB -3759606.4219 MiB      201576                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 105.5156 MiB -7531829.0312 MiB      403733               if temp_g_score < g_score[neighbor]:
    41 105.5156 MiB -945594.8594 MiB       51061                   came_from[neighbor] = current
    42 105.5156 MiB -945595.5625 MiB       51061                   g_score[neighbor] = temp_g_score
    43 105.5156 MiB -945596.8906 MiB       51061                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 105.5156 MiB -946242.0781 MiB       50685           if draw is not None:
    46                                                     draw()
    47                                                     
    48 105.5156 MiB -946242.8594 MiB       50685           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  83.3594 MiB   0.0000 MiB           1       paths = {}
    53  83.3750 MiB   0.0000 MiB           2       for goal in goals:
    54  83.3750 MiB   0.0156 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  83.3750 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 101.4062 MiB 101.4062 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 101.4062 MiB   0.0000 MiB         257       for row in grid:
     8 101.4062 MiB   0.0000 MiB       65792           for spot in row:
     9 101.4062 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 101.4062 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 101.4062 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 101.4062 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 101.4062 MiB   0.0000 MiB           1       came_from = {}
    18 104.0781 MiB   2.6719 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 104.0781 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 104.3125 MiB -1817154.4375 MiB       44492       while not open_set.empty():
    22 104.3125 MiB -1817155.3438 MiB       44492           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 104.3125 MiB -1817157.4688 MiB       44492           current = open_set.get()[1]
    28                                         
    29 104.3125 MiB -1817158.6094 MiB       44492           if current in remaining_goals:
    30  48.6719 MiB -55.6406 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  48.6719 MiB   0.0000 MiB           1               if not remaining_goals:
    32  48.6719 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 104.3125 MiB -16314726.9688 MiB      399070           for neighbor in current.neighbors:
    35 104.3125 MiB -14497599.3125 MiB      354579               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 104.3125 MiB -14497602.2812 MiB      354579               if current.row != neighbor.row and current.col != neighbor.col:
    38 104.3125 MiB -7242282.9531 MiB      177065                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 104.3125 MiB -14497616.3594 MiB      354579               if temp_g_score < g_score[neighbor]:
    41 104.3125 MiB -1829905.2656 MiB       44995                   came_from[neighbor] = current
    42 104.3125 MiB -1829906.8125 MiB       44995                   g_score[neighbor] = temp_g_score
    43 104.3125 MiB -1829908.3438 MiB       44995                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 104.3125 MiB -1817152.1250 MiB       44491           if draw is not None:
    46                                                     draw()
    47                                                     
    48 104.3125 MiB -1817153.2656 MiB       44491           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  48.6719 MiB   0.0000 MiB           1       paths = {}
    53  48.9375 MiB   0.0156 MiB           2       for goal in goals:
    54  48.9375 MiB   0.2500 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  48.9688 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  98.4062 MiB  98.4062 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  98.4062 MiB   0.0000 MiB         257       for row in grid:
     8  98.4062 MiB   0.0000 MiB       65792           for spot in row:
     9  98.4062 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  98.4062 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  98.4062 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  98.4062 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  98.4062 MiB   0.0000 MiB           1       came_from = {}
    18 100.0781 MiB -50571.1719 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  98.5312 MiB  -1.5469 MiB           1       g_score[start] = 0
    20                                         
    21  99.1094 MiB -175440.7031 MiB       21697       while not open_set.empty():
    22  99.1094 MiB -175441.2656 MiB       21697           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  99.1094 MiB -175441.9844 MiB       21697           current = open_set.get()[1]
    28                                         
    29  99.1094 MiB -175442.5625 MiB       21697           if current in remaining_goals:
    30  88.8438 MiB -10.2656 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  88.8438 MiB   0.0000 MiB           1               if not remaining_goals:
    32  88.8438 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  99.1094 MiB -1574448.9062 MiB      194727           for neighbor in current.neighbors:
    35  99.1094 MiB -1399011.6719 MiB      173031               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  99.1094 MiB -1399013.5312 MiB      173031               if current.row != neighbor.row and current.col != neighbor.col:
    38  99.1094 MiB -698779.2031 MiB       86426                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  99.1094 MiB -1399019.3125 MiB      173031               if temp_g_score < g_score[neighbor]:
    41  99.1094 MiB -178286.7031 MiB       22202                   came_from[neighbor] = current
    42  99.1094 MiB -178287.1094 MiB       22202                   g_score[neighbor] = temp_g_score
    43  99.1094 MiB -178287.8750 MiB       22202                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  99.1094 MiB -175439.8438 MiB       21696           if draw is not None:
    46                                                     draw()
    47                                                     
    48  99.1094 MiB -175440.2500 MiB       21696           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  88.8438 MiB   0.0000 MiB           1       paths = {}
    53  88.8750 MiB   0.0000 MiB           2       for goal in goals:
    54  88.8750 MiB   0.0312 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  88.8906 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  99.1562 MiB  99.1562 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  99.1562 MiB  -1.5312 MiB         257       for row in grid:
     8  99.1562 MiB -392.3125 MiB       65792           for spot in row:
     9  99.1562 MiB -390.7969 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  99.1250 MiB  -0.0312 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  99.1250 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  99.1250 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  99.1250 MiB   0.0000 MiB           1       came_from = {}
    18 103.4531 MiB   4.3281 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19 103.4531 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 103.4531 MiB -143794.0000 MiB       23688       while not open_set.empty():
    22 103.4531 MiB -143794.1406 MiB       23688           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 103.4531 MiB -143794.3906 MiB       23688           current = open_set.get()[1]
    28                                         
    29 103.4531 MiB -143794.6875 MiB       23688           if current in remaining_goals:
    30  89.6406 MiB -13.8125 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  89.6406 MiB   0.0000 MiB           1               if not remaining_goals:
    32  89.6406 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 103.4531 MiB -1285291.8125 MiB      212361           for neighbor in current.neighbors:
    35 103.4531 MiB -1141499.7188 MiB      188674               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 103.4531 MiB -1141500.7344 MiB      188674               if current.row != neighbor.row and current.col != neighbor.col:
    38 103.4531 MiB -569301.4219 MiB       94200                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 103.4531 MiB -1141505.9375 MiB      188674               if temp_g_score < g_score[neighbor]:
    41 103.4531 MiB -143297.1875 MiB       24088                   came_from[neighbor] = current
    42 103.4531 MiB -143299.2188 MiB       24088                   g_score[neighbor] = temp_g_score
    43 103.4531 MiB -143299.3281 MiB       24088                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 103.4531 MiB -143793.7188 MiB       23687           if draw is not None:
    46                                                     draw()
    47                                                     
    48 103.4531 MiB -143793.9688 MiB       23687           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  89.6406 MiB   0.0000 MiB           1       paths = {}
    53  89.6406 MiB   0.0000 MiB           2       for goal in goals:
    54  89.6406 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  89.6406 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  97.1250 MiB  97.1250 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  97.1250 MiB -870.3906 MiB         257       for row in grid:
     8  97.1250 MiB -222676.9844 MiB       65792           for spot in row:
     9  97.1250 MiB -221810.9844 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  90.9688 MiB  -6.1562 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  91.1562 MiB   0.1875 MiB           1       open_set = PriorityQueue()
    16  91.3906 MiB   0.2344 MiB           1       open_set.put((0, start))
    17  91.3906 MiB   0.0000 MiB           1       came_from = {}
    18  96.3750 MiB -1825.8438 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  96.1562 MiB  -0.2188 MiB           1       g_score[start] = 0
    20                                         
    21  96.3438 MiB -985009.8125 MiB       19706       while not open_set.empty():
    22  96.3438 MiB -985010.9219 MiB       19706           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  96.3438 MiB -985017.9688 MiB       19706           current = open_set.get()[1]
    28                                         
    29  96.3438 MiB -985019.9688 MiB       19706           if current in remaining_goals:
    30  34.7969 MiB -61.5469 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  34.7969 MiB   0.0000 MiB           1               if not remaining_goals:
    32  34.7969 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  96.3438 MiB -8825318.5469 MiB      176530           for neighbor in current.neighbors:
    35  96.3438 MiB -7840323.5312 MiB      156825               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  96.3438 MiB -7840330.1094 MiB      156825               if current.row != neighbor.row and current.col != neighbor.col:
    38  96.3438 MiB -3913668.7500 MiB       78277                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  96.3438 MiB -7840348.3125 MiB      156825               if temp_g_score < g_score[neighbor]:
    41  96.3438 MiB -994003.4062 MiB       20071                   came_from[neighbor] = current
    42  96.3438 MiB -994004.6875 MiB       20071                   g_score[neighbor] = temp_g_score
    43  96.3438 MiB -994008.8906 MiB       20071                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  96.3438 MiB -985006.9531 MiB       19705           if draw is not None:
    46                                                     draw()
    47                                                     
    48  96.3438 MiB -985008.4062 MiB       19705           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  34.7969 MiB   0.0000 MiB           1       paths = {}
    53  52.7031 MiB   0.0156 MiB           2       for goal in goals:
    54  52.7031 MiB  17.8906 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  52.7188 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  93.6719 MiB  93.6719 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  93.6719 MiB -47.4688 MiB         257       for row in grid:
     8  93.6719 MiB -12131.5156 MiB       65792           for spot in row:
     9  93.6719 MiB -12084.4531 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  93.2031 MiB  -0.4688 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  93.2031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  93.2031 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  93.2031 MiB   0.0000 MiB           1       came_from = {}
    18  97.9844 MiB   4.7812 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  97.9844 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  98.0000 MiB -1776816.9844 MiB       32734       while not open_set.empty():
    22  98.0000 MiB -1776818.8594 MiB       32734           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  98.0000 MiB -1776821.9375 MiB       32734           current = open_set.get()[1]
    28                                         
    29  98.0000 MiB -1776823.2969 MiB       32734           if current in remaining_goals:
    30  44.6406 MiB -53.3594 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  44.6406 MiB   0.0000 MiB           1               if not remaining_goals:
    32  44.6406 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  98.0000 MiB -15951521.1094 MiB      293871           for neighbor in current.neighbors:
    35  98.0000 MiB -14174723.8438 MiB      261138               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  98.0000 MiB -14174728.6875 MiB      261138               if current.row != neighbor.row and current.col != neighbor.col:
    38  98.0000 MiB -7080814.4062 MiB      130448                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  98.0000 MiB -14174750.7656 MiB      261138               if temp_g_score < g_score[neighbor]:
    41  98.0000 MiB -1798545.4375 MiB       33292                   came_from[neighbor] = current
    42  98.0000 MiB -1798547.0781 MiB       33292                   g_score[neighbor] = temp_g_score
    43  98.0000 MiB -1798549.9375 MiB       33292                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  98.0000 MiB -1776813.4531 MiB       32733           if draw is not None:
    46                                                     draw()
    47                                                     
    48  98.0000 MiB -1776814.9219 MiB       32733           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  44.6406 MiB   0.0000 MiB           1       paths = {}
    53  44.8750 MiB   0.0469 MiB           2       for goal in goals:
    54  44.8438 MiB   0.1875 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  44.8906 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  99.1875 MiB  99.1875 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  99.2031 MiB -1846.7344 MiB         257       for row in grid:
     8  99.2031 MiB -473581.8281 MiB       65792           for spot in row:
     9  99.2031 MiB -471736.6875 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  93.8750 MiB  -5.3281 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  94.0625 MiB   0.1875 MiB           1       open_set = PriorityQueue()
    16  94.2969 MiB   0.2344 MiB           1       open_set.put((0, start))
    17  94.2969 MiB   0.0000 MiB           1       came_from = {}
    18  99.4062 MiB   5.1094 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  99.4062 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  99.5156 MiB -3537766.5938 MiB       63652       while not open_set.empty():
    22  99.5156 MiB -3537768.2344 MiB       63652           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  99.5156 MiB -3537771.0781 MiB       63652           current = open_set.get()[1]
    28                                         
    29  99.5156 MiB -3537772.9219 MiB       63652           if current in remaining_goals:
    30  41.6094 MiB -57.9062 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  41.6094 MiB   0.0000 MiB           1               if not remaining_goals:
    32  41.6094 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  99.5156 MiB -31715165.5000 MiB      570267           for neighbor in current.neighbors:
    35  99.5156 MiB -28177417.1094 MiB      506616               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  99.5156 MiB -28177418.9375 MiB      506616               if current.row != neighbor.row and current.col != neighbor.col:
    38  99.5156 MiB -14068078.1562 MiB      252877                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  99.5156 MiB -28177438.0312 MiB      506616               if temp_g_score < g_score[neighbor]:
    41  99.5156 MiB -3536150.5312 MiB       63808                   came_from[neighbor] = current
    42  99.5156 MiB -3536152.6719 MiB       63808                   g_score[neighbor] = temp_g_score
    43  99.5156 MiB -3536156.0312 MiB       63808                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  99.5156 MiB -3537763.7656 MiB       63651           if draw is not None:
    46                                                     draw()
    47                                                     
    48  99.5156 MiB -3537765.1094 MiB       63651           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  41.6094 MiB   0.0000 MiB           1       paths = {}
    53  41.9062 MiB   0.0156 MiB           2       for goal in goals:
    54  41.9062 MiB   0.2812 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  41.9375 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  92.6406 MiB  92.6406 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  92.6562 MiB   0.0000 MiB         257       for row in grid:
     8  92.6562 MiB   0.0000 MiB       65792           for spot in row:
     9  92.6562 MiB   0.0156 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  92.6562 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  92.6562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  92.6562 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  92.6562 MiB   0.0000 MiB           1       came_from = {}
    18  97.5156 MiB   4.8594 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  97.5156 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  97.7500 MiB -2024798.1719 MiB       58567       while not open_set.empty():
    22  97.7500 MiB -2024799.4375 MiB       58567           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  97.7500 MiB -2024802.8438 MiB       58567           current = open_set.get()[1]
    28                                         
    29  97.7500 MiB -2024804.2188 MiB       58567           if current in remaining_goals:
    30  44.9531 MiB -52.7969 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  44.9531 MiB   0.0000 MiB           1               if not remaining_goals:
    32  44.9531 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  97.7500 MiB -18143733.4688 MiB      525585           for neighbor in current.neighbors:
    35  97.7500 MiB -16118952.0000 MiB      467019               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  97.7500 MiB -16118957.1562 MiB      467019               if current.row != neighbor.row and current.col != neighbor.col:
    38  97.7500 MiB -8046331.0156 MiB      233258                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  97.7500 MiB -16118974.7344 MiB      467019               if temp_g_score < g_score[neighbor]:
    41  97.7500 MiB -2018347.2812 MiB       59082                   came_from[neighbor] = current
    42  97.7500 MiB -2018348.6094 MiB       59082                   g_score[neighbor] = temp_g_score
    43  97.7500 MiB -2018350.9062 MiB       59082                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  97.7500 MiB -2024795.4062 MiB       58566           if draw is not None:
    46                                                     draw()
    47                                                     
    48  97.7500 MiB -2024796.6406 MiB       58566           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  44.9531 MiB   0.0000 MiB           1       paths = {}
    53  45.0938 MiB   0.0156 MiB           2       for goal in goals:
    54  45.0938 MiB   0.1250 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  45.1094 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  92.4062 MiB  92.4062 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  92.4062 MiB -20.7500 MiB         257       for row in grid:
     8  92.4062 MiB -5243.0312 MiB       65792           for spot in row:
     9  92.4062 MiB -5222.5781 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  91.9531 MiB  -0.4531 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  91.9531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  91.9531 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  91.9531 MiB   0.0000 MiB           1       came_from = {}
    18  95.0000 MiB   3.0469 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  95.0000 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  95.3281 MiB -1125065.6719 MiB       64712       while not open_set.empty():
    22  95.3281 MiB -1125066.7500 MiB       64712           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  95.3281 MiB -1125068.7344 MiB       64712           current = open_set.get()[1]
    28                                         
    29  95.3281 MiB -1125069.9375 MiB       64712           if current in remaining_goals:
    30  48.8438 MiB -46.4844 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  48.8438 MiB   0.0000 MiB           1               if not remaining_goals:
    32  48.8438 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  95.3281 MiB -10050786.4531 MiB      579597           for neighbor in current.neighbors:
    35  95.3281 MiB -8925734.3906 MiB      514886               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  95.3281 MiB -8925740.7031 MiB      514886               if current.row != neighbor.row and current.col != neighbor.col:
    38  95.3281 MiB -4450519.6719 MiB      256977                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  95.3281 MiB -8925755.3438 MiB      514886               if temp_g_score < g_score[neighbor]:
    41  95.3281 MiB -1109010.5938 MiB       64798                   came_from[neighbor] = current
    42  95.3281 MiB -1109011.3594 MiB       64798                   g_score[neighbor] = temp_g_score
    43  95.3281 MiB -1109013.2031 MiB       64798                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  95.3281 MiB -1125063.2188 MiB       64711           if draw is not None:
    46                                                     draw()
    47                                                     
    48  95.3281 MiB -1125064.6562 MiB       64711           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  48.8438 MiB   0.0000 MiB           1       paths = {}
    53  48.9844 MiB   0.0156 MiB           2       for goal in goals:
    54  48.9844 MiB   0.1250 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  49.0000 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  90.8281 MiB  90.8281 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  90.8281 MiB -155.6250 MiB         257       for row in grid:
     8  90.8281 MiB -39932.0000 MiB       65792           for spot in row:
     9  90.8281 MiB -39776.9688 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  89.9531 MiB  -0.8750 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  89.9531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  89.9531 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  89.9531 MiB   0.0000 MiB           1       came_from = {}
    18  94.7188 MiB -57.2656 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  94.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  94.8438 MiB -28237.4062 MiB       11737       while not open_set.empty():
    22  94.8438 MiB -28237.4688 MiB       11737           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  94.8438 MiB -28237.9062 MiB       11737           current = open_set.get()[1]
    28                                         
    29  94.8438 MiB -28238.0938 MiB       11737           if current in remaining_goals:
    30  90.9688 MiB  -3.8750 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  90.9688 MiB   0.0000 MiB           1               if not remaining_goals:
    32  90.9688 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  94.8438 MiB -254122.9375 MiB      105624           for neighbor in current.neighbors:
    35  94.8438 MiB -225886.5938 MiB       93888               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  94.8438 MiB -225886.9688 MiB       93888               if current.row != neighbor.row and current.col != neighbor.col:
    38  94.8438 MiB -112946.5000 MiB       46944                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  94.8438 MiB -225887.7812 MiB       93888               if temp_g_score < g_score[neighbor]:
    41  94.8438 MiB -29037.0312 MiB       12255                   came_from[neighbor] = current
    42  94.8438 MiB -29037.2969 MiB       12255                   g_score[neighbor] = temp_g_score
    43  94.8438 MiB -29037.4688 MiB       12255                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  94.8438 MiB -28237.3125 MiB       11736           if draw is not None:
    46                                                     draw()
    47                                                     
    48  94.8438 MiB -28237.3438 MiB       11736           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  90.9688 MiB   0.0000 MiB           1       paths = {}
    53  90.9688 MiB   0.0000 MiB           2       for goal in goals:
    54  90.9688 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  90.9688 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  93.8906 MiB  93.8906 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  93.8906 MiB  -6.6875 MiB         257       for row in grid:
     8  93.8906 MiB -1712.6406 MiB       65792           for spot in row:
     9  93.8906 MiB -1706.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  93.8281 MiB  -0.0625 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  93.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  93.8281 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  93.8281 MiB   0.0000 MiB           1       came_from = {}
    18  97.2344 MiB   3.4062 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  97.2344 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  97.2344 MiB -1436276.4531 MiB       28639       while not open_set.empty():
    22  97.2344 MiB -1436278.0156 MiB       28639           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  97.2344 MiB -1436282.1406 MiB       28639           current = open_set.get()[1]
    28                                         
    29  97.2344 MiB -1436283.2188 MiB       28639           if current in remaining_goals:
    30  47.9375 MiB -49.2969 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  47.9375 MiB   0.0000 MiB           1               if not remaining_goals:
    32  47.9375 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  97.2344 MiB -12901370.5938 MiB      257259           for neighbor in current.neighbors:
    35  97.2344 MiB -11465106.6094 MiB      228621               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  97.2344 MiB -11465121.2344 MiB      228621               if current.row != neighbor.row and current.col != neighbor.col:
    38  97.2344 MiB -5728476.5938 MiB      114230                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  97.2344 MiB -11465134.5469 MiB      228621               if temp_g_score < g_score[neighbor]:
    41  97.2344 MiB -1462066.4531 MiB       29250                   came_from[neighbor] = current
    42  97.2344 MiB -1462067.4375 MiB       29250                   g_score[neighbor] = temp_g_score
    43  97.2344 MiB -1462069.3281 MiB       29250                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  97.2344 MiB -1436272.2656 MiB       28638           if draw is not None:
    46                                                     draw()
    47                                                     
    48  97.2344 MiB -1436274.2500 MiB       28638           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  47.9375 MiB   0.0000 MiB           1       paths = {}
    53  48.0312 MiB   0.0156 MiB           2       for goal in goals:
    54  48.0312 MiB   0.0781 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  48.0469 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  87.1562 MiB  87.1562 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  87.1562 MiB  -7.8438 MiB         257       for row in grid:
     8  87.1562 MiB -2010.1562 MiB       65792           for spot in row:
     9  87.1562 MiB -2002.3125 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  87.1250 MiB  -0.0312 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  87.1250 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  87.1250 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  87.1250 MiB   0.0000 MiB           1       came_from = {}
    18  91.3906 MiB -21882.6562 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  90.3750 MiB  -1.0156 MiB           1       g_score[start] = 0
    20                                         
    21  90.5938 MiB   0.0000 MiB        3623       while not open_set.empty():
    22  90.5938 MiB   0.0000 MiB        3623           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  90.5938 MiB   0.0000 MiB        3623           current = open_set.get()[1]
    28                                         
    29  90.5938 MiB   0.0000 MiB        3623           if current in remaining_goals:
    30  90.5938 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  90.5938 MiB   0.0000 MiB           1               if not remaining_goals:
    32  90.5938 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  90.5938 MiB   0.0000 MiB       32475           for neighbor in current.neighbors:
    35  90.5938 MiB   0.0000 MiB       28853               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  90.5938 MiB   0.0000 MiB       28853               if current.row != neighbor.row and current.col != neighbor.col:
    38  90.5938 MiB   0.0000 MiB       14406                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  90.5938 MiB   0.0000 MiB       28853               if temp_g_score < g_score[neighbor]:
    41  90.5938 MiB   0.2188 MiB        3858                   came_from[neighbor] = current
    42  90.5938 MiB   0.0000 MiB        3858                   g_score[neighbor] = temp_g_score
    43  90.5938 MiB   0.0000 MiB        3858                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  90.5938 MiB   0.0000 MiB        3622           if draw is not None:
    46                                                     draw()
    47                                                     
    48  90.5938 MiB   0.0000 MiB        3622           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  90.5938 MiB   0.0000 MiB           1       paths = {}
    53  90.5938 MiB   0.0000 MiB           2       for goal in goals:
    54  90.5938 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  90.5938 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  91.4688 MiB  91.4688 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  91.4688 MiB   0.0000 MiB         257       for row in grid:
     8  91.4688 MiB   0.0000 MiB       65792           for spot in row:
     9  91.4688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  91.4688 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  91.4688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  91.4688 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  91.4688 MiB   0.0000 MiB           1       came_from = {}
    18  92.2969 MiB -11331.2656 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  92.0781 MiB  -0.2188 MiB           1       g_score[start] = 0
    20                                         
    21  92.1250 MiB -2044544.5625 MiB       51001       while not open_set.empty():
    22  92.1250 MiB -2044545.8594 MiB       51001           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  92.1250 MiB -2044548.7812 MiB       51001           current = open_set.get()[1]
    28                                         
    29  92.1250 MiB -2044550.2031 MiB       51001           if current in remaining_goals:
    30  46.3438 MiB -45.7812 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  46.3438 MiB   0.0000 MiB           1               if not remaining_goals:
    32  46.3438 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  92.1250 MiB -18350009.2500 MiB      457343           for neighbor in current.neighbors:
    35  92.1250 MiB -16305481.1406 MiB      406343               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  92.1250 MiB -16305484.5625 MiB      406343               if current.row != neighbor.row and current.col != neighbor.col:
    38  92.1250 MiB -8144367.7188 MiB      202896                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  92.1250 MiB -16305499.4688 MiB      406343               if temp_g_score < g_score[neighbor]:
    41  92.1250 MiB -2054824.2812 MiB       51450                   came_from[neighbor] = current
    42  92.1250 MiB -2054825.1562 MiB       51450                   g_score[neighbor] = temp_g_score
    43  92.1250 MiB -2054826.8906 MiB       51450                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  92.1250 MiB -2044541.4375 MiB       51000           if draw is not None:
    46                                                     draw()
    47                                                     
    48  92.1250 MiB -2044542.8750 MiB       51000           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  46.3438 MiB   0.0000 MiB           1       paths = {}
    53  46.6250 MiB   0.0156 MiB           2       for goal in goals:
    54  46.6250 MiB   0.2656 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  46.6562 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  88.6875 MiB  88.6875 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  88.6875 MiB   0.0000 MiB         257       for row in grid:
     8  88.6875 MiB   0.0000 MiB       65792           for spot in row:
     9  88.6875 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  88.6875 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  88.6875 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  88.6875 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  88.6875 MiB   0.0000 MiB           1       came_from = {}
    18  93.7031 MiB   5.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  93.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  93.7500 MiB -77375.5156 MiB       26275       while not open_set.empty():
    22  93.7500 MiB -77376.0781 MiB       26275           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  93.7500 MiB -77377.3906 MiB       26275           current = open_set.get()[1]
    28                                         
    29  93.7500 MiB -77377.8750 MiB       26275           if current in remaining_goals:
    30  87.7031 MiB  -6.0469 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  87.7031 MiB   0.0000 MiB           1               if not remaining_goals:
    32  87.7031 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  93.7500 MiB -694591.8750 MiB      236118           for neighbor in current.neighbors:
    35  93.7500 MiB -617218.3125 MiB      209844               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  93.7500 MiB -617218.9219 MiB      209844               if current.row != neighbor.row and current.col != neighbor.col:
    38  93.7500 MiB -308315.6250 MiB      104864                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  93.7500 MiB -617219.6250 MiB      209844               if temp_g_score < g_score[neighbor]:
    41  93.7500 MiB -78190.6094 MiB       26901                   came_from[neighbor] = current
    42  93.7500 MiB -78190.6875 MiB       26901                   g_score[neighbor] = temp_g_score
    43  93.7500 MiB -78190.8750 MiB       26901                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  93.7500 MiB -77374.7969 MiB       26274           if draw is not None:
    46                                                     draw()
    47                                                     
    48  93.7500 MiB -77374.9844 MiB       26274           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  87.7031 MiB   0.0000 MiB           1       paths = {}
    53  87.7031 MiB   0.0000 MiB           2       for goal in goals:
    54  87.7031 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  87.7031 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  97.3438 MiB  97.3438 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  97.3438 MiB -105.1094 MiB         257       for row in grid:
     8  97.3438 MiB -27011.5938 MiB       65792           for spot in row:
     9  97.3438 MiB -26906.7656 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  96.8594 MiB  -0.4844 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  96.8594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  96.8594 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  96.8594 MiB   0.0000 MiB           1       came_from = {}
    18  98.4844 MiB -47358.4844 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  98.4844 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  98.5312 MiB -19326.6250 MiB        9496       while not open_set.empty():
    22  98.5312 MiB -19326.7500 MiB        9496           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  98.5312 MiB -19327.2031 MiB        9496           current = open_set.get()[1]
    28                                         
    29  98.5312 MiB -19327.3125 MiB        9496           if current in remaining_goals:
    30  90.4688 MiB  -8.0625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  90.4688 MiB   0.0000 MiB           1               if not remaining_goals:
    32  90.4688 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  98.5312 MiB -172819.7500 MiB       84805           for neighbor in current.neighbors:
    35  98.5312 MiB -153494.8906 MiB       75310               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  98.5312 MiB -153495.8125 MiB       75310               if current.row != neighbor.row and current.col != neighbor.col:
    38  98.5312 MiB -76576.1250 MiB       37547                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  98.5312 MiB -153497.6406 MiB       75310               if temp_g_score < g_score[neighbor]:
    41  98.5312 MiB -19646.1562 MiB        9726                   came_from[neighbor] = current
    42  98.5312 MiB -19646.5625 MiB        9726                   g_score[neighbor] = temp_g_score
    43  98.5312 MiB -19647.8438 MiB        9726                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  98.5312 MiB -19326.4219 MiB        9495           if draw is not None:
    46                                                     draw()
    47                                                     
    48  98.5312 MiB -19326.5312 MiB        9495           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  90.4688 MiB   0.0000 MiB           1       paths = {}
    53  90.4688 MiB   0.0000 MiB           2       for goal in goals:
    54  90.4688 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  90.4688 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  98.0156 MiB  98.0156 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  98.0156 MiB -1589.6406 MiB         257       for row in grid:
     8  98.0156 MiB -406927.8281 MiB       65792           for spot in row:
     9  98.0156 MiB -405343.7344 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  87.8906 MiB -10.1250 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  88.0625 MiB   0.1719 MiB           1       open_set = PriorityQueue()
    16  88.2969 MiB   0.2344 MiB           1       open_set.put((0, start))
    17  88.2969 MiB   0.0000 MiB           1       came_from = {}
    18  92.7344 MiB -157.1875 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  92.7344 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  92.7500 MiB -1532500.1875 MiB       30593       while not open_set.empty():
    22  92.7500 MiB -1532501.4531 MiB       30593           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  92.7500 MiB -1532504.8594 MiB       30593           current = open_set.get()[1]
    28                                         
    29  92.7500 MiB -1532506.3438 MiB       30593           if current in remaining_goals:
    30  40.2812 MiB -52.4688 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  40.2812 MiB   0.0000 MiB           1               if not remaining_goals:
    32  40.2812 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  92.7500 MiB -13745847.4531 MiB      274208           for neighbor in current.neighbors:
    35  92.7500 MiB -12213365.6562 MiB      243616               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  92.7500 MiB -12213367.1719 MiB      243616               if current.row != neighbor.row and current.col != neighbor.col:
    38  92.7500 MiB -6099042.5781 MiB      121622                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  92.7500 MiB -12213384.5781 MiB      243616               if temp_g_score < g_score[neighbor]:
    41  92.7500 MiB -1546325.9375 MiB       31031                   came_from[neighbor] = current
    42  92.7500 MiB -1546327.1250 MiB       31031                   g_score[neighbor] = temp_g_score
    43  92.7500 MiB -1546329.3906 MiB       31031                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  92.7500 MiB -1532495.5781 MiB       30592           if draw is not None:
    46                                                     draw()
    47                                                     
    48  92.7500 MiB -1532497.4062 MiB       30592           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  40.2812 MiB   0.0000 MiB           1       paths = {}
    53  40.4375 MiB   0.0156 MiB           2       for goal in goals:
    54  40.4375 MiB   0.1406 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  40.4531 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  90.7969 MiB  90.7969 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  90.7969 MiB   0.0000 MiB         257       for row in grid:
     8  90.7969 MiB   0.0000 MiB       65792           for spot in row:
     9  90.7969 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  90.7969 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  90.8125 MiB   0.0156 MiB           1       open_set = PriorityQueue()
    16  90.8125 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  90.8125 MiB   0.0000 MiB           1       came_from = {}
    18  96.9375 MiB   6.1250 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  96.9375 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  97.1719 MiB -508787.7188 MiB       23778       while not open_set.empty():
    22  97.1719 MiB -508789.5156 MiB       23778           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  97.1719 MiB -508793.0781 MiB       23778           current = open_set.get()[1]
    28                                         
    29  97.1719 MiB -508794.6875 MiB       23778           if current in remaining_goals:
    30  46.4844 MiB -50.6875 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  46.4844 MiB   0.0000 MiB           1               if not remaining_goals:
    32  46.4844 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  97.1719 MiB -4563818.6875 MiB      213196           for neighbor in current.neighbors:
    35  97.1719 MiB -4055046.6250 MiB      189419               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  97.1719 MiB -4055058.2188 MiB      189419               if current.row != neighbor.row and current.col != neighbor.col:
    38  97.1719 MiB -2025072.5312 MiB       94577                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  97.1719 MiB -4055075.2344 MiB      189419               if temp_g_score < g_score[neighbor]:
    41  97.1719 MiB -512768.9844 MiB       24245                   came_from[neighbor] = current
    42  97.1719 MiB -512770.2969 MiB       24245                   g_score[neighbor] = temp_g_score
    43  97.1719 MiB -512772.0000 MiB       24245                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  97.1719 MiB -508784.7031 MiB       23777           if draw is not None:
    46                                                     draw()
    47                                                     
    48  97.1719 MiB -508785.9531 MiB       23777           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  46.4844 MiB   0.0000 MiB           1       paths = {}
    53  46.5469 MiB   0.0156 MiB           2       for goal in goals:
    54  46.5469 MiB   0.0469 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  46.5625 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  89.2188 MiB  89.2188 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  89.2188 MiB -375.5469 MiB         257       for row in grid:
     8  89.2188 MiB -96026.4375 MiB       65792           for spot in row:
     9  89.2188 MiB -95653.9375 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  85.6094 MiB  -3.6094 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  85.6094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  85.6094 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  85.6094 MiB   0.0000 MiB           1       came_from = {}
    18  90.6875 MiB -3381.6562 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  90.2969 MiB  -0.3906 MiB           1       g_score[start] = 0
    20                                         
    21  90.7031 MiB -1614258.8438 MiB       57913       while not open_set.empty():
    22  90.7031 MiB -1614259.5938 MiB       57913           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  90.7031 MiB -1614261.7969 MiB       57913           current = open_set.get()[1]
    28                                         
    29  90.7031 MiB -1614262.9844 MiB       57913           if current in remaining_goals:
    30  49.5625 MiB -41.1406 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  49.5625 MiB   0.0000 MiB           1               if not remaining_goals:
    32  49.5625 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  90.7031 MiB -14460799.2188 MiB      519236           for neighbor in current.neighbors:
    35  90.7031 MiB -12846552.6562 MiB      461324               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  90.7031 MiB -12846557.8750 MiB      461324               if current.row != neighbor.row and current.col != neighbor.col:
    38  90.7031 MiB -6412133.3125 MiB      230334                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  90.7031 MiB -12846574.6875 MiB      461324               if temp_g_score < g_score[neighbor]:
    41  90.7031 MiB -1608340.3281 MiB       58269                   came_from[neighbor] = current
    42  90.7031 MiB -1608341.9062 MiB       58269                   g_score[neighbor] = temp_g_score
    43  90.7031 MiB -1608343.7031 MiB       58269                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  90.7031 MiB -1614256.8125 MiB       57912           if draw is not None:
    46                                                     draw()
    47                                                     
    48  90.7031 MiB -1614257.9688 MiB       57912           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  49.5625 MiB   0.0000 MiB           1       paths = {}
    53  49.7031 MiB   0.0156 MiB           2       for goal in goals:
    54  49.7031 MiB   0.1250 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  49.7344 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  92.0781 MiB  92.0781 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  92.0938 MiB -274.2500 MiB         257       for row in grid:
     8  92.0938 MiB -70263.0938 MiB       65792           for spot in row:
     9  92.0938 MiB -69989.8750 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  90.3281 MiB  -1.7656 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  90.3281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  90.3281 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  90.3281 MiB   0.0000 MiB           1       came_from = {}
    18  92.2812 MiB -17855.3750 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  89.8125 MiB  -2.4688 MiB           1       g_score[start] = 0
    20                                         
    21  89.9531 MiB -1223198.0469 MiB       22180       while not open_set.empty():
    22  89.9531 MiB -1223199.4219 MiB       22180           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  89.9531 MiB -1223201.9531 MiB       22180           current = open_set.get()[1]
    28                                         
    29  89.9531 MiB -1223202.8906 MiB       22180           if current in remaining_goals:
    30  31.8906 MiB -58.0625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  31.8906 MiB   0.0000 MiB           1               if not remaining_goals:
    32  31.8906 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  89.9531 MiB -10962332.4688 MiB      198703           for neighbor in current.neighbors:
    35  89.9531 MiB -9739150.2812 MiB      176524               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  89.9531 MiB -9739154.2500 MiB      176524               if current.row != neighbor.row and current.col != neighbor.col:
    38  89.9531 MiB -4861950.8750 MiB       88111                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  89.9531 MiB -9739169.3750 MiB      176524               if temp_g_score < g_score[neighbor]:
    41  89.9531 MiB -1235292.6875 MiB       22554                   came_from[neighbor] = current
    42  89.9531 MiB -1235293.7656 MiB       22554                   g_score[neighbor] = temp_g_score
    43  89.9531 MiB -1235295.8906 MiB       22554                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  89.9531 MiB -1223193.7344 MiB       22179           if draw is not None:
    46                                                     draw()
    47                                                     
    48  89.9531 MiB -1223196.0625 MiB       22179           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  31.8906 MiB   0.0000 MiB           1       paths = {}
    53  32.0156 MiB   0.0156 MiB           2       for goal in goals:
    54  32.0156 MiB   0.1094 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  32.0469 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  87.9062 MiB  87.9062 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  87.9062 MiB -30.1719 MiB         257       for row in grid:
     8  87.9062 MiB -7563.8906 MiB       65792           for spot in row:
     9  87.9062 MiB -7534.7188 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  86.5156 MiB  -1.3906 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  86.5156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  86.5156 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  86.5156 MiB   0.0000 MiB           1       came_from = {}
    18  86.7969 MiB -175035.3438 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  83.6562 MiB  -3.1406 MiB           1       g_score[start] = 0
    20                                         
    21  83.7500 MiB -10067.6875 MiB        3743       while not open_set.empty():
    22  83.7500 MiB -10067.7344 MiB        3743           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  83.7500 MiB -10067.8750 MiB        3743           current = open_set.get()[1]
    28                                         
    29  83.7500 MiB -10068.0312 MiB        3743           if current in remaining_goals:
    30  80.2656 MiB  -3.4844 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  80.2656 MiB   0.0000 MiB           1               if not remaining_goals:
    32  80.2656 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  83.7500 MiB -89661.1406 MiB       33295           for neighbor in current.neighbors:
    35  83.7500 MiB -79594.4062 MiB       29553               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  83.7500 MiB -79594.7969 MiB       29553               if current.row != neighbor.row and current.col != neighbor.col:
    38  83.7500 MiB -39646.4531 MiB       14713                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  83.7500 MiB -79595.4688 MiB       29553               if temp_g_score < g_score[neighbor]:
    41  83.7500 MiB -10332.0000 MiB        3890                   came_from[neighbor] = current
    42  83.7500 MiB -10332.1250 MiB        3890                   g_score[neighbor] = temp_g_score
    43  83.7500 MiB -10332.2188 MiB        3890                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  83.7500 MiB -10067.6719 MiB        3742           if draw is not None:
    46                                                     draw()
    47                                                     
    48  83.7500 MiB -10067.6719 MiB        3742           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  80.2656 MiB   0.0000 MiB           1       paths = {}
    53  80.2656 MiB   0.0000 MiB           2       for goal in goals:
    54  80.2656 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  80.2656 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  88.8906 MiB  88.8906 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  88.8906 MiB -106.3438 MiB         257       for row in grid:
     8  88.8906 MiB -27174.5625 MiB       65792           for spot in row:
     9  88.8906 MiB -27069.3125 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  87.6094 MiB  -1.2812 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  87.6094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  87.6094 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  87.6094 MiB   0.0000 MiB           1       came_from = {}
    18  92.0781 MiB   4.4688 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  92.0781 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  92.4688 MiB -1720856.2344 MiB       51458       while not open_set.empty():
    22  92.4688 MiB -1720857.1562 MiB       51458           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  92.4688 MiB -1720860.2656 MiB       51458           current = open_set.get()[1]
    28                                         
    29  92.4688 MiB -1720861.8906 MiB       51458           if current in remaining_goals:
    30  38.9844 MiB -53.4844 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  38.9844 MiB   0.0000 MiB           1               if not remaining_goals:
    32  38.9844 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  92.4688 MiB -15443999.8438 MiB      461486           for neighbor in current.neighbors:
    35  92.4688 MiB -13723162.3438 MiB      410029               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  92.4688 MiB -13723166.1406 MiB      410029               if current.row != neighbor.row and current.col != neighbor.col:
    38  92.4688 MiB -6854398.5938 MiB      204744                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  92.4688 MiB -13723181.4688 MiB      410029               if temp_g_score < g_score[neighbor]:
    41  92.4688 MiB -1728268.6250 MiB       51923                   came_from[neighbor] = current
    42  92.4688 MiB -1728269.9688 MiB       51923                   g_score[neighbor] = temp_g_score
    43  92.4688 MiB -1728271.6406 MiB       51923                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  92.4688 MiB -1720852.4531 MiB       51457           if draw is not None:
    46                                                     draw()
    47                                                     
    48  92.4688 MiB -1720854.6250 MiB       51457           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  38.9844 MiB   0.0000 MiB           1       paths = {}
    53  39.2812 MiB   0.0156 MiB           2       for goal in goals:
    54  39.2812 MiB   0.2812 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  39.3125 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  87.1250 MiB  87.1250 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  87.1250 MiB -474.7969 MiB         257       for row in grid:
     8  87.1250 MiB -121257.7969 MiB       65792           for spot in row:
     9  87.1250 MiB -120786.1094 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  81.9531 MiB  -5.1719 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  81.9531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  81.9531 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  81.9531 MiB   0.0000 MiB           1       came_from = {}
    18  86.3594 MiB -4305.5938 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  86.1719 MiB  -0.1875 MiB           1       g_score[start] = 0
    20                                         
    21  86.2344 MiB -2108025.1250 MiB       60247       while not open_set.empty():
    22  86.2344 MiB -2108029.4219 MiB       60247           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  86.2344 MiB -2108032.7969 MiB       60247           current = open_set.get()[1]
    28                                         
    29  86.2344 MiB -2108034.2031 MiB       60247           if current in remaining_goals:
    30  35.8125 MiB -50.4219 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  35.8125 MiB   0.0000 MiB           1               if not remaining_goals:
    32  35.8125 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  86.2344 MiB -18891965.6250 MiB      539949           for neighbor in current.neighbors:
    35  86.2344 MiB -16783965.8438 MiB      479703               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  86.2344 MiB -16783969.0000 MiB      479703               if current.row != neighbor.row and current.col != neighbor.col:
    38  86.2344 MiB -8378704.8594 MiB      239475                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  86.2344 MiB -16783984.6875 MiB      479703               if temp_g_score < g_score[neighbor]:
    41  86.2344 MiB -2105151.0469 MiB       60512                   came_from[neighbor] = current
    42  86.2344 MiB -2105152.5312 MiB       60512                   g_score[neighbor] = temp_g_score
    43  86.2344 MiB -2105156.0625 MiB       60512                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  86.2344 MiB -2108016.4375 MiB       60246           if draw is not None:
    46                                                     draw()
    47                                                     
    48  86.2344 MiB -2108018.7188 MiB       60246           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  35.8125 MiB   0.0000 MiB           1       paths = {}
    53  36.3125 MiB   0.0156 MiB           2       for goal in goals:
    54  36.3125 MiB   0.4844 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  36.3438 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  86.0625 MiB  86.0625 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  86.0625 MiB -464.6250 MiB         257       for row in grid:
     8  86.0625 MiB -119278.2344 MiB       65792           for spot in row:
     9  86.0625 MiB -118816.4219 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  82.3750 MiB  -3.6875 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  82.3750 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  82.3750 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  82.3750 MiB   0.0000 MiB           1       came_from = {}
    18  88.0000 MiB   5.6250 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  88.0000 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  88.1250 MiB -3073538.7344 MiB       60544       while not open_set.empty():
    22  88.1250 MiB -3073540.7188 MiB       60544           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  88.1250 MiB -3073544.3906 MiB       60544           current = open_set.get()[1]
    28                                         
    29  88.1250 MiB -3073546.3594 MiB       60544           if current in remaining_goals:
    30  37.1719 MiB -50.9531 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  37.1719 MiB   0.0000 MiB           1               if not remaining_goals:
    32  37.1719 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  88.1250 MiB -27545962.5312 MiB      542714           for neighbor in current.neighbors:
    35  88.1250 MiB -24472448.1406 MiB      482171               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  88.1250 MiB -24472439.6094 MiB      482171               if current.row != neighbor.row and current.col != neighbor.col:
    38  88.1250 MiB -12217027.7656 MiB      240724                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  88.1250 MiB -24472458.6562 MiB      482171               if temp_g_score < g_score[neighbor]:
    41  88.1250 MiB -3077355.0625 MiB       60839                   came_from[neighbor] = current
    42  88.1250 MiB -3077357.0781 MiB       60839                   g_score[neighbor] = temp_g_score
    43  88.1250 MiB -3077361.3906 MiB       60839                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  88.1250 MiB -3073531.3594 MiB       60543           if draw is not None:
    46                                                     draw()
    47                                                     
    48  88.1250 MiB -3073533.8750 MiB       60543           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  37.1719 MiB   0.0000 MiB           1       paths = {}
    53  37.4688 MiB   0.0156 MiB           2       for goal in goals:
    54  37.4688 MiB   0.2812 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  37.4844 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  92.4062 MiB  92.4062 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  92.4062 MiB -381.7969 MiB         257       for row in grid:
     8  92.4062 MiB -97880.0938 MiB       65792           for spot in row:
     9  92.4062 MiB -97499.9062 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  90.5938 MiB  -1.8125 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  90.5938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  90.5938 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  90.5938 MiB   0.0000 MiB           1       came_from = {}
    18  95.4688 MiB   4.8750 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  95.4688 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  95.5781 MiB -2604483.6094 MiB       58553       while not open_set.empty():
    22  95.5781 MiB -2604485.5781 MiB       58553           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  95.5781 MiB -2604489.0000 MiB       58553           current = open_set.get()[1]
    28                                         
    29  95.5781 MiB -2604490.0469 MiB       58553           if current in remaining_goals:
    30  35.9375 MiB -59.6406 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  35.9375 MiB   0.0000 MiB           1               if not remaining_goals:
    32  35.9375 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  95.5781 MiB -23335035.0625 MiB      525056           for neighbor in current.neighbors:
    35  95.5781 MiB -20730572.5469 MiB      466504               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  95.5781 MiB -20730578.5781 MiB      466504               if current.row != neighbor.row and current.col != neighbor.col:
    38  95.5781 MiB -10347894.2344 MiB      232934                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  95.5781 MiB -20730597.6875 MiB      466504               if temp_g_score < g_score[neighbor]:
    41  95.5781 MiB -2596275.9219 MiB       58935                   came_from[neighbor] = current
    42  95.5781 MiB -2596277.0156 MiB       58935                   g_score[neighbor] = temp_g_score
    43  95.5781 MiB -2596280.4688 MiB       58935                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  95.5781 MiB -2604481.0469 MiB       58552           if draw is not None:
    46                                                     draw()
    47                                                     
    48  95.5781 MiB -2604482.0469 MiB       58552           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  35.9375 MiB   0.0000 MiB           1       paths = {}
    53  36.1562 MiB   0.0156 MiB           2       for goal in goals:
    54  36.1562 MiB   0.2031 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  36.1875 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  88.1406 MiB  88.1406 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  88.1406 MiB -1212.0156 MiB         257       for row in grid:
     8  88.1406 MiB -310094.7812 MiB       65792           for spot in row:
     9  88.1406 MiB -308889.3281 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  78.5000 MiB  -9.6406 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  78.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  78.5000 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  78.5000 MiB   0.0000 MiB           1       came_from = {}
    18  79.7031 MiB -1800868.0625 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  37.6875 MiB -42.0156 MiB           1       g_score[start] = 0
    20                                         
    21  52.7188 MiB -24973.3281 MiB       56416       while not open_set.empty():
    22  52.7188 MiB -24973.4688 MiB       56416           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  52.7188 MiB -24974.0312 MiB       56416           current = open_set.get()[1]
    28                                         
    29  52.7188 MiB -24974.2031 MiB       56416           if current in remaining_goals:
    30  50.8281 MiB  -1.8906 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  50.8281 MiB   0.0000 MiB           1               if not remaining_goals:
    32  50.8281 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  52.7188 MiB -224290.7500 MiB      506394           for neighbor in current.neighbors:
    35  52.7188 MiB -199327.4375 MiB      449979               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  52.7188 MiB -199319.5938 MiB      449979               if current.row != neighbor.row and current.col != neighbor.col:
    38  52.7188 MiB -99592.6250 MiB      224766                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  52.7188 MiB -199327.6719 MiB      449979               if temp_g_score < g_score[neighbor]:
    41  52.7188 MiB -25269.1406 MiB       56983                   came_from[neighbor] = current
    42  52.7188 MiB -25272.2500 MiB       56983                   g_score[neighbor] = temp_g_score
    43  52.7188 MiB -25272.3438 MiB       56983                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  52.7188 MiB -24972.5781 MiB       56415           if draw is not None:
    46                                                     draw()
    47                                                     
    48  52.7188 MiB -24973.2500 MiB       56415           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  50.8281 MiB   0.0000 MiB           1       paths = {}
    53  51.0000 MiB   0.0156 MiB           2       for goal in goals:
    54  51.0000 MiB   0.1562 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  51.0156 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  90.9531 MiB  90.9531 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  90.9531 MiB  -3.1250 MiB         257       for row in grid:
     8  90.9531 MiB -799.6719 MiB       65792           for spot in row:
     9  90.9531 MiB -796.5625 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  90.9375 MiB  -0.0156 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  90.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  90.9375 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  90.9375 MiB   0.0000 MiB           1       came_from = {}
    18  95.1406 MiB   4.2031 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  95.1406 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  95.4844 MiB -217188.1719 MiB       41382       while not open_set.empty():
    22  95.4844 MiB -217188.2500 MiB       41382           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  95.4844 MiB -217188.3750 MiB       41382           current = open_set.get()[1]
    28                                         
    29  95.4844 MiB -217188.3750 MiB       41382           if current in remaining_goals:
    30  87.2500 MiB  -8.2344 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  87.2500 MiB   0.0000 MiB           1               if not remaining_goals:
    32  87.2500 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  95.4844 MiB -1949837.2812 MiB      371098           for neighbor in current.neighbors:
    35  95.4844 MiB -1732652.7031 MiB      329717               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  95.4844 MiB -1732652.4219 MiB      329717               if current.row != neighbor.row and current.col != neighbor.col:
    38  95.4844 MiB -865540.2031 MiB      164637                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  95.4844 MiB -1732655.5625 MiB      329717               if temp_g_score < g_score[neighbor]:
    41  95.4844 MiB -218768.8281 MiB       41865                   came_from[neighbor] = current
    42  95.4844 MiB -218769.7031 MiB       41865                   g_score[neighbor] = temp_g_score
    43  95.4844 MiB -218769.8125 MiB       41865                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  95.4844 MiB -217188.1406 MiB       41381           if draw is not None:
    46                                                     draw()
    47                                                     
    48  95.4844 MiB -217188.1562 MiB       41381           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  87.2500 MiB   0.0000 MiB           1       paths = {}
    53  87.2500 MiB   0.0000 MiB           2       for goal in goals:
    54  87.2500 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  87.2500 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  94.8594 MiB  94.8594 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  94.8594 MiB  -1.2500 MiB         257       for row in grid:
     8  94.8594 MiB -318.0469 MiB       65792           for spot in row:
     9  94.8594 MiB -316.7969 MiB       65536               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  94.7812 MiB  -0.0781 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  94.7812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  94.7812 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  94.7812 MiB   0.0000 MiB           1       came_from = {}
    18  97.3594 MiB -222.7031 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    19  97.3594 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  97.6094 MiB -1184017.9375 MiB       34061       while not open_set.empty():
    22  97.6094 MiB -1184018.4062 MiB       34061           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  97.6094 MiB -1184019.9375 MiB       34061           current = open_set.get()[1]
    28                                         
    29  97.6094 MiB -1184021.3438 MiB       34061           if current in remaining_goals:
    30  43.1875 MiB -54.4219 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  43.1875 MiB   0.0000 MiB           1               if not remaining_goals:
    32  43.1875 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  97.6094 MiB -10629064.4375 MiB      306045           for neighbor in current.neighbors:
    35  97.6094 MiB -9445063.2500 MiB      271985               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  97.6094 MiB -9445073.4844 MiB      271985               if current.row != neighbor.row and current.col != neighbor.col:
    38  97.6094 MiB -4718105.0625 MiB      135910                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  97.6094 MiB -9445090.4844 MiB      271985               if temp_g_score < g_score[neighbor]:
    41  97.6094 MiB -1192269.4688 MiB       34736                   came_from[neighbor] = current
    42  97.6094 MiB -1192270.2188 MiB       34736                   g_score[neighbor] = temp_g_score
    43  97.6094 MiB -1192271.1406 MiB       34736                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  97.6094 MiB -1184015.9844 MiB       34060           if draw is not None:
    46                                                     draw()
    47                                                     
    48  97.6094 MiB -1184016.7500 MiB       34060           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  43.1875 MiB   0.0000 MiB           1       paths = {}
    53  43.2344 MiB   0.0156 MiB           2       for goal in goals:
    54  43.2344 MiB   0.0312 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  43.2656 MiB   0.0312 MiB           1       return paths


