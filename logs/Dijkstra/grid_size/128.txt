Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  51.5469 MiB  51.5469 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  52.5625 MiB   0.0000 MiB         129       for row in grid:
     8  52.5625 MiB   0.0625 MiB       16512           for spot in row:
     9  52.5625 MiB   0.9531 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  52.5625 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  52.5625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  52.5625 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  52.5781 MiB   0.0156 MiB           1       came_from = {}
    18  54.1250 MiB   1.5469 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  54.1250 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  54.1250 MiB   0.0000 MiB         882       while not open_set.empty():
    22  54.1250 MiB   0.0000 MiB         882           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  54.1250 MiB   0.0000 MiB         882           current = open_set.get()[1]
    28                                         
    29  54.1250 MiB   0.0000 MiB         882           if current in remaining_goals:
    30  54.1250 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  54.1250 MiB   0.0000 MiB           1               if not remaining_goals:
    32  54.1250 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  54.1250 MiB   0.0000 MiB        7824           for neighbor in current.neighbors:
    35  54.1250 MiB   0.0000 MiB        6943               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  54.1250 MiB   0.0000 MiB        6943               if current.row != neighbor.row and current.col != neighbor.col:
    38  54.1250 MiB   0.0000 MiB        3454                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  54.1250 MiB   0.0000 MiB        6943               if temp_g_score < g_score[neighbor]:
    41  54.1250 MiB   0.0000 MiB         985                   came_from[neighbor] = current
    42  54.1250 MiB   0.0000 MiB         985                   g_score[neighbor] = temp_g_score
    43  54.1250 MiB   0.0000 MiB         985                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  54.1250 MiB   0.0000 MiB         881           if draw is not None:
    46                                                     draw()
    47                                                     
    48  54.1250 MiB   0.0000 MiB         881           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  54.1250 MiB   0.0000 MiB           1       paths = {}
    53  54.1250 MiB   0.0000 MiB           2       for goal in goals:
    54  54.1250 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  54.1250 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  58.6406 MiB  58.6406 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  59.6250 MiB   0.0000 MiB         129       for row in grid:
     8  59.6250 MiB   0.0000 MiB       16512           for spot in row:
     9  59.6250 MiB   0.9844 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  59.6250 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  59.6250 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  59.6250 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  59.6250 MiB   0.0000 MiB           1       came_from = {}
    18  60.7031 MiB   1.0781 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  60.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  60.7031 MiB   0.0000 MiB        1401       while not open_set.empty():
    22  60.7031 MiB   0.0000 MiB        1401           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  60.7031 MiB   0.0000 MiB        1401           current = open_set.get()[1]
    28                                         
    29  60.7031 MiB   0.0000 MiB        1401           if current in remaining_goals:
    30  60.7031 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  60.7031 MiB   0.0000 MiB           1               if not remaining_goals:
    32  60.7031 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  60.7031 MiB   0.0000 MiB       12600           for neighbor in current.neighbors:
    35  60.7031 MiB   0.0000 MiB       11200               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  60.7031 MiB   0.0000 MiB       11200               if current.row != neighbor.row and current.col != neighbor.col:
    38  60.7031 MiB   0.0000 MiB        5600                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  60.7031 MiB   0.0000 MiB       11200               if temp_g_score < g_score[neighbor]:
    41  60.7031 MiB   0.0000 MiB        1583                   came_from[neighbor] = current
    42  60.7031 MiB   0.0000 MiB        1583                   g_score[neighbor] = temp_g_score
    43  60.7031 MiB   0.0000 MiB        1583                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  60.7031 MiB   0.0000 MiB        1400           if draw is not None:
    46                                                     draw()
    47                                                     
    48  60.7031 MiB   0.0000 MiB        1400           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  60.7031 MiB   0.0000 MiB           1       paths = {}
    53  60.7031 MiB   0.0000 MiB           2       for goal in goals:
    54  60.7031 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  60.7031 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  62.4375 MiB  62.4375 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  62.4375 MiB   0.0000 MiB         129       for row in grid:
     8  62.4375 MiB   0.0000 MiB       16512           for spot in row:
     9  62.4375 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  62.4375 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  62.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  62.4375 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  62.4375 MiB   0.0000 MiB           1       came_from = {}
    18  62.7500 MiB   0.3125 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  62.7500 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  63.3906 MiB   0.0000 MiB       13130       while not open_set.empty():
    22  63.3906 MiB   0.0000 MiB       13130           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  63.3906 MiB   0.0000 MiB       13130           current = open_set.get()[1]
    28                                         
    29  63.3906 MiB   0.0000 MiB       13130           if current in remaining_goals:
    30  63.3906 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.3906 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.3906 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  63.3906 MiB   0.0000 MiB      117517           for neighbor in current.neighbors:
    35  63.3906 MiB   0.0000 MiB      104388               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  63.3906 MiB   0.0000 MiB      104388               if current.row != neighbor.row and current.col != neighbor.col:
    38  63.3906 MiB   0.0000 MiB       52087                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  63.3906 MiB   0.0000 MiB      104388               if temp_g_score < g_score[neighbor]:
    41  63.3906 MiB   0.6406 MiB       13416                   came_from[neighbor] = current
    42  63.3906 MiB   0.0000 MiB       13416                   g_score[neighbor] = temp_g_score
    43  63.3906 MiB   0.0000 MiB       13416                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  63.3906 MiB   0.0000 MiB       13129           if draw is not None:
    46                                                     draw()
    47                                                     
    48  63.3906 MiB   0.0000 MiB       13129           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.3906 MiB   0.0000 MiB           1       paths = {}
    53  63.3906 MiB   0.0000 MiB           2       for goal in goals:
    54  63.3906 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.3906 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  66.2812 MiB  66.2812 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  67.2812 MiB   0.0000 MiB         129       for row in grid:
     8  67.2812 MiB   0.0000 MiB       16512           for spot in row:
     9  67.2812 MiB   1.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  67.2812 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  67.2812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  67.2812 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  67.2812 MiB   0.0000 MiB           1       came_from = {}
    18  68.3594 MiB   1.0781 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  68.3594 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  68.3594 MiB   0.0000 MiB        3134       while not open_set.empty():
    22  68.3594 MiB   0.0000 MiB        3134           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  68.3594 MiB   0.0000 MiB        3134           current = open_set.get()[1]
    28                                         
    29  68.3594 MiB   0.0000 MiB        3134           if current in remaining_goals:
    30  68.3594 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  68.3594 MiB   0.0000 MiB           1               if not remaining_goals:
    32  68.3594 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  68.3594 MiB   0.0000 MiB       28197           for neighbor in current.neighbors:
    35  68.3594 MiB   0.0000 MiB       25064               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  68.3594 MiB   0.0000 MiB       25064               if current.row != neighbor.row and current.col != neighbor.col:
    38  68.3594 MiB   0.0000 MiB       12532                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  68.3594 MiB   0.0000 MiB       25064               if temp_g_score < g_score[neighbor]:
    41  68.3594 MiB   0.0000 MiB        3404                   came_from[neighbor] = current
    42  68.3594 MiB   0.0000 MiB        3404                   g_score[neighbor] = temp_g_score
    43  68.3594 MiB   0.0000 MiB        3404                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  68.3594 MiB   0.0000 MiB        3133           if draw is not None:
    46                                                     draw()
    47                                                     
    48  68.3594 MiB   0.0000 MiB        3133           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  68.3594 MiB   0.0000 MiB           1       paths = {}
    53  68.3594 MiB   0.0000 MiB           2       for goal in goals:
    54  68.3594 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  68.3594 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.9375 MiB  63.9375 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.9375 MiB   0.0000 MiB         129       for row in grid:
     8  63.9375 MiB   0.0000 MiB       16512           for spot in row:
     9  63.9375 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.9375 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.9375 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.9375 MiB   0.0000 MiB           1       came_from = {}
    18  64.2500 MiB   0.3125 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.2500 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.5469 MiB -860.9375 MiB       11258       while not open_set.empty():
    22  64.5469 MiB -860.9375 MiB       11258           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.5469 MiB -860.9375 MiB       11258           current = open_set.get()[1]
    28                                         
    29  64.5469 MiB -860.9375 MiB       11258           if current in remaining_goals:
    30  64.3594 MiB  -0.1875 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  64.3594 MiB   0.0000 MiB           1               if not remaining_goals:
    32  64.3594 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.5469 MiB -7714.5156 MiB      100624           for neighbor in current.neighbors:
    35  64.5469 MiB -6853.6875 MiB       89367               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.5469 MiB -6853.7344 MiB       89367               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.5469 MiB -3421.5000 MiB       44569                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.5469 MiB -6853.7656 MiB       89367               if temp_g_score < g_score[neighbor]:
    41  64.5469 MiB -870.5938 MiB       11509                   came_from[neighbor] = current
    42  64.5469 MiB -870.8906 MiB       11509                   g_score[neighbor] = temp_g_score
    43  64.5469 MiB -870.9062 MiB       11509                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.5469 MiB -860.8281 MiB       11257           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.5469 MiB -860.8750 MiB       11257           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  64.3594 MiB   0.0000 MiB           1       paths = {}
    53  64.3594 MiB   0.0000 MiB           2       for goal in goals:
    54  64.3594 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  64.3594 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  64.4531 MiB  64.4531 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  64.4531 MiB   0.0000 MiB         129       for row in grid:
     8  64.4531 MiB   0.0000 MiB       16512           for spot in row:
     9  64.4531 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  64.4531 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  64.4531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  64.4531 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  64.4531 MiB   0.0000 MiB           1       came_from = {}
    18  64.7656 MiB   0.3125 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.7656 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.7812 MiB -1695.7500 MiB       10472       while not open_set.empty():
    22  64.7812 MiB -1695.7500 MiB       10472           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.7812 MiB -1695.7500 MiB       10472           current = open_set.get()[1]
    28                                         
    29  64.7812 MiB -1695.7500 MiB       10472           if current in remaining_goals:
    30  64.5938 MiB  -0.1875 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  64.5938 MiB   0.0000 MiB           1               if not remaining_goals:
    32  64.5938 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.7812 MiB -15154.4375 MiB       93512           for neighbor in current.neighbors:
    35  64.7812 MiB -13458.7812 MiB       83041               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.7812 MiB -13458.7969 MiB       83041               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.7812 MiB -6712.1250 MiB       41400                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.7812 MiB -13458.7969 MiB       83041               if temp_g_score < g_score[neighbor]:
    41  64.7812 MiB -1709.9844 MiB       10677                   came_from[neighbor] = current
    42  64.7812 MiB -1710.0000 MiB       10677                   g_score[neighbor] = temp_g_score
    43  64.7812 MiB -1710.0000 MiB       10677                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.7812 MiB -1695.7500 MiB       10471           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.7812 MiB -1695.7500 MiB       10471           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  64.5938 MiB   0.0000 MiB           1       paths = {}
    53  64.5938 MiB   0.0000 MiB           2       for goal in goals:
    54  64.5938 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  64.5938 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  64.3125 MiB  64.3125 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  64.3125 MiB   0.0000 MiB         129       for row in grid:
     8  64.3125 MiB   0.0000 MiB       16512           for spot in row:
     9  64.3125 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  64.3125 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  64.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  64.3125 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  64.3125 MiB   0.0000 MiB           1       came_from = {}
    18  64.3125 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.3125 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.3594 MiB -11003.9062 MiB       13077       while not open_set.empty():
    22  64.3594 MiB -11003.9062 MiB       13077           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.3594 MiB -11003.9062 MiB       13077           current = open_set.get()[1]
    28                                         
    29  64.3594 MiB -11003.9219 MiB       13077           if current in remaining_goals:
    30  63.4375 MiB  -0.9219 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.4375 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.4375 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.3594 MiB -98400.2656 MiB      116828           for neighbor in current.neighbors:
    35  64.3594 MiB -87396.5625 MiB      103752               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.3594 MiB -87396.7188 MiB      103752               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.3594 MiB -43594.7812 MiB       51734                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.3594 MiB -87397.1562 MiB      103752               if temp_g_score < g_score[neighbor]:
    41  64.3594 MiB -11100.7656 MiB       13289                   came_from[neighbor] = current
    42  64.3594 MiB -11100.8125 MiB       13289                   g_score[neighbor] = temp_g_score
    43  64.3594 MiB -11100.8125 MiB       13289                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.3594 MiB -11003.8906 MiB       13076           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.3594 MiB -11003.8906 MiB       13076           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.4375 MiB   0.0000 MiB           1       paths = {}
    53  63.4375 MiB   0.0000 MiB           2       for goal in goals:
    54  63.4375 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.4375 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.5625 MiB  63.5625 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.5625 MiB   0.0000 MiB         129       for row in grid:
     8  63.5625 MiB   0.0000 MiB       16512           for spot in row:
     9  63.5625 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.5625 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.5625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.5625 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.5625 MiB   0.0000 MiB           1       came_from = {}
    18  64.3281 MiB   0.7656 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.3281 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.5625 MiB   0.0000 MiB        4196       while not open_set.empty():
    22  64.5625 MiB   0.0000 MiB        4196           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.5625 MiB   0.0000 MiB        4196           current = open_set.get()[1]
    28                                         
    29  64.5625 MiB   0.0000 MiB        4196           if current in remaining_goals:
    30  64.5625 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  64.5625 MiB   0.0000 MiB           1               if not remaining_goals:
    32  64.5625 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.5625 MiB   0.0000 MiB       37755           for neighbor in current.neighbors:
    35  64.5625 MiB   0.0000 MiB       33560               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.5625 MiB   0.0000 MiB       33560               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.5625 MiB   0.0000 MiB       16780                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.5625 MiB   0.0000 MiB       33560               if temp_g_score < g_score[neighbor]:
    41  64.5625 MiB   0.2344 MiB        4506                   came_from[neighbor] = current
    42  64.5625 MiB   0.0000 MiB        4506                   g_score[neighbor] = temp_g_score
    43  64.5625 MiB   0.0000 MiB        4506                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.5625 MiB   0.0000 MiB        4195           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.5625 MiB   0.0000 MiB        4195           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  64.5625 MiB   0.0000 MiB           1       paths = {}
    53  64.5625 MiB   0.0000 MiB           2       for goal in goals:
    54  64.5625 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  64.5625 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.3438 MiB  63.3438 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.3438 MiB   0.0000 MiB         129       for row in grid:
     8  63.3438 MiB   0.0000 MiB       16512           for spot in row:
     9  63.3438 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.3438 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.3438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.3438 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.3438 MiB   0.0000 MiB           1       came_from = {}
    18  63.3438 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  63.3438 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  63.4219 MiB -5079.5938 MiB       14058       while not open_set.empty():
    22  63.4219 MiB -5079.5938 MiB       14058           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  63.4219 MiB -5079.5938 MiB       14058           current = open_set.get()[1]
    28                                         
    29  63.4219 MiB -5079.5938 MiB       14058           if current in remaining_goals:
    30  62.9844 MiB  -0.4375 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  62.9844 MiB   0.0000 MiB           1               if not remaining_goals:
    32  62.9844 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  63.4219 MiB -45350.5938 MiB      125546           for neighbor in current.neighbors:
    35  63.4219 MiB -40271.1094 MiB      111489               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  63.4219 MiB -40271.2344 MiB      111489               if current.row != neighbor.row and current.col != neighbor.col:
    38  63.4219 MiB -20075.5469 MiB       55584                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  63.4219 MiB -40271.3438 MiB      111489               if temp_g_score < g_score[neighbor]:
    41  63.4219 MiB -5078.5000 MiB       14235                   came_from[neighbor] = current
    42  63.4219 MiB -5078.5781 MiB       14235                   g_score[neighbor] = temp_g_score
    43  63.4219 MiB -5078.5781 MiB       14235                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  63.4219 MiB -5079.5625 MiB       14057           if draw is not None:
    46                                                     draw()
    47                                                     
    48  63.4219 MiB -5079.5625 MiB       14057           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  62.9844 MiB   0.0000 MiB           1       paths = {}
    53  62.9844 MiB   0.0000 MiB           2       for goal in goals:
    54  62.9844 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  62.9844 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.0781 MiB  63.0781 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.0781 MiB   0.0000 MiB         129       for row in grid:
     8  63.0781 MiB   0.0000 MiB       16512           for spot in row:
     9  63.0781 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.0781 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.0781 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.0781 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.0781 MiB   0.0000 MiB           1       came_from = {}
    18  63.0781 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  63.0781 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  63.0781 MiB   0.0000 MiB        2899       while not open_set.empty():
    22  63.0781 MiB   0.0000 MiB        2899           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  63.0781 MiB   0.0000 MiB        2899           current = open_set.get()[1]
    28                                         
    29  63.0781 MiB   0.0000 MiB        2899           if current in remaining_goals:
    30  63.0781 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.0781 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.0781 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  63.0781 MiB   0.0000 MiB       25935           for neighbor in current.neighbors:
    35  63.0781 MiB   0.0000 MiB       23037               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  63.0781 MiB   0.0000 MiB       23037               if current.row != neighbor.row and current.col != neighbor.col:
    38  63.0781 MiB   0.0000 MiB       11494                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  63.0781 MiB   0.0000 MiB       23037               if temp_g_score < g_score[neighbor]:
    41  63.0781 MiB   0.0000 MiB        3096                   came_from[neighbor] = current
    42  63.0781 MiB   0.0000 MiB        3096                   g_score[neighbor] = temp_g_score
    43  63.0781 MiB   0.0000 MiB        3096                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  63.0781 MiB   0.0000 MiB        2898           if draw is not None:
    46                                                     draw()
    47                                                     
    48  63.0781 MiB   0.0000 MiB        2898           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.0781 MiB   0.0000 MiB           1       paths = {}
    53  63.0781 MiB   0.0000 MiB           2       for goal in goals:
    54  63.0781 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.0781 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.1094 MiB  63.1094 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.8750 MiB   0.0000 MiB         129       for row in grid:
     8  63.8750 MiB   0.0000 MiB       16512           for spot in row:
     9  63.8750 MiB   0.7656 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.8750 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.8750 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.8750 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.8750 MiB   0.0000 MiB           1       came_from = {}
    18  64.3906 MiB   0.5156 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.3906 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.4688 MiB   0.0000 MiB        6635       while not open_set.empty():
    22  64.4688 MiB   0.0000 MiB        6635           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.4688 MiB   0.0000 MiB        6635           current = open_set.get()[1]
    28                                         
    29  64.4688 MiB   0.0000 MiB        6635           if current in remaining_goals:
    30  64.4688 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  64.4688 MiB   0.0000 MiB           1               if not remaining_goals:
    32  64.4688 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.4688 MiB   0.0000 MiB       59176           for neighbor in current.neighbors:
    35  64.4688 MiB   0.0000 MiB       52542               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.4688 MiB   0.0000 MiB       52542               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.4688 MiB   0.0000 MiB       26183                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.4688 MiB   0.0000 MiB       52542               if temp_g_score < g_score[neighbor]:
    41  64.4688 MiB   0.0781 MiB        6833                   came_from[neighbor] = current
    42  64.4688 MiB   0.0000 MiB        6833                   g_score[neighbor] = temp_g_score
    43  64.4688 MiB   0.0000 MiB        6833                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.4688 MiB   0.0000 MiB        6634           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.4688 MiB   0.0000 MiB        6634           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  64.4688 MiB   0.0000 MiB           1       paths = {}
    53  64.4688 MiB   0.0000 MiB           2       for goal in goals:
    54  64.4688 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  64.4688 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  67.8906 MiB  67.8906 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  67.8906 MiB   0.0000 MiB         129       for row in grid:
     8  67.8906 MiB   0.0000 MiB       16512           for spot in row:
     9  67.8906 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  67.8906 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  67.8906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  67.8906 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  67.8906 MiB   0.0000 MiB           1       came_from = {}
    18  67.8906 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  67.8906 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  67.9062 MiB -130.9844 MiB       14646       while not open_set.empty():
    22  67.9062 MiB -130.9844 MiB       14646           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  67.9062 MiB -130.9844 MiB       14646           current = open_set.get()[1]
    28                                         
    29  67.9062 MiB -130.9844 MiB       14646           if current in remaining_goals:
    30  67.8906 MiB  -0.0156 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  67.8906 MiB   0.0000 MiB           1               if not remaining_goals:
    32  67.8906 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  67.9062 MiB -1172.1406 MiB      130838           for neighbor in current.neighbors:
    35  67.9062 MiB -1041.1562 MiB      116193               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  67.9062 MiB -1041.2344 MiB      116193               if current.row != neighbor.row and current.col != neighbor.col:
    38  67.9062 MiB -519.3281 MiB       57936                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  67.9062 MiB -1041.2344 MiB      116193               if temp_g_score < g_score[neighbor]:
    41  67.9062 MiB -129.7344 MiB       14831                   came_from[neighbor] = current
    42  67.9062 MiB -129.7969 MiB       14831                   g_score[neighbor] = temp_g_score
    43  67.9062 MiB -129.7969 MiB       14831                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  67.9062 MiB -130.9844 MiB       14645           if draw is not None:
    46                                                     draw()
    47                                                     
    48  67.9062 MiB -130.9844 MiB       14645           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  67.8906 MiB   0.0000 MiB           1       paths = {}
    53  67.8906 MiB   0.0000 MiB           2       for goal in goals:
    54  67.8906 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  67.8906 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  68.2500 MiB  68.2500 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  68.2500 MiB   0.0000 MiB         129       for row in grid:
     8  68.2500 MiB   0.0000 MiB       16512           for spot in row:
     9  68.2500 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  68.2500 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  68.2500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  68.2500 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  68.2500 MiB   0.0000 MiB           1       came_from = {}
    18  68.2500 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  68.2500 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  68.2500 MiB   0.0000 MiB          73       while not open_set.empty():
    22  68.2500 MiB   0.0000 MiB          73           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  68.2500 MiB   0.0000 MiB          73           current = open_set.get()[1]
    28                                         
    29  68.2500 MiB   0.0000 MiB          73           if current in remaining_goals:
    30  68.2500 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  68.2500 MiB   0.0000 MiB           1               if not remaining_goals:
    32  68.2500 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  68.2500 MiB   0.0000 MiB         648           for neighbor in current.neighbors:
    35  68.2500 MiB   0.0000 MiB         576               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  68.2500 MiB   0.0000 MiB         576               if current.row != neighbor.row and current.col != neighbor.col:
    38  68.2500 MiB   0.0000 MiB         288                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  68.2500 MiB   0.0000 MiB         576               if temp_g_score < g_score[neighbor]:
    41  68.2500 MiB   0.0000 MiB         117                   came_from[neighbor] = current
    42  68.2500 MiB   0.0000 MiB         117                   g_score[neighbor] = temp_g_score
    43  68.2500 MiB   0.0000 MiB         117                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  68.2500 MiB   0.0000 MiB          72           if draw is not None:
    46                                                     draw()
    47                                                     
    48  68.2500 MiB   0.0000 MiB          72           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  68.2500 MiB   0.0000 MiB           1       paths = {}
    53  68.2500 MiB   0.0000 MiB           2       for goal in goals:
    54  68.2500 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  68.2500 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  68.2969 MiB  68.2969 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  68.2969 MiB   0.0000 MiB         129       for row in grid:
     8  68.2969 MiB   0.0000 MiB       16512           for spot in row:
     9  68.2969 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  68.2969 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  68.2969 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  68.2969 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  68.2969 MiB   0.0000 MiB           1       came_from = {}
    18  68.2969 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  68.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  68.2969 MiB   0.0000 MiB          81       while not open_set.empty():
    22  68.2969 MiB   0.0000 MiB          81           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  68.2969 MiB   0.0000 MiB          81           current = open_set.get()[1]
    28                                         
    29  68.2969 MiB   0.0000 MiB          81           if current in remaining_goals:
    30  68.2969 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  68.2969 MiB   0.0000 MiB           1               if not remaining_goals:
    32  68.2969 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  68.2969 MiB   0.0000 MiB         720           for neighbor in current.neighbors:
    35  68.2969 MiB   0.0000 MiB         640               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  68.2969 MiB   0.0000 MiB         640               if current.row != neighbor.row and current.col != neighbor.col:
    38  68.2969 MiB   0.0000 MiB         320                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  68.2969 MiB   0.0000 MiB         640               if temp_g_score < g_score[neighbor]:
    41  68.2969 MiB   0.0000 MiB         127                   came_from[neighbor] = current
    42  68.2969 MiB   0.0000 MiB         127                   g_score[neighbor] = temp_g_score
    43  68.2969 MiB   0.0000 MiB         127                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  68.2969 MiB   0.0000 MiB          80           if draw is not None:
    46                                                     draw()
    47                                                     
    48  68.2969 MiB   0.0000 MiB          80           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  68.2969 MiB   0.0000 MiB           1       paths = {}
    53  68.2969 MiB   0.0000 MiB           2       for goal in goals:
    54  68.2969 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  68.2969 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  68.2969 MiB  68.2969 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  68.2969 MiB   0.0000 MiB         129       for row in grid:
     8  68.2969 MiB   0.0000 MiB       16512           for spot in row:
     9  68.2969 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  68.2969 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  68.2969 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  68.2969 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  68.2969 MiB   0.0000 MiB           1       came_from = {}
    18  68.2969 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  68.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  68.2969 MiB   0.0000 MiB         853       while not open_set.empty():
    22  68.2969 MiB   0.0000 MiB         853           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  68.2969 MiB   0.0000 MiB         853           current = open_set.get()[1]
    28                                         
    29  68.2969 MiB   0.0000 MiB         853           if current in remaining_goals:
    30  68.2969 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  68.2969 MiB   0.0000 MiB           1               if not remaining_goals:
    32  68.2969 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  68.2969 MiB   0.0000 MiB        7572           for neighbor in current.neighbors:
    35  68.2969 MiB   0.0000 MiB        6720               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  68.2969 MiB   0.0000 MiB        6720               if current.row != neighbor.row and current.col != neighbor.col:
    38  68.2969 MiB   0.0000 MiB        3344                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  68.2969 MiB   0.0000 MiB        6720               if temp_g_score < g_score[neighbor]:
    41  68.2969 MiB   0.0000 MiB         953                   came_from[neighbor] = current
    42  68.2969 MiB   0.0000 MiB         953                   g_score[neighbor] = temp_g_score
    43  68.2969 MiB   0.0000 MiB         953                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  68.2969 MiB   0.0000 MiB         852           if draw is not None:
    46                                                     draw()
    47                                                     
    48  68.2969 MiB   0.0000 MiB         852           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  68.2969 MiB   0.0000 MiB           1       paths = {}
    53  68.2969 MiB   0.0000 MiB           2       for goal in goals:
    54  68.2969 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  68.2969 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  68.3125 MiB  68.3125 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/128.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  68.3125 MiB   0.0000 MiB         129       for row in grid:
     8  68.3125 MiB   0.0000 MiB       16512           for spot in row:
     9  68.3125 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  68.3125 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  68.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  68.3125 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  68.3125 MiB   0.0000 MiB           1       came_from = {}
    18  68.3125 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  68.3125 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  68.9844 MiB -1036.3750 MiB       13127       while not open_set.empty():
    22  68.9844 MiB -1036.3750 MiB       13127           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  68.9844 MiB -1036.3750 MiB       13127           current = open_set.get()[1]
    28                                         
    29  68.9844 MiB -1036.3906 MiB       13127           if current in remaining_goals:
    30  68.3438 MiB  -0.6406 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  68.3438 MiB   0.0000 MiB           1               if not remaining_goals:
    32  68.3438 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  68.9844 MiB -9253.1875 MiB      117248           for neighbor in current.neighbors:
    35  68.9844 MiB -8217.0000 MiB      104122               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  68.9844 MiB -8217.1562 MiB      104122               if current.row != neighbor.row and current.col != neighbor.col:
    38  68.9844 MiB -4096.5938 MiB       51914                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  68.9844 MiB -8217.2344 MiB      104122               if temp_g_score < g_score[neighbor]:
    41  68.9844 MiB -1024.7344 MiB       13319                   came_from[neighbor] = current
    42  68.9844 MiB -1025.4062 MiB       13319                   g_score[neighbor] = temp_g_score
    43  68.9844 MiB -1025.4062 MiB       13319                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  68.9844 MiB -1036.3750 MiB       13126           if draw is not None:
    46                                                     draw()
    47                                                     
    48  68.9844 MiB -1036.3750 MiB       13126           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  68.3438 MiB   0.0000 MiB           1       paths = {}
    53  68.3438 MiB   0.0000 MiB           2       for goal in goals:
    54  68.3438 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  68.3438 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  68.3594 MiB  68.3594 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/256.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  68.3594 MiB   0.0000 MiB         129       for row in grid:
     8  68.3594 MiB   0.0000 MiB       16512           for spot in row:
     9  68.3594 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  68.3594 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  68.3594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  68.3594 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  68.3594 MiB   0.0000 MiB           1       came_from = {}
    18  68.3750 MiB   0.0156 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  68.3750 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  68.3750 MiB -874.2500 MiB        8018       while not open_set.empty():
    22  68.3750 MiB -874.2500 MiB        8018           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  68.3750 MiB -874.2500 MiB        8018           current = open_set.get()[1]
    28                                         
    29  68.3750 MiB -874.2500 MiB        8018           if current in remaining_goals:
    30  68.1719 MiB  -0.2031 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  68.1719 MiB   0.0000 MiB           1               if not remaining_goals:
    32  68.1719 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  68.3750 MiB -7825.6562 MiB       71793           for neighbor in current.neighbors:
    35  68.3750 MiB -6951.5469 MiB       63776               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  68.3750 MiB -6951.5469 MiB       63776               if current.row != neighbor.row and current.col != neighbor.col:
    38  68.3750 MiB -3468.9688 MiB       31828                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  68.3750 MiB -6951.5469 MiB       63776               if temp_g_score < g_score[neighbor]:
    41  68.3750 MiB -885.0156 MiB        8300                   came_from[neighbor] = current
    42  68.3750 MiB -885.0156 MiB        8300                   g_score[neighbor] = temp_g_score
    43  68.3750 MiB -885.0156 MiB        8300                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  68.3750 MiB -874.2500 MiB        8017           if draw is not None:
    46                                                     draw()
    47                                                     
    48  68.3750 MiB -874.2500 MiB        8017           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  68.1719 MiB   0.0000 MiB           1       paths = {}
    53  68.1719 MiB   0.0000 MiB           2       for goal in goals:
    54  68.1719 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  68.1719 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  68.2031 MiB  68.2031 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/256.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  68.2031 MiB   0.0000 MiB         129       for row in grid:
     8  68.2031 MiB   0.0000 MiB       16512           for spot in row:
     9  68.2031 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  68.2031 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  68.2031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  68.2031 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  68.2031 MiB   0.0000 MiB           1       came_from = {}
    18  68.2031 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  68.2031 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  68.2031 MiB -12125.8281 MiB       11417       while not open_set.empty():
    22  68.2031 MiB -12126.0156 MiB       11417           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  68.2031 MiB -12126.3281 MiB       11417           current = open_set.get()[1]
    28                                         
    29  68.2031 MiB -12126.3281 MiB       11417           if current in remaining_goals:
    30  66.9062 MiB  -1.2969 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  66.9062 MiB   0.0000 MiB           1               if not remaining_goals:
    32  66.9062 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  68.2031 MiB -108404.0469 MiB      101948           for neighbor in current.neighbors:
    35  68.2031 MiB -96278.5781 MiB       90532               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  68.2031 MiB -96278.7969 MiB       90532               if current.row != neighbor.row and current.col != neighbor.col:
    38  68.2031 MiB -48019.7656 MiB       45134                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  68.2031 MiB -96279.2031 MiB       90532               if temp_g_score < g_score[neighbor]:
    41  68.2031 MiB -12135.9531 MiB       11613                   came_from[neighbor] = current
    42  68.2031 MiB -12136.1719 MiB       11613                   g_score[neighbor] = temp_g_score
    43  68.2031 MiB -12136.2188 MiB       11613                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  68.2031 MiB -12125.6719 MiB       11416           if draw is not None:
    46                                                     draw()
    47                                                     
    48  68.2031 MiB -12125.7812 MiB       11416           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  66.9062 MiB   0.0000 MiB           1       paths = {}
    53  66.9062 MiB   0.0000 MiB           2       for goal in goals:
    54  66.9062 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  66.9062 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  67.0625 MiB  67.0625 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/256.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  67.0625 MiB   0.0000 MiB         129       for row in grid:
     8  67.0625 MiB   0.0000 MiB       16512           for spot in row:
     9  67.0625 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  67.0625 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  67.0625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  67.0625 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  67.0625 MiB   0.0000 MiB           1       came_from = {}
    18  67.7188 MiB   0.6562 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  67.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  67.8438 MiB   0.0000 MiB        2300       while not open_set.empty():
    22  67.8438 MiB   0.0000 MiB        2300           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  67.8438 MiB   0.0000 MiB        2300           current = open_set.get()[1]
    28                                         
    29  67.8438 MiB   0.0000 MiB        2300           if current in remaining_goals:
    30  67.8438 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  67.8438 MiB   0.0000 MiB           1               if not remaining_goals:
    32  67.8438 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  67.8438 MiB   0.0000 MiB       20368           for neighbor in current.neighbors:
    35  67.8438 MiB   0.0000 MiB       18069               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  67.8438 MiB   0.0000 MiB       18069               if current.row != neighbor.row and current.col != neighbor.col:
    38  67.8438 MiB   0.0000 MiB        8981                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  67.8438 MiB   0.0000 MiB       18069               if temp_g_score < g_score[neighbor]:
    41  67.8438 MiB   0.1250 MiB        2415                   came_from[neighbor] = current
    42  67.8438 MiB   0.0000 MiB        2415                   g_score[neighbor] = temp_g_score
    43  67.8438 MiB   0.0000 MiB        2415                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  67.8438 MiB   0.0000 MiB        2299           if draw is not None:
    46                                                     draw()
    47                                                     
    48  67.8438 MiB   0.0000 MiB        2299           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  67.8438 MiB   0.0000 MiB           1       paths = {}
    53  67.8438 MiB   0.0000 MiB           2       for goal in goals:
    54  67.8438 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  67.8438 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  67.8906 MiB  67.8906 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/256.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  67.8906 MiB   0.0000 MiB         129       for row in grid:
     8  67.8906 MiB   0.0000 MiB       16512           for spot in row:
     9  67.8906 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  67.8906 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  67.8906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  67.8906 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  67.8906 MiB   0.0000 MiB           1       came_from = {}
    18  67.9062 MiB   0.0156 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  67.9062 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  67.9219 MiB -17260.3594 MiB       11793       while not open_set.empty():
    22  67.9219 MiB -17260.3594 MiB       11793           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  67.9219 MiB -17260.3594 MiB       11793           current = open_set.get()[1]
    28                                         
    29  67.9219 MiB -17260.3594 MiB       11793           if current in remaining_goals:
    30  65.8594 MiB  -2.0625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  65.8594 MiB   0.0000 MiB           1               if not remaining_goals:
    32  65.8594 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  67.9219 MiB -154401.2656 MiB      105687           for neighbor in current.neighbors:
    35  67.9219 MiB -137141.5781 MiB       93895               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  67.9219 MiB -137143.0156 MiB       93895               if current.row != neighbor.row and current.col != neighbor.col:
    38  67.9219 MiB -68418.7344 MiB       46874                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  67.9219 MiB -137143.2188 MiB       93895               if temp_g_score < g_score[neighbor]:
    41  67.9219 MiB -17356.4062 MiB       12122                   came_from[neighbor] = current
    42  67.9219 MiB -17356.4219 MiB       12122                   g_score[neighbor] = temp_g_score
    43  67.9219 MiB -17356.4219 MiB       12122                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  67.9219 MiB -17260.3594 MiB       11792           if draw is not None:
    46                                                     draw()
    47                                                     
    48  67.9219 MiB -17260.3594 MiB       11792           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  65.8594 MiB   0.0000 MiB           1       paths = {}
    53  65.8594 MiB   0.0000 MiB           2       for goal in goals:
    54  65.8594 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  65.8594 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  65.8594 MiB  65.8594 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/256.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  65.8594 MiB   0.0000 MiB         129       for row in grid:
     8  65.8594 MiB   0.0000 MiB       16512           for spot in row:
     9  65.8594 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  65.8594 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  65.8594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  65.8594 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  65.8594 MiB   0.0000 MiB           1       came_from = {}
    18  66.1562 MiB   0.2969 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  66.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  66.2031 MiB -277.7344 MiB        7608       while not open_set.empty():
    22  66.2031 MiB -277.7344 MiB        7608           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  66.2031 MiB -277.7344 MiB        7608           current = open_set.get()[1]
    28                                         
    29  66.2031 MiB -277.7344 MiB        7608           if current in remaining_goals:
    30  66.1250 MiB  -0.0781 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  66.1250 MiB   0.0000 MiB           1               if not remaining_goals:
    32  66.1250 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  66.2031 MiB -2492.3438 MiB       68376           for neighbor in current.neighbors:
    35  66.2031 MiB -2214.6250 MiB       60769               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  66.2031 MiB -2214.6875 MiB       60769               if current.row != neighbor.row and current.col != neighbor.col:
    38  66.2031 MiB -1106.3281 MiB       30370                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  66.2031 MiB -2214.6875 MiB       60769               if temp_g_score < g_score[neighbor]:
    41  66.2031 MiB -283.2344 MiB        7981                   came_from[neighbor] = current
    42  66.2031 MiB -283.2812 MiB        7981                   g_score[neighbor] = temp_g_score
    43  66.2031 MiB -283.2812 MiB        7981                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  66.2031 MiB -277.7344 MiB        7607           if draw is not None:
    46                                                     draw()
    47                                                     
    48  66.2031 MiB -277.7344 MiB        7607           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  66.1250 MiB   0.0000 MiB           1       paths = {}
    53  66.1250 MiB   0.0000 MiB           2       for goal in goals:
    54  66.1250 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  66.1250 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  66.2031 MiB  66.2031 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/256.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  66.2031 MiB   0.0000 MiB         129       for row in grid:
     8  66.2031 MiB   0.0000 MiB       16512           for spot in row:
     9  66.2031 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  66.2031 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  66.2031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  66.2031 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  66.2031 MiB   0.0000 MiB           1       came_from = {}
    18  66.8281 MiB   0.6250 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  66.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  66.8281 MiB -26820.0000 MiB       10854       while not open_set.empty():
    22  66.8281 MiB -26820.0000 MiB       10854           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  66.8281 MiB -26820.0469 MiB       10854           current = open_set.get()[1]
    28                                         
    29  66.8281 MiB -26820.4688 MiB       10854           if current in remaining_goals:
    30  63.0625 MiB  -3.7656 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.0625 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.0625 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  66.8281 MiB -240262.4688 MiB       97000           for neighbor in current.neighbors:
    35  66.8281 MiB -213443.3125 MiB       86147               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  66.8281 MiB -213443.7656 MiB       86147               if current.row != neighbor.row and current.col != neighbor.col:
    38  66.8281 MiB -106540.4375 MiB       42961                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  66.8281 MiB -213444.5469 MiB       86147               if temp_g_score < g_score[neighbor]:
    41  66.8281 MiB -27195.5938 MiB       11103                   came_from[neighbor] = current
    42  66.8281 MiB -27195.6250 MiB       11103                   g_score[neighbor] = temp_g_score
    43  66.8281 MiB -27195.7812 MiB       11103                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  66.8281 MiB -26820.0000 MiB       10853           if draw is not None:
    46                                                     draw()
    47                                                     
    48  66.8281 MiB -26820.0000 MiB       10853           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.0625 MiB   0.0000 MiB           1       paths = {}
    53  63.0625 MiB   0.0000 MiB           2       for goal in goals:
    54  63.0625 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.0625 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.2500 MiB  63.2500 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/512.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.2500 MiB   0.0000 MiB         129       for row in grid:
     8  63.2500 MiB   0.0000 MiB       16512           for spot in row:
     9  63.2500 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.2500 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.2500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.2500 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.2500 MiB   0.0000 MiB           1       came_from = {}
    18  63.7969 MiB   0.5469 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  63.7969 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  63.7969 MiB   0.0000 MiB        1641       while not open_set.empty():
    22  63.7969 MiB   0.0000 MiB        1641           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  63.7969 MiB   0.0000 MiB        1641           current = open_set.get()[1]
    28                                         
    29  63.7969 MiB   0.0000 MiB        1641           if current in remaining_goals:
    30  63.7969 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.7969 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.7969 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  63.7969 MiB   0.0000 MiB       14760           for neighbor in current.neighbors:
    35  63.7969 MiB   0.0000 MiB       13120               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  63.7969 MiB   0.0000 MiB       13120               if current.row != neighbor.row and current.col != neighbor.col:
    38  63.7969 MiB   0.0000 MiB        6560                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  63.7969 MiB   0.0000 MiB       13120               if temp_g_score < g_score[neighbor]:
    41  63.7969 MiB   0.0000 MiB        1837                   came_from[neighbor] = current
    42  63.7969 MiB   0.0000 MiB        1837                   g_score[neighbor] = temp_g_score
    43  63.7969 MiB   0.0000 MiB        1837                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  63.7969 MiB   0.0000 MiB        1640           if draw is not None:
    46                                                     draw()
    47                                                     
    48  63.7969 MiB   0.0000 MiB        1640           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.7969 MiB   0.0000 MiB           1       paths = {}
    53  63.7969 MiB   0.0000 MiB           2       for goal in goals:
    54  63.7969 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.7969 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  62.9688 MiB  62.9688 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/512.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  62.9688 MiB   0.0000 MiB         129       for row in grid:
     8  62.9688 MiB   0.0000 MiB       16512           for spot in row:
     9  62.9688 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  62.9688 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  62.9688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  62.9688 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  62.9688 MiB   0.0000 MiB           1       came_from = {}
    18  63.0312 MiB   0.0625 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  63.0312 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  63.0312 MiB   0.0000 MiB         797       while not open_set.empty():
    22  63.0312 MiB   0.0000 MiB         797           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  63.0312 MiB   0.0000 MiB         797           current = open_set.get()[1]
    28                                         
    29  63.0312 MiB   0.0000 MiB         797           if current in remaining_goals:
    30  63.0312 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.0312 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.0312 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  63.0312 MiB   0.0000 MiB        7137           for neighbor in current.neighbors:
    35  63.0312 MiB   0.0000 MiB        6341               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  63.0312 MiB   0.0000 MiB        6341               if current.row != neighbor.row and current.col != neighbor.col:
    38  63.0312 MiB   0.0000 MiB        3166                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  63.0312 MiB   0.0000 MiB        6341               if temp_g_score < g_score[neighbor]:
    41  63.0312 MiB   0.0000 MiB         918                   came_from[neighbor] = current
    42  63.0312 MiB   0.0000 MiB         918                   g_score[neighbor] = temp_g_score
    43  63.0312 MiB   0.0000 MiB         918                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  63.0312 MiB   0.0000 MiB         796           if draw is not None:
    46                                                     draw()
    47                                                     
    48  63.0312 MiB   0.0000 MiB         796           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.0312 MiB   0.0000 MiB           1       paths = {}
    53  63.0312 MiB   0.0000 MiB           2       for goal in goals:
    54  63.0312 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.0312 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.7344 MiB  63.7344 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/512.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.7344 MiB   0.0000 MiB         129       for row in grid:
     8  63.7344 MiB   0.0000 MiB       16512           for spot in row:
     9  63.7344 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.7344 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.7344 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.7344 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.7344 MiB   0.0000 MiB           1       came_from = {}
    18  64.4688 MiB   0.7344 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.4688 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.5156 MiB   0.0000 MiB        1819       while not open_set.empty():
    22  64.5156 MiB   0.0000 MiB        1819           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.5156 MiB   0.0000 MiB        1819           current = open_set.get()[1]
    28                                         
    29  64.5156 MiB   0.0000 MiB        1819           if current in remaining_goals:
    30  64.5156 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  64.5156 MiB   0.0000 MiB           1               if not remaining_goals:
    32  64.5156 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.5156 MiB   0.0000 MiB       16362           for neighbor in current.neighbors:
    35  64.5156 MiB   0.0000 MiB       14544               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.5156 MiB   0.0000 MiB       14544               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.5156 MiB   0.0000 MiB        7272                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.5156 MiB   0.0000 MiB       14544               if temp_g_score < g_score[neighbor]:
    41  64.5156 MiB   0.0469 MiB        2025                   came_from[neighbor] = current
    42  64.5156 MiB   0.0000 MiB        2025                   g_score[neighbor] = temp_g_score
    43  64.5156 MiB   0.0000 MiB        2025                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.5156 MiB   0.0000 MiB        1818           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.5156 MiB   0.0000 MiB        1818           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  64.5156 MiB   0.0000 MiB           1       paths = {}
    53  64.5156 MiB   0.0000 MiB           2       for goal in goals:
    54  64.5156 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  64.5156 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.5469 MiB  63.5469 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/512.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.5469 MiB   0.0000 MiB         129       for row in grid:
     8  63.5469 MiB   0.0000 MiB       16512           for spot in row:
     9  63.5469 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.5469 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.5469 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.5469 MiB   0.0000 MiB           1       came_from = {}
    18  63.6562 MiB   0.1094 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  63.6562 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  63.7656 MiB   0.0000 MiB        9481       while not open_set.empty():
    22  63.7656 MiB   0.0000 MiB        9481           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  63.7656 MiB   0.0000 MiB        9481           current = open_set.get()[1]
    28                                         
    29  63.7656 MiB   0.0000 MiB        9481           if current in remaining_goals:
    30  63.7656 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.7656 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.7656 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  63.7656 MiB   0.0000 MiB       84766           for neighbor in current.neighbors:
    35  63.7656 MiB   0.0000 MiB       75286               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  63.7656 MiB   0.0000 MiB       75286               if current.row != neighbor.row and current.col != neighbor.col:
    38  63.7656 MiB   0.0000 MiB       37551                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  63.7656 MiB   0.0000 MiB       75286               if temp_g_score < g_score[neighbor]:
    41  63.7656 MiB   0.1094 MiB        9731                   came_from[neighbor] = current
    42  63.7656 MiB   0.0000 MiB        9731                   g_score[neighbor] = temp_g_score
    43  63.7656 MiB   0.0000 MiB        9731                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  63.7656 MiB   0.0000 MiB        9480           if draw is not None:
    46                                                     draw()
    47                                                     
    48  63.7656 MiB   0.0000 MiB        9480           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.7656 MiB   0.0000 MiB           1       paths = {}
    53  63.7656 MiB   0.0000 MiB           2       for goal in goals:
    54  63.7656 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.7656 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.8438 MiB  63.8438 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/512.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.8438 MiB   0.0000 MiB         129       for row in grid:
     8  63.8438 MiB   0.0000 MiB       16512           for spot in row:
     9  63.8438 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.8438 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.8438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.8438 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.8438 MiB   0.0000 MiB           1       came_from = {}
    18  64.0312 MiB   0.1875 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.0312 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.0312 MiB -109.3281 MiB        1095       while not open_set.empty():
    22  64.0312 MiB -109.3438 MiB        1095           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.0312 MiB -109.3750 MiB        1095           current = open_set.get()[1]
    28                                         
    29  64.0312 MiB -109.3750 MiB        1095           if current in remaining_goals:
    30  63.7188 MiB  -0.3125 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.7188 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.7188 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.0312 MiB -981.5625 MiB        9846           for neighbor in current.neighbors:
    35  64.0312 MiB -872.5000 MiB        8752               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.0312 MiB -872.5000 MiB        8752               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.0312 MiB -436.2500 MiB        4376                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.0312 MiB -872.5000 MiB        8752               if temp_g_score < g_score[neighbor]:
    41  64.0312 MiB -116.5625 MiB        1253                   came_from[neighbor] = current
    42  64.0312 MiB -116.5625 MiB        1253                   g_score[neighbor] = temp_g_score
    43  64.0312 MiB -116.5625 MiB        1253                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.0312 MiB -109.0625 MiB        1094           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.0312 MiB -109.1250 MiB        1094           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.7188 MiB   0.0000 MiB           1       paths = {}
    53  63.7188 MiB   0.0000 MiB           2       for goal in goals:
    54  63.7188 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.7188 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.9375 MiB  63.9375 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.9375 MiB   0.0000 MiB         129       for row in grid:
     8  63.9375 MiB   0.0000 MiB       16512           for spot in row:
     9  63.9375 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.9375 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.9375 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.9375 MiB   0.0000 MiB           1       came_from = {}
    18  64.3438 MiB   0.4062 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.3438 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.3438 MiB   0.0000 MiB        1616       while not open_set.empty():
    22  64.3438 MiB   0.0000 MiB        1616           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.3438 MiB   0.0000 MiB        1616           current = open_set.get()[1]
    28                                         
    29  64.3438 MiB   0.0000 MiB        1616           if current in remaining_goals:
    30  64.3438 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  64.3438 MiB   0.0000 MiB           1               if not remaining_goals:
    32  64.3438 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.3438 MiB   0.0000 MiB       14535           for neighbor in current.neighbors:
    35  64.3438 MiB   0.0000 MiB       12920               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.3438 MiB   0.0000 MiB       12920               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.3438 MiB   0.0000 MiB        6460                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.3438 MiB   0.0000 MiB       12920               if temp_g_score < g_score[neighbor]:
    41  64.3438 MiB   0.0000 MiB        1806                   came_from[neighbor] = current
    42  64.3438 MiB   0.0000 MiB        1806                   g_score[neighbor] = temp_g_score
    43  64.3438 MiB   0.0000 MiB        1806                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.3438 MiB   0.0000 MiB        1615           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.3438 MiB   0.0000 MiB        1615           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  64.3438 MiB   0.0000 MiB           1       paths = {}
    53  64.3438 MiB   0.0000 MiB           2       for goal in goals:
    54  64.3438 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  64.3438 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  67.7188 MiB  67.7188 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  67.7188 MiB   0.0000 MiB         129       for row in grid:
     8  67.7188 MiB   0.0000 MiB       16512           for spot in row:
     9  67.7188 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  67.7188 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  67.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  67.7188 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  67.7188 MiB   0.0000 MiB           1       came_from = {}
    18  67.8125 MiB   0.0938 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  67.8125 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  67.8125 MiB   0.0000 MiB         430       while not open_set.empty():
    22  67.8125 MiB   0.0000 MiB         430           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  67.8125 MiB   0.0000 MiB         430           current = open_set.get()[1]
    28                                         
    29  67.8125 MiB   0.0000 MiB         430           if current in remaining_goals:
    30  67.8125 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  67.8125 MiB   0.0000 MiB           1               if not remaining_goals:
    32  67.8125 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  67.8125 MiB   0.0000 MiB        3762           for neighbor in current.neighbors:
    35  67.8125 MiB   0.0000 MiB        3333               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  67.8125 MiB   0.0000 MiB        3333               if current.row != neighbor.row and current.col != neighbor.col:
    38  67.8125 MiB   0.0000 MiB        1650                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  67.8125 MiB   0.0000 MiB        3333               if temp_g_score < g_score[neighbor]:
    41  67.8125 MiB   0.0000 MiB         497                   came_from[neighbor] = current
    42  67.8125 MiB   0.0000 MiB         497                   g_score[neighbor] = temp_g_score
    43  67.8125 MiB   0.0000 MiB         497                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  67.8125 MiB   0.0000 MiB         429           if draw is not None:
    46                                                     draw()
    47                                                     
    48  67.8125 MiB   0.0000 MiB         429           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  67.8125 MiB   0.0000 MiB           1       paths = {}
    53  67.8125 MiB   0.0000 MiB           2       for goal in goals:
    54  67.8125 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  67.8125 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  68.2344 MiB  68.2344 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  68.2344 MiB   0.0000 MiB         129       for row in grid:
     8  68.2344 MiB   0.0000 MiB       16512           for spot in row:
     9  68.2344 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  68.2344 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  68.2344 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  68.2344 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  68.2344 MiB   0.0000 MiB           1       came_from = {}
    18  68.2344 MiB   0.0000 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  68.2344 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  68.2344 MiB -63554.0781 MiB       13845       while not open_set.empty():
    22  68.2344 MiB -63554.0781 MiB       13845           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  68.2344 MiB -63554.0781 MiB       13845           current = open_set.get()[1]
    28                                         
    29  68.2344 MiB -63554.0938 MiB       13845           if current in remaining_goals:
    30  51.4062 MiB -16.8281 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  51.4062 MiB   0.0000 MiB           1               if not remaining_goals:
    32  51.4062 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  68.2344 MiB -567849.9688 MiB      123638           for neighbor in current.neighbors:
    35  68.2344 MiB -504297.4531 MiB      109794               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  68.2344 MiB -504298.6719 MiB      109794               if current.row != neighbor.row and current.col != neighbor.col:
    38  68.2344 MiB -251495.7188 MiB       54738                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  68.2344 MiB -504303.4688 MiB      109794               if temp_g_score < g_score[neighbor]:
    41  68.2344 MiB -63178.4844 MiB       14023                   came_from[neighbor] = current
    42  68.2344 MiB -63179.2812 MiB       14023                   g_score[neighbor] = temp_g_score
    43  68.2344 MiB -63185.4219 MiB       14023                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  68.2344 MiB -63554.0781 MiB       13844           if draw is not None:
    46                                                     draw()
    47                                                     
    48  68.2344 MiB -63554.0781 MiB       13844           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  51.4062 MiB   0.0000 MiB           1       paths = {}
    53  51.4844 MiB   0.0000 MiB           2       for goal in goals:
    54  51.4844 MiB   0.0781 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  51.4844 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  67.6406 MiB  67.6406 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  67.6406 MiB   0.0000 MiB         129       for row in grid:
     8  67.6406 MiB   0.0000 MiB       16512           for spot in row:
     9  67.6406 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  67.6406 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  67.6406 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  67.6406 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  67.6406 MiB   0.0000 MiB           1       came_from = {}
    18  67.8281 MiB   0.1875 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  67.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  67.8906 MiB -1679.8125 MiB       10392       while not open_set.empty():
    22  67.8906 MiB -1679.8125 MiB       10392           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  67.8906 MiB -1679.8125 MiB       10392           current = open_set.get()[1]
    28                                         
    29  67.8906 MiB -1679.8125 MiB       10392           if current in remaining_goals:
    30  67.8750 MiB  -0.0156 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  67.8750 MiB   0.0000 MiB           1               if not remaining_goals:
    32  67.8750 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  67.8906 MiB -15069.3281 MiB       92944           for neighbor in current.neighbors:
    35  67.8906 MiB -13389.5156 MiB       82553               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  67.8906 MiB -13390.0000 MiB       82553               if current.row != neighbor.row and current.col != neighbor.col:
    38  67.8906 MiB -6685.9531 MiB       41181                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  67.8906 MiB -13390.0000 MiB       82553               if temp_g_score < g_score[neighbor]:
    41  67.8906 MiB -1740.4062 MiB       10647                   came_from[neighbor] = current
    42  67.8906 MiB -1740.4688 MiB       10647                   g_score[neighbor] = temp_g_score
    43  67.8906 MiB -1740.4688 MiB       10647                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  67.8906 MiB -1679.8125 MiB       10391           if draw is not None:
    46                                                     draw()
    47                                                     
    48  67.8906 MiB -1679.8125 MiB       10391           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  67.8750 MiB   0.0000 MiB           1       paths = {}
    53  67.8750 MiB   0.0000 MiB           2       for goal in goals:
    54  67.8750 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  67.8750 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  67.9219 MiB  67.9219 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  67.9219 MiB   0.0000 MiB         129       for row in grid:
     8  67.9219 MiB   0.0000 MiB       16512           for spot in row:
     9  67.9219 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  67.9219 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  67.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  67.9219 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  67.9219 MiB   0.0000 MiB           1       came_from = {}
    18  67.9219 MiB -1030.9062 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  67.5938 MiB  -0.3281 MiB           1       g_score[start] = 0
    20                                         
    21  67.5938 MiB -23508.1406 MiB       12903       while not open_set.empty():
    22  67.5938 MiB -23508.4375 MiB       12903           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  67.5938 MiB -23508.7812 MiB       12903           current = open_set.get()[1]
    28                                         
    29  67.5938 MiB -23508.7969 MiB       12903           if current in remaining_goals:
    30  63.4375 MiB  -4.1562 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.4375 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.4375 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  67.5938 MiB -209853.2344 MiB      115363           for neighbor in current.neighbors:
    35  67.5938 MiB -186347.1875 MiB      102461               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  67.5938 MiB -186348.2188 MiB      102461               if current.row != neighbor.row and current.col != neighbor.col:
    38  67.5938 MiB -92894.5625 MiB       51105                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  67.5938 MiB -186348.5938 MiB      102461               if temp_g_score < g_score[neighbor]:
    41  67.5938 MiB -23507.3594 MiB       13138                   came_from[neighbor] = current
    42  67.5938 MiB -23507.5000 MiB       13138                   g_score[neighbor] = temp_g_score
    43  67.5938 MiB -23507.6719 MiB       13138                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  67.5938 MiB -23507.9844 MiB       12902           if draw is not None:
    46                                                     draw()
    47                                                     
    48  67.5938 MiB -23507.9844 MiB       12902           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.4375 MiB   0.0000 MiB           1       paths = {}
    53  63.4531 MiB   0.0156 MiB           2       for goal in goals:
    54  63.4531 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.4531 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  65.2812 MiB  65.2812 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  65.2812 MiB -23.0000 MiB         129       for row in grid:
     8  65.2812 MiB -2957.6875 MiB       16512           for spot in row:
     9  65.2812 MiB -2934.7656 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  65.0938 MiB  -0.1875 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  65.0938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  65.0938 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  65.0938 MiB   0.0000 MiB           1       came_from = {}
    18  65.7344 MiB   0.6406 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  65.7344 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  65.7500 MiB -7174.8750 MiB        5237       while not open_set.empty():
    22  65.7500 MiB -7174.8750 MiB        5237           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  65.7500 MiB -7174.8906 MiB        5237           current = open_set.get()[1]
    28                                         
    29  65.7500 MiB -7174.9062 MiB        5237           if current in remaining_goals:
    30  63.4219 MiB  -2.3281 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.4219 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.4219 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  65.7500 MiB -63883.2344 MiB       46705           for neighbor in current.neighbors:
    35  65.7500 MiB -56709.0469 MiB       41469               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  65.7500 MiB -56709.6875 MiB       41469               if current.row != neighbor.row and current.col != neighbor.col:
    38  65.7500 MiB -28244.9062 MiB       20665                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  65.7500 MiB -56709.8594 MiB       41469               if temp_g_score < g_score[neighbor]:
    41  65.7500 MiB -7221.5312 MiB        5416                   came_from[neighbor] = current
    42  65.7500 MiB -7221.6875 MiB        5416                   g_score[neighbor] = temp_g_score
    43  65.7500 MiB -7221.7344 MiB        5416                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  65.7500 MiB -7174.8594 MiB        5236           if draw is not None:
    46                                                     draw()
    47                                                     
    48  65.7500 MiB -7174.8594 MiB        5236           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.4219 MiB   0.0000 MiB           1       paths = {}
    53  63.4219 MiB   0.0000 MiB           2       for goal in goals:
    54  63.4219 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.4219 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.7812 MiB  63.7812 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  64.3438 MiB   0.0000 MiB         129       for row in grid:
     8  64.3438 MiB   0.0000 MiB       16512           for spot in row:
     9  64.3438 MiB   0.5625 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  64.3438 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  64.3438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  64.3438 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  64.3438 MiB   0.0000 MiB           1       came_from = {}
    18  65.3281 MiB   0.9844 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  65.3281 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  65.3594 MiB -307966.6094 MiB       15299       while not open_set.empty():
    22  65.3594 MiB -307967.5312 MiB       15299           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  65.3594 MiB -307968.4531 MiB       15299           current = open_set.get()[1]
    28                                         
    29  65.3594 MiB -307969.0781 MiB       15299           if current in remaining_goals:
    30  37.6094 MiB -27.7500 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  37.6094 MiB   0.0000 MiB           1               if not remaining_goals:
    32  37.6094 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  65.3594 MiB -2748770.9219 MiB      136512           for neighbor in current.neighbors:
    35  65.3594 MiB -2440811.7031 MiB      121214               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  65.3594 MiB -2440815.3906 MiB      121214               if current.row != neighbor.row and current.col != neighbor.col:
    38  65.3594 MiB -1216650.6250 MiB       60413                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  65.3594 MiB -2440821.7344 MiB      121214               if temp_g_score < g_score[neighbor]:
    41  65.3594 MiB -307186.4219 MiB       15417                   came_from[neighbor] = current
    42  65.3594 MiB -307188.1562 MiB       15417                   g_score[neighbor] = temp_g_score
    43  65.3594 MiB -307189.3906 MiB       15417                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  65.3594 MiB -307964.6094 MiB       15298           if draw is not None:
    46                                                     draw()
    47                                                     
    48  65.3594 MiB -307965.5625 MiB       15298           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  37.6250 MiB   0.0156 MiB           1       paths = {}
    53  37.6406 MiB   0.0156 MiB           2       for goal in goals:
    54  37.6406 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  37.6562 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  61.7812 MiB  61.7812 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  61.7812 MiB -10.6094 MiB         129       for row in grid:
     8  61.7812 MiB -1357.4531 MiB       16512           for spot in row:
     9  61.7812 MiB -1346.9531 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  61.6719 MiB  -0.1094 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  61.6875 MiB   0.0156 MiB           1       open_set = PriorityQueue()
    16  61.6875 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  61.6875 MiB   0.0000 MiB           1       came_from = {}
    18  62.3281 MiB   0.6406 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  62.3281 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  62.5312 MiB   0.0000 MiB        5862       while not open_set.empty():
    22  62.5312 MiB   0.0000 MiB        5862           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  62.5312 MiB   0.0000 MiB        5862           current = open_set.get()[1]
    28                                         
    29  62.5312 MiB   0.0000 MiB        5862           if current in remaining_goals:
    30  62.5312 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  62.5312 MiB   0.0000 MiB           1               if not remaining_goals:
    32  62.5312 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  62.5312 MiB   0.0000 MiB       52647           for neighbor in current.neighbors:
    35  62.5312 MiB   0.0000 MiB       46786               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  62.5312 MiB   0.0000 MiB       46786               if current.row != neighbor.row and current.col != neighbor.col:
    38  62.5312 MiB   0.0000 MiB       23376                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  62.5312 MiB   0.0000 MiB       46786               if temp_g_score < g_score[neighbor]:
    41  62.5312 MiB   0.2031 MiB        6178                   came_from[neighbor] = current
    42  62.5312 MiB   0.0000 MiB        6178                   g_score[neighbor] = temp_g_score
    43  62.5312 MiB   0.0000 MiB        6178                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  62.5312 MiB   0.0000 MiB        5861           if draw is not None:
    46                                                     draw()
    47                                                     
    48  62.5312 MiB   0.0000 MiB        5861           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  62.5312 MiB   0.0000 MiB           1       paths = {}
    53  62.5312 MiB   0.0000 MiB           2       for goal in goals:
    54  62.5312 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  62.5312 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  62.6875 MiB  62.6875 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  62.6875 MiB -13.2812 MiB         129       for row in grid:
     8  62.6875 MiB -1698.7500 MiB       16512           for spot in row:
     9  62.6875 MiB -1685.4688 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  62.5312 MiB  -0.1562 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  62.5312 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  62.5312 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  62.5312 MiB   0.0000 MiB           1       came_from = {}
    18  63.4062 MiB   0.8750 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  63.4062 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  63.4688 MiB -74.4531 MiB        8826       while not open_set.empty():
    22  63.4688 MiB -74.4531 MiB        8826           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  63.4688 MiB -74.4531 MiB        8826           current = open_set.get()[1]
    28                                         
    29  63.4688 MiB -74.4531 MiB        8826           if current in remaining_goals:
    30  63.4219 MiB  -0.0469 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.4219 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.4219 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  63.4688 MiB -661.7656 MiB       78936           for neighbor in current.neighbors:
    35  63.4688 MiB -587.3125 MiB       70111               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  63.4688 MiB -587.3125 MiB       70111               if current.row != neighbor.row and current.col != neighbor.col:
    38  63.4688 MiB -292.3281 MiB       34974                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  63.4688 MiB -587.3438 MiB       70111               if temp_g_score < g_score[neighbor]:
    41  63.4688 MiB -73.0312 MiB        9087                   came_from[neighbor] = current
    42  63.4688 MiB -73.0938 MiB        9087                   g_score[neighbor] = temp_g_score
    43  63.4688 MiB -73.0938 MiB        9087                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  63.4688 MiB -74.4531 MiB        8825           if draw is not None:
    46                                                     draw()
    47                                                     
    48  63.4688 MiB -74.4531 MiB        8825           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.4219 MiB   0.0000 MiB           1       paths = {}
    53  63.4219 MiB   0.0000 MiB           2       for goal in goals:
    54  63.4219 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.4219 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  64.0156 MiB  64.0156 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  64.0156 MiB   0.0000 MiB         129       for row in grid:
     8  64.0156 MiB   0.0000 MiB       16512           for spot in row:
     9  64.0156 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  64.0156 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  64.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  64.0156 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  64.0156 MiB   0.0000 MiB           1       came_from = {}
    18  64.2656 MiB   0.2500 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.2656 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.2812 MiB -1919.5781 MiB        5393       while not open_set.empty():
    22  64.2812 MiB -1919.5781 MiB        5393           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.2812 MiB -1919.5781 MiB        5393           current = open_set.get()[1]
    28                                         
    29  64.2812 MiB -1919.5781 MiB        5393           if current in remaining_goals:
    30  64.2188 MiB  -0.0625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  64.2188 MiB   0.0000 MiB           1               if not remaining_goals:
    32  64.2188 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.2812 MiB -17134.4531 MiB       48076           for neighbor in current.neighbors:
    35  64.2812 MiB -15215.0938 MiB       42684               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.2812 MiB -15215.3281 MiB       42684               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.2812 MiB -7584.1094 MiB       21267                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.2812 MiB -15215.3438 MiB       42684               if temp_g_score < g_score[neighbor]:
    41  64.2812 MiB -1966.9062 MiB        5579                   came_from[neighbor] = current
    42  64.2812 MiB -1966.9219 MiB        5579                   g_score[neighbor] = temp_g_score
    43  64.2812 MiB -1966.9219 MiB        5579                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.2812 MiB -1919.5781 MiB        5392           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.2812 MiB -1919.5781 MiB        5392           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  64.2188 MiB   0.0000 MiB           1       paths = {}
    53  64.2188 MiB   0.0000 MiB           2       for goal in goals:
    54  64.2188 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  64.2188 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  64.4219 MiB  64.4219 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  64.4219 MiB  -0.1719 MiB         129       for row in grid:
     8  64.4219 MiB -22.1094 MiB       16512           for spot in row:
     9  64.4219 MiB -21.9375 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  64.4062 MiB  -0.0156 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  64.4062 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  64.4062 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  64.4062 MiB   0.0000 MiB           1       came_from = {}
    18  64.5781 MiB   0.1719 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.5781 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.5781 MiB -2754.2656 MiB        3355       while not open_set.empty():
    22  64.5781 MiB -2754.2656 MiB        3355           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.5781 MiB -2754.3281 MiB        3355           current = open_set.get()[1]
    28                                         
    29  64.5781 MiB -2754.3281 MiB        3355           if current in remaining_goals:
    30  63.7031 MiB  -0.8750 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.7031 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.7031 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.5781 MiB -24524.4844 MiB       29812           for neighbor in current.neighbors:
    35  64.5781 MiB -21770.5938 MiB       26458               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.5781 MiB -21770.8750 MiB       26458               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.5781 MiB -10843.9062 MiB       13167                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.5781 MiB -21770.9219 MiB       26458               if temp_g_score < g_score[neighbor]:
    41  64.5781 MiB -2817.9844 MiB        3495                   came_from[neighbor] = current
    42  64.5781 MiB -2818.0469 MiB        3495                   g_score[neighbor] = temp_g_score
    43  64.5781 MiB -2818.1562 MiB        3495                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.5781 MiB -2754.2031 MiB        3354           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.5781 MiB -2754.2031 MiB        3354           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.7031 MiB   0.0000 MiB           1       paths = {}
    53  63.7031 MiB   0.0000 MiB           2       for goal in goals:
    54  63.7031 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.7031 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  64.6094 MiB  64.6094 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  64.6094 MiB   0.0000 MiB         129       for row in grid:
     8  64.6094 MiB   0.0000 MiB       16512           for spot in row:
     9  64.6094 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  64.6094 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  64.6094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  64.6094 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  64.6094 MiB   0.0000 MiB           1       came_from = {}
    18  65.2031 MiB   0.5938 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  65.2031 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  65.2031 MiB -51235.7812 MiB       12555       while not open_set.empty():
    22  65.2031 MiB -51236.5625 MiB       12555           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  65.2031 MiB -51237.5938 MiB       12555           current = open_set.get()[1]
    28                                         
    29  65.2031 MiB -51238.0781 MiB       12555           if current in remaining_goals:
    30  53.5312 MiB -11.6719 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  53.5312 MiB   0.0000 MiB           1               if not remaining_goals:
    32  53.5312 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  65.2031 MiB -455528.7188 MiB      112255           for neighbor in current.neighbors:
    35  65.2031 MiB -404298.3906 MiB       99701               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  65.2031 MiB -404299.6406 MiB       99701               if current.row != neighbor.row and current.col != neighbor.col:
    38  65.2031 MiB -201232.7656 MiB       49729                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  65.2031 MiB -404300.8281 MiB       99701               if temp_g_score < g_score[neighbor]:
    41  65.2031 MiB -50205.2344 MiB       12790                   came_from[neighbor] = current
    42  65.2031 MiB -50205.2500 MiB       12790                   g_score[neighbor] = temp_g_score
    43  65.2031 MiB -50205.3906 MiB       12790                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  65.2031 MiB -51233.2812 MiB       12554           if draw is not None:
    46                                                     draw()
    47                                                     
    48  65.2031 MiB -51235.2031 MiB       12554           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  53.5312 MiB   0.0000 MiB           1       paths = {}
    53  53.5312 MiB   0.0000 MiB           2       for goal in goals:
    54  53.5312 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  53.5312 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  55.2812 MiB  55.2812 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  55.5000 MiB   0.0000 MiB         129       for row in grid:
     8  55.5000 MiB   0.0000 MiB       16512           for spot in row:
     9  55.5000 MiB   0.2188 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  55.5000 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  55.5156 MiB   0.0156 MiB           1       open_set = PriorityQueue()
    16  55.5156 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  55.5156 MiB   0.0000 MiB           1       came_from = {}
    18  56.3750 MiB   0.8594 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  56.3750 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  56.5000 MiB   0.0000 MiB        4010       while not open_set.empty():
    22  56.5000 MiB   0.0000 MiB        4010           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  56.5000 MiB   0.0000 MiB        4010           current = open_set.get()[1]
    28                                         
    29  56.5000 MiB   0.0000 MiB        4010           if current in remaining_goals:
    30  56.5000 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  56.5000 MiB   0.0000 MiB           1               if not remaining_goals:
    32  56.5000 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  56.5000 MiB   0.0000 MiB       36081           for neighbor in current.neighbors:
    35  56.5000 MiB   0.0000 MiB       32072               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  56.5000 MiB   0.0000 MiB       32072               if current.row != neighbor.row and current.col != neighbor.col:
    38  56.5000 MiB   0.0000 MiB       16036                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  56.5000 MiB   0.0000 MiB       32072               if temp_g_score < g_score[neighbor]:
    41  56.5000 MiB   0.1250 MiB        4312                   came_from[neighbor] = current
    42  56.5000 MiB   0.0000 MiB        4312                   g_score[neighbor] = temp_g_score
    43  56.5000 MiB   0.0000 MiB        4312                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  56.5000 MiB   0.0000 MiB        4009           if draw is not None:
    46                                                     draw()
    47                                                     
    48  56.5000 MiB   0.0000 MiB        4009           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  56.5000 MiB   0.0000 MiB           1       paths = {}
    53  56.5000 MiB   0.0000 MiB           2       for goal in goals:
    54  56.5000 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  56.5156 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  64.9219 MiB  64.9219 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  64.9219 MiB -149.1875 MiB         129       for row in grid:
     8  64.9219 MiB -19125.7031 MiB       16512           for spot in row:
     9  64.9219 MiB -18977.4062 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.7188 MiB  -1.2031 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.7188 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.7188 MiB   0.0000 MiB           1       came_from = {}
    18  64.3750 MiB -38.9844 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.2500 MiB  -0.1250 MiB           1       g_score[start] = 0
    20                                         
    21  64.2500 MiB -223.9844 MiB        2676       while not open_set.empty():
    22  64.2500 MiB -223.9844 MiB        2676           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.2500 MiB -224.1250 MiB        2676           current = open_set.get()[1]
    28                                         
    29  64.2500 MiB -224.2500 MiB        2676           if current in remaining_goals:
    30  63.9219 MiB  -0.3281 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.9219 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.9219 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.2500 MiB -2004.6719 MiB       23832           for neighbor in current.neighbors:
    35  64.2500 MiB -1780.6875 MiB       21157               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.2500 MiB -1780.7500 MiB       21157               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.2500 MiB -888.6250 MiB       10538                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.2500 MiB -1780.7812 MiB       21157               if temp_g_score < g_score[neighbor]:
    41  64.2500 MiB -230.9531 MiB        2849                   came_from[neighbor] = current
    42  64.2500 MiB -230.9531 MiB        2849                   g_score[neighbor] = temp_g_score
    43  64.2500 MiB -230.9531 MiB        2849                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.2500 MiB -223.9844 MiB        2675           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.2500 MiB -223.9844 MiB        2675           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.9219 MiB   0.0000 MiB           1       paths = {}
    53  63.9219 MiB   0.0000 MiB           2       for goal in goals:
    54  63.9219 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.9219 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.9688 MiB  63.9688 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.9844 MiB   0.0000 MiB         129       for row in grid:
     8  63.9844 MiB   0.0000 MiB       16512           for spot in row:
     9  63.9844 MiB   0.0156 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.9844 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.9844 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.9844 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.9844 MiB   0.0000 MiB           1       came_from = {}
    18  64.2969 MiB   0.3125 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.4531 MiB -693.4531 MiB        9486       while not open_set.empty():
    22  64.4531 MiB -693.4531 MiB        9486           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.4531 MiB -693.4531 MiB        9486           current = open_set.get()[1]
    28                                         
    29  64.4531 MiB -693.4531 MiB        9486           if current in remaining_goals:
    30  64.4531 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  64.4531 MiB   0.0000 MiB           1               if not remaining_goals:
    32  64.4531 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.4531 MiB -6199.3125 MiB       84686           for neighbor in current.neighbors:
    35  64.4531 MiB -5505.9844 MiB       75201               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.4531 MiB -5506.0000 MiB       75201               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.4531 MiB -2746.1562 MiB       37488                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.4531 MiB -5506.0000 MiB       75201               if temp_g_score < g_score[neighbor]:
    41  64.4531 MiB -717.3438 MiB        9691                   came_from[neighbor] = current
    42  64.4531 MiB -717.5000 MiB        9691                   g_score[neighbor] = temp_g_score
    43  64.4531 MiB -717.5000 MiB        9691                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.4531 MiB -693.4531 MiB        9485           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.4531 MiB -693.4531 MiB        9485           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  64.4531 MiB   0.0000 MiB           1       paths = {}
    53  64.4531 MiB   0.0000 MiB           2       for goal in goals:
    54  64.4531 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  64.4531 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.5312 MiB  63.5312 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.5312 MiB   0.0000 MiB         129       for row in grid:
     8  63.5312 MiB   0.0000 MiB       16512           for spot in row:
     9  63.5312 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.5312 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.5312 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.5312 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.5312 MiB   0.0000 MiB           1       came_from = {}
    18  64.1719 MiB   0.6406 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.1719 MiB   0.0000 MiB        2457       while not open_set.empty():
    22  64.1719 MiB   0.0000 MiB        2457           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.1719 MiB   0.0000 MiB        2457           current = open_set.get()[1]
    28                                         
    29  64.1719 MiB   0.0000 MiB        2457           if current in remaining_goals:
    30  64.1719 MiB   0.0000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  64.1719 MiB   0.0000 MiB           1               if not remaining_goals:
    32  64.1719 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.1719 MiB   0.0000 MiB       21900           for neighbor in current.neighbors:
    35  64.1719 MiB   0.0000 MiB       19444               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.1719 MiB   0.0000 MiB       19444               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.1719 MiB   0.0000 MiB        9688                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.1719 MiB   0.0000 MiB       19444               if temp_g_score < g_score[neighbor]:
    41  64.1719 MiB   0.0000 MiB        2623                   came_from[neighbor] = current
    42  64.1719 MiB   0.0000 MiB        2623                   g_score[neighbor] = temp_g_score
    43  64.1719 MiB   0.0000 MiB        2623                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.1719 MiB   0.0000 MiB        2456           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.1719 MiB   0.0000 MiB        2456           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  64.1719 MiB   0.0000 MiB           1       paths = {}
    53  64.1719 MiB   0.0000 MiB           2       for goal in goals:
    54  64.1719 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  64.1719 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  64.3125 MiB  64.3125 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  64.3125 MiB   0.0000 MiB         129       for row in grid:
     8  64.3125 MiB   0.0000 MiB       16512           for spot in row:
     9  64.3125 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  64.3125 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  64.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  64.3125 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  64.3125 MiB   0.0000 MiB           1       came_from = {}
    18  64.5938 MiB   0.2812 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.5938 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.5938 MiB -3797.0781 MiB        5653       while not open_set.empty():
    22  64.5938 MiB -3797.0781 MiB        5653           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.5938 MiB -3797.0781 MiB        5653           current = open_set.get()[1]
    28                                         
    29  64.5938 MiB -3797.0781 MiB        5653           if current in remaining_goals:
    30  63.8594 MiB  -0.7344 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.8594 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.8594 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.5938 MiB -34014.8125 MiB       50709           for neighbor in current.neighbors:
    35  64.5938 MiB -30218.2812 MiB       45057               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.5938 MiB -30218.3750 MiB       45057               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.5938 MiB -15084.0312 MiB       22502                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.5938 MiB -30218.7656 MiB       45057               if temp_g_score < g_score[neighbor]:
    41  64.5938 MiB -3901.2969 MiB        5944                   came_from[neighbor] = current
    42  64.5938 MiB -3901.2969 MiB        5944                   g_score[neighbor] = temp_g_score
    43  64.5938 MiB -3901.2969 MiB        5944                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.5938 MiB -3797.0781 MiB        5652           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.5938 MiB -3797.0781 MiB        5652           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.8594 MiB   0.0000 MiB           1       paths = {}
    53  63.8594 MiB   0.0000 MiB           2       for goal in goals:
    54  63.8594 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.8594 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.9062 MiB  63.9062 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  64.5000 MiB   0.0000 MiB         129       for row in grid:
     8  64.5000 MiB   0.0000 MiB       16512           for spot in row:
     9  64.5000 MiB   0.5938 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  64.5000 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  64.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  64.5000 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  64.5000 MiB   0.0000 MiB           1       came_from = {}
    18  64.8438 MiB   0.3438 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  64.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.8438 MiB -16182.4531 MiB       13707       while not open_set.empty():
    22  64.8438 MiB -16182.4531 MiB       13707           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.8438 MiB -16182.4531 MiB       13707           current = open_set.get()[1]
    28                                         
    29  64.8438 MiB -16182.4531 MiB       13707           if current in remaining_goals:
    30  63.2500 MiB  -1.5938 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.2500 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.2500 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.8438 MiB -144648.4219 MiB      122391           for neighbor in current.neighbors:
    35  64.8438 MiB -128466.8594 MiB      108685               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.8438 MiB -128467.2500 MiB      108685               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.8438 MiB -64072.2656 MiB       54183                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.8438 MiB -128467.5625 MiB      108685               if temp_g_score < g_score[neighbor]:
    41  64.8438 MiB -16265.0312 MiB       13894                   came_from[neighbor] = current
    42  64.8438 MiB -16265.0469 MiB       13894                   g_score[neighbor] = temp_g_score
    43  64.8438 MiB -16265.0938 MiB       13894                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.8438 MiB -16182.1719 MiB       13706           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.8438 MiB -16182.4531 MiB       13706           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.2500 MiB   0.0000 MiB           1       paths = {}
    53  63.2656 MiB   0.0000 MiB           2       for goal in goals:
    54  63.2656 MiB   0.0156 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.2656 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  66.9531 MiB  66.9531 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  66.9531 MiB   0.0000 MiB         129       for row in grid:
     8  66.9531 MiB   0.0000 MiB       16512           for spot in row:
     9  66.9531 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  66.9531 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  66.9531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  66.9531 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  66.9531 MiB   0.0000 MiB           1       came_from = {}
    18  67.6562 MiB   0.7031 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  67.6562 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  67.7031 MiB -8859.5781 MiB       11343       while not open_set.empty():
    22  67.7031 MiB -8859.5781 MiB       11343           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  67.7031 MiB -8859.7344 MiB       11343           current = open_set.get()[1]
    28                                         
    29  67.7031 MiB -8859.7656 MiB       11343           if current in remaining_goals:
    30  66.3594 MiB  -1.3438 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  66.3594 MiB   0.0000 MiB           1               if not remaining_goals:
    32  66.3594 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  67.7031 MiB -79188.7188 MiB      101730           for neighbor in current.neighbors:
    35  67.7031 MiB -70330.0781 MiB       90388               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  67.7031 MiB -70330.2656 MiB       90388               if current.row != neighbor.row and current.col != neighbor.col:
    38  67.7031 MiB -35075.0156 MiB       45136                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  67.7031 MiB -70330.5469 MiB       90388               if temp_g_score < g_score[neighbor]:
    41  67.7031 MiB -8867.0938 MiB       11703                   came_from[neighbor] = current
    42  67.7031 MiB -8867.1406 MiB       11703                   g_score[neighbor] = temp_g_score
    43  67.7031 MiB -8867.1406 MiB       11703                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  67.7031 MiB -8859.5781 MiB       11342           if draw is not None:
    46                                                     draw()
    47                                                     
    48  67.7031 MiB -8859.5781 MiB       11342           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  66.3594 MiB   0.0000 MiB           1       paths = {}
    53  66.3750 MiB   0.0156 MiB           2       for goal in goals:
    54  66.3750 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  66.3750 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  66.7969 MiB  66.7969 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  66.8906 MiB   0.0000 MiB         129       for row in grid:
     8  66.8906 MiB   0.0000 MiB       16512           for spot in row:
     9  66.8906 MiB   0.0938 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  66.8906 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  66.8906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  66.8906 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  66.8906 MiB   0.0000 MiB           1       came_from = {}
    18  67.1875 MiB   0.2969 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  67.1875 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  67.2031 MiB -1405.3281 MiB       13627       while not open_set.empty():
    22  67.2031 MiB -1405.7031 MiB       13627           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  67.2031 MiB -1405.9062 MiB       13627           current = open_set.get()[1]
    28                                         
    29  67.2031 MiB -1405.9062 MiB       13627           if current in remaining_goals:
    30  66.6094 MiB  -0.5938 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  66.6094 MiB   0.0000 MiB           1               if not remaining_goals:
    32  66.6094 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  67.2031 MiB -12544.8594 MiB      121754           for neighbor in current.neighbors:
    35  67.2031 MiB -11139.6406 MiB      108128               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  67.2031 MiB -11139.6406 MiB      108128               if current.row != neighbor.row and current.col != neighbor.col:
    38  67.2031 MiB -5552.9531 MiB       53918                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  67.2031 MiB -11139.6719 MiB      108128               if temp_g_score < g_score[neighbor]:
    41  67.2031 MiB -1396.6875 MiB       13841                   came_from[neighbor] = current
    42  67.2031 MiB -1396.7031 MiB       13841                   g_score[neighbor] = temp_g_score
    43  67.2031 MiB -1396.7031 MiB       13841                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  67.2031 MiB -1405.3281 MiB       13626           if draw is not None:
    46                                                     draw()
    47                                                     
    48  67.2031 MiB -1405.3281 MiB       13626           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  66.6094 MiB   0.0000 MiB           1       paths = {}
    53  66.6094 MiB   0.0000 MiB           2       for goal in goals:
    54  66.6094 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  66.6094 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  67.4531 MiB  67.4531 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  67.4531 MiB -11.5938 MiB         129       for row in grid:
     8  67.4531 MiB -1490.5625 MiB       16512           for spot in row:
     9  67.4531 MiB -1479.1875 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  67.2344 MiB  -0.2188 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  67.2344 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  67.2344 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  67.2344 MiB   0.0000 MiB           1       came_from = {}
    18  67.2812 MiB   0.0469 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  67.2812 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  67.2812 MiB -41374.9062 MiB        8902       while not open_set.empty():
    22  67.2812 MiB -41375.4844 MiB        8902           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  67.2812 MiB -41376.0938 MiB        8902           current = open_set.get()[1]
    28                                         
    29  67.2812 MiB -41376.1719 MiB        8902           if current in remaining_goals:
    30  57.6562 MiB  -9.6250 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  57.6562 MiB   0.0000 MiB           1               if not remaining_goals:
    32  57.6562 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  67.2812 MiB -369421.1875 MiB       79501           for neighbor in current.neighbors:
    35  67.2812 MiB -328047.5781 MiB       70600               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  67.2812 MiB -328050.2969 MiB       70600               if current.row != neighbor.row and current.col != neighbor.col:
    38  67.2812 MiB -163549.9688 MiB       35199                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  67.2812 MiB -328052.9688 MiB       70600               if temp_g_score < g_score[neighbor]:
    41  67.2812 MiB -41602.2344 MiB        9124                   came_from[neighbor] = current
    42  67.2812 MiB -41602.4531 MiB        9124                   g_score[neighbor] = temp_g_score
    43  67.2812 MiB -41602.8125 MiB        9124                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  67.2812 MiB -41374.9062 MiB        8901           if draw is not None:
    46                                                     draw()
    47                                                     
    48  67.2812 MiB -41374.9062 MiB        8901           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  57.6562 MiB   0.0000 MiB           1       paths = {}
    53  57.7031 MiB   0.0000 MiB           2       for goal in goals:
    54  57.7031 MiB   0.0469 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  57.7188 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  61.8750 MiB  61.8750 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  61.9375 MiB   0.0000 MiB         129       for row in grid:
     8  61.9375 MiB   0.0000 MiB       16512           for spot in row:
     9  61.9375 MiB   0.0625 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  61.9375 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  61.9531 MiB   0.0156 MiB           1       open_set = PriorityQueue()
    16  61.9531 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  61.9531 MiB   0.0000 MiB           1       came_from = {}
    18  62.2656 MiB   0.3125 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  62.2656 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  62.2969 MiB -13370.2656 MiB        7164       while not open_set.empty():
    22  62.2969 MiB -13370.5938 MiB        7164           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  62.2969 MiB -13371.3438 MiB        7164           current = open_set.get()[1]
    28                                         
    29  62.2969 MiB -13371.3750 MiB        7164           if current in remaining_goals:
    30  60.0000 MiB  -2.2969 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  60.0000 MiB   0.0000 MiB           1               if not remaining_goals:
    32  60.0000 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  62.2969 MiB -119706.8438 MiB       64215           for neighbor in current.neighbors:
    35  62.2969 MiB -106337.1250 MiB       57052               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  62.2969 MiB -106337.5625 MiB       57052               if current.row != neighbor.row and current.col != neighbor.col:
    38  62.2969 MiB -53066.0625 MiB       28484                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  62.2969 MiB -106337.7188 MiB       57052               if temp_g_score < g_score[neighbor]:
    41  62.2969 MiB -13609.6875 MiB        7462                   came_from[neighbor] = current
    42  62.2969 MiB -13609.8594 MiB        7462                   g_score[neighbor] = temp_g_score
    43  62.2969 MiB -13609.9062 MiB        7462                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  62.2969 MiB -13370.1094 MiB        7163           if draw is not None:
    46                                                     draw()
    47                                                     
    48  62.2969 MiB -13370.1094 MiB        7163           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  60.0000 MiB   0.0000 MiB           1       paths = {}
    53  60.0000 MiB   0.0000 MiB           2       for goal in goals:
    54  60.0000 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  60.0000 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5  63.1562 MiB  63.1562 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7  63.1562 MiB   0.0000 MiB         129       for row in grid:
     8  63.1562 MiB   0.0000 MiB       16512           for spot in row:
     9  63.1562 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  63.1562 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  63.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16  63.1562 MiB   0.0000 MiB           1       open_set.put((0, start))
    17  63.1562 MiB   0.0000 MiB           1       came_from = {}
    18  63.8125 MiB   0.6562 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    19  63.8125 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21  64.4531 MiB -1139.4688 MiB        8715       while not open_set.empty():
    22  64.4531 MiB -1139.4688 MiB        8715           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  64.4531 MiB -1139.6250 MiB        8715           current = open_set.get()[1]
    28                                         
    29  64.4531 MiB -1139.6250 MiB        8715           if current in remaining_goals:
    30  63.5469 MiB  -0.9062 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  63.5469 MiB   0.0000 MiB           1               if not remaining_goals:
    32  63.5469 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  64.4531 MiB -10135.2812 MiB       77994           for neighbor in current.neighbors:
    35  64.4531 MiB -8996.1875 MiB       69280               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  64.4531 MiB -8996.2656 MiB       69280               if current.row != neighbor.row and current.col != neighbor.col:
    38  64.4531 MiB -4479.3750 MiB       34568                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  64.4531 MiB -8996.3750 MiB       69280               if temp_g_score < g_score[neighbor]:
    41  64.4531 MiB -1122.9531 MiB        8989                   came_from[neighbor] = current
    42  64.4531 MiB -1123.6094 MiB        8989                   g_score[neighbor] = temp_g_score
    43  64.4531 MiB -1123.7500 MiB        8989                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  64.4531 MiB -1139.3125 MiB        8714           if draw is not None:
    46                                                     draw()
    47                                                     
    48  64.4531 MiB -1139.4531 MiB        8714           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  63.5469 MiB   0.0000 MiB           1       paths = {}
    53  63.5469 MiB   0.0000 MiB           2       for goal in goals:
    54  63.5469 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  63.5469 MiB   0.0000 MiB           1       return paths


