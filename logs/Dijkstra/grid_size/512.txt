Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 134.0469 MiB 134.0469 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/512.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 148.9375 MiB -68.9062 MiB         513       for row in grid:
     8 148.9688 MiB -34350.9375 MiB      262656           for spot in row:
     9 148.9688 MiB -34268.9375 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 147.5312 MiB  -1.4062 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 147.5312 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 147.5469 MiB   0.0156 MiB           1       open_set.put((0, start))
    17 147.5469 MiB   0.0000 MiB           1       came_from = {}
    18 171.6250 MiB -167863.9844 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 164.7188 MiB  -6.9062 MiB           1       g_score[start] = 0
    20                                         
    21 165.7969 MiB -13045324.2969 MiB      180541       while not open_set.empty():
    22 165.7969 MiB -13045326.4688 MiB      180541           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 165.7969 MiB -13045334.4375 MiB      180541           current = open_set.get()[1]
    28                                         
    29 165.7969 MiB -13045337.2500 MiB      180541           if current in remaining_goals:
    30  98.2344 MiB -67.5625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  98.2344 MiB   0.0000 MiB           1               if not remaining_goals:
    32  98.2344 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 165.7969 MiB -117240123.7188 MiB     1622071           for neighbor in current.neighbors:
    35 165.7969 MiB -104194852.0625 MiB     1441531               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 165.7969 MiB -104194827.7031 MiB     1441531               if current.row != neighbor.row and current.col != neighbor.col:
    38 165.7969 MiB -52069616.7656 MiB      720301                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 165.7969 MiB -104194858.5938 MiB     1441531               if temp_g_score < g_score[neighbor]:
    41 165.7969 MiB -13094234.8906 MiB      181552                   came_from[neighbor] = current
    42 165.7969 MiB -13094241.9219 MiB      181552                   g_score[neighbor] = temp_g_score
    43 165.7969 MiB -13094247.9531 MiB      181552                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 165.7969 MiB -13045300.4375 MiB      180540           if draw is not None:
    46                                                     draw()
    47                                                     
    48 165.7969 MiB -13045309.5625 MiB      180540           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  98.2344 MiB   0.0000 MiB           1       paths = {}
    53  99.9062 MiB   0.0000 MiB           2       for goal in goals:
    54  99.9062 MiB   1.6719 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  99.9062 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 248.1250 MiB 248.1250 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 255.2500 MiB -5581.2812 MiB         513       for row in grid:
     8 255.2656 MiB -2857377.5781 MiB      262656           for spot in row:
     9 255.2656 MiB -2851781.0000 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 249.3750 MiB  -5.8750 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 249.3750 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 249.3750 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 249.3906 MiB   0.0156 MiB           1       came_from = {}
    18 268.3438 MiB -240085.7969 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 266.9062 MiB  -1.4375 MiB           1       g_score[start] = 0
    20                                         
    21 267.0938 MiB -13018645.5938 MiB       98634       while not open_set.empty():
    22 267.0938 MiB -13018650.4844 MiB       98634           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 267.0938 MiB -13018659.6719 MiB       98634           current = open_set.get()[1]
    28                                         
    29 267.0938 MiB -13018665.6094 MiB       98634           if current in remaining_goals:
    30  89.7969 MiB -177.2969 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  89.7969 MiB   0.0000 MiB           1               if not remaining_goals:
    32  89.7969 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 267.0938 MiB -116934713.5000 MiB      885748           for neighbor in current.neighbors:
    35 267.0938 MiB -103916136.9062 MiB      787115               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 267.0938 MiB -103916163.1250 MiB      787115               if current.row != neighbor.row and current.col != neighbor.col:
    38 267.0938 MiB -51919668.0781 MiB      393233                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 267.0938 MiB -103916227.6719 MiB      787115               if temp_g_score < g_score[neighbor]:
    41 267.0938 MiB -13082809.5781 MiB       99411                   came_from[neighbor] = current
    42 267.0938 MiB -13082814.4062 MiB       99411                   g_score[neighbor] = temp_g_score
    43 267.0938 MiB -13082823.2344 MiB       99411                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 267.0938 MiB -13018631.0625 MiB       98633           if draw is not None:
    46                                                     draw()
    47                                                     
    48 267.0938 MiB -13018639.5469 MiB       98633           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  89.7969 MiB   0.0000 MiB           1       paths = {}
    53  89.9531 MiB   0.0000 MiB           2       for goal in goals:
    54  89.9531 MiB   0.1562 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  89.9531 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 242.9062 MiB 242.9062 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 254.5312 MiB  -1.2656 MiB         513       for row in grid:
     8 254.5312 MiB -660.8906 MiB      262656           for spot in row:
     9 254.5312 MiB -648.1094 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 254.5312 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 254.5312 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 254.5312 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 254.5312 MiB   0.0000 MiB           1       came_from = {}
    18 276.1719 MiB  21.6406 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 276.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 276.3750 MiB -36807848.8906 MiB      248227       while not open_set.empty():
    22 276.3750 MiB -36807855.5781 MiB      248227           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 276.3750 MiB -36807868.3906 MiB      248227           current = open_set.get()[1]
    28                                         
    29 276.3750 MiB -36807874.4844 MiB      248227           if current in remaining_goals:
    30  69.2812 MiB -207.0938 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  69.2812 MiB   0.0000 MiB           1               if not remaining_goals:
    32  69.2812 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 276.3750 MiB -330517565.2656 MiB     2229215           for neighbor in current.neighbors:
    35 276.3750 MiB -293709795.5938 MiB     1980989               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 276.3750 MiB -293709797.2969 MiB     1980989               if current.row != neighbor.row and current.col != neighbor.col:
    38 276.3750 MiB -146729926.6094 MiB      989692                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 276.3750 MiB -293709874.1250 MiB     1980989               if temp_g_score < g_score[neighbor]:
    41 276.3750 MiB -36751739.5781 MiB      248664                   came_from[neighbor] = current
    42 276.3750 MiB -36751747.3906 MiB      248664                   g_score[neighbor] = temp_g_score
    43 276.3750 MiB -36751763.8906 MiB      248664                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 276.3750 MiB -36807831.5781 MiB      248226           if draw is not None:
    46                                                     draw()
    47                                                     
    48 276.3750 MiB -36807840.4688 MiB      248226           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  69.2812 MiB   0.0000 MiB           1       paths = {}
    53  72.8906 MiB   0.0000 MiB           2       for goal in goals:
    54  72.8906 MiB   3.6094 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  72.9375 MiB   0.0469 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 250.5156 MiB 250.5156 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 259.5156 MiB -50.8281 MiB         513       for row in grid:
     8 259.5156 MiB -26137.7500 MiB      262656           for spot in row:
     9 259.5156 MiB -26078.5938 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 258.1094 MiB  -1.4062 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 258.1094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 258.1094 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 258.1094 MiB   0.0000 MiB           1       came_from = {}
    18 270.3594 MiB -391898.1719 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 270.3594 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 270.3750 MiB -10218246.8906 MiB       97065       while not open_set.empty():
    22 270.3750 MiB -10218250.6250 MiB       97065           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 270.3750 MiB -10218262.9844 MiB       97065           current = open_set.get()[1]
    28                                         
    29 270.3750 MiB -10218267.3438 MiB       97065           if current in remaining_goals:
    30 101.6406 MiB -168.7344 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 101.6406 MiB   0.0000 MiB           1               if not remaining_goals:
    32 101.6406 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 270.3750 MiB -91752045.7031 MiB      871786           for neighbor in current.neighbors:
    35 270.3750 MiB -81533851.0938 MiB      774722               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 270.3750 MiB -81533868.0781 MiB      774722               if current.row != neighbor.row and current.col != neighbor.col:
    38 270.3750 MiB -40731899.7656 MiB      387063                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 270.3750 MiB -81533923.8594 MiB      774722               if temp_g_score < g_score[neighbor]:
    41 270.3750 MiB -10239687.3594 MiB       97861                   came_from[neighbor] = current
    42 270.3750 MiB -10239691.8906 MiB       97861                   g_score[neighbor] = temp_g_score
    43 270.3750 MiB -10239698.7188 MiB       97861                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 270.3750 MiB -10218236.2969 MiB       97064           if draw is not None:
    46                                                     draw()
    47                                                     
    48 270.3750 MiB -10218240.9688 MiB       97064           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 101.6406 MiB   0.0000 MiB           1       paths = {}
    53 101.9375 MiB   0.0000 MiB           2       for goal in goals:
    54 101.9375 MiB   0.2969 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 101.9375 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 249.2812 MiB 249.2812 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 254.0469 MiB -426.0312 MiB         513       for row in grid:
     8 254.0469 MiB -219246.7344 MiB      262656           for spot in row:
     9 254.0469 MiB -218813.4062 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 254.0469 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 254.0469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 254.0469 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 254.0469 MiB   0.0000 MiB           1       came_from = {}
    18 272.1719 MiB -128417.6406 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 272.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 272.6406 MiB -12120010.0000 MiB      104005       while not open_set.empty():
    22 272.6406 MiB -12120014.6719 MiB      104005           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 272.6406 MiB -12120024.3750 MiB      104005           current = open_set.get()[1]
    28                                         
    29 272.6406 MiB -12120029.0625 MiB      104005           if current in remaining_goals:
    30 106.3906 MiB -166.2500 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 106.3906 MiB   0.0000 MiB           1               if not remaining_goals:
    32 106.3906 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 272.6406 MiB -109024728.0000 MiB      935676           for neighbor in current.neighbors:
    35 272.6406 MiB -96904769.7031 MiB      831672               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 272.6406 MiB -96904787.2500 MiB      831672               if current.row != neighbor.row and current.col != neighbor.col:
    38 272.6406 MiB -48443412.2031 MiB      415776                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 272.6406 MiB -96904847.9219 MiB      831672               if temp_g_score < g_score[neighbor]:
    41 272.6406 MiB -12218191.5312 MiB      105377                   came_from[neighbor] = current
    42 272.6406 MiB -12218196.5938 MiB      105377                   g_score[neighbor] = temp_g_score
    43 272.6406 MiB -12218203.8125 MiB      105377                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 272.6406 MiB -12119999.0469 MiB      104004           if draw is not None:
    46                                                     draw()
    47                                                     
    48 272.6406 MiB -12120004.0938 MiB      104004           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 106.3906 MiB   0.0000 MiB           1       paths = {}
    53 106.6719 MiB   0.0000 MiB           2       for goal in goals:
    54 106.6719 MiB   0.2812 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 106.6875 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 243.9688 MiB 243.9688 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 247.0938 MiB -961.1250 MiB         513       for row in grid:
     8 247.0938 MiB -493524.6719 MiB      262656           for spot in row:
     9 247.0938 MiB -492558.9062 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 247.0938 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 247.0938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 247.0938 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 247.0938 MiB   0.0000 MiB           1       came_from = {}
    18 260.8125 MiB -2476418.7656 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 218.0156 MiB -42.7969 MiB           1       g_score[start] = 0
    20                                         
    21 219.8438 MiB -2141596.0938 MiB       18209       while not open_set.empty():
    22 219.8438 MiB -2141600.4375 MiB       18209           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 219.8438 MiB -2141619.0781 MiB       18209           current = open_set.get()[1]
    28                                         
    29 219.8438 MiB -2141622.8750 MiB       18209           if current in remaining_goals:
    30 146.7969 MiB -73.0469 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 146.7969 MiB   0.0000 MiB           1               if not remaining_goals:
    32 146.7969 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 219.8438 MiB -19274087.6875 MiB      163872           for neighbor in current.neighbors:
    35 219.8438 MiB -17132528.5000 MiB      145664               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 219.8438 MiB -17132540.1719 MiB      145664               if current.row != neighbor.row and current.col != neighbor.col:
    38 219.8438 MiB -8566281.6250 MiB       72832                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 219.8438 MiB -17132573.3438 MiB      145664               if temp_g_score < g_score[neighbor]:
    41 219.8438 MiB -2199675.4375 MiB       18847                   came_from[neighbor] = current
    42 219.8438 MiB -2199678.5781 MiB       18847                   g_score[neighbor] = temp_g_score
    43 219.8438 MiB -2199682.5469 MiB       18847                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 219.8438 MiB -2141588.3750 MiB       18208           if draw is not None:
    46                                                     draw()
    47                                                     
    48 219.8438 MiB -2141591.8750 MiB       18208           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 146.8125 MiB   0.0156 MiB           1       paths = {}
    53 146.8750 MiB   0.0000 MiB           2       for goal in goals:
    54 146.8750 MiB   0.0625 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 146.9219 MiB   0.0469 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 254.2031 MiB 254.2031 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 258.2188 MiB -269.0000 MiB         513       for row in grid:
     8 258.2188 MiB -138144.5781 MiB      262656           for spot in row:
     9 258.2188 MiB -137870.8750 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 258.2188 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 258.2188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 258.2188 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 258.2188 MiB   0.0000 MiB           1       came_from = {}
    18 262.9062 MiB -1733264.6406 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 260.0000 MiB  -2.9062 MiB           1       g_score[start] = 0
    20                                         
    21 261.1094 MiB -32051713.1406 MiB      170184       while not open_set.empty():
    22 261.1094 MiB -32051720.4219 MiB      170184           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 261.1094 MiB -32051737.8125 MiB      170184           current = open_set.get()[1]
    28                                         
    29 261.1094 MiB -32051745.5625 MiB      170184           if current in remaining_goals:
    30  77.2812 MiB -183.8281 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  77.2812 MiB   0.0000 MiB           1               if not remaining_goals:
    32  77.2812 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 261.1094 MiB -287965396.0469 MiB     1529131           for neighbor in current.neighbors:
    35 261.1094 MiB -255913814.7656 MiB     1358948               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 261.1094 MiB -255913803.9531 MiB     1358948               if current.row != neighbor.row and current.col != neighbor.col:
    38 261.1094 MiB -127873931.2344 MiB      679055                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 261.1094 MiB -255913880.9531 MiB     1358948               if temp_g_score < g_score[neighbor]:
    41 261.1094 MiB -32177197.1250 MiB      171182                   came_from[neighbor] = current
    42 261.1094 MiB -32177203.7188 MiB      171182                   g_score[neighbor] = temp_g_score
    43 261.1094 MiB -32177215.7812 MiB      171182                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 261.1094 MiB -32051652.7344 MiB      170183           if draw is not None:
    46                                                     draw()
    47                                                     
    48 261.1094 MiB -32051662.3750 MiB      170183           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  77.2812 MiB   0.0000 MiB           1       paths = {}
    53  79.2500 MiB   0.0000 MiB           2       for goal in goals:
    54  79.2500 MiB   1.9688 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  79.2500 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 244.4531 MiB 244.4531 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 248.6719 MiB  -8.8906 MiB         513       for row in grid:
     8 248.6719 MiB -4587.0625 MiB      262656           for spot in row:
     9 248.6719 MiB -4573.8281 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 248.6719 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 248.6719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 248.6719 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 248.6719 MiB   0.0000 MiB           1       came_from = {}
    18 266.5625 MiB -238187.0000 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 260.5625 MiB  -6.0000 MiB           1       g_score[start] = 0
    20                                         
    21 261.3750 MiB -21415189.3281 MiB      151963       while not open_set.empty():
    22 261.3750 MiB -21415197.3906 MiB      151963           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 261.3750 MiB -21415209.8750 MiB      151963           current = open_set.get()[1]
    28                                         
    29 261.3750 MiB -21415215.6250 MiB      151963           if current in remaining_goals:
    30  75.3125 MiB -186.0625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  75.3125 MiB   0.0000 MiB           1               if not remaining_goals:
    32  75.3125 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 261.3750 MiB -192370324.6562 MiB     1365122           for neighbor in current.neighbors:
    35 261.3750 MiB -170955201.1562 MiB     1213160               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 261.3750 MiB -170955225.1406 MiB     1213160               if current.row != neighbor.row and current.col != neighbor.col:
    38 261.3750 MiB -85416979.8438 MiB      606158                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 261.3750 MiB -170955286.8906 MiB     1213160               if temp_g_score < g_score[neighbor]:
    41 261.3750 MiB -21456374.4688 MiB      152851                   came_from[neighbor] = current
    42 261.3750 MiB -21456380.4531 MiB      152851                   g_score[neighbor] = temp_g_score
    43 261.3750 MiB -21456389.9688 MiB      152851                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 261.3750 MiB -21415174.5469 MiB      151962           if draw is not None:
    46                                                     draw()
    47                                                     
    48 261.3750 MiB -21415180.4219 MiB      151962           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  75.3125 MiB   0.0000 MiB           1       paths = {}
    53  76.5156 MiB   0.0000 MiB           2       for goal in goals:
    54  76.5156 MiB   1.2031 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  76.5625 MiB   0.0469 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 242.7344 MiB 242.7344 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 242.7344 MiB -9707.1719 MiB         513       for row in grid:
     8 242.7344 MiB -4970031.4375 MiB      262656           for spot in row:
     9 242.7344 MiB -4960350.6719 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 200.7031 MiB -42.0312 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 200.7031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 200.7188 MiB   0.0156 MiB           1       open_set.put((0, start))
    17 200.7188 MiB   0.0000 MiB           1       came_from = {}
    18 229.0312 MiB  28.3125 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 229.0312 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 229.3438 MiB -5994622.7344 MiB       69860       while not open_set.empty():
    22 229.3438 MiB -5994625.5625 MiB       69860           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 229.3438 MiB -5994632.2188 MiB       69860           current = open_set.get()[1]
    28                                         
    29 229.3438 MiB -5994635.2188 MiB       69860           if current in remaining_goals:
    30 130.6094 MiB -98.7344 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 130.6094 MiB   0.0000 MiB           1               if not remaining_goals:
    32 130.6094 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 229.3438 MiB -53876562.3281 MiB      627984           for neighbor in current.neighbors:
    35 229.3438 MiB -47881971.2656 MiB      558125               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 229.3438 MiB -47881986.0312 MiB      558125               if current.row != neighbor.row and current.col != neighbor.col:
    38 229.3438 MiB -23928627.4062 MiB      278938                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 229.3438 MiB -47882019.3594 MiB      558125               if temp_g_score < g_score[neighbor]:
    41 229.3438 MiB -6044291.8906 MiB       70819                   came_from[neighbor] = current
    42 229.3438 MiB -6044295.1562 MiB       70819                   g_score[neighbor] = temp_g_score
    43 229.3438 MiB -6044300.3594 MiB       70819                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 229.3438 MiB -5994616.7188 MiB       69859           if draw is not None:
    46                                                     draw()
    47                                                     
    48 229.3438 MiB -5994619.5000 MiB       69859           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 130.6094 MiB   0.0000 MiB           1       paths = {}
    53 130.6719 MiB   0.0000 MiB           2       for goal in goals:
    54 130.6719 MiB   0.0625 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 130.6875 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 246.2031 MiB 246.2031 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 246.2031 MiB -47427.2812 MiB         513       for row in grid:
     8 246.2031 MiB -24278447.1719 MiB      262656           for spot in row:
     9 246.2031 MiB -24231161.9062 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  35.1406 MiB -211.0625 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  35.4844 MiB   0.3438 MiB           1       open_set = PriorityQueue()
    16  35.7031 MiB   0.2188 MiB           1       open_set.put((0, start))
    17  35.7188 MiB   0.0156 MiB           1       came_from = {}
    18  73.0938 MiB -98215.4375 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  73.1094 MiB   0.0156 MiB           1       g_score[start] = 0
    20                                         
    21 133.7812 MiB -2060201.1562 MiB       60891       while not open_set.empty():
    22 133.7812 MiB -2060203.5469 MiB       60891           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 133.7812 MiB -2060207.9844 MiB       60891           current = open_set.get()[1]
    28                                         
    29 133.7812 MiB -2060209.4531 MiB       60891           if current in remaining_goals:
    30  68.5000 MiB -65.2812 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  68.5000 MiB   0.0000 MiB           1               if not remaining_goals:
    32  68.5000 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 133.7812 MiB -18541439.6250 MiB      548010           for neighbor in current.neighbors:
    35 133.7812 MiB -16481308.3750 MiB      487120               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 133.7812 MiB -16481295.4531 MiB      487120               if current.row != neighbor.row and current.col != neighbor.col:
    38 133.7812 MiB -8240717.0469 MiB      243560                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 133.7812 MiB -16481327.4375 MiB      487120               if temp_g_score < g_score[neighbor]:
    41 133.7812 MiB -2083657.9062 MiB       62057                   came_from[neighbor] = current
    42 133.7812 MiB -2083661.6562 MiB       62057                   g_score[neighbor] = temp_g_score
    43 133.7812 MiB -2083665.6719 MiB       62057                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 133.7812 MiB -2060196.6719 MiB       60890           if draw is not None:
    46                                                     draw()
    47                                                     
    48 133.7812 MiB -2060198.9844 MiB       60890           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  68.5000 MiB   0.0000 MiB           1       paths = {}
    53  68.6562 MiB   0.0156 MiB           2       for goal in goals:
    54  68.6562 MiB   0.1406 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  68.6719 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 238.2031 MiB 238.2031 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 240.0156 MiB  -0.8750 MiB         513       for row in grid:
     8 240.0156 MiB -455.6250 MiB      262656           for spot in row:
     9 240.0156 MiB -452.9062 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 240.0156 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 240.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 240.0156 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 240.0156 MiB   0.0000 MiB           1       came_from = {}
    18 264.7188 MiB -37197.1875 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 264.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 266.0156 MiB -2391256.5781 MiB       38558       while not open_set.empty():
    22 266.0156 MiB -2391260.1406 MiB       38558           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 266.0156 MiB -2391269.1250 MiB       38558           current = open_set.get()[1]
    28                                         
    29 266.0156 MiB -2391272.8438 MiB       38558           if current in remaining_goals:
    30  58.8594 MiB -207.1562 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  58.8594 MiB   0.0000 MiB           1               if not remaining_goals:
    32  58.8594 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 266.0156 MiB -21456367.2344 MiB      346668           for neighbor in current.neighbors:
    35 266.0156 MiB -19065158.5000 MiB      308111               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 266.0156 MiB -19065190.9375 MiB      308111               if current.row != neighbor.row and current.col != neighbor.col:
    38 266.0156 MiB -9522129.7812 MiB      153998                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 266.0156 MiB -19065247.9375 MiB      308111               if temp_g_score < g_score[neighbor]:
    41 266.0156 MiB -2395777.9375 MiB       39343                   came_from[neighbor] = current
    42 266.0156 MiB -2395784.2344 MiB       39343                   g_score[neighbor] = temp_g_score
    43 266.0156 MiB -2395794.0781 MiB       39343                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 266.0156 MiB -2391247.4062 MiB       38557           if draw is not None:
    46                                                     draw()
    47                                                     
    48 266.0156 MiB -2391251.8750 MiB       38557           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  58.8594 MiB   0.0000 MiB           1       paths = {}
    53  59.0781 MiB   0.0000 MiB           2       for goal in goals:
    54  59.0781 MiB   0.2188 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  59.0938 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 244.9531 MiB 244.9531 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 245.4219 MiB -5872.6250 MiB         513       for row in grid:
     8 245.4219 MiB -2991413.0000 MiB      262656           for spot in row:
     9 245.4219 MiB -2985602.5000 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 158.6406 MiB -86.7812 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 158.9688 MiB   0.3281 MiB           1       open_set = PriorityQueue()
    16 159.1875 MiB   0.2188 MiB           1       open_set.put((0, start))
    17 159.2031 MiB   0.0156 MiB           1       came_from = {}
    18 165.4375 MiB -3244304.1875 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 106.4219 MiB -59.0156 MiB           1       g_score[start] = 0
    20                                         
    21 127.1562 MiB -5499635.7031 MiB      122082       while not open_set.empty():
    22 127.1562 MiB -5499638.2656 MiB      122082           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 127.1562 MiB -5499643.9844 MiB      122082           current = open_set.get()[1]
    28                                         
    29 127.1562 MiB -5499646.2031 MiB      122082           if current in remaining_goals:
    30  59.0938 MiB -68.0625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  59.0938 MiB   0.0000 MiB           1               if not remaining_goals:
    32  59.0938 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 127.1562 MiB -49407705.3125 MiB     1096585           for neighbor in current.neighbors:
    35 127.1562 MiB -43908127.6094 MiB      974504               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 127.1562 MiB -43908119.9062 MiB      974504               if current.row != neighbor.row and current.col != neighbor.col:
    38 127.1562 MiB -21939353.4375 MiB      486895                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 127.1562 MiB -43908158.1719 MiB      974504               if temp_g_score < g_score[neighbor]:
    41 127.1562 MiB -5517882.9219 MiB      122978                   came_from[neighbor] = current
    42 127.1562 MiB -5517886.4375 MiB      122978                   g_score[neighbor] = temp_g_score
    43 127.1562 MiB -5517895.1250 MiB      122978                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 127.1562 MiB -5499629.4375 MiB      122081           if draw is not None:
    46                                                     draw()
    47                                                     
    48 127.1562 MiB -5499632.5625 MiB      122081           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  59.0938 MiB   0.0000 MiB           1       paths = {}
    53  60.7656 MiB   0.0000 MiB           2       for goal in goals:
    54  60.7656 MiB   1.6719 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  60.7812 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 248.5312 MiB 248.5312 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 248.5312 MiB -35085.5312 MiB         513       for row in grid:
     8 248.5312 MiB -17958867.7188 MiB      262656           for spot in row:
     9 248.5312 MiB -17923876.0781 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 110.0469 MiB -138.4844 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 110.3750 MiB   0.3281 MiB           1       open_set = PriorityQueue()
    16 110.5781 MiB   0.2031 MiB           1       open_set.put((0, start))
    17 110.5781 MiB   0.0000 MiB           1       came_from = {}
    18 142.2188 MiB -3641.4375 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 142.2188 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 145.5469 MiB -7638855.8438 MiB      100248       while not open_set.empty():
    22 145.5469 MiB -7638863.3906 MiB      100248           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 145.5469 MiB -7638872.1562 MiB      100248           current = open_set.get()[1]
    28                                         
    29 145.5469 MiB -7638876.3438 MiB      100248           if current in remaining_goals:
    30  62.2344 MiB -83.3125 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  62.2344 MiB   0.0000 MiB           1               if not remaining_goals:
    32  62.2344 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 145.5469 MiB -68591878.0469 MiB      900343           for neighbor in current.neighbors:
    35 145.5469 MiB -60953078.5312 MiB      800096               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 145.5469 MiB -60953091.9844 MiB      800096               if current.row != neighbor.row and current.col != neighbor.col:
    38 145.5469 MiB -30450401.6406 MiB      399735                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 145.5469 MiB -60953138.8438 MiB      800096               if temp_g_score < g_score[neighbor]:
    41 145.5469 MiB -7661139.1719 MiB      101024                   came_from[neighbor] = current
    42 145.5469 MiB -7661143.0625 MiB      101024                   g_score[neighbor] = temp_g_score
    43 145.5469 MiB -7661148.6406 MiB      101024                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 145.5469 MiB -7638843.1875 MiB      100247           if draw is not None:
    46                                                     draw()
    47                                                     
    48 145.5469 MiB -7638846.6094 MiB      100247           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  62.2344 MiB   0.0000 MiB           1       paths = {}
    53  62.7812 MiB   0.0000 MiB           2       for goal in goals:
    54  62.7812 MiB   0.5469 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  62.7969 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 249.2344 MiB 249.2344 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 249.2344 MiB -59685.0625 MiB         513       for row in grid:
     8 249.2344 MiB -30571584.1875 MiB      262656           for spot in row:
     9 249.2344 MiB -30511982.0938 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 101.8125 MiB -147.4219 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 102.1562 MiB   0.3438 MiB           1       open_set = PriorityQueue()
    16 102.3750 MiB   0.2188 MiB           1       open_set.put((0, start))
    17 102.3750 MiB   0.0000 MiB           1       came_from = {}
    18 136.8125 MiB -329.8750 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 136.8125 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 159.9062 MiB -12652007.7969 MiB      226734       while not open_set.empty():
    22 159.9062 MiB -12652010.8281 MiB      226734           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 159.9062 MiB -12652017.7656 MiB      226734           current = open_set.get()[1]
    28                                         
    29 159.9062 MiB -12652021.2656 MiB      226734           if current in remaining_goals:
    30  93.5781 MiB -66.3281 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  93.5781 MiB   0.0000 MiB           1               if not remaining_goals:
    32  93.5781 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 159.9062 MiB -113647780.1406 MiB     2037472           for neighbor in current.neighbors:
    35 159.9062 MiB -100995836.7344 MiB     1810739               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 159.9062 MiB -100995792.3125 MiB     1810739               if current.row != neighbor.row and current.col != neighbor.col:
    38 159.9062 MiB -50461359.9062 MiB      904849                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 159.9062 MiB -100995849.7656 MiB     1810739               if temp_g_score < g_score[neighbor]:
    41 159.9062 MiB -12652659.4062 MiB      227735                   came_from[neighbor] = current
    42 159.9062 MiB -12652666.3750 MiB      227735                   g_score[neighbor] = temp_g_score
    43 159.9062 MiB -12652672.0938 MiB      227735                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 159.9062 MiB -12652000.7656 MiB      226733           if draw is not None:
    46                                                     draw()
    47                                                     
    48 159.9062 MiB -12652003.1562 MiB      226733           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  93.5781 MiB   0.0000 MiB           1       paths = {}
    53  93.8594 MiB   0.0000 MiB           2       for goal in goals:
    54  93.8594 MiB   0.2812 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  93.8750 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 255.0781 MiB 255.0781 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 255.3594 MiB -27.9062 MiB         513       for row in grid:
     8 255.3594 MiB -14299.6562 MiB      262656           for spot in row:
     9 255.3594 MiB -14271.4219 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 255.3594 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 255.3594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 255.3594 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 255.3594 MiB   0.0000 MiB           1       came_from = {}
    18 271.7656 MiB -359751.1250 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 271.7344 MiB  -0.0312 MiB           1       g_score[start] = 0
    20                                         
    21 271.7344 MiB -8825880.3906 MiB       69343       while not open_set.empty():
    22 271.7344 MiB -8825886.3594 MiB       69343           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 271.7344 MiB -8825897.3125 MiB       69343           current = open_set.get()[1]
    28                                         
    29 271.7344 MiB -8825900.7344 MiB       69343           if current in remaining_goals:
    30  74.1719 MiB -197.5625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  74.1719 MiB   0.0000 MiB           1               if not remaining_goals:
    32  74.1719 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 271.7344 MiB -79320433.6875 MiB      623343           for neighbor in current.neighbors:
    35 271.7344 MiB -70494601.1875 MiB      554001               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 271.7344 MiB -70494658.6094 MiB      554001               if current.row != neighbor.row and current.col != neighbor.col:
    38 271.7344 MiB -35228861.5156 MiB      276878                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 271.7344 MiB -70494753.8281 MiB      554001               if temp_g_score < g_score[neighbor]:
    41 271.7344 MiB -8892441.9219 MiB       70298                   came_from[neighbor] = current
    42 271.7344 MiB -8892445.3750 MiB       70298                   g_score[neighbor] = temp_g_score
    43 271.7344 MiB -8892453.3906 MiB       70298                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 271.7344 MiB -8825871.9844 MiB       69342           if draw is not None:
    46                                                     draw()
    47                                                     
    48 271.7344 MiB -8825875.2344 MiB       69342           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  74.1719 MiB   0.0000 MiB           1       paths = {}
    53  74.4062 MiB   0.0000 MiB           2       for goal in goals:
    54  74.4062 MiB   0.2344 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  74.4219 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 252.2031 MiB 252.2031 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 252.2031 MiB -10727.2812 MiB         513       for row in grid:
     8 252.2031 MiB -5493188.2500 MiB      262656           for spot in row:
     9 252.2031 MiB -5482478.5156 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 217.1719 MiB -35.0312 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 217.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 217.1719 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 217.1719 MiB   0.0000 MiB           1       came_from = {}
    18 238.9219 MiB -4638.3750 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 238.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 238.9531 MiB -16689138.2969 MiB      146304       while not open_set.empty():
    22 238.9531 MiB -16689141.4375 MiB      146304           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 238.9531 MiB -16689148.6562 MiB      146304           current = open_set.get()[1]
    28                                         
    29 238.9531 MiB -16689151.1875 MiB      146304           if current in remaining_goals:
    30 130.8594 MiB -108.0938 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 130.8594 MiB   0.0000 MiB           1               if not remaining_goals:
    32 130.8594 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 238.9531 MiB -149899729.8125 MiB     1314304           for neighbor in current.neighbors:
    35 238.9531 MiB -133210633.7031 MiB     1168001               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 238.9531 MiB -133210625.1562 MiB     1168001               if current.row != neighbor.row and current.col != neighbor.col:
    38 238.9531 MiB -66555152.7812 MiB      583597                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 238.9531 MiB -133210666.4531 MiB     1168001               if temp_g_score < g_score[neighbor]:
    41 238.9531 MiB -16767454.1406 MiB      147225                   came_from[neighbor] = current
    42 238.9531 MiB -16767457.1094 MiB      147225                   g_score[neighbor] = temp_g_score
    43 238.9531 MiB -16767495.3594 MiB      147225                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 238.9531 MiB -16689131.7812 MiB      146303           if draw is not None:
    46                                                     draw()
    47                                                     
    48 238.9531 MiB -16689134.2969 MiB      146303           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 130.8594 MiB   0.0000 MiB           1       paths = {}
    53 130.9688 MiB   0.0000 MiB           2       for goal in goals:
    54 130.9688 MiB   0.1094 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 130.9688 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 256.8438 MiB 256.8438 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 256.8438 MiB -8558.4844 MiB         513       for row in grid:
     8 256.8438 MiB -4385489.8594 MiB      262656           for spot in row:
     9 256.8438 MiB -4376946.7031 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 231.5625 MiB -25.2812 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 231.7656 MiB   0.2031 MiB           1       open_set = PriorityQueue()
    16 231.9688 MiB   0.2031 MiB           1       open_set.put((0, start))
    17 231.9688 MiB   0.0000 MiB           1       came_from = {}
    18 253.9375 MiB -66585.7969 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 253.2188 MiB  -0.7188 MiB           1       g_score[start] = 0
    20                                         
    21 253.4062 MiB -9897563.2031 MiB      117559       while not open_set.empty():
    22 253.4062 MiB -9897566.9062 MiB      117559           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 253.4062 MiB -9897572.0469 MiB      117559           current = open_set.get()[1]
    28                                         
    29 253.4062 MiB -9897585.0000 MiB      117559           if current in remaining_goals:
    30 150.9062 MiB -102.5000 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 150.9062 MiB   0.0000 MiB           1               if not remaining_goals:
    32 150.9062 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 253.4062 MiB -88927496.8750 MiB     1055854           for neighbor in current.neighbors:
    35 253.4062 MiB -79029980.2031 MiB      938296               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 253.4062 MiB -79029973.5156 MiB      938296               if current.row != neighbor.row and current.col != neighbor.col:
    38 253.4062 MiB -39490073.6406 MiB      468787                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 253.4062 MiB -79030008.9219 MiB      938296               if temp_g_score < g_score[neighbor]:
    41 253.4062 MiB -9936378.4062 MiB      118451                   came_from[neighbor] = current
    42 253.4062 MiB -9936380.2344 MiB      118451                   g_score[neighbor] = temp_g_score
    43 253.4062 MiB -9936384.8281 MiB      118451                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 253.4062 MiB -9897556.7500 MiB      117558           if draw is not None:
    46                                                     draw()
    47                                                     
    48 253.4062 MiB -9897559.6094 MiB      117558           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 150.9062 MiB   0.0000 MiB           1       paths = {}
    53 151.0156 MiB   0.0312 MiB           2       for goal in goals:
    54 151.0156 MiB   0.0781 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 151.0156 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 257.1562 MiB 257.1562 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 257.6094 MiB   0.0000 MiB         513       for row in grid:
     8 257.6094 MiB   0.0000 MiB      262656           for spot in row:
     9 257.6094 MiB   0.4531 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 257.6094 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 257.6094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 257.6094 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 257.6094 MiB   0.0000 MiB           1       came_from = {}
    18 270.9844 MiB  13.3750 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 270.9844 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 271.2812 MiB -22938205.5000 MiB      191235       while not open_set.empty():
    22 271.2812 MiB -22938218.5000 MiB      191235           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 271.2812 MiB -22938226.2344 MiB      191235           current = open_set.get()[1]
    28                                         
    29 271.2812 MiB -22938230.1406 MiB      191235           if current in remaining_goals:
    30  95.0312 MiB -176.2500 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  95.0312 MiB   0.0000 MiB           1               if not remaining_goals:
    32  95.0312 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 271.2812 MiB -206014989.5312 MiB     1717790           for neighbor in current.neighbors:
    35 271.2812 MiB -183076845.3906 MiB     1526556               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 271.2812 MiB -183076843.2656 MiB     1526556               if current.row != neighbor.row and current.col != neighbor.col:
    38 271.2812 MiB -91467374.5469 MiB      762726                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 271.2812 MiB -183076910.0781 MiB     1526556               if temp_g_score < g_score[neighbor]:
    41 271.2812 MiB -22916682.0469 MiB      192007                   came_from[neighbor] = current
    42 271.2812 MiB -22916690.3594 MiB      192007                   g_score[neighbor] = temp_g_score
    43 271.2812 MiB -22916697.2969 MiB      192007                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 271.2812 MiB -22938192.3125 MiB      191234           if draw is not None:
    46                                                     draw()
    47                                                     
    48 271.2812 MiB -22938196.8281 MiB      191234           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  95.0312 MiB   0.0000 MiB           1       paths = {}
    53  95.9219 MiB   0.0156 MiB           2       for goal in goals:
    54  95.9219 MiB   0.8750 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  95.9219 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 266.9219 MiB 266.9219 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 266.9531 MiB -69.5469 MiB         513       for row in grid:
     8 266.9531 MiB -35777.6875 MiB      262656           for spot in row:
     9 266.9531 MiB -35707.9531 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 266.9531 MiB   0.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 266.9531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 266.9531 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 266.9531 MiB   0.0000 MiB           1       came_from = {}
    18 278.9219 MiB -29461.2188 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 278.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 278.9375 MiB -19194095.5781 MiB      183032       while not open_set.empty():
    22 278.9375 MiB -19194102.2656 MiB      183032           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 278.9375 MiB -19194116.2500 MiB      183032           current = open_set.get()[1]
    28                                         
    29 278.9375 MiB -19194123.4375 MiB      183032           if current in remaining_goals:
    30 102.9844 MiB -175.9531 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 102.9844 MiB   0.0000 MiB           1               if not remaining_goals:
    32 102.9844 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 278.9375 MiB -172641144.1875 MiB     1646712           for neighbor in current.neighbors:
    35 278.9375 MiB -153447130.8750 MiB     1463681               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 278.9375 MiB -153447165.3750 MiB     1463681               if current.row != neighbor.row and current.col != neighbor.col:
    38 278.9375 MiB -76706111.5312 MiB      731746                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 278.9375 MiB -153447264.6719 MiB     1463681               if temp_g_score < g_score[neighbor]:
    41 278.9375 MiB -19304123.6875 MiB      184803                   came_from[neighbor] = current
    42 278.9375 MiB -19304132.1250 MiB      184803                   g_score[neighbor] = temp_g_score
    43 278.9375 MiB -19304146.9062 MiB      184803                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 278.9375 MiB -19194081.5625 MiB      183031           if draw is not None:
    46                                                     draw()
    47                                                     
    48 278.9375 MiB -19194088.5312 MiB      183031           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 102.9844 MiB   0.0000 MiB           1       paths = {}
    53 103.8281 MiB   0.0000 MiB           2       for goal in goals:
    54 103.8281 MiB   0.8438 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 103.8438 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 249.0312 MiB 249.0312 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 250.7188 MiB -49188.7188 MiB         513       for row in grid:
     8 250.7500 MiB -25178513.5469 MiB      262656           for spot in row:
     9 250.7500 MiB -25129438.8125 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  86.7188 MiB -164.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  87.0781 MiB   0.3594 MiB           1       open_set = PriorityQueue()
    16  87.2812 MiB   0.2031 MiB           1       open_set.put((0, start))
    17  87.2812 MiB   0.0000 MiB           1       came_from = {}
    18 126.1094 MiB  28.1719 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 126.1094 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 138.2969 MiB -5904807.2812 MiB      183856       while not open_set.empty():
    22 138.2969 MiB -5904811.9062 MiB      183856           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 138.2969 MiB -5904820.7812 MiB      183856           current = open_set.get()[1]
    28                                         
    29 138.2969 MiB -5904827.3750 MiB      183856           if current in remaining_goals:
    30 100.0469 MiB -38.2500 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 100.0469 MiB   0.0000 MiB           1               if not remaining_goals:
    32 100.0469 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 138.2969 MiB -53044416.7188 MiB     1651694           for neighbor in current.neighbors:
    35 138.2969 MiB -47139654.4531 MiB     1467839               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 138.2969 MiB -47139636.8125 MiB     1467839               if current.row != neighbor.row and current.col != neighbor.col:
    38 138.2969 MiB -23553415.3594 MiB      733420                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 138.2969 MiB -47139684.5000 MiB     1467839               if temp_g_score < g_score[neighbor]:
    41 138.2969 MiB -5915114.3594 MiB      184757                   came_from[neighbor] = current
    42 138.2969 MiB -5915129.0781 MiB      184757                   g_score[neighbor] = temp_g_score
    43 138.2969 MiB -5915134.6250 MiB      184757                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 138.2969 MiB -5904800.3281 MiB      183855           if draw is not None:
    46                                                     draw()
    47                                                     
    48 138.2969 MiB -5904803.6719 MiB      183855           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 100.0469 MiB   0.0000 MiB           1       paths = {}
    53 102.1562 MiB   0.0156 MiB           2       for goal in goals:
    54 102.1562 MiB   2.0938 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 102.1719 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 267.6406 MiB 267.6406 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 267.6406 MiB -903.6094 MiB         513       for row in grid:
     8 267.6406 MiB -459917.3281 MiB      262656           for spot in row:
     9 267.6406 MiB -459017.5625 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 259.7344 MiB  -7.9062 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 259.7344 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 259.7344 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 259.7344 MiB   0.0000 MiB           1       came_from = {}
    18 268.7031 MiB -127945.5625 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 268.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 269.5781 MiB -18613274.2500 MiB      131153       while not open_set.empty():
    22 269.5781 MiB -18613278.3281 MiB      131153           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 269.5781 MiB -18613285.7812 MiB      131153           current = open_set.get()[1]
    28                                         
    29 269.5781 MiB -18613289.4062 MiB      131153           if current in remaining_goals:
    30  96.2656 MiB -173.3125 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  96.2656 MiB   0.0000 MiB           1               if not remaining_goals:
    32  96.2656 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 269.5781 MiB -167160029.5938 MiB     1178218           for neighbor in current.neighbors:
    35 269.5781 MiB -148546801.4844 MiB     1047066               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 269.5781 MiB -148546802.7031 MiB     1047066               if current.row != neighbor.row and current.col != neighbor.col:
    38 269.5781 MiB -74213846.7188 MiB      523175                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 269.5781 MiB -148546854.3750 MiB     1047066               if temp_g_score < g_score[neighbor]:
    41 269.5781 MiB -18642449.8594 MiB      132039                   came_from[neighbor] = current
    42 269.5781 MiB -18642456.2031 MiB      132039                   g_score[neighbor] = temp_g_score
    43 269.5781 MiB -18642475.2656 MiB      132039                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 269.5781 MiB -18613265.0000 MiB      131152           if draw is not None:
    46                                                     draw()
    47                                                     
    48 269.5781 MiB -18613269.0312 MiB      131152           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  96.2656 MiB   0.0000 MiB           1       paths = {}
    53  96.5000 MiB   0.0000 MiB           2       for goal in goals:
    54  96.5000 MiB   0.2344 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  96.5000 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 258.3750 MiB 258.3750 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 258.3750 MiB -4879.1406 MiB         513       for row in grid:
     8 258.3750 MiB -2493619.9688 MiB      262656           for spot in row:
     9 258.3750 MiB -2488759.1562 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 227.8125 MiB -30.5625 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 228.0156 MiB   0.2031 MiB           1       open_set = PriorityQueue()
    16 228.2188 MiB   0.2031 MiB           1       open_set.put((0, start))
    17 228.2188 MiB   0.0000 MiB           1       came_from = {}
    18 231.5938 MiB -31371830.6562 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  69.2812 MiB -162.3125 MiB           1       g_score[start] = 0
    20                                         
    21 134.6562 MiB -10222028.8281 MiB      193911       while not open_set.empty():
    22 134.6562 MiB -10222031.8750 MiB      193911           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 134.6562 MiB -10222038.4375 MiB      193911           current = open_set.get()[1]
    28                                         
    29 134.6562 MiB -10222041.9375 MiB      193911           if current in remaining_goals:
    30  76.7344 MiB -57.9219 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  76.7344 MiB   0.0000 MiB           1               if not remaining_goals:
    32  76.7344 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 134.6562 MiB -91815495.7656 MiB     1741709           for neighbor in current.neighbors:
    35 134.6562 MiB -81593560.1250 MiB     1547799               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 134.6562 MiB -81593521.2969 MiB     1547799               if current.row != neighbor.row and current.col != neighbor.col:
    38 134.6562 MiB -40766459.2031 MiB      773320                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 134.6562 MiB -81593573.0469 MiB     1547799               if temp_g_score < g_score[neighbor]:
    41 134.6562 MiB -10229722.3750 MiB      194632                   came_from[neighbor] = current
    42 134.6562 MiB -10229729.9531 MiB      194632                   g_score[neighbor] = temp_g_score
    43 134.6562 MiB -10229739.3594 MiB      194632                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 134.6562 MiB -10222020.6094 MiB      193910           if draw is not None:
    46                                                     draw()
    47                                                     
    48 134.6562 MiB -10222023.7500 MiB      193910           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  76.7344 MiB   0.0000 MiB           1       paths = {}
    53  79.2656 MiB   0.0000 MiB           2       for goal in goals:
    54  79.2656 MiB   2.5312 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  79.3125 MiB   0.0469 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 259.0469 MiB 259.0469 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 259.0469 MiB -610.9219 MiB         513       for row in grid:
     8 259.0469 MiB -312862.4531 MiB      262656           for spot in row:
     9 259.0469 MiB -312252.2344 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 257.7500 MiB  -1.2969 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 257.7500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 257.7500 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 257.7500 MiB   0.0000 MiB           1       came_from = {}
    18 269.5781 MiB -17951.4062 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 269.5781 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 269.5938 MiB -14051035.7812 MiB       94125       while not open_set.empty():
    22 269.5938 MiB -14051041.1406 MiB       94125           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 269.5938 MiB -14051052.7500 MiB       94125           current = open_set.get()[1]
    28                                         
    29 269.5938 MiB -14051058.2656 MiB       94125           if current in remaining_goals:
    30  72.9219 MiB -196.6719 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  72.9219 MiB   0.0000 MiB           1               if not remaining_goals:
    32  72.9219 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 269.5938 MiB -126253929.5781 MiB      845392           for neighbor in current.neighbors:
    35 269.5938 MiB -112202961.7969 MiB      751268               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 269.5938 MiB -112202989.0312 MiB      751268               if current.row != neighbor.row and current.col != neighbor.col:
    38 269.5938 MiB -56067662.2031 MiB      375347                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 269.5938 MiB -112203067.7969 MiB      751268               if temp_g_score < g_score[neighbor]:
    41 269.5938 MiB -14120705.5156 MiB       95003                   came_from[neighbor] = current
    42 269.5938 MiB -14120711.6094 MiB       95003                   g_score[neighbor] = temp_g_score
    43 269.5938 MiB -14120727.3750 MiB       95003                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 269.5938 MiB -14051023.1719 MiB       94124           if draw is not None:
    46                                                     draw()
    47                                                     
    48 269.5938 MiB -14051029.1406 MiB       94124           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  72.9219 MiB   0.0000 MiB           1       paths = {}
    53  73.2656 MiB   0.0000 MiB           2       for goal in goals:
    54  73.2656 MiB   0.3438 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  73.2656 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 260.3281 MiB 260.3281 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 260.3281 MiB -3664.4062 MiB         513       for row in grid:
     8 260.3281 MiB -1876988.9375 MiB      262656           for spot in row:
     9 260.3281 MiB -1873331.2344 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 250.6406 MiB  -9.6875 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 250.6406 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 250.6562 MiB   0.0156 MiB           1       open_set.put((0, start))
    17 250.6562 MiB   0.0000 MiB           1       came_from = {}
    18 266.5938 MiB -5243.0469 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 266.5938 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 266.5938 MiB -35853400.9531 MiB      235793       while not open_set.empty():
    22 266.5938 MiB -35853406.9688 MiB      235793           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 266.5938 MiB -35853417.7031 MiB      235793           current = open_set.get()[1]
    28                                         
    29 266.5938 MiB -35853423.6719 MiB      235793           if current in remaining_goals:
    30  80.4062 MiB -186.1875 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  80.4062 MiB   0.0000 MiB           1               if not remaining_goals:
    32  80.4062 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 266.5938 MiB -322010359.9688 MiB     2118337           for neighbor in current.neighbors:
    35 266.5938 MiB -286157035.8594 MiB     1882545               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 266.5938 MiB -286157011.8906 MiB     1882545               if current.row != neighbor.row and current.col != neighbor.col:
    38 266.5938 MiB -142967203.8906 MiB      940641                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 266.5938 MiB -286157089.4219 MiB     1882545               if temp_g_score < g_score[neighbor]:
    41 266.5938 MiB -35835021.5000 MiB      236572                   came_from[neighbor] = current
    42 266.5938 MiB -35835029.2031 MiB      236572                   g_score[neighbor] = temp_g_score
    43 266.5938 MiB -35835042.0469 MiB      236572                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 266.5938 MiB -35853384.3438 MiB      235792           if draw is not None:
    46                                                     draw()
    47                                                     
    48 266.5938 MiB -35853394.1562 MiB      235792           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  80.4062 MiB   0.0000 MiB           1       paths = {}
    53  82.2031 MiB   0.0000 MiB           2       for goal in goals:
    54  82.2031 MiB   1.7969 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  82.2031 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 260.0156 MiB 260.0156 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 260.0156 MiB -3854.5625 MiB         513       for row in grid:
     8 260.0156 MiB -1974351.9062 MiB      262656           for spot in row:
     9 260.0156 MiB -1970507.3750 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 245.1094 MiB -14.9062 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 245.1094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 245.1094 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 245.1094 MiB   0.0000 MiB           1       came_from = {}
    18 249.0938 MiB -9539270.0469 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  44.7031 MiB -204.3906 MiB           1       g_score[start] = 0
    20                                         
    21 130.9375 MiB -11956201.9844 MiB      219674       while not open_set.empty():
    22 130.9375 MiB -11956205.8906 MiB      219674           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 130.9375 MiB -11956215.7812 MiB      219674           current = open_set.get()[1]
    28                                         
    29 130.9375 MiB -11956222.9062 MiB      219674           if current in remaining_goals:
    30  76.5312 MiB -54.4062 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  76.5312 MiB   0.0000 MiB           1               if not remaining_goals:
    32  76.5312 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 130.9375 MiB -107428407.5625 MiB     1973470           for neighbor in current.neighbors:
    35 130.9375 MiB -95472335.9219 MiB     1753797               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 130.9375 MiB -95472278.1719 MiB     1753797               if current.row != neighbor.row and current.col != neighbor.col:
    38 130.9375 MiB -47706712.9531 MiB      876301                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 130.9375 MiB -95472329.1562 MiB     1753797               if temp_g_score < g_score[neighbor]:
    41 130.9375 MiB -11983901.7500 MiB      220521                   came_from[neighbor] = current
    42 130.9375 MiB -11983906.8750 MiB      220521                   g_score[neighbor] = temp_g_score
    43 130.9375 MiB -11983914.6406 MiB      220521                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 130.9375 MiB -11956192.6250 MiB      219673           if draw is not None:
    46                                                     draw()
    47                                                     
    48 130.9375 MiB -11956197.5781 MiB      219673           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  76.5312 MiB   0.0000 MiB           1       paths = {}
    53  79.5000 MiB   0.0000 MiB           2       for goal in goals:
    54  79.5000 MiB   2.9688 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  79.5156 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 259.7969 MiB 259.7969 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 259.7969 MiB -6759.3438 MiB         513       for row in grid:
     8 259.7969 MiB -3461594.1250 MiB      262656           for spot in row:
     9 259.7969 MiB -3454845.8438 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 242.9062 MiB -16.8906 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 243.1094 MiB   0.2031 MiB           1       open_set = PriorityQueue()
    16 243.3281 MiB   0.2188 MiB           1       open_set.put((0, start))
    17 243.3281 MiB   0.0000 MiB           1       came_from = {}
    18 260.4062 MiB -118253.7188 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 258.3438 MiB  -2.0625 MiB           1       g_score[start] = 0
    20                                         
    21 258.4688 MiB -21006789.4844 MiB      119436       while not open_set.empty():
    22 258.4688 MiB -21006795.2344 MiB      119436           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 258.4688 MiB -21006805.7500 MiB      119436           current = open_set.get()[1]
    28                                         
    29 258.4688 MiB -21006810.3281 MiB      119436           if current in remaining_goals:
    30  87.7969 MiB -170.6719 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  87.7969 MiB   0.0000 MiB           1               if not remaining_goals:
    32  87.7969 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 258.4688 MiB -188733727.1562 MiB     1072921           for neighbor in current.neighbors:
    35 258.4688 MiB -167727024.8750 MiB      953486               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 258.4688 MiB -167727045.5469 MiB      953486               if current.row != neighbor.row and current.col != neighbor.col:
    38 258.4688 MiB -83809288.8750 MiB      476411                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 258.4688 MiB -167727129.6250 MiB      953486               if temp_g_score < g_score[neighbor]:
    41 258.4688 MiB -21145476.6875 MiB      120390                   came_from[neighbor] = current
    42 258.4688 MiB -21145481.2344 MiB      120390                   g_score[neighbor] = temp_g_score
    43 258.4688 MiB -21145489.4688 MiB      120390                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 258.4688 MiB -21006777.8125 MiB      119435           if draw is not None:
    46                                                     draw()
    47                                                     
    48 258.4688 MiB -21006783.4219 MiB      119435           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  87.7969 MiB   0.0000 MiB           1       paths = {}
    53  89.1094 MiB   0.0000 MiB           2       for goal in goals:
    54  89.1094 MiB   1.3125 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  89.1406 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 253.3125 MiB 253.3125 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 253.3125 MiB -822.4219 MiB         513       for row in grid:
     8 253.3125 MiB -415096.7031 MiB      262656           for spot in row:
     9 253.3125 MiB -414287.8594 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 232.9688 MiB -20.3438 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 232.9688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 232.9688 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 232.9688 MiB   0.0000 MiB           1       came_from = {}
    18 245.7188 MiB -219657.0000 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 245.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 245.7344 MiB -19260607.5625 MiB      133196       while not open_set.empty():
    22 245.7344 MiB -19260612.1875 MiB      133196           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 245.7344 MiB -19260622.8906 MiB      133196           current = open_set.get()[1]
    28                                         
    29 245.7344 MiB -19260628.4375 MiB      133196           if current in remaining_goals:
    30  94.5000 MiB -151.2344 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  94.5000 MiB   0.0000 MiB           1               if not remaining_goals:
    32  94.5000 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 245.7344 MiB -173119631.2188 MiB     1197363           for neighbor in current.neighbors:
    35 245.7344 MiB -153859091.1250 MiB     1064168               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 245.7344 MiB -153859089.6562 MiB     1064168               if current.row != neighbor.row and current.col != neighbor.col:
    38 245.7344 MiB -76892094.4531 MiB      531852                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 245.7344 MiB -153859184.7812 MiB     1064168               if temp_g_score < g_score[neighbor]:
    41 245.7344 MiB -19361705.3750 MiB      134376                   came_from[neighbor] = current
    42 245.7344 MiB -19361711.1719 MiB      134376                   g_score[neighbor] = temp_g_score
    43 245.7344 MiB -19361720.3125 MiB      134376                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 245.7344 MiB -19260595.2656 MiB      133195           if draw is not None:
    46                                                     draw()
    47                                                     
    48 245.7344 MiB -19260601.1094 MiB      133195           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  94.5000 MiB   0.0000 MiB           1       paths = {}
    53  94.7031 MiB   0.0156 MiB           2       for goal in goals:
    54  94.7031 MiB   0.1875 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  94.7031 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 259.3750 MiB 259.3750 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 259.3750 MiB -1742.5312 MiB         513       for row in grid:
     8 259.3750 MiB -890918.5781 MiB      262656           for spot in row:
     9 259.3750 MiB -889181.1406 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 252.5312 MiB  -6.8438 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 252.5312 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 252.5312 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 252.5312 MiB   0.0000 MiB           1       came_from = {}
    18 267.6875 MiB  15.1562 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 267.6875 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 268.2656 MiB -877327.5312 MiB       66399       while not open_set.empty():
    22 268.2656 MiB -877328.6406 MiB       66399           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 268.2656 MiB -877329.9062 MiB       66399           current = open_set.get()[1]
    28                                         
    29 268.2656 MiB -877330.2812 MiB       66399           if current in remaining_goals:
    30 246.7812 MiB -21.4844 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 246.7812 MiB   0.0000 MiB           1               if not remaining_goals:
    32 246.7812 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 268.2656 MiB -7876629.2969 MiB      596029           for neighbor in current.neighbors:
    35 268.2656 MiB -6999308.4688 MiB      529631               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 268.2656 MiB -6999312.1719 MiB      529631               if current.row != neighbor.row and current.col != neighbor.col:
    38 268.2656 MiB -3496469.3594 MiB      264557                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 268.2656 MiB -6999321.5312 MiB      529631               if temp_g_score < g_score[neighbor]:
    41 268.2656 MiB -880699.7031 MiB       67026                   came_from[neighbor] = current
    42 268.2656 MiB -880700.6719 MiB       67026                   g_score[neighbor] = temp_g_score
    43 268.2656 MiB -880701.1094 MiB       67026                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 268.2656 MiB -877325.7656 MiB       66398           if draw is not None:
    46                                                     draw()
    47                                                     
    48 268.2656 MiB -877326.2188 MiB       66398           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 246.7812 MiB   0.0000 MiB           1       paths = {}
    53 246.7812 MiB   0.0000 MiB           2       for goal in goals:
    54 246.7812 MiB   0.0000 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 246.7812 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 264.4688 MiB 264.4688 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 264.4688 MiB -1606.7969 MiB         513       for row in grid:
     8 264.4688 MiB -821612.3594 MiB      262656           for spot in row:
     9 264.4688 MiB -820009.4219 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 258.5625 MiB  -5.9062 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 258.5625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 258.5625 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 258.5625 MiB   0.0000 MiB           1       came_from = {}
    18 268.7656 MiB  10.2031 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 268.7656 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 269.4062 MiB -14628610.6406 MiB      151759       while not open_set.empty():
    22 269.4062 MiB -14628613.7031 MiB      151759           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 269.4062 MiB -14628621.2344 MiB      151759           current = open_set.get()[1]
    28                                         
    29 269.4062 MiB -14628625.4688 MiB      151759           if current in remaining_goals:
    30 141.8125 MiB -127.5938 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 141.8125 MiB   0.0000 MiB           1               if not remaining_goals:
    32 141.8125 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 269.4062 MiB -131480305.2812 MiB     1363270           for neighbor in current.neighbors:
    35 269.4062 MiB -116851733.9062 MiB     1211512               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 269.4062 MiB -116851754.2500 MiB     1211512               if current.row != neighbor.row and current.col != neighbor.col:
    38 269.4062 MiB -58396540.9375 MiB      605331                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 269.4062 MiB -116851796.8594 MiB     1211512               if temp_g_score < g_score[neighbor]:
    41 269.4062 MiB -14687918.2969 MiB      152697                   came_from[neighbor] = current
    42 269.4062 MiB -14687922.3750 MiB      152697                   g_score[neighbor] = temp_g_score
    43 269.4062 MiB -14687929.0625 MiB      152697                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 269.4062 MiB -14628602.8281 MiB      151758           if draw is not None:
    46                                                     draw()
    47                                                     
    48 269.4062 MiB -14628606.8125 MiB      151758           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 141.8125 MiB   0.0000 MiB           1       paths = {}
    53 142.2969 MiB   0.0000 MiB           2       for goal in goals:
    54 142.2969 MiB   0.4844 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 142.3281 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 258.3125 MiB 258.3125 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 258.3281 MiB -4557.0625 MiB         513       for row in grid:
     8 258.3281 MiB -2331390.8125 MiB      262656           for spot in row:
     9 258.3281 MiB -2326845.2031 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 242.2812 MiB -16.0469 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 242.2812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 242.2812 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 242.2812 MiB   0.0000 MiB           1       came_from = {}
    18 251.2344 MiB -6715.9375 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 251.2344 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 251.5625 MiB -2168359.6875 MiB       55333       while not open_set.empty():
    22 251.5625 MiB -2168361.8750 MiB       55333           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 251.5625 MiB -2168366.8594 MiB       55333           current = open_set.get()[1]
    28                                         
    29 251.5625 MiB -2168369.3281 MiB       55333           if current in remaining_goals:
    30 157.4688 MiB -94.0938 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 157.4688 MiB   0.0000 MiB           1               if not remaining_goals:
    32 157.4688 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 251.5625 MiB -19485460.4062 MiB      496896           for neighbor in current.neighbors:
    35 251.5625 MiB -17317126.2656 MiB      441564               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 251.5625 MiB -17317140.9219 MiB      441564               if current.row != neighbor.row and current.col != neighbor.col:
    38 251.5625 MiB -8653771.1406 MiB      220600                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 251.5625 MiB -17317169.3438 MiB      441564               if temp_g_score < g_score[neighbor]:
    41 251.5625 MiB -2187679.6094 MiB       56121                   came_from[neighbor] = current
    42 251.5625 MiB -2187682.7031 MiB       56121                   g_score[neighbor] = temp_g_score
    43 251.5625 MiB -2187687.1094 MiB       56121                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 251.5625 MiB -2168353.7500 MiB       55332           if draw is not None:
    46                                                     draw()
    47                                                     
    48 251.5625 MiB -2168356.6875 MiB       55332           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 157.4688 MiB   0.0000 MiB           1       paths = {}
    53 157.6250 MiB   0.0000 MiB           2       for goal in goals:
    54 157.6250 MiB   0.1562 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 157.6406 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 257.4688 MiB 257.4688 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 257.4844 MiB -201.0938 MiB         513       for row in grid:
     8 257.4844 MiB -103035.0938 MiB      262656           for spot in row:
     9 257.4844 MiB -102834.9219 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 256.2656 MiB  -1.2188 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 256.2656 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 256.2656 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 256.2656 MiB   0.0000 MiB           1       came_from = {}
    18 265.3750 MiB -23374.2500 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 265.3750 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 266.0938 MiB -8439801.2031 MiB      116777       while not open_set.empty():
    22 266.0938 MiB -8439806.0625 MiB      116777           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 266.0938 MiB -8439815.8125 MiB      116777           current = open_set.get()[1]
    28                                         
    29 266.0938 MiB -8439819.7656 MiB      116777           if current in remaining_goals:
    30  98.9844 MiB -167.1094 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  98.9844 MiB   0.0000 MiB           1               if not remaining_goals:
    32  98.9844 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 266.0938 MiB -75883154.2188 MiB     1049616           for neighbor in current.neighbors:
    35 266.0938 MiB -67443400.8438 MiB      932840               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 266.0938 MiB -67443417.0000 MiB      932840               if current.row != neighbor.row and current.col != neighbor.col:
    38 266.0938 MiB -33709474.6250 MiB      466192                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 266.0938 MiB -67443462.9219 MiB      932840               if temp_g_score < g_score[neighbor]:
    41 266.0938 MiB -8484931.0938 MiB      117929                   came_from[neighbor] = current
    42 266.0938 MiB -8484935.3594 MiB      117929                   g_score[neighbor] = temp_g_score
    43 266.0938 MiB -8484942.0625 MiB      117929                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 266.0938 MiB -8439792.3594 MiB      116776           if draw is not None:
    46                                                     draw()
    47                                                     
    48 266.0938 MiB -8439796.8594 MiB      116776           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  98.9844 MiB   0.0000 MiB           1       paths = {}
    53  99.2500 MiB   0.0000 MiB           2       for goal in goals:
    54  99.2500 MiB   0.2656 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  99.2500 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 256.9062 MiB 256.9062 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 256.9062 MiB -156.2969 MiB         513       for row in grid:
     8 256.9062 MiB -80161.0781 MiB      262656           for spot in row:
     9 256.9062 MiB -80004.7812 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 256.7344 MiB  -0.1719 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 256.7344 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 256.7344 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 256.7344 MiB   0.0000 MiB           1       came_from = {}
    18 269.0156 MiB -590.4219 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 269.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 269.0156 MiB -21837239.8906 MiB      186028       while not open_set.empty():
    22 269.0156 MiB -21837244.4219 MiB      186028           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 269.0156 MiB -21837252.0625 MiB      186028           current = open_set.get()[1]
    28                                         
    29 269.0156 MiB -21837255.8906 MiB      186028           if current in remaining_goals:
    30 136.8594 MiB -132.1562 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31 136.8594 MiB   0.0000 MiB           1               if not remaining_goals:
    32 136.8594 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 269.0156 MiB -196413897.0312 MiB     1673391           for neighbor in current.neighbors:
    35 269.0156 MiB -174576717.8438 MiB     1487364               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 269.0156 MiB -174576711.3906 MiB     1487364               if current.row != neighbor.row and current.col != neighbor.col:
    38 269.0156 MiB -87268367.1875 MiB      743540                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 269.0156 MiB -174576753.8281 MiB     1487364               if temp_g_score < g_score[neighbor]:
    41 269.0156 MiB -21948542.1875 MiB      187692                   came_from[neighbor] = current
    42 269.0156 MiB -21948546.6719 MiB      187692                   g_score[neighbor] = temp_g_score
    43 269.0156 MiB -21948553.4844 MiB      187692                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 269.0156 MiB -21837229.7656 MiB      186027           if draw is not None:
    46                                                     draw()
    47                                                     
    48 269.0156 MiB -21837234.2188 MiB      186027           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52 136.8594 MiB   0.0000 MiB           1       paths = {}
    53 137.0938 MiB   0.0000 MiB           2       for goal in goals:
    54 137.0938 MiB   0.2344 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56 137.1094 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 268.5000 MiB 268.5000 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 268.5156 MiB -12604.3594 MiB         513       for row in grid:
     8 268.5156 MiB -6459686.5156 MiB      262656           for spot in row:
     9 268.5156 MiB -6447104.8906 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 234.1875 MiB -34.3281 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 234.1875 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 234.2031 MiB   0.0156 MiB           1       open_set.put((0, start))
    17 234.2031 MiB   0.0000 MiB           1       came_from = {}
    18 254.8438 MiB -5647.7656 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 254.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 255.1406 MiB -21107362.0156 MiB      191689       while not open_set.empty():
    22 255.1406 MiB -21107367.5625 MiB      191689           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 255.1406 MiB -21107377.5469 MiB      191689           current = open_set.get()[1]
    28                                         
    29 255.1406 MiB -21107382.2500 MiB      191689           if current in remaining_goals:
    30  98.7656 MiB -156.3750 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  98.7656 MiB   0.0000 MiB           1               if not remaining_goals:
    32  98.7656 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 255.1406 MiB -189746203.5469 MiB     1722457           for neighbor in current.neighbors:
    35 255.1406 MiB -168638901.0469 MiB     1530769               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 255.1406 MiB -168638899.4688 MiB     1530769               if current.row != neighbor.row and current.col != neighbor.col:
    38 255.1406 MiB -84283064.6406 MiB      764929                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 255.1406 MiB -168638959.4375 MiB     1530769               if temp_g_score < g_score[neighbor]:
    41 255.1406 MiB -21175758.6719 MiB      192740                   came_from[neighbor] = current
    42 255.1406 MiB -21175764.0625 MiB      192740                   g_score[neighbor] = temp_g_score
    43 255.1406 MiB -21175772.1562 MiB      192740                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 255.1406 MiB -21107348.4219 MiB      191688           if draw is not None:
    46                                                     draw()
    47                                                     
    48 255.1406 MiB -21107354.9688 MiB      191688           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  98.7656 MiB   0.0000 MiB           1       paths = {}
    53  99.0469 MiB   0.0156 MiB           2       for goal in goals:
    54  99.0469 MiB   0.2656 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  99.0469 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 262.9219 MiB 262.9219 MiB           1   @profile(precision=4, stream=open('logs/Dijkstra/grid_size/1024.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 262.9375 MiB -1291.0000 MiB         513       for row in grid:
     8 262.9375 MiB -659374.1719 MiB      262656           for spot in row:
     9 262.9375 MiB -658088.9531 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 253.9375 MiB  -9.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 253.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 253.9531 MiB   0.0156 MiB           1       open_set.put((0, start))
    17 253.9531 MiB   0.0000 MiB           1       came_from = {}
    18 260.3438 MiB -801421.5156 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 258.0781 MiB  -2.2656 MiB           1       g_score[start] = 0
    20                                         
    21 258.9219 MiB -12384641.7188 MiB      115609       while not open_set.empty():
    22 258.9219 MiB -12384646.9062 MiB      115609           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 258.9219 MiB -12384658.8594 MiB      115609           current = open_set.get()[1]
    28                                         
    29 258.9219 MiB -12384666.1094 MiB      115609           if current in remaining_goals:
    30  93.5156 MiB -165.4062 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  93.5156 MiB   0.0000 MiB           1               if not remaining_goals:
    32  93.5156 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 258.9219 MiB -111271796.1875 MiB     1038349           for neighbor in current.neighbors:
    35 258.9219 MiB -98887219.5312 MiB      922741               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 258.9219 MiB -98887239.7344 MiB      922741               if current.row != neighbor.row and current.col != neighbor.col:
    38 258.9219 MiB -49412225.2344 MiB      461017                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 258.9219 MiB -98887310.1406 MiB      922741               if temp_g_score < g_score[neighbor]:
    41 258.9219 MiB -12441580.5469 MiB      116480                   came_from[neighbor] = current
    42 258.9219 MiB -12441587.0781 MiB      116480                   g_score[neighbor] = temp_g_score
    43 258.9219 MiB -12441597.9844 MiB      116480                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 258.9219 MiB -12384629.6406 MiB      115608           if draw is not None:
    46                                                     draw()
    47                                                     
    48 258.9219 MiB -12384634.9844 MiB      115608           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  93.5156 MiB   0.0000 MiB           1       paths = {}
    53  93.9531 MiB   0.0000 MiB           2       for goal in goals:
    54  93.9531 MiB   0.4375 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  93.9844 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 259.2031 MiB 259.2031 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/1.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 259.2031 MiB -2027.2812 MiB         513       for row in grid:
     8 259.2031 MiB -1039764.2344 MiB      262656           for spot in row:
     9 259.2031 MiB -1037741.2500 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 252.8281 MiB  -6.3750 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 252.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 252.8281 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 252.8281 MiB   0.0000 MiB           1       came_from = {}
    18 267.7031 MiB -37362.2344 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 267.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 268.1875 MiB -6990031.1250 MiB       74373       while not open_set.empty():
    22 268.1875 MiB -6990035.2031 MiB       74373           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 268.1875 MiB -6990044.4844 MiB       74373           current = open_set.get()[1]
    28                                         
    29 268.1875 MiB -6990049.3750 MiB       74373           if current in remaining_goals:
    30  78.0938 MiB -190.0938 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  78.0938 MiB   0.0000 MiB           1               if not remaining_goals:
    32  78.0938 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 268.1875 MiB -62828300.2188 MiB      668937           for neighbor in current.neighbors:
    35 268.1875 MiB -55838318.7500 MiB      594565               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 268.1875 MiB -55838342.0625 MiB      594565               if current.row != neighbor.row and current.col != neighbor.col:
    38 268.1875 MiB -27905821.1250 MiB      297214                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 268.1875 MiB -55838391.4844 MiB      594565               if temp_g_score < g_score[neighbor]:
    41 268.1875 MiB -7025665.9688 MiB       75490                   came_from[neighbor] = current
    42 268.1875 MiB -7025672.2188 MiB       75490                   g_score[neighbor] = temp_g_score
    43 268.1875 MiB -7025682.2656 MiB       75490                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 268.1875 MiB -6990021.4375 MiB       74372           if draw is not None:
    46                                                     draw()
    47                                                     
    48 268.1875 MiB -6990026.0938 MiB       74372           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  78.0938 MiB   0.0000 MiB           1       paths = {}
    53  78.3750 MiB   0.0000 MiB           2       for goal in goals:
    54  78.3750 MiB   0.2812 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  78.3906 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 254.9375 MiB 254.9375 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/1.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 254.9375 MiB -3598.4688 MiB         513       for row in grid:
     8 254.9375 MiB -1824472.2344 MiB      262656           for spot in row:
     9 254.9375 MiB -1820913.4375 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 191.3281 MiB -63.6094 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 191.6406 MiB   0.3125 MiB           1       open_set = PriorityQueue()
    16 191.8438 MiB   0.2031 MiB           1       open_set.put((0, start))
    17 191.8438 MiB   0.0000 MiB           1       came_from = {}
    18 194.5469 MiB -30461487.0156 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  82.9531 MiB -111.5938 MiB           1       g_score[start] = 0
    20                                         
    21 142.0469 MiB -10331211.7656 MiB      220071       while not open_set.empty():
    22 142.0469 MiB -10331216.5000 MiB      220071           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 142.0469 MiB -10331230.9219 MiB      220071           current = open_set.get()[1]
    28                                         
    29 142.0469 MiB -10331234.4844 MiB      220071           if current in remaining_goals:
    30  82.7031 MiB -59.3438 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  82.7031 MiB   0.0000 MiB           1               if not remaining_goals:
    32  82.7031 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 142.0469 MiB -92796501.8594 MiB     1976822           for neighbor in current.neighbors:
    35 142.0469 MiB -82465383.1719 MiB     1756752               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 142.0469 MiB -82465324.4844 MiB     1756752               if current.row != neighbor.row and current.col != neighbor.col:
    38 142.0469 MiB -41202069.3750 MiB      877742                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 142.0469 MiB -82465376.3594 MiB     1756752               if temp_g_score < g_score[neighbor]:
    41 142.0469 MiB -10330614.8281 MiB      220785                   came_from[neighbor] = current
    42 142.0469 MiB -10330620.7656 MiB      220785                   g_score[neighbor] = temp_g_score
    43 142.0469 MiB -10330627.9688 MiB      220785                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 142.0469 MiB -10331202.5469 MiB      220070           if draw is not None:
    46                                                     draw()
    47                                                     
    48 142.0469 MiB -10331206.3125 MiB      220070           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  82.7031 MiB   0.0000 MiB           1       paths = {}
    53  83.7344 MiB   0.0156 MiB           2       for goal in goals:
    54  83.7344 MiB   1.0156 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  83.7500 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 259.5000 MiB 259.5000 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 259.5000 MiB -8415.4531 MiB         513       for row in grid:
     8 259.5000 MiB -4304010.9375 MiB      262656           for spot in row:
     9 259.5000 MiB -4295614.2656 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 213.7812 MiB -45.7188 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 213.7812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    16 213.7812 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 213.7812 MiB   0.0000 MiB           1       came_from = {}
    18 239.3594 MiB -37829.3281 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 236.5469 MiB  -2.8125 MiB           1       g_score[start] = 0
    20                                         
    21 236.6406 MiB -35267358.7031 MiB      227764       while not open_set.empty():
    22 236.6406 MiB -35267383.3750 MiB      227764           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 236.6406 MiB -35267393.5781 MiB      227764           current = open_set.get()[1]
    28                                         
    29 236.6406 MiB -35267398.7031 MiB      227764           if current in remaining_goals:
    30  77.0781 MiB -159.5625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  77.0781 MiB   0.0000 MiB           1               if not remaining_goals:
    32  77.0781 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 236.6406 MiB -316812267.0625 MiB     2045972           for neighbor in current.neighbors:
    35 236.6406 MiB -281544979.7500 MiB     1818209               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 236.6406 MiB -281544948.6406 MiB     1818209               if current.row != neighbor.row and current.col != neighbor.col:
    38 236.6406 MiB -140673886.9375 MiB      908456                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 236.6406 MiB -281545059.7500 MiB     1818209               if temp_g_score < g_score[neighbor]:
    41 236.6406 MiB -35343642.8281 MiB      228479                   came_from[neighbor] = current
    42 236.6406 MiB -35343647.3594 MiB      228479                   g_score[neighbor] = temp_g_score
    43 236.6406 MiB -35343656.2031 MiB      228479                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 236.6406 MiB -35267343.2188 MiB      227763           if draw is not None:
    46                                                     draw()
    47                                                     
    48 236.6406 MiB -35267353.1406 MiB      227763           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  77.0781 MiB   0.0000 MiB           1       paths = {}
    53  78.0938 MiB   0.0000 MiB           2       for goal in goals:
    54  78.0938 MiB   1.0156 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  78.0938 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 259.7344 MiB 259.7344 MiB           1   @profile(stream=open('logs/Dijkstra/num_goals/10.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 259.7344 MiB -28654.0000 MiB         513       for row in grid:
     8 259.7344 MiB -14669791.6719 MiB      262656           for spot in row:
     9 259.7344 MiB -14641242.8906 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  84.9062 MiB -174.8281 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  85.2656 MiB   0.3594 MiB           1       open_set = PriorityQueue()
    16  85.4844 MiB   0.2188 MiB           1       open_set.put((0, start))
    17  85.5000 MiB   0.0156 MiB           1       came_from = {}
    18 109.6562 MiB -1047168.9375 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 102.3906 MiB  -7.2656 MiB           1       g_score[start] = 0
    20                                         
    21 131.9219 MiB -13965218.4062 MiB      232204       while not open_set.empty():
    22 131.9219 MiB -13965241.9688 MiB      232204           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 131.9219 MiB -13965252.6719 MiB      232204           current = open_set.get()[1]
    28                                         
    29 131.9219 MiB -13965279.7656 MiB      232204           if current in remaining_goals:
    30  45.1875 MiB -86.7344 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  45.1875 MiB   0.0000 MiB           1               if not remaining_goals:
    32  45.1875 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 131.9219 MiB -125446827.3438 MiB     2086034           for neighbor in current.neighbors:
    35 131.9219 MiB -111481878.7812 MiB     1853831               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 131.9219 MiB -111481673.2812 MiB     1853831               if current.row != neighbor.row and current.col != neighbor.col:
    38 131.9219 MiB -55702052.4688 MiB      926284                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 131.9219 MiB -111481866.9688 MiB     1853831               if temp_g_score < g_score[neighbor]:
    41 131.9219 MiB -13989990.3906 MiB      232973                   came_from[neighbor] = current
    42 131.9219 MiB -13990012.7031 MiB      232973                   g_score[neighbor] = temp_g_score
    43 131.9219 MiB -13990055.3594 MiB      232973                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 131.9219 MiB -13965164.6875 MiB      232203           if draw is not None:
    46                                                     draw()
    47                                                     
    48 131.9219 MiB -13965193.6094 MiB      232203           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  45.1875 MiB   0.0000 MiB           1       paths = {}
    53  48.7031 MiB   0.0000 MiB           2       for goal in goals:
    54  48.7031 MiB   3.5156 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  48.7031 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 256.8281 MiB 256.8281 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 256.8281 MiB -109215.7812 MiB         513       for row in grid:
     8 256.8281 MiB -55986682.9844 MiB      262656           for spot in row:
     9 256.8281 MiB -55877594.8125 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  70.7188 MiB -186.1094 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  71.0469 MiB   0.3281 MiB           1       open_set = PriorityQueue()
    16  71.2656 MiB   0.2188 MiB           1       open_set.put((0, start))
    17  71.2656 MiB   0.0000 MiB           1       came_from = {}
    18  99.8281 MiB -690336.5156 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  80.5625 MiB -19.2656 MiB           1       g_score[start] = 0
    20                                         
    21 131.3906 MiB -9024041.5469 MiB      183216       while not open_set.empty():
    22 131.3906 MiB -9024070.9688 MiB      183216           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 131.3906 MiB -9024095.0625 MiB      183216           current = open_set.get()[1]
    28                                         
    29 131.3906 MiB -9024098.5938 MiB      183216           if current in remaining_goals:
    30  79.7812 MiB -51.6094 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  79.7812 MiB   0.0000 MiB           1               if not remaining_goals:
    32  79.7812 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 131.3906 MiB -81088561.8125 MiB     1646158           for neighbor in current.neighbors:
    35 131.3906 MiB -72064613.6250 MiB     1462943               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 131.3906 MiB -72064566.7188 MiB     1462943               if current.row != neighbor.row and current.col != neighbor.col:
    38 131.3906 MiB -36011095.2969 MiB      731009                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 131.3906 MiB -72064604.2031 MiB     1462943               if temp_g_score < g_score[neighbor]:
    41 131.3906 MiB -9061190.2656 MiB      184215                   came_from[neighbor] = current
    42 131.3906 MiB -9061197.5000 MiB      184215                   g_score[neighbor] = temp_g_score
    43 131.3906 MiB -9061202.5312 MiB      184215                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 131.3906 MiB -9024035.5312 MiB      183215           if draw is not None:
    46                                                     draw()
    47                                                     
    48 131.3906 MiB -9024037.6719 MiB      183215           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  79.7812 MiB   0.0000 MiB           1       paths = {}
    53  81.6875 MiB   0.0000 MiB           2       for goal in goals:
    54  81.6875 MiB   1.9062 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  81.6875 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 255.9062 MiB 255.9062 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 255.9062 MiB -27345.5781 MiB         513       for row in grid:
     8 255.9062 MiB -13976281.4062 MiB      262656           for spot in row:
     9 255.9062 MiB -13949066.2500 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  74.9062 MiB -181.0000 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  75.2656 MiB   0.3594 MiB           1       open_set = PriorityQueue()
    16  75.4688 MiB   0.2031 MiB           1       open_set.put((0, start))
    17  75.4844 MiB   0.0156 MiB           1       came_from = {}
    18  83.5938 MiB -5143743.0312 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  51.0625 MiB -32.5312 MiB           1       g_score[start] = 0
    20                                         
    21  58.2500 MiB -387998.3438 MiB       26983       while not open_set.empty():
    22  58.2500 MiB -387998.6406 MiB       26983           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  58.2500 MiB -388004.3594 MiB       26983           current = open_set.get()[1]
    28                                         
    29  58.2500 MiB -388005.5625 MiB       26983           if current in remaining_goals:
    30  44.6406 MiB -13.6094 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  44.6406 MiB   0.0000 MiB           1               if not remaining_goals:
    32  44.6406 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  58.2500 MiB -3481453.8906 MiB      242226           for neighbor in current.neighbors:
    35  58.2500 MiB -3093460.2344 MiB      215244               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  58.2500 MiB -3093446.3750 MiB      215244               if current.row != neighbor.row and current.col != neighbor.col:
    38  58.2500 MiB -1544991.6250 MiB      107520                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  58.2500 MiB -3093452.3750 MiB      215244               if temp_g_score < g_score[neighbor]:
    41  58.2500 MiB -392818.5625 MiB       27547                   came_from[neighbor] = current
    42  58.2500 MiB -392819.4844 MiB       27547                   g_score[neighbor] = temp_g_score
    43  58.2500 MiB -392828.4844 MiB       27547                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  58.2500 MiB -387998.0000 MiB       26982           if draw is not None:
    46                                                     draw()
    47                                                     
    48  58.2500 MiB -387998.0469 MiB       26982           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  44.6406 MiB   0.0000 MiB           1       paths = {}
    53  44.8438 MiB   0.0156 MiB           2       for goal in goals:
    54  44.8438 MiB   0.1875 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  44.8438 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 253.2656 MiB 253.2656 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 253.2656 MiB -16542.0312 MiB         513       for row in grid:
     8 253.2656 MiB -8446305.1562 MiB      262656           for spot in row:
     9 253.2656 MiB -8429848.7344 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 101.6719 MiB -151.5938 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 101.8281 MiB   0.1562 MiB           1       open_set = PriorityQueue()
    16 101.8438 MiB   0.0156 MiB           1       open_set.put((0, start))
    17 101.8594 MiB   0.0156 MiB           1       came_from = {}
    18 108.4375 MiB -6020314.0000 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  90.2969 MiB -18.1406 MiB           1       g_score[start] = 0
    20                                         
    21 126.9688 MiB -5220226.0312 MiB       84054       while not open_set.empty():
    22 126.9688 MiB -5220228.0781 MiB       84054           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 126.9688 MiB -5220232.4219 MiB       84054           current = open_set.get()[1]
    28                                         
    29 126.9688 MiB -5220239.1406 MiB       84054           if current in remaining_goals:
    30  60.9062 MiB -66.0625 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  60.9062 MiB   0.0000 MiB           1               if not remaining_goals:
    32  60.9062 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 126.9688 MiB -46874997.9219 MiB      754879           for neighbor in current.neighbors:
    35 126.9688 MiB -41654841.7188 MiB      670826               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 126.9688 MiB -41654827.1719 MiB      670826               if current.row != neighbor.row and current.col != neighbor.col:
    38 126.9688 MiB -20809692.6250 MiB      335147                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 126.9688 MiB -41654858.0625 MiB      670826               if temp_g_score < g_score[neighbor]:
    41 126.9688 MiB -5249955.7812 MiB       84796                   came_from[neighbor] = current
    42 126.9688 MiB -5249957.7969 MiB       84796                   g_score[neighbor] = temp_g_score
    43 126.9688 MiB -5249965.7188 MiB       84796                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 126.9688 MiB -5220220.5781 MiB       84053           if draw is not None:
    46                                                     draw()
    47                                                     
    48 126.9688 MiB -5220223.0000 MiB       84053           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  60.9062 MiB   0.0000 MiB           1       paths = {}
    53  61.6719 MiB   0.0000 MiB           2       for goal in goals:
    54  61.6719 MiB   0.7656 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  61.6719 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 254.1875 MiB 254.1875 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 254.1875 MiB -56755.4844 MiB         513       for row in grid:
     8 254.1875 MiB -29064266.2344 MiB      262656           for spot in row:
     9 254.1875 MiB -29007630.7656 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  91.5938 MiB -162.5938 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  91.9375 MiB   0.3438 MiB           1       open_set = PriorityQueue()
    16  92.1562 MiB   0.2188 MiB           1       open_set.put((0, start))
    17  92.1562 MiB   0.0000 MiB           1       came_from = {}
    18 115.9375 MiB -1391030.2969 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  88.5000 MiB -27.4375 MiB           1       g_score[start] = 0
    20                                         
    21  88.9688 MiB -372301.5469 MiB       10236       while not open_set.empty():
    22  88.9688 MiB -372301.7812 MiB       10236           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  88.9688 MiB -372302.7500 MiB       10236           current = open_set.get()[1]
    28                                         
    29  88.9688 MiB -372304.8594 MiB       10236           if current in remaining_goals:
    30  36.2188 MiB -52.7500 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  36.2188 MiB   0.0000 MiB           1               if not remaining_goals:
    32  36.2188 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  88.9688 MiB -3350472.5156 MiB       92115           for neighbor in current.neighbors:
    35  88.9688 MiB -2978186.2031 MiB       81880               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  88.9688 MiB -2978192.7031 MiB       81880               if current.row != neighbor.row and current.col != neighbor.col:
    38  88.9688 MiB -1489141.7031 MiB       40940                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  88.9688 MiB -2978199.0625 MiB       81880               if temp_g_score < g_score[neighbor]:
    41  88.9688 MiB -383716.9375 MiB       10714                   came_from[neighbor] = current
    42  88.9688 MiB -383720.6250 MiB       10714                   g_score[neighbor] = temp_g_score
    43  88.9688 MiB -383734.2500 MiB       10714                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  88.9688 MiB -372293.2812 MiB       10235           if draw is not None:
    46                                                     draw()
    47                                                     
    48  88.9688 MiB -372294.2188 MiB       10235           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  36.2188 MiB   0.0000 MiB           1       paths = {}
    53  36.3438 MiB   0.0000 MiB           2       for goal in goals:
    54  36.3438 MiB   0.1250 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  36.3750 MiB   0.0312 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 252.9062 MiB 252.9062 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 252.9062 MiB -56957.5781 MiB         513       for row in grid:
     8 252.9062 MiB -29171257.5469 MiB      262656           for spot in row:
     9 252.9062 MiB -29114377.7188 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  79.9375 MiB -172.9688 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  80.2812 MiB   0.3438 MiB           1       open_set = PriorityQueue()
    16  80.5000 MiB   0.2188 MiB           1       open_set.put((0, start))
    17  80.5156 MiB   0.0156 MiB           1       came_from = {}
    18 112.1250 MiB -402892.7812 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 106.0000 MiB  -6.1250 MiB           1       g_score[start] = 0
    20                                         
    21 130.3750 MiB -10285727.1094 MiB      180041       while not open_set.empty():
    22 130.3750 MiB -10285731.8594 MiB      180041           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 130.3750 MiB -10285738.2969 MiB      180041           current = open_set.get()[1]
    28                                         
    29 130.3750 MiB -10285742.6406 MiB      180041           if current in remaining_goals:
    30  71.5312 MiB -58.8438 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  71.5312 MiB   0.0000 MiB           1               if not remaining_goals:
    32  71.5312 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 130.3750 MiB -92397833.2969 MiB     1617251           for neighbor in current.neighbors:
    35 130.3750 MiB -82112201.6719 MiB     1437211               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 130.3750 MiB -82112156.6250 MiB     1437211               if current.row != neighbor.row and current.col != neighbor.col:
    38 130.3750 MiB -41027239.6719 MiB      718088                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 130.3750 MiB -82112239.4375 MiB     1437211               if temp_g_score < g_score[neighbor]:
    41 130.3750 MiB -10315531.9375 MiB      180838                   came_from[neighbor] = current
    42 130.3750 MiB -10315536.3438 MiB      180838                   g_score[neighbor] = temp_g_score
    43 130.3750 MiB -10315544.8125 MiB      180838                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 130.3750 MiB -10285720.7188 MiB      180040           if draw is not None:
    46                                                     draw()
    47                                                     
    48 130.3750 MiB -10285723.7969 MiB      180040           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  71.5312 MiB   0.0000 MiB           1       paths = {}
    53  71.9688 MiB   0.0156 MiB           2       for goal in goals:
    54  71.9688 MiB   0.4219 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  71.9844 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 256.8594 MiB 256.8594 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 256.8594 MiB -84136.2969 MiB         513       for row in grid:
     8 256.8594 MiB -43119535.1562 MiB      262656           for spot in row:
     9 256.8594 MiB -43035451.8750 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  81.1094 MiB -175.7500 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  81.4844 MiB   0.3750 MiB           1       open_set = PriorityQueue()
    16  81.6875 MiB   0.2031 MiB           1       open_set.put((0, start))
    17  81.7031 MiB   0.0156 MiB           1       came_from = {}
    18  94.5156 MiB -9075530.5469 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  49.5000 MiB -45.0156 MiB           1       g_score[start] = 0
    20                                         
    21  53.9844 MiB -281185.1719 MiB       22719       while not open_set.empty():
    22  53.9844 MiB -281185.7656 MiB       22719           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27  53.9844 MiB -281186.4688 MiB       22719           current = open_set.get()[1]
    28                                         
    29  53.9844 MiB -281189.7500 MiB       22719           if current in remaining_goals:
    30  39.9375 MiB -14.0469 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  39.9375 MiB   0.0000 MiB           1               if not remaining_goals:
    32  39.9375 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34  53.9844 MiB -2525128.7031 MiB      203949           for neighbor in current.neighbors:
    35  53.9844 MiB -2243948.4844 MiB      181231               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37  53.9844 MiB -2243943.3438 MiB      181231               if current.row != neighbor.row and current.col != neighbor.col:
    38  53.9844 MiB -1121029.7031 MiB       90530                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40  53.9844 MiB -2243956.8438 MiB      181231               if temp_g_score < g_score[neighbor]:
    41  53.9844 MiB -284900.3594 MiB       23246                   came_from[neighbor] = current
    42  53.9844 MiB -284901.8750 MiB       23246                   g_score[neighbor] = temp_g_score
    43  53.9844 MiB -284902.2656 MiB       23246                   open_set.put((temp_g_score, neighbor))
    44                                         
    45  53.9844 MiB -281231.2031 MiB       22718           if draw is not None:
    46                                                     draw()
    47                                                     
    48  53.9844 MiB -281184.8438 MiB       22718           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  39.9375 MiB   0.0000 MiB           1       paths = {}
    53  40.2188 MiB   0.0000 MiB           2       for goal in goals:
    54  40.2188 MiB   0.2812 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  40.2188 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 247.7500 MiB 247.7500 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 247.7656 MiB -44485.7344 MiB         513       for row in grid:
     8 247.7656 MiB -22765937.4062 MiB      262656           for spot in row:
     9 247.7656 MiB -22721543.4062 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  85.5000 MiB -162.2656 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  85.8438 MiB   0.3438 MiB           1       open_set = PriorityQueue()
    16  86.0469 MiB   0.2031 MiB           1       open_set.put((0, start))
    17  86.0625 MiB   0.0156 MiB           1       came_from = {}
    18 121.5938 MiB -189641.0000 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 119.5781 MiB  -2.0156 MiB           1       g_score[start] = 0
    20                                         
    21 129.0156 MiB -9024632.8750 MiB      126307       while not open_set.empty():
    22 129.0156 MiB -9024637.5156 MiB      126307           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 129.0156 MiB -9024672.9062 MiB      126307           current = open_set.get()[1]
    28                                         
    29 129.0156 MiB -9024679.1875 MiB      126307           if current in remaining_goals:
    30  57.1875 MiB -71.8281 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  57.1875 MiB   0.0000 MiB           1               if not remaining_goals:
    32  57.1875 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 129.0156 MiB -81064648.8438 MiB     1134685           for neighbor in current.neighbors:
    35 129.0156 MiB -72040114.5156 MiB     1008379               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 129.0156 MiB -72040078.5625 MiB     1008379               if current.row != neighbor.row and current.col != neighbor.col:
    38 129.0156 MiB -35994029.4688 MiB      503845                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 129.0156 MiB -72040126.1719 MiB     1008379               if temp_g_score < g_score[neighbor]:
    41 129.0156 MiB -9063759.2344 MiB      127188                   came_from[neighbor] = current
    42 129.0156 MiB -9063769.2969 MiB      127188                   g_score[neighbor] = temp_g_score
    43 129.0156 MiB -9063783.0312 MiB      127188                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 129.0156 MiB -9024620.9531 MiB      126306           if draw is not None:
    46                                                     draw()
    47                                                     
    48 129.0156 MiB -9024625.6719 MiB      126306           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  57.1875 MiB   0.0000 MiB           1       paths = {}
    53  58.0000 MiB   0.0156 MiB           2       for goal in goals:
    54  58.0000 MiB   0.7969 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  58.0156 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 247.8125 MiB 247.8125 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 247.8125 MiB -84731.4531 MiB         513       for row in grid:
     8 247.8125 MiB -43428056.3594 MiB      262656           for spot in row:
     9 247.8125 MiB -43343432.5469 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  66.9688 MiB -180.8438 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  67.3281 MiB   0.3594 MiB           1       open_set = PriorityQueue()
    16  67.5469 MiB   0.2188 MiB           1       open_set.put((0, start))
    17  67.5625 MiB   0.0156 MiB           1       came_from = {}
    18 104.0000 MiB -1357446.4375 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  69.0312 MiB -34.9688 MiB           1       g_score[start] = 0
    20                                         
    21 133.9844 MiB -8632709.9688 MiB      150206       while not open_set.empty():
    22 133.9844 MiB -8632714.4844 MiB      150206           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 133.9844 MiB -8632723.3906 MiB      150206           current = open_set.get()[1]
    28                                         
    29 133.9844 MiB -8632732.9688 MiB      150206           if current in remaining_goals:
    30  66.4688 MiB -67.5156 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  66.4688 MiB   0.0000 MiB           1               if not remaining_goals:
    32  66.4688 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 133.9844 MiB -77559571.7969 MiB     1349827           for neighbor in current.neighbors:
    35 133.9844 MiB -68926971.2656 MiB     1199622               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 133.9844 MiB -68926933.1094 MiB     1199622               if current.row != neighbor.row and current.col != neighbor.col:
    38 133.9844 MiB -34441126.8125 MiB      599475                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 133.9844 MiB -68926970.9219 MiB     1199622               if temp_g_score < g_score[neighbor]:
    41 133.9844 MiB -8663493.7344 MiB      151264                   came_from[neighbor] = current
    42 133.9844 MiB -8663504.2500 MiB      151264                   g_score[neighbor] = temp_g_score
    43 133.9844 MiB -8663510.6406 MiB      151264                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 133.9844 MiB -8632703.8125 MiB      150205           if draw is not None:
    46                                                     draw()
    47                                                     
    48 133.9844 MiB -8632708.1250 MiB      150205           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  66.4688 MiB   0.0000 MiB           1       paths = {}
    53  67.6562 MiB   0.0000 MiB           2       for goal in goals:
    54  67.6562 MiB   1.1875 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  67.6562 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 251.7188 MiB 251.7188 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 251.7188 MiB -100573.9688 MiB         513       for row in grid:
     8 251.7188 MiB -51530722.2656 MiB      262656           for spot in row:
     9 251.7188 MiB -51430239.8281 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  65.1250 MiB -186.5938 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  65.4531 MiB   0.3281 MiB           1       open_set = PriorityQueue()
    16  65.6719 MiB   0.2188 MiB           1       open_set.put((0, start))
    17  65.6719 MiB   0.0000 MiB           1       came_from = {}
    18 107.3438 MiB -41006.4844 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  98.9062 MiB  -8.4375 MiB           1       g_score[start] = 0
    20                                         
    21 132.1250 MiB -12186903.2188 MiB      210441       while not open_set.empty():
    22 132.1250 MiB -12186907.2812 MiB      210441           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 132.1250 MiB -12186914.2500 MiB      210441           current = open_set.get()[1]
    28                                         
    29 132.1250 MiB -12186957.6406 MiB      210441           if current in remaining_goals:
    30  53.9375 MiB -78.1875 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  53.9375 MiB   0.0000 MiB           1               if not remaining_goals:
    32  53.9375 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 132.1250 MiB -109455169.0469 MiB     1890284           for neighbor in current.neighbors:
    35 132.1250 MiB -97268352.9375 MiB     1679844               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 132.1250 MiB -97268329.9531 MiB     1679844               if current.row != neighbor.row and current.col != neighbor.col:
    38 132.1250 MiB -48596506.7344 MiB      839310                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 132.1250 MiB -97268392.9062 MiB     1679844               if temp_g_score < g_score[neighbor]:
    41 132.1250 MiB -12196668.6875 MiB      211161                   came_from[neighbor] = current
    42 132.1250 MiB -12196674.5469 MiB      211161                   g_score[neighbor] = temp_g_score
    43 132.1250 MiB -12196680.7031 MiB      211161                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 132.1250 MiB -12186892.7031 MiB      210440           if draw is not None:
    46                                                     draw()
    47                                                     
    48 132.1250 MiB -12186897.0469 MiB      210440           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  53.9375 MiB   0.0000 MiB           1       paths = {}
    53  57.2031 MiB   0.0000 MiB           2       for goal in goals:
    54  57.2031 MiB   3.2656 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  57.2031 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 258.2969 MiB 258.2969 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 258.2969 MiB -18087.1875 MiB         513       for row in grid:
     8 258.2969 MiB -9254056.1250 MiB      262656           for spot in row:
     9 258.2969 MiB -9236063.8125 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 122.1094 MiB -136.1875 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 122.2344 MiB   0.1250 MiB           1       open_set = PriorityQueue()
    16 122.2500 MiB   0.0156 MiB           1       open_set.put((0, start))
    17 122.2500 MiB   0.0000 MiB           1       came_from = {}
    18 125.5312 MiB -9798758.1406 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19  91.6562 MiB -33.8750 MiB           1       g_score[start] = 0
    20                                         
    21 132.2500 MiB -15252367.8750 MiB      217686       while not open_set.empty():
    22 132.2500 MiB -15252371.1562 MiB      217686           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 132.2500 MiB -15252392.1250 MiB      217686           current = open_set.get()[1]
    28                                         
    29 132.2500 MiB -15252396.3438 MiB      217686           if current in remaining_goals:
    30  51.2188 MiB -81.0312 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  51.2188 MiB   0.0000 MiB           1               if not remaining_goals:
    32  51.2188 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 132.2500 MiB -137021773.5625 MiB     1955384           for neighbor in current.neighbors:
    35 132.2500 MiB -121769488.0312 MiB     1737699               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 132.2500 MiB -121769481.6406 MiB     1737699               if current.row != neighbor.row and current.col != neighbor.col:
    38 132.2500 MiB -60843422.0312 MiB      868220                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 132.2500 MiB -121769558.7188 MiB     1737699               if temp_g_score < g_score[neighbor]:
    41 132.2500 MiB -15270244.9375 MiB      218401                   came_from[neighbor] = current
    42 132.2500 MiB -15270249.7188 MiB      218401                   g_score[neighbor] = temp_g_score
    43 132.2500 MiB -15270254.9844 MiB      218401                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 132.2500 MiB -15252367.7500 MiB      217685           if draw is not None:
    46                                                     draw()
    47                                                     
    48 132.2500 MiB -15252362.4219 MiB      217685           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  51.2188 MiB   0.0000 MiB           1       paths = {}
    53  56.4375 MiB   0.0000 MiB           2       for goal in goals:
    54  56.4375 MiB   5.2188 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  56.4375 MiB   0.0000 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 251.7969 MiB 251.7969 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 251.7969 MiB -11072.6719 MiB         513       for row in grid:
     8 251.7969 MiB -5669798.8281 MiB      262656           for spot in row:
     9 251.7969 MiB -5658755.3906 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12 212.9062 MiB -38.8906 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15 212.9844 MiB   0.0781 MiB           1       open_set = PriorityQueue()
    16 212.9844 MiB   0.0000 MiB           1       open_set.put((0, start))
    17 213.0000 MiB   0.0156 MiB           1       came_from = {}
    18 226.8438 MiB -4381297.0312 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 158.2188 MiB -68.6250 MiB           1       g_score[start] = 0
    20                                         
    21 160.7031 MiB -4594944.7969 MiB      106317       while not open_set.empty():
    22 160.7031 MiB -4594946.0000 MiB      106317           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 160.7031 MiB -4594949.2969 MiB      106317           current = open_set.get()[1]
    28                                         
    29 160.7031 MiB -4594951.1875 MiB      106317           if current in remaining_goals:
    30  72.7188 MiB -87.9844 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  72.7188 MiB   0.0000 MiB           1               if not remaining_goals:
    32  72.7188 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 160.7031 MiB -41290650.0625 MiB      955959           for neighbor in current.neighbors:
    35 160.7031 MiB -36695737.8281 MiB      849643               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 160.7031 MiB -36695738.6875 MiB      849643               if current.row != neighbor.row and current.col != neighbor.col:
    38 160.7031 MiB -18337360.9531 MiB      424674                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 160.7031 MiB -36695797.7188 MiB      849643               if temp_g_score < g_score[neighbor]:
    41 160.7031 MiB -4614179.8438 MiB      107506                   came_from[neighbor] = current
    42 160.7031 MiB -4614184.2969 MiB      107506                   g_score[neighbor] = temp_g_score
    43 160.7031 MiB -4614190.7031 MiB      107506                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 160.7031 MiB -4594940.8438 MiB      106316           if draw is not None:
    46                                                     draw()
    47                                                     
    48 160.7031 MiB -4594942.2969 MiB      106316           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  72.7188 MiB   0.0000 MiB           1       paths = {}
    53  73.0469 MiB   0.0000 MiB           2       for goal in goals:
    54  73.0469 MiB   0.3281 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  73.0625 MiB   0.0156 MiB           1       return paths


Filename: /Users/selimhan/Documents/pathfinding-experiment/dijkstra.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     5 252.0781 MiB 252.0781 MiB           1   @profile(stream=open('logs/Dijkstra/obstacle_density/30.txt', 'w+'))
     6                                         def dijkstra_algorithm(grid, start, goals, draw=None):
     7 252.0781 MiB -30863.2500 MiB         513       for row in grid:
     8 252.0781 MiB -15781585.3594 MiB      262656           for spot in row:
     9 252.0781 MiB -15750836.1094 MiB      262144               spot.update_neighbors(grid)
    10                                                     
    11                                             # Create a copy of the goals list to avoid modifying the original list
    12  92.0469 MiB -160.0312 MiB           1       remaining_goals = goals.copy()
    13                                         
    14                                             # Initialize data structures
    15  92.3750 MiB   0.3281 MiB           1       open_set = PriorityQueue()
    16  92.5938 MiB   0.2188 MiB           1       open_set.put((0, start))
    17  92.6094 MiB   0.0156 MiB           1       came_from = {}
    18 123.0938 MiB -168442.0000 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    19 123.0938 MiB   0.0000 MiB           1       g_score[start] = 0
    20                                         
    21 133.8281 MiB -1907330.3125 MiB       43661       while not open_set.empty():
    22 133.8281 MiB -1907334.8438 MiB       43661           if draw:  # If there is draw it means the UI is running, check for quit event
    23                                                     for event in pygame.event.get():
    24                                                         if event.type == pygame.QUIT:
    25                                                             pygame.quit()
    26                                         
    27 133.8281 MiB -1907354.7188 MiB       43661           current = open_set.get()[1]
    28                                         
    29 133.8281 MiB -1907356.2500 MiB       43661           if current in remaining_goals:
    30  56.4844 MiB -77.3438 MiB           1               remaining_goals.remove(current)  # Remove this goal from the list
    31  56.4844 MiB   0.0000 MiB           1               if not remaining_goals:
    32  56.4844 MiB   0.0000 MiB           1                   break  # All goals found
    33                                         
    34 133.8281 MiB -17129116.2812 MiB      392262           for neighbor in current.neighbors:
    35 133.8281 MiB -15221826.1562 MiB      348602               temp_g_score = g_score[current] + 10  # Cost of moving orthogonally
    36                                         
    37 133.8281 MiB -15221846.0625 MiB      348602               if current.row != neighbor.row and current.col != neighbor.col:
    38 133.8281 MiB -7604917.3125 MiB      174188                   temp_g_score = g_score[current] + 14  # Cost of moving diagonally
    39                                         
    40 133.8281 MiB -15221911.4844 MiB      348602               if temp_g_score < g_score[neighbor]:
    41 133.8281 MiB -1934399.6250 MiB       44395                   came_from[neighbor] = current
    42 133.8281 MiB -1934400.9531 MiB       44395                   g_score[neighbor] = temp_g_score
    43 133.8281 MiB -1934403.0469 MiB       44395                   open_set.put((temp_g_score, neighbor))
    44                                         
    45 133.8281 MiB -1907324.1094 MiB       43660           if draw is not None:
    46                                                     draw()
    47                                                     
    48 133.8281 MiB -1907325.4844 MiB       43660           if current != start and not current.is_end() and draw:
    49                                                     current.make_closed()
    50                                                     
    51                                             # Reconstruct paths to all goals
    52  56.4844 MiB   0.0000 MiB           1       paths = {}
    53  56.7031 MiB   0.0000 MiB           2       for goal in goals:
    54  56.7031 MiB   0.2188 MiB           1           paths[goal] = reconstruct_path(came_from, goal)
    55                                         
    56  56.7188 MiB   0.0156 MiB           1       return paths


