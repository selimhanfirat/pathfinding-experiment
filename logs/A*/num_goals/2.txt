Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.1 MiB     67.1 MiB           1   @profile(stream=open('logs/A*/num_goals/2.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     71.1 MiB      0.0 MiB         257       for row in grid:
    30     71.1 MiB      0.0 MiB       65792           for spot in row:
    31     71.1 MiB      4.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.1 MiB      0.0 MiB           1       count = 0
    34     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.1 MiB      0.0 MiB           1       came_from = {}
    37     77.9 MiB      6.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     77.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     78.6 MiB -829464.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.7 MiB    -13.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.4 MiB   -836.2 MiB         748       while not open_set.empty():
    47     65.4 MiB   -836.3 MiB         748           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.4 MiB   -836.5 MiB         748           current = open_set.get()[2]
    53     65.4 MiB   -836.7 MiB         748           open_set_hash.remove(current)
    54                                         
    55     65.4 MiB   -837.0 MiB         748           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.4 MiB   -837.3 MiB         748           if current == end:
    60     63.4 MiB     -2.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.4 MiB  -7520.7 MiB        6723           for neighbor in current.neighbors:
    65     65.4 MiB  -6685.7 MiB        5976               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.4 MiB  -3343.6 MiB        2988                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.4 MiB  -3342.4 MiB        2988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.4 MiB  -6685.8 MiB        5976               if temp_g_score < g_score[neighbor]:
    71     65.4 MiB  -1030.9 MiB         956                   came_from[neighbor] = current
    72     65.4 MiB  -1031.0 MiB         956                   g_score[neighbor] = temp_g_score
    73     65.4 MiB  -1031.0 MiB         956                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.4 MiB  -1031.0 MiB         956                   if neighbor not in open_set_hash:
    75     65.4 MiB  -1031.0 MiB         956                       count += 1
    76     65.4 MiB  -1031.0 MiB         956                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.4 MiB  -1031.0 MiB         956                       open_set_hash.add(neighbor)
    78                                                             
    79     65.4 MiB   -836.0 MiB         747           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.4 MiB   -836.0 MiB         747           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.8 MiB     64.8 MiB           1   @profile(stream=open('logs/A*/num_goals/2.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     66.8 MiB    -55.2 MiB         257       for row in grid:
    30     66.8 MiB -14237.0 MiB       65792           for spot in row:
    31     66.8 MiB -14179.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.8 MiB      0.0 MiB           1       count = 0
    34     66.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.8 MiB      0.0 MiB           1       came_from = {}
    37     68.9 MiB -19828.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.5 MiB -19979.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.6 MiB  -3705.8 MiB        3480       while not open_set.empty():
    47     71.6 MiB  -3705.9 MiB        3480           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.6 MiB  -3706.2 MiB        3480           current = open_set.get()[2]
    53     71.6 MiB  -3706.4 MiB        3480           open_set_hash.remove(current)
    54                                         
    55     71.6 MiB  -3706.5 MiB        3480           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.6 MiB  -3706.6 MiB        3480           if current == end:
    60     70.4 MiB     -1.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.6 MiB -33350.6 MiB       31311           for neighbor in current.neighbors:
    65     71.6 MiB -29644.9 MiB       27832               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.6 MiB -14823.2 MiB       13916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.6 MiB -14821.8 MiB       13916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.6 MiB -29645.5 MiB       27832               if temp_g_score < g_score[neighbor]:
    71     71.6 MiB  -3977.5 MiB        3834                   came_from[neighbor] = current
    72     71.6 MiB  -3977.5 MiB        3834                   g_score[neighbor] = temp_g_score
    73     71.6 MiB  -3977.5 MiB        3834                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.6 MiB  -3977.5 MiB        3834                   if neighbor not in open_set_hash:
    75     71.6 MiB  -3977.5 MiB        3834                       count += 1
    76     71.6 MiB  -3977.5 MiB        3834                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.6 MiB  -3977.5 MiB        3834                       open_set_hash.add(neighbor)
    78                                                             
    79     71.6 MiB  -3705.8 MiB        3479           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.6 MiB  -3705.8 MiB        3479           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.1 MiB     96.1 MiB           1   @profile(stream=open('logs/A*/num_goals/3.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.2 MiB   -117.2 MiB         257       for row in grid:
    30     98.2 MiB -30139.4 MiB       65792           for spot in row:
    31     98.2 MiB -30021.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.2 MiB      0.0 MiB           1       count = 0
    34     98.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.2 MiB      0.0 MiB           1       came_from = {}
    37    104.5 MiB      6.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.5 MiB -418368.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.1 MiB    -10.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.3 MiB    -44.7 MiB        1365       while not open_set.empty():
    47     94.3 MiB    -44.7 MiB        1365           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.3 MiB    -44.7 MiB        1365           current = open_set.get()[2]
    53     94.3 MiB    -44.7 MiB        1365           open_set_hash.remove(current)
    54                                         
    55     94.3 MiB    -44.7 MiB        1365           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.3 MiB    -44.7 MiB        1365           if current == end:
    60     94.3 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.3 MiB   -401.8 MiB       12276           for neighbor in current.neighbors:
    65     94.3 MiB   -357.4 MiB       10912               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.3 MiB   -178.8 MiB        5456                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.3 MiB   -178.5 MiB        5456                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.3 MiB   -357.4 MiB       10912               if temp_g_score < g_score[neighbor]:
    71     94.3 MiB    -52.0 MiB        1625                   came_from[neighbor] = current
    72     94.3 MiB    -52.1 MiB        1625                   g_score[neighbor] = temp_g_score
    73     94.3 MiB    -52.1 MiB        1625                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.3 MiB    -52.1 MiB        1625                   if neighbor not in open_set_hash:
    75     94.3 MiB    -52.1 MiB        1625                       count += 1
    76     94.3 MiB    -52.0 MiB        1625                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.3 MiB    -52.0 MiB        1625                       open_set_hash.add(neighbor)
    78                                                             
    79     94.3 MiB    -44.7 MiB        1364           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.3 MiB    -44.7 MiB        1364           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.4 MiB     94.4 MiB           1   @profile(stream=open('logs/A*/num_goals/3.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.3 MiB      0.0 MiB         257       for row in grid:
    30     97.3 MiB      0.0 MiB       65792           for spot in row:
    31     97.3 MiB      3.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.3 MiB      0.0 MiB           1       count = 0
    34     97.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.3 MiB      0.0 MiB           1       came_from = {}
    37    101.6 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.9 MiB -62568.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.1 MiB     -3.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.1 MiB      0.0 MiB         203       while not open_set.empty():
    47    102.1 MiB      0.0 MiB         203           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.1 MiB      0.0 MiB         203           current = open_set.get()[2]
    53    102.1 MiB      0.0 MiB         203           open_set_hash.remove(current)
    54                                         
    55    102.1 MiB      0.0 MiB         203           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.1 MiB      0.0 MiB         203           if current == end:
    60    102.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.1 MiB      0.0 MiB        1818           for neighbor in current.neighbors:
    65    102.1 MiB      0.0 MiB        1616               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.1 MiB      0.0 MiB         808                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.1 MiB      0.0 MiB         808                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.1 MiB      0.0 MiB        1616               if temp_g_score < g_score[neighbor]:
    71    102.1 MiB      0.0 MiB         331                   came_from[neighbor] = current
    72    102.1 MiB      0.0 MiB         331                   g_score[neighbor] = temp_g_score
    73    102.1 MiB      0.0 MiB         331                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.1 MiB      0.0 MiB         331                   if neighbor not in open_set_hash:
    75    102.1 MiB      0.0 MiB         331                       count += 1
    76    102.1 MiB      0.0 MiB         331                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.1 MiB      0.0 MiB         331                       open_set_hash.add(neighbor)
    78                                                             
    79    102.1 MiB      0.0 MiB         202           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.1 MiB      0.0 MiB         202           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.0 MiB    108.0 MiB           1   @profile(stream=open('logs/A*/num_goals/3.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.0 MiB  -2774.9 MiB         257       for row in grid:
    30    108.0 MiB -711285.8 MiB       65792           for spot in row:
    31    108.0 MiB -708521.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.2 MiB    -14.8 MiB           1       count = 0
    34     93.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.2 MiB      0.0 MiB           1       came_from = {}
    37     95.0 MiB -127099.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.0 MiB     -4.0 MiB           1       g_score[start] = 0
    39     96.8 MiB      5.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.9 MiB  -6273.8 MiB        6765       while not open_set.empty():
    47     96.9 MiB  -6273.8 MiB        6765           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.9 MiB  -6273.8 MiB        6765           current = open_set.get()[2]
    53     96.9 MiB  -6274.0 MiB        6765           open_set_hash.remove(current)
    54                                         
    55     96.9 MiB  -6274.0 MiB        6765           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.9 MiB  -6274.0 MiB        6765           if current == end:
    60     96.5 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.9 MiB -56460.4 MiB       60876           for neighbor in current.neighbors:
    65     96.9 MiB -50186.8 MiB       54112               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.9 MiB -25094.7 MiB       27056                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.9 MiB -25092.4 MiB       27056                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.9 MiB -50187.2 MiB       54112               if temp_g_score < g_score[neighbor]:
    71     96.9 MiB  -6620.8 MiB        7229                   came_from[neighbor] = current
    72     96.9 MiB  -6620.8 MiB        7229                   g_score[neighbor] = temp_g_score
    73     96.9 MiB  -6620.8 MiB        7229                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.9 MiB  -6620.8 MiB        7229                   if neighbor not in open_set_hash:
    75     96.9 MiB  -6620.8 MiB        7229                       count += 1
    76     96.9 MiB  -6620.8 MiB        7229                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.9 MiB  -6620.8 MiB        7229                       open_set_hash.add(neighbor)
    78                                                             
    79     96.9 MiB  -6273.8 MiB        6764           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.9 MiB  -6273.8 MiB        6764           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.6 MiB     96.6 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.8 MiB   -199.9 MiB         257       for row in grid:
    30     96.8 MiB -49292.6 MiB       65792           for spot in row:
    31     96.8 MiB -49105.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     78.8 MiB    -18.1 MiB           1       count = 0
    34     78.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     78.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     78.8 MiB      0.0 MiB           1       came_from = {}
    37     83.3 MiB -10189.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.9 MiB    -12.3 MiB           1       g_score[start] = 0
    39     75.6 MiB      4.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.6 MiB -95800.3 MiB        6500       while not open_set.empty():
    47     75.6 MiB -95800.5 MiB        6500           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.6 MiB -95800.9 MiB        6500           current = open_set.get()[2]
    53     75.6 MiB -95801.5 MiB        6500           open_set_hash.remove(current)
    54                                         
    55     75.6 MiB -95801.9 MiB        6500           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.6 MiB -95802.2 MiB        6500           if current == end:
    60     60.1 MiB    -15.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.6 MiB -862148.6 MiB       58491           for neighbor in current.neighbors:
    65     75.6 MiB -766352.7 MiB       51992               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.6 MiB -383188.4 MiB       25996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.6 MiB -383168.3 MiB       25996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.6 MiB -766362.7 MiB       51992               if temp_g_score < g_score[neighbor]:
    71     75.6 MiB -103086.1 MiB        7102                   came_from[neighbor] = current
    72     75.6 MiB -103086.4 MiB        7102                   g_score[neighbor] = temp_g_score
    73     75.6 MiB -103085.9 MiB        7102                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.6 MiB -103086.0 MiB        7102                   if neighbor not in open_set_hash:
    75     75.6 MiB -103086.3 MiB        7102                       count += 1
    76     75.6 MiB -103083.6 MiB        7102                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.6 MiB -103083.7 MiB        7102                       open_set_hash.add(neighbor)
    78                                                             
    79     75.6 MiB -95799.6 MiB        6499           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.6 MiB -95799.7 MiB        6499           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.8 MiB    102.8 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.8 MiB      0.0 MiB         257       for row in grid:
    30    102.8 MiB      0.0 MiB       65792           for spot in row:
    31    102.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.8 MiB      0.0 MiB           1       count = 0
    34    102.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.8 MiB      0.0 MiB           1       came_from = {}
    37    105.9 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.4 MiB -174556.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.9 MiB     -4.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.0 MiB      0.0 MiB          20       while not open_set.empty():
    47    102.0 MiB      0.0 MiB          20           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.0 MiB      0.0 MiB          20           current = open_set.get()[2]
    53    102.0 MiB      0.0 MiB          20           open_set_hash.remove(current)
    54                                         
    55    102.0 MiB      0.0 MiB          20           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.0 MiB      0.0 MiB          20           if current == end:
    60    102.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.0 MiB      0.0 MiB         171           for neighbor in current.neighbors:
    65    102.0 MiB      0.0 MiB         152               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.0 MiB      0.0 MiB          76                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.0 MiB      0.0 MiB          76                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.0 MiB      0.0 MiB         152               if temp_g_score < g_score[neighbor]:
    71    102.0 MiB      0.0 MiB          46                   came_from[neighbor] = current
    72    102.0 MiB      0.0 MiB          46                   g_score[neighbor] = temp_g_score
    73    102.0 MiB      0.0 MiB          46                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.0 MiB      0.0 MiB          46                   if neighbor not in open_set_hash:
    75    102.0 MiB      0.0 MiB          46                       count += 1
    76    102.0 MiB      0.0 MiB          46                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.0 MiB      0.0 MiB          46                       open_set_hash.add(neighbor)
    78                                                             
    79    102.0 MiB      0.0 MiB          19           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.0 MiB      0.0 MiB          19           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.8 MiB    103.8 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.1 MiB  -1796.6 MiB         257       for row in grid:
    30    104.1 MiB -460500.9 MiB       65792           for spot in row:
    31    104.1 MiB -458707.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.8 MiB     -9.3 MiB           1       count = 0
    34     94.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.8 MiB      0.0 MiB           1       came_from = {}
    37     99.0 MiB  -2988.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.9 MiB     -0.1 MiB           1       g_score[start] = 0
    39    102.5 MiB   -429.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.5 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.5 MiB -104201.3 MiB        3159       while not open_set.empty():
    47    102.5 MiB -104202.4 MiB        3159           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.5 MiB -104203.3 MiB        3159           current = open_set.get()[2]
    53    102.5 MiB -104203.5 MiB        3159           open_set_hash.remove(current)
    54                                         
    55    102.5 MiB -104205.2 MiB        3159           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.5 MiB -104208.8 MiB        3159           if current == end:
    60     59.2 MiB    -43.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.5 MiB -937588.0 MiB       28422           for neighbor in current.neighbors:
    65    102.5 MiB -833404.4 MiB       25264               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.5 MiB -416733.7 MiB       12632                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.5 MiB -416673.5 MiB       12632                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.5 MiB -833407.5 MiB       25264               if temp_g_score < g_score[neighbor]:
    71    102.5 MiB -119459.7 MiB        3679                   came_from[neighbor] = current
    72    102.5 MiB -119460.0 MiB        3679                   g_score[neighbor] = temp_g_score
    73    102.5 MiB -119459.2 MiB        3679                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.5 MiB -119459.8 MiB        3679                   if neighbor not in open_set_hash:
    75    102.5 MiB -119460.4 MiB        3679                       count += 1
    76    102.5 MiB -119461.9 MiB        3679                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.5 MiB -119462.5 MiB        3679                       open_set_hash.add(neighbor)
    78                                                             
    79    102.5 MiB -104189.4 MiB        3158           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.5 MiB -104191.4 MiB        3158           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.4 MiB    104.4 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.4 MiB    -58.8 MiB         257       for row in grid:
    30    104.4 MiB -15011.7 MiB       65792           for spot in row:
    31    104.4 MiB -14953.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.8 MiB     -0.6 MiB           1       count = 0
    34    103.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.8 MiB      0.0 MiB           1       came_from = {}
    37    105.7 MiB -178334.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.1 MiB     -5.7 MiB           1       g_score[start] = 0
    39    104.8 MiB -56585.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.2 MiB     -3.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.4 MiB   -785.1 MiB         748       while not open_set.empty():
    47    101.4 MiB   -785.2 MiB         748           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.4 MiB   -785.2 MiB         748           current = open_set.get()[2]
    53    101.4 MiB   -785.3 MiB         748           open_set_hash.remove(current)
    54                                         
    55    101.4 MiB   -785.3 MiB         748           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.4 MiB   -785.3 MiB         748           if current == end:
    60     97.4 MiB     -4.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.4 MiB  -7049.0 MiB        6723           for neighbor in current.neighbors:
    65    101.4 MiB  -6264.5 MiB        5976               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.4 MiB  -3136.5 MiB        2988                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.4 MiB  -3128.8 MiB        2988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.4 MiB  -6266.2 MiB        5976               if temp_g_score < g_score[neighbor]:
    71    101.4 MiB   -957.7 MiB         926                   came_from[neighbor] = current
    72    101.4 MiB   -958.0 MiB         926                   g_score[neighbor] = temp_g_score
    73    101.4 MiB   -958.4 MiB         926                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.4 MiB   -958.4 MiB         926                   if neighbor not in open_set_hash:
    75    101.4 MiB   -958.4 MiB         926                       count += 1
    76    101.4 MiB   -958.7 MiB         926                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.4 MiB   -958.7 MiB         926                       open_set_hash.add(neighbor)
    78                                                             
    79    101.4 MiB   -785.1 MiB         747           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.4 MiB   -785.1 MiB         747           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.5 MiB     97.5 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.7 MiB  -5336.2 MiB         257       for row in grid:
    30     98.7 MiB -1370956.3 MiB       65792           for spot in row:
    31     98.7 MiB -1365651.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     68.0 MiB    -30.7 MiB           1       count = 0
    34     68.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     68.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     68.0 MiB      0.0 MiB           1       came_from = {}
    37     69.4 MiB -70099.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     73.1 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     73.1 MiB -46271.7 MiB        7579       while not open_set.empty():
    47     73.1 MiB -46272.0 MiB        7579           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     73.1 MiB -46272.4 MiB        7579           current = open_set.get()[2]
    53     73.1 MiB -46272.4 MiB        7579           open_set_hash.remove(current)
    54                                         
    55     73.1 MiB -46272.8 MiB        7579           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     73.1 MiB -46273.2 MiB        7579           if current == end:
    60     62.3 MiB    -10.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     73.1 MiB -416407.7 MiB       68202           for neighbor in current.neighbors:
    65     73.1 MiB -370139.1 MiB       60624               if current.row != neighbor.row and current.col != neighbor.col:
    66     73.1 MiB -185079.9 MiB       30312                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     73.1 MiB -185063.7 MiB       30312                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     73.1 MiB -370144.4 MiB       60624               if temp_g_score < g_score[neighbor]:
    71     73.1 MiB -48574.3 MiB        8075                   came_from[neighbor] = current
    72     73.1 MiB -48574.5 MiB        8075                   g_score[neighbor] = temp_g_score
    73     73.1 MiB -48574.9 MiB        8075                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     73.1 MiB -48575.4 MiB        8075                   if neighbor not in open_set_hash:
    75     73.1 MiB -48575.5 MiB        8075                       count += 1
    76     73.1 MiB -48572.8 MiB        8075                       open_set.put((f_score[neighbor], count, neighbor))
    77     73.1 MiB -48573.4 MiB        8075                       open_set_hash.add(neighbor)
    78                                                             
    79     73.1 MiB -46271.2 MiB        7578           if draw is not None:
    80                                                     draw()
    81                                         
    82     73.1 MiB -46271.5 MiB        7578           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.7 MiB    103.7 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.7 MiB    -61.6 MiB         257       for row in grid:
    30    103.7 MiB -15788.5 MiB       65792           for spot in row:
    31    103.7 MiB -15727.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.1 MiB     -0.5 MiB           1       count = 0
    34    103.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.1 MiB      0.0 MiB           1       came_from = {}
    37    107.6 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.6 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.6 MiB      0.0 MiB        1152       while not open_set.empty():
    47    110.6 MiB      0.0 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.6 MiB      0.0 MiB        1152           current = open_set.get()[2]
    53    110.6 MiB      0.0 MiB        1152           open_set_hash.remove(current)
    54                                         
    55    110.6 MiB      0.0 MiB        1152           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.6 MiB      0.0 MiB        1152           if current == end:
    60    110.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.6 MiB      0.0 MiB       10359           for neighbor in current.neighbors:
    65    110.6 MiB      0.0 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.6 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.6 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.6 MiB      0.0 MiB        9208               if temp_g_score < g_score[neighbor]:
    71    110.6 MiB      0.1 MiB        1442                   came_from[neighbor] = current
    72    110.6 MiB      0.0 MiB        1442                   g_score[neighbor] = temp_g_score
    73    110.6 MiB      0.0 MiB        1442                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.6 MiB      0.0 MiB        1442                   if neighbor not in open_set_hash:
    75    110.6 MiB      0.0 MiB        1442                       count += 1
    76    110.6 MiB      0.0 MiB        1442                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.6 MiB      0.0 MiB        1442                       open_set_hash.add(neighbor)
    78                                                             
    79    110.6 MiB      0.0 MiB        1151           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.6 MiB      0.0 MiB        1151           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.6 MiB    110.6 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.6 MiB  -1210.2 MiB         257       for row in grid:
    30    110.6 MiB -308036.3 MiB       65792           for spot in row:
    31    110.6 MiB -306841.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.8 MiB    -22.8 MiB           1       count = 0
    34     87.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     87.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     87.9 MiB      0.0 MiB           1       came_from = {}
    37     93.1 MiB -30133.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.5 MiB     -1.6 MiB           1       g_score[start] = 0
    39     95.4 MiB -166236.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     84.0 MiB    -11.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     84.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     84.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     84.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     86.1 MiB  -5578.5 MiB        1737       while not open_set.empty():
    47     86.1 MiB  -5578.5 MiB        1737           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     86.1 MiB  -5578.5 MiB        1737           current = open_set.get()[2]
    53     86.1 MiB  -5578.9 MiB        1737           open_set_hash.remove(current)
    54                                         
    55     86.1 MiB  -5579.2 MiB        1737           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     86.1 MiB  -5579.3 MiB        1737           if current == end:
    60     84.8 MiB     -1.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     84.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     86.1 MiB -50193.4 MiB       15624           for neighbor in current.neighbors:
    65     86.1 MiB -44616.4 MiB       13888               if current.row != neighbor.row and current.col != neighbor.col:
    66     86.1 MiB -22308.1 MiB        6944                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     86.1 MiB -22309.3 MiB        6944                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     86.1 MiB -44618.1 MiB       13888               if temp_g_score < g_score[neighbor]:
    71     86.1 MiB  -8062.6 MiB        2525                   came_from[neighbor] = current
    72     86.1 MiB  -8062.6 MiB        2525                   g_score[neighbor] = temp_g_score
    73     86.1 MiB  -8062.6 MiB        2525                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     86.1 MiB  -8062.6 MiB        2525                   if neighbor not in open_set_hash:
    75     86.1 MiB  -8062.8 MiB        2525                       count += 1
    76     86.1 MiB  -8056.7 MiB        2525                       open_set.put((f_score[neighbor], count, neighbor))
    77     86.1 MiB  -8059.3 MiB        2525                       open_set_hash.add(neighbor)
    78                                                             
    79     86.1 MiB  -5578.2 MiB        1736           if draw is not None:
    80                                                     draw()
    81                                         
    82     86.1 MiB  -5578.4 MiB        1736           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.9 MiB    100.9 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.9 MiB   -499.7 MiB         257       for row in grid:
    30    100.9 MiB -128327.4 MiB       65792           for spot in row:
    31    100.9 MiB -127830.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.8 MiB     -3.1 MiB           1       count = 0
    34     97.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.8 MiB      0.0 MiB           1       came_from = {}
    37    102.1 MiB  -1659.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.4 MiB -25670.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.8 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.9 MiB -91409.5 MiB        5664       while not open_set.empty():
    47    101.9 MiB -91410.4 MiB        5664           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.9 MiB -91411.9 MiB        5664           current = open_set.get()[2]
    53    101.9 MiB -91413.4 MiB        5664           open_set_hash.remove(current)
    54                                         
    55    101.9 MiB -91422.5 MiB        5664           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.9 MiB -91423.0 MiB        5664           if current == end:
    60     56.4 MiB    -45.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.9 MiB -822500.6 MiB       50967           for neighbor in current.neighbors:
    65    101.9 MiB -731097.2 MiB       45304               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.9 MiB -365588.6 MiB       22652                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.9 MiB -365531.2 MiB       22652                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.9 MiB -731124.9 MiB       45304               if temp_g_score < g_score[neighbor]:
    71    101.9 MiB -102765.0 MiB        6434                   came_from[neighbor] = current
    72    101.9 MiB -102765.4 MiB        6434                   g_score[neighbor] = temp_g_score
    73    101.9 MiB -102766.0 MiB        6434                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.9 MiB -102766.5 MiB        6434                   if neighbor not in open_set_hash:
    75    101.9 MiB -102766.8 MiB        6434                       count += 1
    76    101.9 MiB -102758.5 MiB        6434                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.9 MiB -102758.7 MiB        6434                       open_set_hash.add(neighbor)
    78                                                             
    79    101.9 MiB -91408.1 MiB        5663           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.9 MiB -91408.8 MiB        5663           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.5 MiB     59.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.1 MiB   -203.3 MiB         257       for row in grid:
    30     60.1 MiB -52232.7 MiB       65792           for spot in row:
    31     60.1 MiB -52029.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.0 MiB     -0.2 MiB           1       count = 0
    34     60.1 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     60.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.1 MiB      0.0 MiB           1       came_from = {}
    37     64.2 MiB -10212.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.6 MiB  -4391.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.1 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.3 MiB -10461.2 MiB        3498       while not open_set.empty():
    47     68.3 MiB -10461.8 MiB        3498           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.3 MiB -10464.4 MiB        3498           current = open_set.get()[2]
    53     68.3 MiB -10465.0 MiB        3498           open_set_hash.remove(current)
    54                                         
    55     68.3 MiB -10465.1 MiB        3498           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.3 MiB -10465.5 MiB        3498           if current == end:
    60     47.8 MiB    -20.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.9 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.3 MiB -94068.1 MiB       31473           for neighbor in current.neighbors:
    65     68.3 MiB -83609.7 MiB       27976               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.3 MiB -41822.2 MiB       13988                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.3 MiB -41790.8 MiB       13988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.3 MiB -83615.3 MiB       27976               if temp_g_score < g_score[neighbor]:
    71     68.3 MiB -11672.8 MiB        3866                   came_from[neighbor] = current
    72     68.3 MiB -11673.1 MiB        3866                   g_score[neighbor] = temp_g_score
    73     68.3 MiB -11673.4 MiB        3866                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.3 MiB -11673.8 MiB        3866                   if neighbor not in open_set_hash:
    75     68.3 MiB -11674.0 MiB        3866                       count += 1
    76     68.3 MiB -11674.6 MiB        3866                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.3 MiB -11677.7 MiB        3866                       open_set_hash.add(neighbor)
    78                                                             
    79     68.3 MiB -10459.9 MiB        3497           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.3 MiB -10460.1 MiB        3497           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.7 MiB    101.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.7 MiB    -44.2 MiB         257       for row in grid:
    30    101.7 MiB -11328.0 MiB       65792           for spot in row:
    31    101.7 MiB -11283.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.5 MiB     -0.2 MiB           1       count = 0
    34    101.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.5 MiB      0.0 MiB           1       came_from = {}
    37    103.6 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.0 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.2 MiB    -13.0 MiB        4845       while not open_set.empty():
    47    106.2 MiB    -13.0 MiB        4845           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.2 MiB    -13.0 MiB        4845           current = open_set.get()[2]
    53    106.2 MiB    -13.0 MiB        4845           open_set_hash.remove(current)
    54                                         
    55    106.2 MiB    -13.0 MiB        4845           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.2 MiB    -13.0 MiB        4845           if current == end:
    60    106.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.2 MiB   -117.5 MiB       43596           for neighbor in current.neighbors:
    65    106.2 MiB   -104.6 MiB       38752               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.2 MiB    -52.2 MiB       19376                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.2 MiB    -52.4 MiB       19376                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.2 MiB   -104.6 MiB       38752               if temp_g_score < g_score[neighbor]:
    71    106.2 MiB    -13.6 MiB        5297                   came_from[neighbor] = current
    72    106.2 MiB    -13.8 MiB        5297                   g_score[neighbor] = temp_g_score
    73    106.2 MiB    -13.8 MiB        5297                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.2 MiB    -13.8 MiB        5297                   if neighbor not in open_set_hash:
    75    106.2 MiB    -13.8 MiB        5297                       count += 1
    76    106.2 MiB    -13.8 MiB        5297                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.2 MiB    -13.8 MiB        5297                       open_set_hash.add(neighbor)
    78                                                             
    79    106.2 MiB    -13.0 MiB        4844           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.2 MiB    -13.0 MiB        4844           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB     -6.7 MiB         257       for row in grid:
    30    106.2 MiB  -1716.7 MiB       65792           for spot in row:
    31    106.2 MiB  -1710.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.1 MiB     -0.1 MiB           1       count = 0
    34    106.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.1 MiB      0.0 MiB           1       came_from = {}
    37    107.1 MiB -92994.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.8 MiB     -0.3 MiB           1       g_score[start] = 0
    39    109.3 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.4 MiB -292892.6 MiB        7371       while not open_set.empty():
    47    109.4 MiB -292893.1 MiB        7371           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.4 MiB -292894.5 MiB        7371           current = open_set.get()[2]
    53    109.4 MiB -292895.3 MiB        7371           open_set_hash.remove(current)
    54                                         
    55    109.4 MiB -292895.8 MiB        7371           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.4 MiB -292896.4 MiB        7371           if current == end:
    60     33.4 MiB    -76.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     33.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.4 MiB -2635698.8 MiB       66330           for neighbor in current.neighbors:
    65    109.4 MiB -2342823.5 MiB       58960               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.4 MiB -1171510.9 MiB       29480                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.4 MiB -1171334.0 MiB       29480                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.4 MiB -2342855.6 MiB       58960               if temp_g_score < g_score[neighbor]:
    71    109.4 MiB -307217.9 MiB        7895                   came_from[neighbor] = current
    72    109.4 MiB -307219.6 MiB        7895                   g_score[neighbor] = temp_g_score
    73    109.4 MiB -307221.3 MiB        7895                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.4 MiB -307222.8 MiB        7895                   if neighbor not in open_set_hash:
    75    109.4 MiB -307224.5 MiB        7895                       count += 1
    76    109.4 MiB -307230.0 MiB        7895                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.4 MiB -307231.3 MiB        7895                       open_set_hash.add(neighbor)
    78                                                             
    79    109.4 MiB -292890.8 MiB        7370           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.4 MiB -292892.0 MiB        7370           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.1 MiB     98.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.1 MiB  -1831.9 MiB         257       for row in grid:
    30     98.1 MiB -469740.3 MiB       65792           for spot in row:
    31     98.1 MiB -467913.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.1 MiB     -8.0 MiB           1       count = 0
    34     90.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     90.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     90.5 MiB      0.0 MiB           1       came_from = {}
    37     94.6 MiB  -9583.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.5 MiB     -0.1 MiB           1       g_score[start] = 0
    39     97.0 MiB -1524135.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     41.2 MiB    -55.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     41.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     41.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     41.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     44.7 MiB     -0.0 MiB         189       while not open_set.empty():
    47     44.7 MiB     -0.1 MiB         189           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     44.7 MiB     -0.0 MiB         189           current = open_set.get()[2]
    53     44.7 MiB     -0.1 MiB         189           open_set_hash.remove(current)
    54                                         
    55     44.7 MiB     -0.1 MiB         189           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     44.7 MiB     -0.1 MiB         189           if current == end:
    60     44.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     44.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     44.7 MiB      0.4 MiB        1692           for neighbor in current.neighbors:
    65     44.7 MiB      1.5 MiB        1504               if current.row != neighbor.row and current.col != neighbor.col:
    66     44.7 MiB     -0.3 MiB         752                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     44.7 MiB     -0.2 MiB         752                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     44.7 MiB     -0.4 MiB        1504               if temp_g_score < g_score[neighbor]:
    71     44.7 MiB     -0.1 MiB         445                   came_from[neighbor] = current
    72     44.7 MiB     -0.2 MiB         445                   g_score[neighbor] = temp_g_score
    73     44.7 MiB     -0.2 MiB         445                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     44.7 MiB     -0.2 MiB         445                   if neighbor not in open_set_hash:
    75     44.7 MiB     -0.2 MiB         445                       count += 1
    76     44.7 MiB     -0.1 MiB         445                       open_set.put((f_score[neighbor], count, neighbor))
    77     44.7 MiB     -0.1 MiB         445                       open_set_hash.add(neighbor)
    78                                                             
    79     44.7 MiB     -0.1 MiB         188           if draw is not None:
    80                                                     draw()
    81                                         
    82     44.7 MiB     -0.1 MiB         188           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     48.3 MiB     48.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.0 MiB     -2.6 MiB         257       for row in grid:
    30     64.0 MiB   -697.7 MiB       65792           for spot in row:
    31     64.0 MiB   -679.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.0 MiB      0.0 MiB           1       count = 0
    34     64.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     64.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     64.0 MiB      0.0 MiB           1       came_from = {}
    37     67.7 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.6 MiB  -2386.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.6 MiB   -465.9 MiB        1743       while not open_set.empty():
    47     70.6 MiB   -465.9 MiB        1743           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.6 MiB   -465.9 MiB        1743           current = open_set.get()[2]
    53     70.6 MiB   -465.9 MiB        1743           open_set_hash.remove(current)
    54                                         
    55     70.6 MiB   -466.0 MiB        1743           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.6 MiB   -466.0 MiB        1743           if current == end:
    60     70.1 MiB     -0.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.6 MiB  -4192.0 MiB       15678           for neighbor in current.neighbors:
    65     70.6 MiB  -3726.1 MiB       13936               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.6 MiB  -1863.5 MiB        6968                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.6 MiB  -1862.6 MiB        6968                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.6 MiB  -3726.2 MiB       13936               if temp_g_score < g_score[neighbor]:
    71     70.6 MiB   -520.0 MiB        1991                   came_from[neighbor] = current
    72     70.6 MiB   -520.1 MiB        1991                   g_score[neighbor] = temp_g_score
    73     70.6 MiB   -520.2 MiB        1991                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.6 MiB   -520.2 MiB        1991                   if neighbor not in open_set_hash:
    75     70.6 MiB   -520.2 MiB        1991                       count += 1
    76     70.6 MiB   -520.2 MiB        1991                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.6 MiB   -520.2 MiB        1991                       open_set_hash.add(neighbor)
    78                                                             
    79     70.6 MiB   -465.9 MiB        1742           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.6 MiB   -465.9 MiB        1742           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.7 MiB    106.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.7 MiB   -940.0 MiB         257       for row in grid:
    30    106.7 MiB -240587.2 MiB       65792           for spot in row:
    31    106.7 MiB -239653.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.9 MiB     -6.8 MiB           1       count = 0
    34     99.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.9 MiB      0.0 MiB           1       came_from = {}
    37    103.2 MiB  -2360.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.2 MiB     -0.0 MiB           1       g_score[start] = 0
    39    107.0 MiB -63230.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.0 MiB     -9.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.2 MiB -12485.0 MiB        1332       while not open_set.empty():
    47     98.2 MiB -12485.1 MiB        1332           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.2 MiB -12485.3 MiB        1332           current = open_set.get()[2]
    53     98.2 MiB -12485.4 MiB        1332           open_set_hash.remove(current)
    54                                         
    55     98.2 MiB -12485.5 MiB        1332           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.2 MiB -12485.6 MiB        1332           if current == end:
    60     85.2 MiB    -13.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     85.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.2 MiB -109994.8 MiB       11760           for neighbor in current.neighbors:
    65     98.2 MiB -97513.9 MiB       10429               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.2 MiB -48392.0 MiB        5178                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.2 MiB -49122.7 MiB        5251                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.2 MiB -97515.8 MiB       10429               if temp_g_score < g_score[neighbor]:
    71     98.2 MiB -13348.8 MiB        1475                   came_from[neighbor] = current
    72     98.2 MiB -13349.1 MiB        1475                   g_score[neighbor] = temp_g_score
    73     98.2 MiB -13349.5 MiB        1475                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.2 MiB -13349.9 MiB        1475                   if neighbor not in open_set_hash:
    75     98.2 MiB -13350.3 MiB        1475                       count += 1
    76     98.2 MiB -13350.6 MiB        1475                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.2 MiB -13351.3 MiB        1475                       open_set_hash.add(neighbor)
    78                                                             
    79     98.2 MiB -12484.9 MiB        1331           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.2 MiB -12485.0 MiB        1331           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.7 MiB     88.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.3 MiB    -12.8 MiB         257       for row in grid:
    30     96.3 MiB  -3198.6 MiB       65792           for spot in row:
    31     96.3 MiB  -3177.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.3 MiB      0.0 MiB           1       count = 0
    34     96.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.3 MiB      0.0 MiB           1       came_from = {}
    37    101.0 MiB   -185.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.9 MiB -1824445.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     56.9 MiB    -45.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     56.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     56.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     56.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     57.2 MiB   -248.7 MiB         618       while not open_set.empty():
    47     57.2 MiB   -248.8 MiB         618           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     57.2 MiB   -248.8 MiB         618           current = open_set.get()[2]
    53     57.2 MiB   -248.7 MiB         618           open_set_hash.remove(current)
    54                                         
    55     57.2 MiB   -248.8 MiB         618           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     57.2 MiB   -248.8 MiB         618           if current == end:
    60     56.2 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     57.2 MiB  -2228.7 MiB        5553           for neighbor in current.neighbors:
    65     57.2 MiB  -1979.8 MiB        4936               if current.row != neighbor.row and current.col != neighbor.col:
    66     57.2 MiB   -989.6 MiB        2468                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     57.2 MiB   -990.2 MiB        2468                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     57.2 MiB  -1981.2 MiB        4936               if temp_g_score < g_score[neighbor]:
    71     57.2 MiB   -334.1 MiB         846                   came_from[neighbor] = current
    72     57.2 MiB   -334.2 MiB         846                   g_score[neighbor] = temp_g_score
    73     57.2 MiB   -334.2 MiB         846                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     57.2 MiB   -334.2 MiB         846                   if neighbor not in open_set_hash:
    75     57.2 MiB   -334.2 MiB         846                       count += 1
    76     57.2 MiB   -334.1 MiB         846                       open_set.put((f_score[neighbor], count, neighbor))
    77     57.2 MiB   -334.1 MiB         846                       open_set_hash.add(neighbor)
    78                                                             
    79     57.2 MiB   -248.8 MiB         617           if draw is not None:
    80                                                     draw()
    81                                         
    82     57.2 MiB   -248.8 MiB         617           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.3 MiB    103.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.3 MiB   -429.5 MiB         257       for row in grid:
    30    103.3 MiB -110272.6 MiB       65792           for spot in row:
    31    103.3 MiB -109845.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.0 MiB     -3.3 MiB           1       count = 0
    34    100.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.0 MiB      0.0 MiB           1       came_from = {}
    37    101.3 MiB -99505.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     90.8 MiB    -10.5 MiB           1       g_score[start] = 0
    39     91.2 MiB -359829.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     86.2 MiB     -5.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     86.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     86.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     86.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     87.3 MiB -16469.3 MiB         660       while not open_set.empty():
    47     87.3 MiB -16469.7 MiB         660           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     87.3 MiB -16470.3 MiB         660           current = open_set.get()[2]
    53     87.3 MiB -16470.7 MiB         660           open_set_hash.remove(current)
    54                                         
    55     87.3 MiB -16470.7 MiB         660           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     87.3 MiB -16470.7 MiB         660           if current == end:
    60     59.3 MiB    -27.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.4 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     87.3 MiB -148082.5 MiB        5931           for neighbor in current.neighbors:
    65     87.3 MiB -131643.2 MiB        5272               if current.row != neighbor.row and current.col != neighbor.col:
    66     87.3 MiB -65848.7 MiB        2636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     87.3 MiB -65796.3 MiB        2636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     87.3 MiB -131646.1 MiB        5272               if temp_g_score < g_score[neighbor]:
    71     87.3 MiB -29524.5 MiB        1196                   came_from[neighbor] = current
    72     87.3 MiB -29524.6 MiB        1196                   g_score[neighbor] = temp_g_score
    73     87.3 MiB -29525.1 MiB        1196                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     87.3 MiB -29525.3 MiB        1196                   if neighbor not in open_set_hash:
    75     87.3 MiB -29525.3 MiB        1196                       count += 1
    76     87.3 MiB -29515.5 MiB        1196                       open_set.put((f_score[neighbor], count, neighbor))
    77     87.3 MiB -29516.3 MiB        1196                       open_set_hash.add(neighbor)
    78                                                             
    79     87.3 MiB -16476.5 MiB         659           if draw is not None:
    80                                                     draw()
    81                                         
    82     87.3 MiB -16469.1 MiB         659           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.9 MiB     61.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.2 MiB  -1276.0 MiB         257       for row in grid:
    30     62.2 MiB -327253.9 MiB       65792           for spot in row:
    31     62.2 MiB -325984.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.3 MiB     -3.9 MiB           1       count = 0
    34     58.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.4 MiB      0.0 MiB           1       came_from = {}
    37     63.4 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.8 MiB      5.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.8 MiB      0.0 MiB          60       while not open_set.empty():
    47     68.8 MiB      0.0 MiB          60           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.8 MiB      0.0 MiB          60           current = open_set.get()[2]
    53     68.8 MiB      0.0 MiB          60           open_set_hash.remove(current)
    54                                         
    55     68.8 MiB      0.0 MiB          60           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.8 MiB      0.0 MiB          60           if current == end:
    60     68.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.8 MiB      0.0 MiB         531           for neighbor in current.neighbors:
    65     68.8 MiB      0.0 MiB         472               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.8 MiB      0.0 MiB         236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.8 MiB      0.0 MiB         236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.8 MiB      0.0 MiB         472               if temp_g_score < g_score[neighbor]:
    71     68.8 MiB      0.0 MiB         144                   came_from[neighbor] = current
    72     68.8 MiB      0.0 MiB         144                   g_score[neighbor] = temp_g_score
    73     68.8 MiB      0.0 MiB         144                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.8 MiB      0.0 MiB         144                   if neighbor not in open_set_hash:
    75     68.8 MiB      0.0 MiB         144                       count += 1
    76     68.8 MiB      0.0 MiB         144                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.8 MiB      0.0 MiB         144                       open_set_hash.add(neighbor)
    78                                                             
    79     68.8 MiB      0.0 MiB          59           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.8 MiB      0.0 MiB          59           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.6 MiB    109.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.6 MiB     -5.4 MiB         257       for row in grid:
    30    109.6 MiB  -1386.8 MiB       65792           for spot in row:
    31    109.6 MiB  -1381.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.6 MiB     -0.0 MiB           1       count = 0
    34    109.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.6 MiB      0.0 MiB           1       came_from = {}
    37    113.2 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.3 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.3 MiB      0.0 MiB        3042       while not open_set.empty():
    47    115.3 MiB      0.0 MiB        3042           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.3 MiB      0.0 MiB        3042           current = open_set.get()[2]
    53    115.3 MiB      0.0 MiB        3042           open_set_hash.remove(current)
    54                                         
    55    115.3 MiB      0.0 MiB        3042           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.3 MiB      0.0 MiB        3042           if current == end:
    60    115.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.3 MiB      0.0 MiB       27369           for neighbor in current.neighbors:
    65    115.3 MiB      0.0 MiB       24328               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.3 MiB      0.0 MiB       12164                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.3 MiB      0.0 MiB       12164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.3 MiB      0.0 MiB       24328               if temp_g_score < g_score[neighbor]:
    71    115.3 MiB      0.0 MiB        3378                   came_from[neighbor] = current
    72    115.3 MiB      0.0 MiB        3378                   g_score[neighbor] = temp_g_score
    73    115.3 MiB      0.0 MiB        3378                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.3 MiB      0.0 MiB        3378                   if neighbor not in open_set_hash:
    75    115.3 MiB      0.0 MiB        3378                       count += 1
    76    115.3 MiB      0.0 MiB        3378                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.3 MiB      0.0 MiB        3378                       open_set_hash.add(neighbor)
    78                                                             
    79    115.3 MiB      0.0 MiB        3041           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.3 MiB      0.0 MiB        3041           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.3 MiB    115.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.3 MiB   -888.8 MiB         257       for row in grid:
    30    115.3 MiB -227279.1 MiB       65792           for spot in row:
    31    115.3 MiB -226393.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.2 MiB     -6.1 MiB           1       count = 0
    34    109.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.2 MiB      0.0 MiB           1       came_from = {}
    37    112.8 MiB      3.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.2 MiB   -155.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.2 MiB      0.0 MiB         374       while not open_set.empty():
    47    115.2 MiB      0.0 MiB         374           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.2 MiB      0.0 MiB         374           current = open_set.get()[2]
    53    115.2 MiB      0.0 MiB         374           open_set_hash.remove(current)
    54                                         
    55    115.2 MiB      0.0 MiB         374           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.2 MiB      0.0 MiB         374           if current == end:
    60    115.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.2 MiB      0.0 MiB        3357           for neighbor in current.neighbors:
    65    115.2 MiB      0.0 MiB        2984               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.2 MiB      0.0 MiB        1492                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.2 MiB      0.0 MiB        1492                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.2 MiB      0.0 MiB        2984               if temp_g_score < g_score[neighbor]:
    71    115.2 MiB      0.0 MiB         530                   came_from[neighbor] = current
    72    115.2 MiB      0.0 MiB         530                   g_score[neighbor] = temp_g_score
    73    115.2 MiB      0.0 MiB         530                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.2 MiB      0.0 MiB         530                   if neighbor not in open_set_hash:
    75    115.2 MiB      0.0 MiB         530                       count += 1
    76    115.2 MiB      0.0 MiB         530                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.2 MiB      0.0 MiB         530                       open_set_hash.add(neighbor)
    78                                                             
    79    115.2 MiB      0.0 MiB         373           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.2 MiB      0.0 MiB         373           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.3 MiB    114.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.3 MiB      0.0 MiB         257       for row in grid:
    30    114.3 MiB      0.0 MiB       65792           for spot in row:
    31    114.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.3 MiB      0.0 MiB           1       count = 0
    34    114.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.3 MiB      0.0 MiB           1       came_from = {}
    37    116.8 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.5 MiB   -182.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.5 MiB  -1951.4 MiB        1530       while not open_set.empty():
    47    118.5 MiB  -1951.4 MiB        1530           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.5 MiB  -1951.4 MiB        1530           current = open_set.get()[2]
    53    118.5 MiB  -1951.4 MiB        1530           open_set_hash.remove(current)
    54                                         
    55    118.5 MiB  -1951.4 MiB        1530           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.5 MiB  -1951.4 MiB        1530           if current == end:
    60    115.9 MiB     -2.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.5 MiB -17547.5 MiB       13761           for neighbor in current.neighbors:
    65    118.5 MiB -15596.2 MiB       12232               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.5 MiB  -7800.6 MiB        6116                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.5 MiB  -7795.7 MiB        6116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.5 MiB -15598.7 MiB       12232               if temp_g_score < g_score[neighbor]:
    71    118.5 MiB  -2202.4 MiB        1770                   came_from[neighbor] = current
    72    118.5 MiB  -2202.4 MiB        1770                   g_score[neighbor] = temp_g_score
    73    118.5 MiB  -2202.4 MiB        1770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.5 MiB  -2202.4 MiB        1770                   if neighbor not in open_set_hash:
    75    118.5 MiB  -2202.4 MiB        1770                       count += 1
    76    118.5 MiB  -2202.4 MiB        1770                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.5 MiB  -2202.4 MiB        1770                       open_set_hash.add(neighbor)
    78                                                             
    79    118.5 MiB  -1951.4 MiB        1529           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.5 MiB  -1951.4 MiB        1529           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.9 MiB    115.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.9 MiB    -22.2 MiB         257       for row in grid:
    30    115.9 MiB  -5650.5 MiB       65792           for spot in row:
    31    115.9 MiB  -5629.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.7 MiB     -1.2 MiB           1       count = 0
    34    114.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.7 MiB      0.0 MiB           1       came_from = {}
    37    116.5 MiB  -7343.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.2 MiB     -0.3 MiB           1       g_score[start] = 0
    39    117.8 MiB  -3235.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.4 MiB     -4.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.4 MiB      0.0 MiB         493       while not open_set.empty():
    47    113.4 MiB      0.0 MiB         493           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.4 MiB      0.0 MiB         493           current = open_set.get()[2]
    53    113.4 MiB      0.0 MiB         493           open_set_hash.remove(current)
    54                                         
    55    113.4 MiB      0.0 MiB         493           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.4 MiB      0.0 MiB         493           if current == end:
    60    113.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.4 MiB      0.0 MiB        4428           for neighbor in current.neighbors:
    65    113.4 MiB      0.0 MiB        3936               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.4 MiB      0.0 MiB        1968                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.4 MiB      0.0 MiB        1968                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.4 MiB      0.0 MiB        3936               if temp_g_score < g_score[neighbor]:
    71    113.4 MiB      0.0 MiB         641                   came_from[neighbor] = current
    72    113.4 MiB      0.0 MiB         641                   g_score[neighbor] = temp_g_score
    73    113.4 MiB      0.0 MiB         641                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.4 MiB      0.0 MiB         641                   if neighbor not in open_set_hash:
    75    113.4 MiB      0.0 MiB         641                       count += 1
    76    113.4 MiB      0.0 MiB         641                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.4 MiB      0.0 MiB         641                       open_set_hash.add(neighbor)
    78                                                             
    79    113.4 MiB      0.0 MiB         492           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.4 MiB      0.0 MiB         492           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.7 MiB    113.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.7 MiB    -50.0 MiB         257       for row in grid:
    30    113.7 MiB -12829.8 MiB       65792           for spot in row:
    31    113.7 MiB -12780.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.4 MiB     -1.2 MiB           1       count = 0
    34    112.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.4 MiB      0.0 MiB           1       came_from = {}
    37    115.3 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.9 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.9 MiB      0.0 MiB        1066       while not open_set.empty():
    47    115.9 MiB      0.0 MiB        1066           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.9 MiB      0.0 MiB        1066           current = open_set.get()[2]
    53    115.9 MiB      0.0 MiB        1066           open_set_hash.remove(current)
    54                                         
    55    115.9 MiB      0.0 MiB        1066           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.9 MiB      0.0 MiB        1066           if current == end:
    60    115.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.9 MiB      0.0 MiB        9585           for neighbor in current.neighbors:
    65    115.9 MiB      0.0 MiB        8520               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.9 MiB      0.0 MiB        4260                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.9 MiB      0.0 MiB        4260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.9 MiB      0.0 MiB        8520               if temp_g_score < g_score[neighbor]:
    71    115.9 MiB      0.0 MiB        1418                   came_from[neighbor] = current
    72    115.9 MiB      0.0 MiB        1418                   g_score[neighbor] = temp_g_score
    73    115.9 MiB      0.0 MiB        1418                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.9 MiB      0.0 MiB        1418                   if neighbor not in open_set_hash:
    75    115.9 MiB      0.0 MiB        1418                       count += 1
    76    115.9 MiB      0.0 MiB        1418                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.9 MiB      0.0 MiB        1418                       open_set_hash.add(neighbor)
    78                                                             
    79    115.9 MiB      0.0 MiB        1065           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.9 MiB      0.0 MiB        1065           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.9 MiB    115.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.9 MiB      0.0 MiB         257       for row in grid:
    30    115.9 MiB      0.0 MiB       65792           for spot in row:
    31    115.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.9 MiB      0.0 MiB           1       count = 0
    34    115.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.9 MiB      0.0 MiB           1       came_from = {}
    37    118.5 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    118.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.5 MiB -85851.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.9 MiB     -1.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.9 MiB   -913.0 MiB         972       while not open_set.empty():
    47    116.9 MiB   -913.0 MiB         972           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.9 MiB   -913.0 MiB         972           current = open_set.get()[2]
    53    116.9 MiB   -913.2 MiB         972           open_set_hash.remove(current)
    54                                         
    55    116.9 MiB   -913.4 MiB         972           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.9 MiB   -913.7 MiB         972           if current == end:
    60    113.4 MiB     -3.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.9 MiB  -8209.0 MiB        8739           for neighbor in current.neighbors:
    65    116.9 MiB  -7297.0 MiB        7768               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.9 MiB  -3650.6 MiB        3884                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.9 MiB  -3647.0 MiB        3884                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.9 MiB  -7297.8 MiB        7768               if temp_g_score < g_score[neighbor]:
    71    116.9 MiB  -1060.4 MiB        1150                   came_from[neighbor] = current
    72    116.9 MiB  -1060.5 MiB        1150                   g_score[neighbor] = temp_g_score
    73    116.9 MiB  -1060.6 MiB        1150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.9 MiB  -1060.6 MiB        1150                   if neighbor not in open_set_hash:
    75    116.9 MiB  -1060.6 MiB        1150                       count += 1
    76    116.9 MiB  -1060.6 MiB        1150                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.9 MiB  -1060.6 MiB        1150                       open_set_hash.add(neighbor)
    78                                                             
    79    116.9 MiB   -912.9 MiB         971           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.9 MiB   -913.0 MiB         971           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.2 MiB    114.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.2 MiB   -188.1 MiB         257       for row in grid:
    30    114.2 MiB -48205.0 MiB       65792           for spot in row:
    31    114.2 MiB -48018.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.7 MiB     -2.5 MiB           1       count = 0
    34    111.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.7 MiB      0.0 MiB           1       came_from = {}
    37    113.0 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.2 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.2 MiB   -534.2 MiB        1308       while not open_set.empty():
    47    114.2 MiB   -534.2 MiB        1308           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.2 MiB   -534.2 MiB        1308           current = open_set.get()[2]
    53    114.2 MiB   -534.2 MiB        1308           open_set_hash.remove(current)
    54                                         
    55    114.2 MiB   -534.2 MiB        1308           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.2 MiB   -534.2 MiB        1308           if current == end:
    60    112.5 MiB     -1.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.2 MiB  -4793.4 MiB       11763           for neighbor in current.neighbors:
    65    114.2 MiB  -4259.6 MiB       10456               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.2 MiB  -2129.8 MiB        5228                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.2 MiB  -2129.8 MiB        5228                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.2 MiB  -4259.6 MiB       10456               if temp_g_score < g_score[neighbor]:
    71    114.2 MiB   -636.5 MiB        1572                   came_from[neighbor] = current
    72    114.2 MiB   -636.5 MiB        1572                   g_score[neighbor] = temp_g_score
    73    114.2 MiB   -636.5 MiB        1572                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.2 MiB   -636.5 MiB        1572                   if neighbor not in open_set_hash:
    75    114.2 MiB   -636.7 MiB        1572                       count += 1
    76    114.2 MiB   -637.2 MiB        1572                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.2 MiB   -637.5 MiB        1572                       open_set_hash.add(neighbor)
    78                                                             
    79    114.2 MiB   -534.0 MiB        1307           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.2 MiB   -534.2 MiB        1307           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.5 MiB    112.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.5 MiB    -39.0 MiB         257       for row in grid:
    30    112.5 MiB -10023.0 MiB       65792           for spot in row:
    31    112.5 MiB  -9984.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.7 MiB     -0.8 MiB           1       count = 0
    34    111.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.7 MiB      0.0 MiB           1       came_from = {}
    37    112.7 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.9 MiB      1.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.9 MiB   -129.3 MiB        5423       while not open_set.empty():
    47    113.9 MiB   -129.3 MiB        5423           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.9 MiB   -129.3 MiB        5423           current = open_set.get()[2]
    53    113.9 MiB   -129.3 MiB        5423           open_set_hash.remove(current)
    54                                         
    55    113.9 MiB   -129.3 MiB        5423           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.9 MiB   -129.3 MiB        5423           if current == end:
    60    113.8 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.9 MiB  -1163.0 MiB       48798           for neighbor in current.neighbors:
    65    113.9 MiB  -1033.7 MiB       43376               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.9 MiB   -517.0 MiB       21688                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.9 MiB   -516.8 MiB       21688                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.9 MiB  -1033.8 MiB       43376               if temp_g_score < g_score[neighbor]:
    71    113.9 MiB   -140.5 MiB        5911                   came_from[neighbor] = current
    72    113.9 MiB   -140.5 MiB        5911                   g_score[neighbor] = temp_g_score
    73    113.9 MiB   -140.5 MiB        5911                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.9 MiB   -140.5 MiB        5911                   if neighbor not in open_set_hash:
    75    113.9 MiB   -140.5 MiB        5911                       count += 1
    76    113.9 MiB   -140.5 MiB        5911                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.9 MiB   -140.5 MiB        5911                       open_set_hash.add(neighbor)
    78                                                             
    79    113.9 MiB   -129.3 MiB        5422           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.9 MiB   -129.3 MiB        5422           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.1 MiB    114.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.1 MiB   -126.8 MiB         257       for row in grid:
    30    114.1 MiB -32476.1 MiB       65792           for spot in row:
    31    114.1 MiB -32350.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.1 MiB     -1.0 MiB           1       count = 0
    34    113.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.1 MiB      0.0 MiB           1       came_from = {}
    37    116.3 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.3 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.3 MiB      0.0 MiB         208       while not open_set.empty():
    47    116.3 MiB      0.0 MiB         208           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.3 MiB      0.0 MiB         208           current = open_set.get()[2]
    53    116.3 MiB      0.0 MiB         208           open_set_hash.remove(current)
    54                                         
    55    116.3 MiB      0.0 MiB         208           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.3 MiB      0.0 MiB         208           if current == end:
    60    116.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.3 MiB      0.0 MiB        1863           for neighbor in current.neighbors:
    65    116.3 MiB      0.0 MiB        1656               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.3 MiB      0.0 MiB         828                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.3 MiB      0.0 MiB         828                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.3 MiB      0.0 MiB        1656               if temp_g_score < g_score[neighbor]:
    71    116.3 MiB      0.0 MiB         326                   came_from[neighbor] = current
    72    116.3 MiB      0.0 MiB         326                   g_score[neighbor] = temp_g_score
    73    116.3 MiB      0.0 MiB         326                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.3 MiB      0.0 MiB         326                   if neighbor not in open_set_hash:
    75    116.3 MiB      0.0 MiB         326                       count += 1
    76    116.3 MiB      0.0 MiB         326                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.3 MiB      0.0 MiB         326                       open_set_hash.add(neighbor)
    78                                                             
    79    116.3 MiB      0.0 MiB         207           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.3 MiB      0.0 MiB         207           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.3 MiB    116.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.3 MiB   -469.2 MiB         257       for row in grid:
    30    116.3 MiB -120117.8 MiB       65792           for spot in row:
    31    116.3 MiB -119650.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.5 MiB     -3.8 MiB           1       count = 0
    34    112.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.5 MiB      0.0 MiB           1       came_from = {}
    37    113.9 MiB -27971.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.1 MiB     -0.8 MiB           1       g_score[start] = 0
    39    117.5 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.6 MiB -32461.3 MiB       10902       while not open_set.empty():
    47    117.6 MiB -32461.4 MiB       10902           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.6 MiB -32462.0 MiB       10902           current = open_set.get()[2]
    53    117.6 MiB -32462.4 MiB       10902           open_set_hash.remove(current)
    54                                         
    55    117.6 MiB -32462.6 MiB       10902           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.6 MiB -32462.9 MiB       10902           if current == end:
    60    104.7 MiB    -12.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.6 MiB -292089.8 MiB       98109           for neighbor in current.neighbors:
    65    117.6 MiB -259630.4 MiB       87208               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.6 MiB -129822.7 MiB       43604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.6 MiB -129811.7 MiB       43604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.6 MiB -259635.5 MiB       87208               if temp_g_score < g_score[neighbor]:
    71    117.6 MiB -34529.7 MiB       11670                   came_from[neighbor] = current
    72    117.6 MiB -34531.5 MiB       11670                   g_score[neighbor] = temp_g_score
    73    117.6 MiB -34532.8 MiB       11670                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.6 MiB -34532.8 MiB       11670                   if neighbor not in open_set_hash:
    75    117.6 MiB -34533.0 MiB       11670                       count += 1
    76    117.6 MiB -34532.9 MiB       11670                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.6 MiB -34533.1 MiB       11670                       open_set_hash.add(neighbor)
    78                                                             
    79    117.6 MiB -32461.1 MiB       10901           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.6 MiB -32461.2 MiB       10901           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.4 MiB    110.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.4 MiB    -40.5 MiB         257       for row in grid:
    30    110.4 MiB -10321.3 MiB       65792           for spot in row:
    31    110.4 MiB -10281.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.1 MiB     -1.3 MiB           1       count = 0
    34    109.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.1 MiB      0.0 MiB           1       came_from = {}
    37    112.9 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.0 MiB      1.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.0 MiB      0.0 MiB         540       while not open_set.empty():
    47    114.0 MiB      0.0 MiB         540           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.0 MiB      0.0 MiB         540           current = open_set.get()[2]
    53    114.0 MiB      0.0 MiB         540           open_set_hash.remove(current)
    54                                         
    55    114.0 MiB      0.0 MiB         540           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.0 MiB      0.0 MiB         540           if current == end:
    60    114.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.0 MiB      0.0 MiB        4848           for neighbor in current.neighbors:
    65    114.0 MiB      0.0 MiB        4309               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.0 MiB      0.0 MiB        2154                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.0 MiB      0.0 MiB        2155                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.0 MiB      0.0 MiB        4309               if temp_g_score < g_score[neighbor]:
    71    114.0 MiB      0.0 MiB         691                   came_from[neighbor] = current
    72    114.0 MiB      0.0 MiB         691                   g_score[neighbor] = temp_g_score
    73    114.0 MiB      0.0 MiB         691                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.0 MiB      0.0 MiB         691                   if neighbor not in open_set_hash:
    75    114.0 MiB      0.0 MiB         691                       count += 1
    76    114.0 MiB      0.0 MiB         691                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.0 MiB      0.0 MiB         691                       open_set_hash.add(neighbor)
    78                                                             
    79    114.0 MiB      0.0 MiB         539           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.0 MiB      0.0 MiB         539           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.0 MiB    114.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.0 MiB    -18.4 MiB         257       for row in grid:
    30    114.0 MiB  -4718.5 MiB       65792           for spot in row:
    31    114.0 MiB  -4700.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.9 MiB     -0.1 MiB           1       count = 0
    34    113.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.9 MiB      0.0 MiB           1       came_from = {}
    37    115.3 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.1 MiB  -5181.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.8 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.8 MiB -437717.3 MiB       12369       while not open_set.empty():
    47    115.8 MiB -437718.1 MiB       12369           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.8 MiB -437718.9 MiB       12369           current = open_set.get()[2]
    53    115.8 MiB -437719.5 MiB       12369           open_set_hash.remove(current)
    54                                         
    55    115.8 MiB -437720.0 MiB       12369           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.8 MiB -437720.4 MiB       12369           if current == end:
    60     75.9 MiB    -39.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.8 MiB -3939290.7 MiB      111309           for neighbor in current.neighbors:
    65    115.8 MiB -3501583.6 MiB       98941               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.8 MiB -1750832.2 MiB       49470                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.8 MiB -1750762.0 MiB       49471                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.8 MiB -3501601.5 MiB       98941               if temp_g_score < g_score[neighbor]:
    71    115.8 MiB -452760.7 MiB       13002                   came_from[neighbor] = current
    72    115.8 MiB -452761.7 MiB       13002                   g_score[neighbor] = temp_g_score
    73    115.8 MiB -452761.7 MiB       13002                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.8 MiB -452762.6 MiB       13002                   if neighbor not in open_set_hash:
    75    115.8 MiB -452763.4 MiB       13002                       count += 1
    76    115.8 MiB -452759.5 MiB       13002                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.8 MiB -452760.7 MiB       13002                       open_set_hash.add(neighbor)
    78                                                             
    79    115.8 MiB -437716.0 MiB       12368           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.8 MiB -437716.7 MiB       12368           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.2 MiB    101.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.2 MiB    -11.2 MiB         257       for row in grid:
    30    101.2 MiB  -2871.9 MiB       65792           for spot in row:
    31    101.2 MiB  -2860.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.0 MiB     -0.1 MiB           1       count = 0
    34    101.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.0 MiB      0.0 MiB           1       came_from = {}
    37    103.0 MiB  -5074.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.2 MiB    -34.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.2 MiB      0.0 MiB         920       while not open_set.empty():
    47    109.2 MiB      0.0 MiB         920           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.2 MiB      0.0 MiB         920           current = open_set.get()[2]
    53    109.2 MiB      0.0 MiB         920           open_set_hash.remove(current)
    54                                         
    55    109.2 MiB      0.0 MiB         920           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.2 MiB      0.0 MiB         920           if current == end:
    60    109.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.2 MiB      0.0 MiB        8271           for neighbor in current.neighbors:
    65    109.2 MiB      0.0 MiB        7352               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.2 MiB      0.0 MiB        3676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.2 MiB      0.0 MiB        3676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.2 MiB      0.0 MiB        7352               if temp_g_score < g_score[neighbor]:
    71    109.2 MiB      0.0 MiB        1142                   came_from[neighbor] = current
    72    109.2 MiB      0.0 MiB        1142                   g_score[neighbor] = temp_g_score
    73    109.2 MiB      0.0 MiB        1142                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.2 MiB      0.0 MiB        1142                   if neighbor not in open_set_hash:
    75    109.2 MiB      0.0 MiB        1142                       count += 1
    76    109.2 MiB      0.0 MiB        1142                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.2 MiB      0.0 MiB        1142                       open_set_hash.add(neighbor)
    78                                                             
    79    109.2 MiB      0.0 MiB         919           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.2 MiB      0.0 MiB         919           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.2 MiB    109.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.2 MiB    -75.0 MiB         257       for row in grid:
    30    109.2 MiB -19084.4 MiB       65792           for spot in row:
    31    109.2 MiB -19011.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.9 MiB     -2.3 MiB           1       count = 0
    34    106.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.9 MiB      0.0 MiB           1       came_from = {}
    37    109.2 MiB -47286.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.1 MiB     -3.1 MiB           1       g_score[start] = 0
    39    108.9 MiB -36068.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.4 MiB     -2.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.4 MiB  -2807.0 MiB        1815       while not open_set.empty():
    47    106.4 MiB  -2807.0 MiB        1815           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.4 MiB  -2807.0 MiB        1815           current = open_set.get()[2]
    53    106.4 MiB  -2807.0 MiB        1815           open_set_hash.remove(current)
    54                                         
    55    106.4 MiB  -2807.0 MiB        1815           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.4 MiB  -2807.0 MiB        1815           if current == end:
    60    103.7 MiB     -2.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.4 MiB -25252.6 MiB       16326           for neighbor in current.neighbors:
    65    106.4 MiB -22446.4 MiB       14512               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.4 MiB -11226.4 MiB        7256                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.4 MiB -11220.4 MiB        7256                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.4 MiB -22447.3 MiB       14512               if temp_g_score < g_score[neighbor]:
    71    106.4 MiB  -3212.9 MiB        2115                   came_from[neighbor] = current
    72    106.4 MiB  -3213.1 MiB        2115                   g_score[neighbor] = temp_g_score
    73    106.4 MiB  -3213.5 MiB        2115                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.4 MiB  -3213.7 MiB        2115                   if neighbor not in open_set_hash:
    75    106.4 MiB  -3213.7 MiB        2115                       count += 1
    76    106.4 MiB  -3213.7 MiB        2115                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.4 MiB  -3213.7 MiB        2115                       open_set_hash.add(neighbor)
    78                                                             
    79    106.4 MiB  -2806.7 MiB        1814           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.4 MiB  -2806.8 MiB        1814           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.8 MiB    107.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.8 MiB   -121.7 MiB         257       for row in grid:
    30    107.8 MiB -31234.9 MiB       65792           for spot in row:
    31    107.8 MiB -31113.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.1 MiB     -0.7 MiB           1       count = 0
    34    107.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.1 MiB      0.0 MiB           1       came_from = {}
    37    108.1 MiB -107439.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.2 MiB     -3.9 MiB           1       g_score[start] = 0
    39    108.0 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.0 MiB      0.0 MiB          64       while not open_set.empty():
    47    108.0 MiB      0.0 MiB          64           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.0 MiB      0.0 MiB          64           current = open_set.get()[2]
    53    108.0 MiB      0.0 MiB          64           open_set_hash.remove(current)
    54                                         
    55    108.0 MiB      0.0 MiB          64           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.0 MiB      0.0 MiB          64           if current == end:
    60    108.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.0 MiB      0.0 MiB         567           for neighbor in current.neighbors:
    65    108.0 MiB      0.0 MiB         504               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.0 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.0 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.0 MiB      0.0 MiB         504               if temp_g_score < g_score[neighbor]:
    71    108.0 MiB      0.0 MiB         134                   came_from[neighbor] = current
    72    108.0 MiB      0.0 MiB         134                   g_score[neighbor] = temp_g_score
    73    108.0 MiB      0.0 MiB         134                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.0 MiB      0.0 MiB         134                   if neighbor not in open_set_hash:
    75    108.0 MiB      0.0 MiB         134                       count += 1
    76    108.0 MiB      0.0 MiB         134                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.0 MiB      0.0 MiB         134                       open_set_hash.add(neighbor)
    78                                                             
    79    108.0 MiB      0.0 MiB          63           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.0 MiB      0.0 MiB          63           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.0 MiB    108.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.0 MiB     -7.8 MiB         257       for row in grid:
    30    108.0 MiB  -2009.4 MiB       65792           for spot in row:
    31    108.0 MiB  -2001.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.0 MiB     -0.0 MiB           1       count = 0
    34    108.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.0 MiB      0.0 MiB           1       came_from = {}
    37    111.3 MiB   -391.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.0 MiB     -0.2 MiB           1       g_score[start] = 0
    39    115.2 MiB  -3308.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.8 MiB     -0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.8 MiB   -808.5 MiB         912       while not open_set.empty():
    47    114.8 MiB   -808.9 MiB         912           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.8 MiB   -809.6 MiB         912           current = open_set.get()[2]
    53    114.8 MiB   -809.6 MiB         912           open_set_hash.remove(current)
    54                                         
    55    114.8 MiB   -809.6 MiB         912           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.8 MiB   -810.3 MiB         912           if current == end:
    60    110.3 MiB     -4.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.8 MiB  -7253.6 MiB        8199           for neighbor in current.neighbors:
    65    114.8 MiB  -6446.1 MiB        7288               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.8 MiB  -3223.1 MiB        3644                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.8 MiB  -3223.0 MiB        3644                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.8 MiB  -6447.8 MiB        7288               if temp_g_score < g_score[neighbor]:
    71    114.8 MiB  -1199.5 MiB        1382                   came_from[neighbor] = current
    72    114.8 MiB  -1199.5 MiB        1382                   g_score[neighbor] = temp_g_score
    73    114.8 MiB  -1199.5 MiB        1382                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.8 MiB  -1199.5 MiB        1382                   if neighbor not in open_set_hash:
    75    114.8 MiB  -1199.5 MiB        1382                       count += 1
    76    114.8 MiB  -1199.4 MiB        1382                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.8 MiB  -1199.5 MiB        1382                       open_set_hash.add(neighbor)
    78                                                             
    79    114.8 MiB   -807.8 MiB         911           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.8 MiB   -808.2 MiB         911           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.9 MiB    110.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.9 MiB   -437.0 MiB         257       for row in grid:
    30    110.9 MiB -112083.1 MiB       65792           for spot in row:
    31    110.9 MiB -111647.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.0 MiB     -1.9 MiB           1       count = 0
    34    109.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.0 MiB      0.0 MiB           1       came_from = {}
    37    110.7 MiB  -5580.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.2 MiB     -0.6 MiB           1       g_score[start] = 0
    39    111.4 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.4 MiB -24388.2 MiB        3672       while not open_set.empty():
    47    111.4 MiB -24389.0 MiB        3672           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.4 MiB -24390.5 MiB        3672           current = open_set.get()[2]
    53    111.4 MiB -24391.0 MiB        3672           open_set_hash.remove(current)
    54                                         
    55    111.4 MiB -24394.8 MiB        3672           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.4 MiB -24395.4 MiB        3672           if current == end:
    60     73.1 MiB    -38.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     73.2 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.4 MiB -219343.5 MiB       33039           for neighbor in current.neighbors:
    65    111.4 MiB -194963.2 MiB       29368               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.4 MiB -97514.4 MiB       14684                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.4 MiB -97455.7 MiB       14684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.4 MiB -194975.6 MiB       29368               if temp_g_score < g_score[neighbor]:
    71    111.4 MiB -26926.4 MiB        4050                   came_from[neighbor] = current
    72    111.4 MiB -26926.8 MiB        4050                   g_score[neighbor] = temp_g_score
    73    111.4 MiB -26928.0 MiB        4050                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.4 MiB -26928.7 MiB        4050                   if neighbor not in open_set_hash:
    75    111.4 MiB -26929.4 MiB        4050                       count += 1
    76    111.4 MiB -26930.5 MiB        4050                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.4 MiB -26931.2 MiB        4050                       open_set_hash.add(neighbor)
    78                                                             
    79    111.4 MiB -24385.7 MiB        3671           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.4 MiB -24386.9 MiB        3671           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     73.9 MiB     73.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.2 MiB   -119.9 MiB         257       for row in grid:
    30     76.2 MiB -30735.4 MiB       65792           for spot in row:
    31     76.2 MiB -30611.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     74.6 MiB     -1.6 MiB           1       count = 0
    34     74.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.6 MiB      0.0 MiB           1       came_from = {}
    37     77.2 MiB -13825.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     77.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     78.5 MiB -12809.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     78.0 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     78.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     78.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     78.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     78.6 MiB      0.0 MiB        6210       while not open_set.empty():
    47     78.6 MiB      0.0 MiB        6210           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     78.6 MiB      0.0 MiB        6210           current = open_set.get()[2]
    53     78.6 MiB      0.0 MiB        6210           open_set_hash.remove(current)
    54                                         
    55     78.6 MiB      0.0 MiB        6210           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     78.6 MiB      0.0 MiB        6210           if current == end:
    60     78.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     78.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     78.6 MiB      0.0 MiB       55881           for neighbor in current.neighbors:
    65     78.6 MiB      0.0 MiB       49672               if current.row != neighbor.row and current.col != neighbor.col:
    66     78.6 MiB      0.0 MiB       24836                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     78.6 MiB      0.0 MiB       24836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     78.6 MiB      0.0 MiB       49672               if temp_g_score < g_score[neighbor]:
    71     78.6 MiB      0.5 MiB        6654                   came_from[neighbor] = current
    72     78.6 MiB      0.0 MiB        6654                   g_score[neighbor] = temp_g_score
    73     78.6 MiB      0.0 MiB        6654                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     78.6 MiB      0.0 MiB        6654                   if neighbor not in open_set_hash:
    75     78.6 MiB      0.0 MiB        6654                       count += 1
    76     78.6 MiB      0.0 MiB        6654                       open_set.put((f_score[neighbor], count, neighbor))
    77     78.6 MiB      0.0 MiB        6654                       open_set_hash.add(neighbor)
    78                                                             
    79     78.6 MiB      0.0 MiB        6209           if draw is not None:
    80                                                     draw()
    81                                         
    82     78.6 MiB      0.0 MiB        6209           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.4 MiB    110.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.4 MiB      0.0 MiB         257       for row in grid:
    30    110.4 MiB      0.0 MiB       65792           for spot in row:
    31    110.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.4 MiB      0.0 MiB           1       count = 0
    34    110.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.4 MiB      0.0 MiB           1       came_from = {}
    37    113.6 MiB  -3727.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.7 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.7 MiB      0.0 MiB         550       while not open_set.empty():
    47    115.7 MiB      0.0 MiB         550           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.7 MiB      0.0 MiB         550           current = open_set.get()[2]
    53    115.7 MiB      0.0 MiB         550           open_set_hash.remove(current)
    54                                         
    55    115.7 MiB      0.0 MiB         550           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.7 MiB      0.0 MiB         550           if current == end:
    60    115.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.7 MiB      0.0 MiB        4941           for neighbor in current.neighbors:
    65    115.7 MiB      0.0 MiB        4392               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.7 MiB      0.0 MiB        2196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.7 MiB      0.0 MiB        2196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.7 MiB      0.0 MiB        4392               if temp_g_score < g_score[neighbor]:
    71    115.7 MiB      0.0 MiB         998                   came_from[neighbor] = current
    72    115.7 MiB      0.0 MiB         998                   g_score[neighbor] = temp_g_score
    73    115.7 MiB      0.0 MiB         998                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.7 MiB      0.0 MiB         998                   if neighbor not in open_set_hash:
    75    115.7 MiB      0.0 MiB         998                       count += 1
    76    115.7 MiB      0.0 MiB         998                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.7 MiB      0.0 MiB         998                       open_set_hash.add(neighbor)
    78                                                             
    79    115.7 MiB      0.0 MiB         549           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.7 MiB      0.0 MiB         549           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.7 MiB    115.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.7 MiB   -434.7 MiB         257       for row in grid:
    30    115.7 MiB -111121.5 MiB       65792           for spot in row:
    31    115.7 MiB -110690.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.8 MiB     -4.9 MiB           1       count = 0
    34    110.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.8 MiB      0.0 MiB           1       came_from = {}
    37    112.9 MiB -39145.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.2 MiB     -1.7 MiB           1       g_score[start] = 0
    39    114.0 MiB   -573.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.7 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.7 MiB      0.0 MiB        2620       while not open_set.empty():
    47    113.7 MiB      0.0 MiB        2620           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.7 MiB      0.0 MiB        2620           current = open_set.get()[2]
    53    113.7 MiB      0.0 MiB        2620           open_set_hash.remove(current)
    54                                         
    55    113.7 MiB      0.0 MiB        2620           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.7 MiB      0.0 MiB        2620           if current == end:
    60    113.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.7 MiB      0.0 MiB       23571           for neighbor in current.neighbors:
    65    113.7 MiB      0.0 MiB       20952               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.7 MiB      0.0 MiB       10476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.7 MiB      0.0 MiB       10476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.7 MiB      0.0 MiB       20952               if temp_g_score < g_score[neighbor]:
    71    113.7 MiB      0.0 MiB        2960                   came_from[neighbor] = current
    72    113.7 MiB      0.0 MiB        2960                   g_score[neighbor] = temp_g_score
    73    113.7 MiB      0.0 MiB        2960                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.7 MiB      0.0 MiB        2960                   if neighbor not in open_set_hash:
    75    113.7 MiB      0.0 MiB        2960                       count += 1
    76    113.7 MiB      0.0 MiB        2960                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.7 MiB      0.0 MiB        2960                       open_set_hash.add(neighbor)
    78                                                             
    79    113.7 MiB      0.0 MiB        2619           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.7 MiB      0.0 MiB        2619           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.4 MiB    114.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.4 MiB  -2719.3 MiB         257       for row in grid:
    30    114.4 MiB -694731.9 MiB       65792           for spot in row:
    31    114.4 MiB -692040.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     74.3 MiB    -40.1 MiB           1       count = 0
    34     74.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.4 MiB      0.0 MiB           1       came_from = {}
    37     83.2 MiB   -375.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     83.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     89.0 MiB      5.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     89.2 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     89.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     89.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     89.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     90.7 MiB -53714.0 MiB        3500       while not open_set.empty():
    47     90.7 MiB -53714.7 MiB        3500           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     90.7 MiB -53716.0 MiB        3500           current = open_set.get()[2]
    53     90.7 MiB -53716.7 MiB        3500           open_set_hash.remove(current)
    54                                         
    55     90.7 MiB -53717.4 MiB        3500           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     90.7 MiB -53718.0 MiB        3500           if current == end:
    60     65.6 MiB    -25.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     90.7 MiB -483334.9 MiB       31491           for neighbor in current.neighbors:
    65     90.7 MiB -429626.5 MiB       27992               if current.row != neighbor.row and current.col != neighbor.col:
    66     90.7 MiB -214834.0 MiB       13996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     90.7 MiB -214797.2 MiB       13996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     90.7 MiB -429635.4 MiB       27992               if temp_g_score < g_score[neighbor]:
    71     90.7 MiB -58549.1 MiB        3878                   came_from[neighbor] = current
    72     90.7 MiB -58549.8 MiB        3878                   g_score[neighbor] = temp_g_score
    73     90.7 MiB -58550.5 MiB        3878                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     90.7 MiB -58550.8 MiB        3878                   if neighbor not in open_set_hash:
    75     90.7 MiB -58550.9 MiB        3878                       count += 1
    76     90.7 MiB -58551.3 MiB        3878                       open_set.put((f_score[neighbor], count, neighbor))
    77     90.7 MiB -58551.6 MiB        3878                       open_set_hash.add(neighbor)
    78                                                             
    79     90.7 MiB -53712.7 MiB        3499           if draw is not None:
    80                                                     draw()
    81                                         
    82     90.7 MiB -53713.3 MiB        3499           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     68.3 MiB     68.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     72.8 MiB   -235.4 MiB         257       for row in grid:
    30     72.8 MiB -60323.6 MiB       65792           for spot in row:
    31     72.8 MiB -60084.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.4 MiB     -0.4 MiB           1       count = 0
    34     72.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.4 MiB      0.0 MiB           1       came_from = {}
    37     77.0 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     77.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     77.0 MiB -112370.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     77.0 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     77.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     77.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     77.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     77.0 MiB      0.0 MiB          22       while not open_set.empty():
    47     77.0 MiB      0.0 MiB          22           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     77.0 MiB      0.0 MiB          22           current = open_set.get()[2]
    53     77.0 MiB      0.0 MiB          22           open_set_hash.remove(current)
    54                                         
    55     77.0 MiB      0.0 MiB          22           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     77.0 MiB      0.0 MiB          22           if current == end:
    60     77.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     77.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     77.0 MiB      0.0 MiB         189           for neighbor in current.neighbors:
    65     77.0 MiB      0.0 MiB         168               if current.row != neighbor.row and current.col != neighbor.col:
    66     77.0 MiB      0.0 MiB          84                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     77.0 MiB      0.0 MiB          84                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     77.0 MiB      0.0 MiB         168               if temp_g_score < g_score[neighbor]:
    71     77.0 MiB      0.0 MiB          68                   came_from[neighbor] = current
    72     77.0 MiB      0.0 MiB          68                   g_score[neighbor] = temp_g_score
    73     77.0 MiB      0.0 MiB          68                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     77.0 MiB      0.0 MiB          68                   if neighbor not in open_set_hash:
    75     77.0 MiB      0.0 MiB          68                       count += 1
    76     77.0 MiB      0.0 MiB          68                       open_set.put((f_score[neighbor], count, neighbor))
    77     77.0 MiB      0.0 MiB          68                       open_set_hash.add(neighbor)
    78                                                             
    79     77.0 MiB      0.0 MiB          21           if draw is not None:
    80                                                     draw()
    81                                         
    82     77.0 MiB      0.0 MiB          21           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.9 MiB    109.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.9 MiB   -332.7 MiB         257       for row in grid:
    30    109.9 MiB -85290.9 MiB       65792           for spot in row:
    31    109.9 MiB -84959.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.9 MiB     -2.0 MiB           1       count = 0
    34    107.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.9 MiB      0.0 MiB           1       came_from = {}
    37    112.4 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.2 MiB -25953.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.2 MiB     -2.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.2 MiB -13509.9 MiB        5133       while not open_set.empty():
    47    115.2 MiB -13510.0 MiB        5133           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.2 MiB -13510.3 MiB        5133           current = open_set.get()[2]
    53    115.2 MiB -13510.3 MiB        5133           open_set_hash.remove(current)
    54                                         
    55    115.2 MiB -13510.3 MiB        5133           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.2 MiB -13510.3 MiB        5133           if current == end:
    60    110.8 MiB     -4.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.2 MiB -121560.1 MiB       46188           for neighbor in current.neighbors:
    65    115.2 MiB -108050.8 MiB       41056               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.2 MiB -54027.0 MiB       20528                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.2 MiB -54023.8 MiB       20528                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.2 MiB -108050.8 MiB       41056               if temp_g_score < g_score[neighbor]:
    71    115.2 MiB -15361.7 MiB        5897                   came_from[neighbor] = current
    72    115.2 MiB -15361.7 MiB        5897                   g_score[neighbor] = temp_g_score
    73    115.2 MiB -15361.8 MiB        5897                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.2 MiB -15362.0 MiB        5897                   if neighbor not in open_set_hash:
    75    115.2 MiB -15362.0 MiB        5897                       count += 1
    76    115.2 MiB -15362.0 MiB        5897                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.2 MiB -15361.9 MiB        5897                       open_set_hash.add(neighbor)
    78                                                             
    79    115.2 MiB -13509.4 MiB        5132           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.2 MiB -13509.5 MiB        5132           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.8 MiB    110.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.8 MiB      0.0 MiB         257       for row in grid:
    30    110.8 MiB      0.0 MiB       65792           for spot in row:
    31    110.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.8 MiB      0.0 MiB           1       count = 0
    34    110.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.8 MiB      0.0 MiB           1       came_from = {}
    37    112.2 MiB -128873.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.0 MiB     -5.2 MiB           1       g_score[start] = 0
    39    110.9 MiB      3.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.9 MiB  -4086.3 MiB        1785       while not open_set.empty():
    47    110.9 MiB  -4086.3 MiB        1785           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.9 MiB  -4086.3 MiB        1785           current = open_set.get()[2]
    53    110.9 MiB  -4086.3 MiB        1785           open_set_hash.remove(current)
    54                                         
    55    110.9 MiB  -4086.3 MiB        1785           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.9 MiB  -4086.3 MiB        1785           if current == end:
    60    108.4 MiB     -2.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.9 MiB -36765.6 MiB       16056           for neighbor in current.neighbors:
    65    110.9 MiB -32680.2 MiB       14272               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.9 MiB -16344.3 MiB        7136                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.9 MiB -16336.5 MiB        7136                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.9 MiB -32681.4 MiB       14272               if temp_g_score < g_score[neighbor]:
    71    110.9 MiB  -4551.1 MiB        2037                   came_from[neighbor] = current
    72    110.9 MiB  -4551.1 MiB        2037                   g_score[neighbor] = temp_g_score
    73    110.9 MiB  -4551.1 MiB        2037                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.9 MiB  -4551.1 MiB        2037                   if neighbor not in open_set_hash:
    75    110.9 MiB  -4551.1 MiB        2037                       count += 1
    76    110.9 MiB  -4551.1 MiB        2037                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.9 MiB  -4551.1 MiB        2037                       open_set_hash.add(neighbor)
    78                                                             
    79    110.9 MiB  -4086.3 MiB        1784           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.9 MiB  -4086.3 MiB        1784           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.3 MiB    109.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.3 MiB     -1.3 MiB         257       for row in grid:
    30    109.3 MiB   -332.2 MiB       65792           for spot in row:
    31    109.3 MiB   -331.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.3 MiB     -0.0 MiB           1       count = 0
    34    109.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.3 MiB      0.0 MiB           1       came_from = {}
    37    113.1 MiB   -414.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.2 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.2 MiB  -8083.0 MiB        9179       while not open_set.empty():
    47    115.2 MiB  -8083.0 MiB        9179           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.2 MiB  -8083.0 MiB        9179           current = open_set.get()[2]
    53    115.2 MiB  -8083.0 MiB        9179           open_set_hash.remove(current)
    54                                         
    55    115.2 MiB  -8083.0 MiB        9179           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.2 MiB  -8083.0 MiB        9179           if current == end:
    60    113.9 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.2 MiB -72741.5 MiB       82602           for neighbor in current.neighbors:
    65    115.2 MiB -64658.6 MiB       73424               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.2 MiB -32331.6 MiB       36712                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.2 MiB -32327.1 MiB       36712                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.2 MiB -64658.7 MiB       73424               if temp_g_score < g_score[neighbor]:
    71    115.2 MiB  -8459.0 MiB        9719                   came_from[neighbor] = current
    72    115.2 MiB  -8459.0 MiB        9719                   g_score[neighbor] = temp_g_score
    73    115.2 MiB  -8459.0 MiB        9719                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.2 MiB  -8459.0 MiB        9719                   if neighbor not in open_set_hash:
    75    115.2 MiB  -8459.0 MiB        9719                       count += 1
    76    115.2 MiB  -8459.1 MiB        9719                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.2 MiB  -8459.3 MiB        9719                       open_set_hash.add(neighbor)
    78                                                             
    79    115.2 MiB  -8083.0 MiB        9178           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.2 MiB  -8083.0 MiB        9178           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.9 MiB    113.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.9 MiB  -1233.4 MiB         257       for row in grid:
    30    113.9 MiB -315604.9 MiB       65792           for spot in row:
    31    113.9 MiB -314381.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.3 MiB    -11.6 MiB           1       count = 0
    34    102.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.3 MiB      0.0 MiB           1       came_from = {}
    37    106.5 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.0 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.0 MiB      0.0 MiB        2656       while not open_set.empty():
    47    110.0 MiB      0.0 MiB        2656           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.0 MiB      0.0 MiB        2656           current = open_set.get()[2]
    53    110.0 MiB      0.0 MiB        2656           open_set_hash.remove(current)
    54                                         
    55    110.0 MiB      0.0 MiB        2656           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.0 MiB      0.0 MiB        2656           if current == end:
    60    110.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.0 MiB      0.0 MiB       23895           for neighbor in current.neighbors:
    65    110.0 MiB      0.0 MiB       21240               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.0 MiB      0.0 MiB       10620                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.0 MiB      0.0 MiB       10620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.0 MiB      0.0 MiB       21240               if temp_g_score < g_score[neighbor]:
    71    110.0 MiB      0.0 MiB        3050                   came_from[neighbor] = current
    72    110.0 MiB      0.0 MiB        3050                   g_score[neighbor] = temp_g_score
    73    110.0 MiB      0.0 MiB        3050                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.0 MiB      0.0 MiB        3050                   if neighbor not in open_set_hash:
    75    110.0 MiB      0.0 MiB        3050                       count += 1
    76    110.0 MiB      0.0 MiB        3050                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.0 MiB      0.0 MiB        3050                       open_set_hash.add(neighbor)
    78                                                             
    79    110.0 MiB      0.0 MiB        2655           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.0 MiB      0.0 MiB        2655           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.3 MiB    110.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.3 MiB  -1135.6 MiB         257       for row in grid:
    30    110.3 MiB -290819.3 MiB       65792           for spot in row:
    31    110.3 MiB -289692.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.7 MiB    -10.6 MiB           1       count = 0
    34     99.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.7 MiB      0.0 MiB           1       came_from = {}
    37    105.2 MiB -138026.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.9 MiB    -12.3 MiB           1       g_score[start] = 0
    39     97.0 MiB -159117.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     81.4 MiB    -15.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     81.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     81.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     81.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     81.4 MiB -127904.1 MiB        5168       while not open_set.empty():
    47     81.4 MiB -135576.1 MiB        5168           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     81.4 MiB -135578.7 MiB        5168           current = open_set.get()[2]
    53     81.4 MiB -135578.9 MiB        5168           open_set_hash.remove(current)
    54                                         
    55     81.4 MiB -135579.8 MiB        5168           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     81.4 MiB -135579.9 MiB        5168           if current == end:
    60     54.9 MiB    -26.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     81.4 MiB -1220066.4 MiB       46503           for neighbor in current.neighbors:
    65     81.4 MiB -1084502.2 MiB       41336               if current.row != neighbor.row and current.col != neighbor.col:
    66     81.4 MiB -542280.8 MiB       20668                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     81.4 MiB -542231.4 MiB       20668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     81.4 MiB -1084515.4 MiB       41336               if temp_g_score < g_score[neighbor]:
    71     81.4 MiB -152009.1 MiB        5842                   came_from[neighbor] = current
    72     81.4 MiB -152012.5 MiB        5842                   g_score[neighbor] = temp_g_score
    73     81.4 MiB -152012.4 MiB        5842                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     81.4 MiB -152013.7 MiB        5842                   if neighbor not in open_set_hash:
    75     81.4 MiB -152014.9 MiB        5842                       count += 1
    76     81.4 MiB -151999.3 MiB        5842                       open_set.put((f_score[neighbor], count, neighbor))
    77     81.4 MiB -152004.5 MiB        5842                       open_set_hash.add(neighbor)
    78                                                             
    79     79.9 MiB -135571.5 MiB        5167           if draw is not None:
    80                                                     draw()
    81                                         
    82     79.9 MiB -127904.0 MiB        5167           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     57.7 MiB     57.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     59.1 MiB      0.0 MiB         257       for row in grid:
    30     59.1 MiB      0.0 MiB       65792           for spot in row:
    31     59.1 MiB      1.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.1 MiB      0.0 MiB           1       count = 0
    34     59.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.1 MiB      0.0 MiB           1       came_from = {}
    37     63.3 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.8 MiB      4.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.9 MiB      0.0 MiB         396       while not open_set.empty():
    47     67.9 MiB      0.0 MiB         396           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.9 MiB      0.0 MiB         396           current = open_set.get()[2]
    53     67.9 MiB      0.0 MiB         396           open_set_hash.remove(current)
    54                                         
    55     67.9 MiB      0.0 MiB         396           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.9 MiB      0.0 MiB         396           if current == end:
    60     67.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.9 MiB      0.0 MiB        3555           for neighbor in current.neighbors:
    65     67.9 MiB      0.0 MiB        3160               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.9 MiB      0.0 MiB        1580                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.9 MiB      0.0 MiB        1580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.9 MiB      0.0 MiB        3160               if temp_g_score < g_score[neighbor]:
    71     67.9 MiB      0.0 MiB         508                   came_from[neighbor] = current
    72     67.9 MiB      0.0 MiB         508                   g_score[neighbor] = temp_g_score
    73     67.9 MiB      0.0 MiB         508                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.9 MiB      0.0 MiB         508                   if neighbor not in open_set_hash:
    75     67.9 MiB      0.0 MiB         508                       count += 1
    76     67.9 MiB      0.0 MiB         508                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.9 MiB      0.0 MiB         508                       open_set_hash.add(neighbor)
    78                                                             
    79     67.9 MiB      0.0 MiB         395           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.9 MiB      0.0 MiB         395           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.7 MiB    101.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.7 MiB      0.0 MiB         257       for row in grid:
    30    101.7 MiB      0.0 MiB       65792           for spot in row:
    31    101.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.7 MiB      0.0 MiB           1       count = 0
    34    101.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.7 MiB      0.0 MiB           1       came_from = {}
    37    105.6 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.9 MiB  -2040.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.9 MiB  -4383.7 MiB        2976       while not open_set.empty():
    47    108.9 MiB  -4383.7 MiB        2976           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.9 MiB  -4383.7 MiB        2976           current = open_set.get()[2]
    53    108.9 MiB  -4383.7 MiB        2976           open_set_hash.remove(current)
    54                                         
    55    108.9 MiB  -4383.7 MiB        2976           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.9 MiB  -4383.7 MiB        2976           if current == end:
    60    106.8 MiB     -2.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.9 MiB -39441.3 MiB       26775           for neighbor in current.neighbors:
    65    108.9 MiB -35057.9 MiB       23800               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.9 MiB -17532.3 MiB       11900                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.9 MiB -17526.1 MiB       11900                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.9 MiB -35059.4 MiB       23800               if temp_g_score < g_score[neighbor]:
    71    108.9 MiB  -4793.3 MiB        3318                   came_from[neighbor] = current
    72    108.9 MiB  -4793.3 MiB        3318                   g_score[neighbor] = temp_g_score
    73    108.9 MiB  -4793.3 MiB        3318                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.9 MiB  -4793.3 MiB        3318                   if neighbor not in open_set_hash:
    75    108.9 MiB  -4793.3 MiB        3318                       count += 1
    76    108.9 MiB  -4793.3 MiB        3318                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.9 MiB  -4793.3 MiB        3318                       open_set_hash.add(neighbor)
    78                                                             
    79    108.9 MiB  -4383.7 MiB        2975           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.9 MiB  -4383.7 MiB        2975           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.8 MiB    106.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.8 MiB      0.0 MiB         257       for row in grid:
    30    106.8 MiB      0.0 MiB       65792           for spot in row:
    31    106.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.8 MiB      0.0 MiB           1       count = 0
    34    106.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.8 MiB      0.0 MiB           1       came_from = {}
    37    109.6 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.8 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.8 MiB      0.0 MiB         646       while not open_set.empty():
    47    112.8 MiB      0.0 MiB         646           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.8 MiB      0.0 MiB         646           current = open_set.get()[2]
    53    112.8 MiB      0.0 MiB         646           open_set_hash.remove(current)
    54                                         
    55    112.8 MiB      0.0 MiB         646           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.8 MiB      0.0 MiB         646           if current == end:
    60    112.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.8 MiB      0.0 MiB        5805           for neighbor in current.neighbors:
    65    112.8 MiB      0.0 MiB        5160               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.8 MiB      0.0 MiB        2580                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.8 MiB      0.0 MiB        2580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.8 MiB      0.0 MiB        5160               if temp_g_score < g_score[neighbor]:
    71    112.8 MiB      0.0 MiB         830                   came_from[neighbor] = current
    72    112.8 MiB      0.0 MiB         830                   g_score[neighbor] = temp_g_score
    73    112.8 MiB      0.0 MiB         830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.8 MiB      0.0 MiB         830                   if neighbor not in open_set_hash:
    75    112.8 MiB      0.0 MiB         830                       count += 1
    76    112.8 MiB      0.0 MiB         830                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.8 MiB      0.0 MiB         830                       open_set_hash.add(neighbor)
    78                                                             
    79    112.8 MiB      0.0 MiB         645           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.8 MiB      0.0 MiB         645           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.3 MiB    113.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.3 MiB      0.0 MiB         257       for row in grid:
    30    113.3 MiB      0.0 MiB       65792           for spot in row:
    31    113.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.3 MiB      0.0 MiB           1       count = 0
    34    113.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.3 MiB      0.0 MiB           1       came_from = {}
    37    113.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.4 MiB -77575.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.0 MiB     -1.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.2 MiB     -4.1 MiB        2392       while not open_set.empty():
    47    112.2 MiB     -4.1 MiB        2392           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.2 MiB     -4.1 MiB        2392           current = open_set.get()[2]
    53    112.2 MiB     -4.1 MiB        2392           open_set_hash.remove(current)
    54                                         
    55    112.2 MiB     -4.1 MiB        2392           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.2 MiB     -4.1 MiB        2392           if current == end:
    60    112.1 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.2 MiB    -36.8 MiB       21519           for neighbor in current.neighbors:
    65    112.2 MiB    -32.7 MiB       19128               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.2 MiB    -16.4 MiB        9564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.2 MiB    -16.2 MiB        9564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.2 MiB    -32.7 MiB       19128               if temp_g_score < g_score[neighbor]:
    71    112.2 MiB     -5.2 MiB        2810                   came_from[neighbor] = current
    72    112.2 MiB     -5.3 MiB        2810                   g_score[neighbor] = temp_g_score
    73    112.2 MiB     -5.3 MiB        2810                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.2 MiB     -5.3 MiB        2810                   if neighbor not in open_set_hash:
    75    112.2 MiB     -5.3 MiB        2810                       count += 1
    76    112.2 MiB     -5.3 MiB        2810                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.2 MiB     -5.3 MiB        2810                       open_set_hash.add(neighbor)
    78                                                             
    79    112.2 MiB     -4.1 MiB        2391           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.2 MiB     -4.1 MiB        2391           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.1 MiB    112.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.1 MiB   -527.0 MiB         257       for row in grid:
    30    112.1 MiB -135313.8 MiB       65792           for spot in row:
    31    112.1 MiB -134788.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.7 MiB     -2.4 MiB           1       count = 0
    34    109.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.7 MiB      0.0 MiB           1       came_from = {}
    37    112.3 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.6 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.6 MiB      0.0 MiB         484       while not open_set.empty():
    47    115.6 MiB      0.0 MiB         484           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.6 MiB      0.0 MiB         484           current = open_set.get()[2]
    53    115.6 MiB      0.0 MiB         484           open_set_hash.remove(current)
    54                                         
    55    115.6 MiB      0.0 MiB         484           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.6 MiB      0.0 MiB         484           if current == end:
    60    115.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.6 MiB      0.0 MiB        4347           for neighbor in current.neighbors:
    65    115.6 MiB      0.0 MiB        3864               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.6 MiB      0.0 MiB        1932                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.6 MiB      0.0 MiB        1932                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.6 MiB      0.0 MiB        3864               if temp_g_score < g_score[neighbor]:
    71    115.6 MiB      0.0 MiB         680                   came_from[neighbor] = current
    72    115.6 MiB      0.0 MiB         680                   g_score[neighbor] = temp_g_score
    73    115.6 MiB      0.0 MiB         680                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.6 MiB      0.0 MiB         680                   if neighbor not in open_set_hash:
    75    115.6 MiB      0.0 MiB         680                       count += 1
    76    115.6 MiB      0.0 MiB         680                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.6 MiB      0.0 MiB         680                       open_set_hash.add(neighbor)
    78                                                             
    79    115.6 MiB      0.0 MiB         483           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.6 MiB      0.0 MiB         483           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.5 MiB    113.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.5 MiB      0.0 MiB         257       for row in grid:
    30    113.5 MiB      0.0 MiB       65792           for spot in row:
    31    113.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.5 MiB      0.0 MiB           1       count = 0
    34    113.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.5 MiB      0.0 MiB           1       came_from = {}
    37    115.5 MiB -94336.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.5 MiB    -16.0 MiB           1       g_score[start] = 0
    39     99.5 MiB -1273046.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     81.7 MiB    -17.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     81.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     81.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     81.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     81.8 MiB   -133.9 MiB         588       while not open_set.empty():
    47     81.8 MiB   -133.9 MiB         588           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     81.8 MiB   -133.9 MiB         588           current = open_set.get()[2]
    53     81.8 MiB   -133.9 MiB         588           open_set_hash.remove(current)
    54                                         
    55     81.8 MiB   -133.9 MiB         588           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     81.8 MiB   -133.9 MiB         588           if current == end:
    60     81.7 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     81.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     81.8 MiB  -1203.4 MiB        5283           for neighbor in current.neighbors:
    65     81.8 MiB  -1069.6 MiB        4696               if current.row != neighbor.row and current.col != neighbor.col:
    66     81.8 MiB   -534.7 MiB        2348                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     81.8 MiB   -535.0 MiB        2348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     81.8 MiB  -1069.8 MiB        4696               if temp_g_score < g_score[neighbor]:
    71     81.8 MiB   -200.6 MiB         896                   came_from[neighbor] = current
    72     81.8 MiB   -200.6 MiB         896                   g_score[neighbor] = temp_g_score
    73     81.8 MiB   -200.6 MiB         896                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     81.8 MiB   -200.6 MiB         896                   if neighbor not in open_set_hash:
    75     81.8 MiB   -200.6 MiB         896                       count += 1
    76     81.8 MiB   -200.6 MiB         896                       open_set.put((f_score[neighbor], count, neighbor))
    77     81.8 MiB   -200.6 MiB         896                       open_set_hash.add(neighbor)
    78                                                             
    79     81.8 MiB   -133.9 MiB         587           if draw is not None:
    80                                                     draw()
    81                                         
    82     81.8 MiB   -133.9 MiB         587           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     84.5 MiB     84.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.9 MiB  -2375.3 MiB         257       for row in grid:
    30     92.0 MiB -606059.5 MiB       65792           for spot in row:
    31     92.0 MiB -603692.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.0 MiB    -19.9 MiB           1       count = 0
    34     72.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.0 MiB      0.0 MiB           1       came_from = {}
    37     73.2 MiB -146650.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.5 MiB     -1.7 MiB           1       g_score[start] = 0
    39     72.6 MiB -105277.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.2 MiB     -4.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.3 MiB      0.0 MiB        2343       while not open_set.empty():
    47     68.3 MiB      0.0 MiB        2343           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.3 MiB      0.0 MiB        2343           current = open_set.get()[2]
    53     68.3 MiB      0.0 MiB        2343           open_set_hash.remove(current)
    54                                         
    55     68.3 MiB      0.0 MiB        2343           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.3 MiB      0.0 MiB        2343           if current == end:
    60     68.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.3 MiB      0.0 MiB       21078           for neighbor in current.neighbors:
    65     68.3 MiB      0.0 MiB       18736               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.3 MiB      0.0 MiB        9368                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.3 MiB      0.0 MiB        9368                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.3 MiB      0.0 MiB       18736               if temp_g_score < g_score[neighbor]:
    71     68.3 MiB      0.0 MiB        2615                   came_from[neighbor] = current
    72     68.3 MiB      0.0 MiB        2615                   g_score[neighbor] = temp_g_score
    73     68.3 MiB      0.0 MiB        2615                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.3 MiB      0.0 MiB        2615                   if neighbor not in open_set_hash:
    75     68.3 MiB      0.0 MiB        2615                       count += 1
    76     68.3 MiB      0.0 MiB        2615                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.3 MiB      0.0 MiB        2615                       open_set_hash.add(neighbor)
    78                                                             
    79     68.3 MiB      0.0 MiB        2342           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.3 MiB      0.0 MiB        2342           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.9 MiB     99.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.9 MiB  -1540.9 MiB         257       for row in grid:
    30     99.9 MiB -395892.6 MiB       65792           for spot in row:
    31     99.9 MiB -394357.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.6 MiB     -7.2 MiB           1       count = 0
    34     92.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.6 MiB      0.0 MiB           1       came_from = {}
    37     93.3 MiB -90260.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.2 MiB     -0.1 MiB           1       g_score[start] = 0
    39     98.3 MiB      5.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.3 MiB      0.0 MiB        1008       while not open_set.empty():
    47     98.3 MiB      0.0 MiB        1008           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.3 MiB      0.0 MiB        1008           current = open_set.get()[2]
    53     98.3 MiB      0.0 MiB        1008           open_set_hash.remove(current)
    54                                         
    55     98.3 MiB      0.0 MiB        1008           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.3 MiB      0.0 MiB        1008           if current == end:
    60     98.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.3 MiB      0.0 MiB        9063           for neighbor in current.neighbors:
    65     98.3 MiB      0.0 MiB        8056               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.3 MiB      0.0 MiB        4028                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.3 MiB      0.0 MiB        4028                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.3 MiB      0.0 MiB        8056               if temp_g_score < g_score[neighbor]:
    71     98.3 MiB      0.0 MiB        1190                   came_from[neighbor] = current
    72     98.3 MiB      0.0 MiB        1190                   g_score[neighbor] = temp_g_score
    73     98.3 MiB      0.0 MiB        1190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.3 MiB      0.0 MiB        1190                   if neighbor not in open_set_hash:
    75     98.3 MiB      0.0 MiB        1190                       count += 1
    76     98.3 MiB      0.0 MiB        1190                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.3 MiB      0.0 MiB        1190                       open_set_hash.add(neighbor)
    78                                                             
    79     98.3 MiB      0.0 MiB        1007           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.3 MiB      0.0 MiB        1007           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.3 MiB     98.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.4 MiB    -15.3 MiB         257       for row in grid:
    30     98.4 MiB  -3905.9 MiB       65792           for spot in row:
    31     98.4 MiB  -3890.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.3 MiB     -0.0 MiB           1       count = 0
    34     98.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.3 MiB      0.0 MiB           1       came_from = {}
    37    102.6 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.9 MiB  -1681.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.8 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.8 MiB   -565.4 MiB        1162       while not open_set.empty():
    47    105.8 MiB   -565.4 MiB        1162           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.8 MiB   -565.4 MiB        1162           current = open_set.get()[2]
    53    105.8 MiB   -565.4 MiB        1162           open_set_hash.remove(current)
    54                                         
    55    105.8 MiB   -565.4 MiB        1162           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.8 MiB   -565.4 MiB        1162           if current == end:
    60     97.2 MiB     -8.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.8 MiB  -5034.2 MiB       10449           for neighbor in current.neighbors:
    65    105.8 MiB  -4471.1 MiB        9288               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.8 MiB  -2245.8 MiB        4644                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.8 MiB  -2228.2 MiB        4644                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.8 MiB  -4476.0 MiB        9288               if temp_g_score < g_score[neighbor]:
    71    105.8 MiB   -727.5 MiB        1520                   came_from[neighbor] = current
    72    105.8 MiB   -727.5 MiB        1520                   g_score[neighbor] = temp_g_score
    73    105.8 MiB   -727.5 MiB        1520                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.8 MiB   -727.5 MiB        1520                   if neighbor not in open_set_hash:
    75    105.8 MiB   -727.5 MiB        1520                       count += 1
    76    105.8 MiB   -727.7 MiB        1520                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.8 MiB   -727.6 MiB        1520                       open_set_hash.add(neighbor)
    78                                                             
    79    105.8 MiB   -565.4 MiB        1161           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.8 MiB   -565.4 MiB        1161           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.6 MiB    105.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.6 MiB   -280.2 MiB         257       for row in grid:
    30    105.6 MiB -71595.7 MiB       65792           for spot in row:
    31    105.6 MiB -71317.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.6 MiB     -2.0 MiB           1       count = 0
    34    103.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.6 MiB      0.0 MiB           1       came_from = {}
    37    108.3 MiB      4.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.4 MiB   -310.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.4 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.4 MiB      0.0 MiB        1008       while not open_set.empty():
    47    111.4 MiB      0.0 MiB        1008           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.4 MiB      0.0 MiB        1008           current = open_set.get()[2]
    53    111.4 MiB      0.0 MiB        1008           open_set_hash.remove(current)
    54                                         
    55    111.4 MiB      0.0 MiB        1008           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.4 MiB      0.0 MiB        1008           if current == end:
    60    111.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.4 MiB      0.0 MiB        9063           for neighbor in current.neighbors:
    65    111.4 MiB      0.0 MiB        8056               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.4 MiB      0.0 MiB        4028                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.4 MiB      0.0 MiB        4028                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.4 MiB      0.0 MiB        8056               if temp_g_score < g_score[neighbor]:
    71    111.4 MiB      0.0 MiB        1526                   came_from[neighbor] = current
    72    111.4 MiB      0.0 MiB        1526                   g_score[neighbor] = temp_g_score
    73    111.4 MiB      0.0 MiB        1526                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.4 MiB      0.0 MiB        1526                   if neighbor not in open_set_hash:
    75    111.4 MiB      0.0 MiB        1526                       count += 1
    76    111.4 MiB      0.0 MiB        1526                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.4 MiB      0.0 MiB        1526                       open_set_hash.add(neighbor)
    78                                                             
    79    111.4 MiB      0.0 MiB        1007           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.4 MiB      0.0 MiB        1007           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.4 MiB    111.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.4 MiB   -470.9 MiB         257       for row in grid:
    30    111.4 MiB -120334.2 MiB       65792           for spot in row:
    31    111.4 MiB -119865.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.8 MiB     -3.6 MiB           1       count = 0
    34    107.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.8 MiB      0.0 MiB           1       came_from = {}
    37    108.0 MiB -17791.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.7 MiB     -0.3 MiB           1       g_score[start] = 0
    39    111.0 MiB      3.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.0 MiB      0.0 MiB        3200       while not open_set.empty():
    47    111.0 MiB      0.0 MiB        3200           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.0 MiB      0.0 MiB        3200           current = open_set.get()[2]
    53    111.0 MiB      0.0 MiB        3200           open_set_hash.remove(current)
    54                                         
    55    111.0 MiB      0.0 MiB        3200           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.0 MiB      0.0 MiB        3200           if current == end:
    60    111.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.0 MiB      0.0 MiB       28791           for neighbor in current.neighbors:
    65    111.0 MiB      0.0 MiB       25592               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.0 MiB      0.0 MiB       12796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.0 MiB      0.0 MiB       12796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.0 MiB      0.0 MiB       25592               if temp_g_score < g_score[neighbor]:
    71    111.0 MiB      0.0 MiB        3598                   came_from[neighbor] = current
    72    111.0 MiB      0.0 MiB        3598                   g_score[neighbor] = temp_g_score
    73    111.0 MiB      0.0 MiB        3598                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.0 MiB      0.0 MiB        3598                   if neighbor not in open_set_hash:
    75    111.0 MiB      0.0 MiB        3598                       count += 1
    76    111.0 MiB      0.0 MiB        3598                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.0 MiB      0.0 MiB        3598                       open_set_hash.add(neighbor)
    78                                                             
    79    111.0 MiB      0.0 MiB        3199           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.0 MiB      0.0 MiB        3199           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.2 MiB    111.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.2 MiB      0.0 MiB         257       for row in grid:
    30    111.2 MiB      0.0 MiB       65792           for spot in row:
    31    111.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.2 MiB      0.0 MiB           1       count = 0
    34    111.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.2 MiB      0.0 MiB           1       came_from = {}
    37    112.3 MiB -188545.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.6 MiB     -6.7 MiB           1       g_score[start] = 0
    39    108.9 MiB   -256.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.9 MiB      0.0 MiB          36       while not open_set.empty():
    47    108.9 MiB      0.0 MiB          36           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.9 MiB      0.0 MiB          36           current = open_set.get()[2]
    53    108.9 MiB      0.0 MiB          36           open_set_hash.remove(current)
    54                                         
    55    108.9 MiB      0.0 MiB          36           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.9 MiB      0.0 MiB          36           if current == end:
    60    108.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.9 MiB      0.0 MiB         315           for neighbor in current.neighbors:
    65    108.9 MiB      0.0 MiB         280               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.9 MiB      0.0 MiB         140                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.9 MiB      0.0 MiB         140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.9 MiB      0.0 MiB         280               if temp_g_score < g_score[neighbor]:
    71    108.9 MiB      0.0 MiB          68                   came_from[neighbor] = current
    72    108.9 MiB      0.0 MiB          68                   g_score[neighbor] = temp_g_score
    73    108.9 MiB      0.0 MiB          68                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.9 MiB      0.0 MiB          68                   if neighbor not in open_set_hash:
    75    108.9 MiB      0.0 MiB          68                       count += 1
    76    108.9 MiB      0.0 MiB          68                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.9 MiB      0.0 MiB          68                       open_set_hash.add(neighbor)
    78                                                             
    79    108.9 MiB      0.0 MiB          35           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.9 MiB      0.0 MiB          35           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.9 MiB    108.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.9 MiB   -588.4 MiB         257       for row in grid:
    30    108.9 MiB -150525.7 MiB       65792           for spot in row:
    31    108.9 MiB -149939.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.7 MiB     -3.2 MiB           1       count = 0
    34    105.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.7 MiB      0.0 MiB           1       came_from = {}
    37    108.4 MiB  -1120.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.5 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.5 MiB    -12.7 MiB         870       while not open_set.empty():
    47    108.5 MiB    -12.7 MiB         870           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.5 MiB    -12.7 MiB         870           current = open_set.get()[2]
    53    108.5 MiB    -12.7 MiB         870           open_set_hash.remove(current)
    54                                         
    55    108.5 MiB    -12.7 MiB         870           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.5 MiB    -12.7 MiB         870           if current == end:
    60    108.5 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.5 MiB   -114.2 MiB        7821           for neighbor in current.neighbors:
    65    108.5 MiB   -101.5 MiB        6952               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.5 MiB    -50.8 MiB        3476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.5 MiB    -50.8 MiB        3476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.5 MiB   -101.5 MiB        6952               if temp_g_score < g_score[neighbor]:
    71    108.5 MiB    -14.4 MiB        1044                   came_from[neighbor] = current
    72    108.5 MiB    -14.4 MiB        1044                   g_score[neighbor] = temp_g_score
    73    108.5 MiB    -14.4 MiB        1044                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.5 MiB    -14.4 MiB        1044                   if neighbor not in open_set_hash:
    75    108.5 MiB    -14.4 MiB        1044                       count += 1
    76    108.5 MiB    -14.4 MiB        1044                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.5 MiB    -14.4 MiB        1044                       open_set_hash.add(neighbor)
    78                                                             
    79    108.5 MiB    -12.7 MiB         869           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.5 MiB    -12.7 MiB         869           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.5 MiB    108.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.5 MiB    -68.2 MiB         257       for row in grid:
    30    108.5 MiB -17502.0 MiB       65792           for spot in row:
    31    108.5 MiB -17434.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.9 MiB     -0.6 MiB           1       count = 0
    34    107.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.9 MiB      0.0 MiB           1       came_from = {}
    37    110.5 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.3 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.3 MiB      0.0 MiB         264       while not open_set.empty():
    47    113.3 MiB      0.0 MiB         264           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.3 MiB      0.0 MiB         264           current = open_set.get()[2]
    53    113.3 MiB      0.0 MiB         264           open_set_hash.remove(current)
    54                                         
    55    113.3 MiB      0.0 MiB         264           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.3 MiB      0.0 MiB         264           if current == end:
    60    113.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.3 MiB      0.0 MiB        2367           for neighbor in current.neighbors:
    65    113.3 MiB      0.0 MiB        2104               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.3 MiB      0.0 MiB        1052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.3 MiB      0.0 MiB        1052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.3 MiB      0.0 MiB        2104               if temp_g_score < g_score[neighbor]:
    71    113.3 MiB      0.0 MiB         410                   came_from[neighbor] = current
    72    113.3 MiB      0.0 MiB         410                   g_score[neighbor] = temp_g_score
    73    113.3 MiB      0.0 MiB         410                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.3 MiB      0.0 MiB         410                   if neighbor not in open_set_hash:
    75    113.3 MiB      0.0 MiB         410                       count += 1
    76    113.3 MiB      0.0 MiB         410                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.3 MiB      0.0 MiB         410                       open_set_hash.add(neighbor)
    78                                                             
    79    113.3 MiB      0.0 MiB         263           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.3 MiB      0.0 MiB         263           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.3 MiB    113.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.3 MiB      0.0 MiB         257       for row in grid:
    30    113.3 MiB      0.0 MiB       65792           for spot in row:
    31    113.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.3 MiB      0.0 MiB           1       count = 0
    34    113.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.3 MiB      0.0 MiB           1       came_from = {}
    37    113.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.0 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.0 MiB   -815.2 MiB         750       while not open_set.empty():
    47    117.0 MiB   -815.2 MiB         750           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.0 MiB   -815.2 MiB         750           current = open_set.get()[2]
    53    117.0 MiB   -815.2 MiB         750           open_set_hash.remove(current)
    54                                         
    55    117.0 MiB   -815.2 MiB         750           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.0 MiB   -815.2 MiB         750           if current == end:
    60    114.4 MiB     -2.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.0 MiB  -7330.1 MiB        6741           for neighbor in current.neighbors:
    65    117.0 MiB  -6515.2 MiB        5992               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.0 MiB  -3260.9 MiB        2996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.0 MiB  -3254.5 MiB        2996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.0 MiB  -6517.3 MiB        5992               if temp_g_score < g_score[neighbor]:
    71    117.0 MiB  -1030.8 MiB         978                   came_from[neighbor] = current
    72    117.0 MiB  -1030.8 MiB         978                   g_score[neighbor] = temp_g_score
    73    117.0 MiB  -1030.8 MiB         978                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.0 MiB  -1030.8 MiB         978                   if neighbor not in open_set_hash:
    75    117.0 MiB  -1030.8 MiB         978                       count += 1
    76    117.0 MiB  -1030.8 MiB         978                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.0 MiB  -1030.8 MiB         978                       open_set_hash.add(neighbor)
    78                                                             
    79    117.0 MiB   -815.2 MiB         749           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.0 MiB   -815.2 MiB         749           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.8 MiB    114.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.8 MiB      0.0 MiB         257       for row in grid:
    30    114.8 MiB      0.0 MiB       65792           for spot in row:
    31    114.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.8 MiB      0.0 MiB           1       count = 0
    34    114.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.8 MiB      0.0 MiB           1       came_from = {}
    37    116.9 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.7 MiB  -3894.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.7 MiB   -905.4 MiB        1246       while not open_set.empty():
    47    117.7 MiB   -905.4 MiB        1246           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.7 MiB   -905.4 MiB        1246           current = open_set.get()[2]
    53    117.7 MiB   -905.4 MiB        1246           open_set_hash.remove(current)
    54                                         
    55    117.7 MiB   -905.4 MiB        1246           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.7 MiB   -905.4 MiB        1246           if current == end:
    60    116.9 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.7 MiB  -8148.3 MiB       11205           for neighbor in current.neighbors:
    65    117.7 MiB  -7243.5 MiB        9960               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.7 MiB  -3621.8 MiB        4980                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.7 MiB  -3621.7 MiB        4980                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.7 MiB  -7243.5 MiB        9960               if temp_g_score < g_score[neighbor]:
    71    117.7 MiB  -1422.4 MiB        1970                   came_from[neighbor] = current
    72    117.7 MiB  -1422.4 MiB        1970                   g_score[neighbor] = temp_g_score
    73    117.7 MiB  -1422.4 MiB        1970                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.7 MiB  -1422.4 MiB        1970                   if neighbor not in open_set_hash:
    75    117.7 MiB  -1422.4 MiB        1970                       count += 1
    76    117.7 MiB  -1422.4 MiB        1970                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.7 MiB  -1422.4 MiB        1970                       open_set_hash.add(neighbor)
    78                                                             
    79    117.7 MiB   -905.4 MiB        1245           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.7 MiB   -905.4 MiB        1245           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.9 MiB    116.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.9 MiB   -124.6 MiB         257       for row in grid:
    30    116.9 MiB -31717.3 MiB       65792           for spot in row:
    31    116.9 MiB -31593.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.8 MiB     -2.2 MiB           1       count = 0
    34    114.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.8 MiB      0.0 MiB           1       came_from = {}
    37    116.6 MiB      1.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.4 MiB -29784.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.4 MiB     -1.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.5 MiB      0.0 MiB        1425       while not open_set.empty():
    47    116.5 MiB      0.0 MiB        1425           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.5 MiB      0.0 MiB        1425           current = open_set.get()[2]
    53    116.5 MiB      0.0 MiB        1425           open_set_hash.remove(current)
    54                                         
    55    116.5 MiB      0.0 MiB        1425           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.5 MiB      0.0 MiB        1425           if current == end:
    60    116.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.5 MiB      0.0 MiB       12816           for neighbor in current.neighbors:
    65    116.5 MiB      0.0 MiB       11392               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.5 MiB      0.0 MiB        5696                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.5 MiB      0.0 MiB        5696                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.5 MiB      0.0 MiB       11392               if temp_g_score < g_score[neighbor]:
    71    116.5 MiB      0.1 MiB        1833                   came_from[neighbor] = current
    72    116.5 MiB      0.0 MiB        1833                   g_score[neighbor] = temp_g_score
    73    116.5 MiB      0.0 MiB        1833                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.5 MiB      0.0 MiB        1833                   if neighbor not in open_set_hash:
    75    116.5 MiB      0.0 MiB        1833                       count += 1
    76    116.5 MiB      0.0 MiB        1833                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.5 MiB      0.0 MiB        1833                       open_set_hash.add(neighbor)
    78                                                             
    79    116.5 MiB      0.0 MiB        1424           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.5 MiB      0.0 MiB        1424           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.0 MiB    114.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.0 MiB   -216.2 MiB         257       for row in grid:
    30    114.0 MiB -55545.0 MiB       65792           for spot in row:
    31    114.0 MiB -55329.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.8 MiB     -1.2 MiB           1       count = 0
    34    112.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.8 MiB      0.0 MiB           1       came_from = {}
    37    115.8 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.5 MiB -34953.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.3 MiB     -1.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.4 MiB      0.0 MiB         598       while not open_set.empty():
    47    115.4 MiB      0.0 MiB         598           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.4 MiB      0.0 MiB         598           current = open_set.get()[2]
    53    115.4 MiB      0.0 MiB         598           open_set_hash.remove(current)
    54                                         
    55    115.4 MiB      0.0 MiB         598           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.4 MiB      0.0 MiB         598           if current == end:
    60    115.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.4 MiB      0.0 MiB        5373           for neighbor in current.neighbors:
    65    115.4 MiB      0.0 MiB        4776               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.4 MiB      0.0 MiB        2388                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.4 MiB      0.0 MiB        2388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.4 MiB      0.0 MiB        4776               if temp_g_score < g_score[neighbor]:
    71    115.4 MiB      0.0 MiB         740                   came_from[neighbor] = current
    72    115.4 MiB      0.0 MiB         740                   g_score[neighbor] = temp_g_score
    73    115.4 MiB      0.0 MiB         740                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.4 MiB      0.0 MiB         740                   if neighbor not in open_set_hash:
    75    115.4 MiB      0.0 MiB         740                       count += 1
    76    115.4 MiB      0.0 MiB         740                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.4 MiB      0.0 MiB         740                       open_set_hash.add(neighbor)
    78                                                             
    79    115.4 MiB      0.0 MiB         597           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.4 MiB      0.0 MiB         597           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.4 MiB    115.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.4 MiB   -878.0 MiB         257       for row in grid:
    30    115.4 MiB -224992.4 MiB       65792           for spot in row:
    31    115.4 MiB -224117.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.4 MiB     -4.0 MiB           1       count = 0
    34    111.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.4 MiB      0.0 MiB           1       came_from = {}
    37    113.8 MiB -67920.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.3 MiB     -4.5 MiB           1       g_score[start] = 0
    39    112.5 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.5 MiB   -205.4 MiB         936       while not open_set.empty():
    47    112.5 MiB   -205.4 MiB         936           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.5 MiB   -205.4 MiB         936           current = open_set.get()[2]
    53    112.5 MiB   -205.4 MiB         936           open_set_hash.remove(current)
    54                                         
    55    112.5 MiB   -205.4 MiB         936           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.5 MiB   -205.4 MiB         936           if current == end:
    60    111.6 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.5 MiB  -1841.7 MiB        8415           for neighbor in current.neighbors:
    65    112.5 MiB  -1636.5 MiB        7480               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.5 MiB   -819.1 MiB        3740                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.5 MiB   -817.6 MiB        3740                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.5 MiB  -1636.9 MiB        7480               if temp_g_score < g_score[neighbor]:
    71    112.5 MiB   -246.0 MiB        1130                   came_from[neighbor] = current
    72    112.5 MiB   -246.0 MiB        1130                   g_score[neighbor] = temp_g_score
    73    112.5 MiB   -246.0 MiB        1130                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.5 MiB   -246.1 MiB        1130                   if neighbor not in open_set_hash:
    75    112.5 MiB   -246.1 MiB        1130                       count += 1
    76    112.5 MiB   -246.1 MiB        1130                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.5 MiB   -246.0 MiB        1130                       open_set_hash.add(neighbor)
    78                                                             
    79    112.5 MiB   -205.4 MiB         935           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.5 MiB   -205.4 MiB         935           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.6 MiB    107.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.6 MiB      0.0 MiB         257       for row in grid:
    30    107.6 MiB      0.0 MiB       65792           for spot in row:
    31    107.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.6 MiB      0.0 MiB           1       count = 0
    34    107.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.6 MiB      0.0 MiB           1       came_from = {}
    37    110.4 MiB -10913.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.8 MiB     -0.6 MiB           1       g_score[start] = 0
    39    110.4 MiB  -7873.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.5 MiB      0.0 MiB        1700       while not open_set.empty():
    47    110.5 MiB      0.0 MiB        1700           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.5 MiB      0.0 MiB        1700           current = open_set.get()[2]
    53    110.5 MiB      0.0 MiB        1700           open_set_hash.remove(current)
    54                                         
    55    110.5 MiB      0.0 MiB        1700           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.5 MiB      0.0 MiB        1700           if current == end:
    60    110.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.5 MiB      0.0 MiB       15291           for neighbor in current.neighbors:
    65    110.5 MiB      0.0 MiB       13592               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.5 MiB      0.0 MiB        6796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.5 MiB      0.0 MiB        6796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.5 MiB      0.0 MiB       13592               if temp_g_score < g_score[neighbor]:
    71    110.5 MiB      0.0 MiB        2132                   came_from[neighbor] = current
    72    110.5 MiB      0.0 MiB        2132                   g_score[neighbor] = temp_g_score
    73    110.5 MiB      0.0 MiB        2132                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.5 MiB      0.0 MiB        2132                   if neighbor not in open_set_hash:
    75    110.5 MiB      0.0 MiB        2132                       count += 1
    76    110.5 MiB      0.0 MiB        2132                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.5 MiB      0.0 MiB        2132                       open_set_hash.add(neighbor)
    78                                                             
    79    110.5 MiB      0.0 MiB        1699           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.5 MiB      0.0 MiB        1699           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.5 MiB    110.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.5 MiB     -7.4 MiB         257       for row in grid:
    30    110.5 MiB  -1886.3 MiB       65792           for spot in row:
    31    110.5 MiB  -1879.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.3 MiB     -0.2 MiB           1       count = 0
    34    110.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.3 MiB      0.0 MiB           1       came_from = {}
    37    110.9 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.2 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.2 MiB      0.0 MiB        1392       while not open_set.empty():
    47    112.2 MiB      0.0 MiB        1392           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.2 MiB      0.0 MiB        1392           current = open_set.get()[2]
    53    112.2 MiB      0.0 MiB        1392           open_set_hash.remove(current)
    54                                         
    55    112.2 MiB      0.0 MiB        1392           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.2 MiB      0.0 MiB        1392           if current == end:
    60    112.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.2 MiB      0.0 MiB       12519           for neighbor in current.neighbors:
    65    112.2 MiB      0.0 MiB       11128               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.2 MiB      0.0 MiB        5564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.2 MiB      0.0 MiB        5564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.2 MiB      0.0 MiB       11128               if temp_g_score < g_score[neighbor]:
    71    112.2 MiB      0.0 MiB        1602                   came_from[neighbor] = current
    72    112.2 MiB      0.0 MiB        1602                   g_score[neighbor] = temp_g_score
    73    112.2 MiB      0.0 MiB        1602                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.2 MiB      0.0 MiB        1602                   if neighbor not in open_set_hash:
    75    112.2 MiB      0.0 MiB        1602                       count += 1
    76    112.2 MiB      0.0 MiB        1602                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.2 MiB      0.0 MiB        1602                       open_set_hash.add(neighbor)
    78                                                             
    79    112.2 MiB      0.0 MiB        1391           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.2 MiB      0.0 MiB        1391           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.3 MiB    112.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.3 MiB   -410.4 MiB         257       for row in grid:
    30    112.3 MiB -104787.9 MiB       65792           for spot in row:
    31    112.3 MiB -104379.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.3 MiB     -3.1 MiB           1       count = 0
    34    109.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.3 MiB      0.0 MiB           1       came_from = {}
    37    109.9 MiB -126068.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.3 MiB     -3.6 MiB           1       g_score[start] = 0
    39    106.7 MiB -121054.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.4 MiB     -1.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.6 MiB  -1724.2 MiB        9776       while not open_set.empty():
    47    105.6 MiB  -1724.2 MiB        9776           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.6 MiB  -1724.2 MiB        9776           current = open_set.get()[2]
    53    105.6 MiB  -1724.2 MiB        9776           open_set_hash.remove(current)
    54                                         
    55    105.6 MiB  -1724.2 MiB        9776           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.6 MiB  -1724.2 MiB        9776           if current == end:
    60    103.5 MiB     -2.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.6 MiB -15504.5 MiB       87975           for neighbor in current.neighbors:
    65    105.6 MiB -13781.0 MiB       78200               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.6 MiB  -6892.8 MiB       39100                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.6 MiB  -6889.0 MiB       39100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.6 MiB -13782.1 MiB       78200               if temp_g_score < g_score[neighbor]:
    71    105.6 MiB  -1882.6 MiB       10378                   came_from[neighbor] = current
    72    105.6 MiB  -1882.7 MiB       10378                   g_score[neighbor] = temp_g_score
    73    105.6 MiB  -1882.7 MiB       10378                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.6 MiB  -1882.7 MiB       10378                   if neighbor not in open_set_hash:
    75    105.6 MiB  -1882.7 MiB       10378                       count += 1
    76    105.6 MiB  -1882.7 MiB       10378                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.6 MiB  -1882.7 MiB       10378                       open_set_hash.add(neighbor)
    78                                                             
    79    105.6 MiB  -1724.2 MiB        9775           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.6 MiB  -1724.2 MiB        9775           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.5 MiB    103.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.5 MiB      0.0 MiB         257       for row in grid:
    30    103.5 MiB      0.0 MiB       65792           for spot in row:
    31    103.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.5 MiB      0.0 MiB           1       count = 0
    34    103.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.5 MiB      0.0 MiB           1       came_from = {}
    37    104.1 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.5 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.7 MiB  -7224.3 MiB       13892       while not open_set.empty():
    47    106.7 MiB  -7224.3 MiB       13892           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.7 MiB  -7224.3 MiB       13892           current = open_set.get()[2]
    53    106.7 MiB  -7224.4 MiB       13892           open_set_hash.remove(current)
    54                                         
    55    106.7 MiB  -7224.4 MiB       13892           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.7 MiB  -7224.4 MiB       13892           if current == end:
    60    105.7 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.7 MiB -65012.0 MiB      125019           for neighbor in current.neighbors:
    65    106.7 MiB -57787.8 MiB      111128               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.7 MiB -28894.6 MiB       55564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.7 MiB -28893.4 MiB       55564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.7 MiB -57788.2 MiB      111128               if temp_g_score < g_score[neighbor]:
    71    106.7 MiB  -7534.7 MiB       14678                   came_from[neighbor] = current
    72    106.7 MiB  -7535.1 MiB       14678                   g_score[neighbor] = temp_g_score
    73    106.7 MiB  -7535.3 MiB       14678                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.7 MiB  -7535.3 MiB       14678                   if neighbor not in open_set_hash:
    75    106.7 MiB  -7535.4 MiB       14678                       count += 1
    76    106.7 MiB  -7535.4 MiB       14678                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.7 MiB  -7535.4 MiB       14678                       open_set_hash.add(neighbor)
    78                                                             
    79    106.7 MiB  -7224.3 MiB       13891           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.7 MiB  -7224.3 MiB       13891           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.4 MiB    106.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.4 MiB      0.0 MiB         257       for row in grid:
    30    106.4 MiB      0.0 MiB       65792           for spot in row:
    31    106.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.4 MiB      0.0 MiB           1       count = 0
    34    106.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.4 MiB      0.0 MiB           1       came_from = {}
    37    107.0 MiB -34780.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.0 MiB     -4.0 MiB           1       g_score[start] = 0
    39    105.9 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.9 MiB -382043.7 MiB        9975       while not open_set.empty():
    47    105.9 MiB -382044.6 MiB        9975           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.9 MiB -382046.5 MiB        9975           current = open_set.get()[2]
    53    105.9 MiB -382047.8 MiB        9975           open_set_hash.remove(current)
    54                                         
    55    105.9 MiB -382048.5 MiB        9975           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.9 MiB -382049.2 MiB        9975           if current == end:
    60     57.2 MiB    -48.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.3 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.9 MiB -3438190.4 MiB       89766           for neighbor in current.neighbors:
    65    105.9 MiB -3056157.2 MiB       79792               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.9 MiB -1528120.2 MiB       39896                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.9 MiB -1528045.1 MiB       39896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.9 MiB -3056180.6 MiB       79792               if temp_g_score < g_score[neighbor]:
    71    105.9 MiB -400671.6 MiB       10563                   came_from[neighbor] = current
    72    105.9 MiB -400674.5 MiB       10563                   g_score[neighbor] = temp_g_score
    73    105.9 MiB -400675.6 MiB       10563                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.9 MiB -400680.4 MiB       10563                   if neighbor not in open_set_hash:
    75    105.9 MiB -400681.7 MiB       10563                       count += 1
    76    105.9 MiB -400669.2 MiB       10563                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.9 MiB -400670.1 MiB       10563                       open_set_hash.add(neighbor)
    78                                                             
    79    105.9 MiB -382040.0 MiB        9974           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.9 MiB -382042.2 MiB        9974           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.9 MiB     59.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.1 MiB      0.0 MiB         257       for row in grid:
    30     63.1 MiB      0.0 MiB       65792           for spot in row:
    31     63.1 MiB      3.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.1 MiB      0.0 MiB           1       count = 0
    34     63.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.1 MiB      0.0 MiB           1       came_from = {}
    37     67.0 MiB  -3263.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.8 MiB     -0.2 MiB           1       g_score[start] = 0
    39     70.9 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.0 MiB  -6968.2 MiB        8673       while not open_set.empty():
    47     71.0 MiB  -6968.2 MiB        8673           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.0 MiB  -6968.2 MiB        8673           current = open_set.get()[2]
    53     71.0 MiB  -6968.2 MiB        8673           open_set_hash.remove(current)
    54                                         
    55     71.0 MiB  -6968.2 MiB        8673           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.0 MiB  -6968.2 MiB        8673           if current == end:
    60     69.9 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.0 MiB -62712.3 MiB       78048           for neighbor in current.neighbors:
    65     71.0 MiB -55744.5 MiB       69376               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.0 MiB -27872.9 MiB       34688                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.0 MiB -27871.9 MiB       34688                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.0 MiB -55745.1 MiB       69376               if temp_g_score < g_score[neighbor]:
    71     71.0 MiB  -7439.9 MiB        9377                   came_from[neighbor] = current
    72     71.0 MiB  -7439.9 MiB        9377                   g_score[neighbor] = temp_g_score
    73     71.0 MiB  -7439.9 MiB        9377                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.0 MiB  -7439.9 MiB        9377                   if neighbor not in open_set_hash:
    75     71.0 MiB  -7439.9 MiB        9377                       count += 1
    76     71.0 MiB  -7439.9 MiB        9377                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.0 MiB  -7439.8 MiB        9377                       open_set_hash.add(neighbor)
    78                                                             
    79     71.0 MiB  -6968.2 MiB        8672           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.0 MiB  -6968.2 MiB        8672           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.5 MiB    106.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.5 MiB     -3.8 MiB         257       for row in grid:
    30    106.5 MiB   -750.8 MiB       65792           for spot in row:
    31    106.5 MiB   -748.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.9 MiB     -1.6 MiB           1       count = 0
    34    104.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.9 MiB      0.0 MiB           1       came_from = {}
    37    108.9 MiB  -7477.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.4 MiB     -0.5 MiB           1       g_score[start] = 0
    39    110.4 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.4 MiB    -15.5 MiB        3016       while not open_set.empty():
    47    110.4 MiB    -15.5 MiB        3016           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.4 MiB    -15.5 MiB        3016           current = open_set.get()[2]
    53    110.4 MiB    -15.5 MiB        3016           open_set_hash.remove(current)
    54                                         
    55    110.4 MiB    -15.5 MiB        3016           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.4 MiB    -15.5 MiB        3016           if current == end:
    60    110.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.4 MiB   -139.8 MiB       27135           for neighbor in current.neighbors:
    65    110.4 MiB   -124.2 MiB       24120               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.4 MiB    -62.1 MiB       12060                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.4 MiB    -62.1 MiB       12060                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.4 MiB   -124.3 MiB       24120               if temp_g_score < g_score[neighbor]:
    71    110.4 MiB    -16.9 MiB        3350                   came_from[neighbor] = current
    72    110.4 MiB    -16.9 MiB        3350                   g_score[neighbor] = temp_g_score
    73    110.4 MiB    -16.9 MiB        3350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.4 MiB    -16.9 MiB        3350                   if neighbor not in open_set_hash:
    75    110.4 MiB    -16.9 MiB        3350                       count += 1
    76    110.4 MiB    -16.9 MiB        3350                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.4 MiB    -16.8 MiB        3350                       open_set_hash.add(neighbor)
    78                                                             
    79    110.4 MiB    -15.5 MiB        3015           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.4 MiB    -15.5 MiB        3015           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.4 MiB    110.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.4 MiB      0.0 MiB         257       for row in grid:
    30    110.4 MiB      0.0 MiB       65792           for spot in row:
    31    110.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.4 MiB      0.0 MiB           1       count = 0
    34    110.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.4 MiB      0.0 MiB           1       came_from = {}
    37    113.3 MiB -49036.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.5 MiB     -2.8 MiB           1       g_score[start] = 0
    39    112.5 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.5 MiB      0.0 MiB        1178       while not open_set.empty():
    47    112.5 MiB      0.0 MiB        1178           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.5 MiB      0.0 MiB        1178           current = open_set.get()[2]
    53    112.5 MiB      0.0 MiB        1178           open_set_hash.remove(current)
    54                                         
    55    112.5 MiB      0.0 MiB        1178           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.5 MiB      0.0 MiB        1178           if current == end:
    60    112.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.5 MiB      0.0 MiB       10593           for neighbor in current.neighbors:
    65    112.5 MiB      0.0 MiB        9416               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.5 MiB      0.0 MiB        4708                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.5 MiB      0.0 MiB        4708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.5 MiB      0.0 MiB        9416               if temp_g_score < g_score[neighbor]:
    71    112.5 MiB      0.0 MiB        1462                   came_from[neighbor] = current
    72    112.5 MiB      0.0 MiB        1462                   g_score[neighbor] = temp_g_score
    73    112.5 MiB      0.0 MiB        1462                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.5 MiB      0.0 MiB        1462                   if neighbor not in open_set_hash:
    75    112.5 MiB      0.0 MiB        1462                       count += 1
    76    112.5 MiB      0.0 MiB        1462                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.5 MiB      0.0 MiB        1462                       open_set_hash.add(neighbor)
    78                                                             
    79    112.5 MiB      0.0 MiB        1177           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.5 MiB      0.0 MiB        1177           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.1 MiB    113.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.1 MiB     -1.5 MiB         257       for row in grid:
    30    113.1 MiB   -360.0 MiB       65792           for spot in row:
    31    113.1 MiB   -358.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.6 MiB     -0.5 MiB           1       count = 0
    34    112.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.6 MiB      0.0 MiB           1       came_from = {}
    37    112.8 MiB      0.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.2 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.2 MiB   -408.3 MiB         378       while not open_set.empty():
    47    113.2 MiB   -408.3 MiB         378           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.2 MiB   -408.3 MiB         378           current = open_set.get()[2]
    53    113.2 MiB   -408.3 MiB         378           open_set_hash.remove(current)
    54                                         
    55    113.2 MiB   -408.3 MiB         378           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.2 MiB   -408.3 MiB         378           if current == end:
    60    110.7 MiB     -2.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.2 MiB  -3665.4 MiB        3393           for neighbor in current.neighbors:
    65    113.2 MiB  -3257.5 MiB        3016               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.2 MiB  -1630.6 MiB        1508                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.2 MiB  -1627.2 MiB        1508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.2 MiB  -3258.2 MiB        3016               if temp_g_score < g_score[neighbor]:
    71    113.2 MiB   -521.7 MiB         512                   came_from[neighbor] = current
    72    113.2 MiB   -521.7 MiB         512                   g_score[neighbor] = temp_g_score
    73    113.2 MiB   -521.7 MiB         512                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.2 MiB   -522.0 MiB         512                   if neighbor not in open_set_hash:
    75    113.2 MiB   -522.3 MiB         512                       count += 1
    76    113.2 MiB   -522.5 MiB         512                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.2 MiB   -522.6 MiB         512                       open_set_hash.add(neighbor)
    78                                                             
    79    113.2 MiB   -408.3 MiB         377           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.2 MiB   -408.3 MiB         377           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.7 MiB    110.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.7 MiB      0.0 MiB         257       for row in grid:
    30    110.7 MiB      0.0 MiB       65792           for spot in row:
    31    110.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.7 MiB      0.0 MiB           1       count = 0
    34    110.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.7 MiB      0.0 MiB           1       came_from = {}
    37    113.2 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.6 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.8 MiB      0.0 MiB        3220       while not open_set.empty():
    47    113.8 MiB      0.0 MiB        3220           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.8 MiB      0.0 MiB        3220           current = open_set.get()[2]
    53    113.8 MiB      0.0 MiB        3220           open_set_hash.remove(current)
    54                                         
    55    113.8 MiB      0.0 MiB        3220           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.8 MiB      0.0 MiB        3220           if current == end:
    60    113.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.8 MiB      0.0 MiB       28971           for neighbor in current.neighbors:
    65    113.8 MiB      0.0 MiB       25752               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.8 MiB      0.0 MiB       12876                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.8 MiB      0.0 MiB       12876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.8 MiB      0.0 MiB       25752               if temp_g_score < g_score[neighbor]:
    71    113.8 MiB      0.2 MiB        3590                   came_from[neighbor] = current
    72    113.8 MiB      0.0 MiB        3590                   g_score[neighbor] = temp_g_score
    73    113.8 MiB      0.0 MiB        3590                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.8 MiB      0.0 MiB        3590                   if neighbor not in open_set_hash:
    75    113.8 MiB      0.0 MiB        3590                       count += 1
    76    113.8 MiB      0.0 MiB        3590                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.8 MiB      0.0 MiB        3590                       open_set_hash.add(neighbor)
    78                                                             
    79    113.8 MiB      0.0 MiB        3219           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.8 MiB      0.0 MiB        3219           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.1 MiB    114.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.1 MiB      0.0 MiB         257       for row in grid:
    30    114.1 MiB      0.0 MiB       65792           for spot in row:
    31    114.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.1 MiB      0.0 MiB           1       count = 0
    34    114.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.1 MiB      0.0 MiB           1       came_from = {}
    37    115.8 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.0 MiB      1.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.0 MiB -31811.3 MiB        7182       while not open_set.empty():
    47    117.0 MiB -31811.6 MiB        7182           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.0 MiB -31812.4 MiB        7182           current = open_set.get()[2]
    53    117.0 MiB -31812.8 MiB        7182           open_set_hash.remove(current)
    54                                         
    55    117.0 MiB -31813.1 MiB        7182           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.0 MiB -31813.2 MiB        7182           if current == end:
    60    109.9 MiB     -7.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.0 MiB -286280.9 MiB       64629           for neighbor in current.neighbors:
    65    117.0 MiB -254470.5 MiB       57448               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.0 MiB -127240.4 MiB       28724                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.0 MiB -127232.5 MiB       28724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.0 MiB -254474.2 MiB       57448               if temp_g_score < g_score[neighbor]:
    71    117.0 MiB -33379.3 MiB        7660                   came_from[neighbor] = current
    72    117.0 MiB -33379.4 MiB        7660                   g_score[neighbor] = temp_g_score
    73    117.0 MiB -33379.4 MiB        7660                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.0 MiB -33379.4 MiB        7660                   if neighbor not in open_set_hash:
    75    117.0 MiB -33379.4 MiB        7660                       count += 1
    76    117.0 MiB -33379.4 MiB        7660                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.0 MiB -33379.4 MiB        7660                       open_set_hash.add(neighbor)
    78                                                             
    79    117.0 MiB -31810.9 MiB        7181           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.0 MiB -31811.0 MiB        7181           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.9 MiB    109.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.9 MiB      0.0 MiB         257       for row in grid:
    30    109.9 MiB      0.0 MiB       65792           for spot in row:
    31    109.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.9 MiB      0.0 MiB           1       count = 0
    34    109.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.9 MiB      0.0 MiB           1       came_from = {}
    37    110.0 MiB -21478.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.9 MiB     -2.1 MiB           1       g_score[start] = 0
    39    110.3 MiB -11016.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.3 MiB      0.0 MiB         847       while not open_set.empty():
    47    110.3 MiB      0.0 MiB         847           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.3 MiB      0.0 MiB         847           current = open_set.get()[2]
    53    110.3 MiB      0.0 MiB         847           open_set_hash.remove(current)
    54                                         
    55    110.3 MiB      0.0 MiB         847           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.3 MiB      0.0 MiB         847           if current == end:
    60    110.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.3 MiB      0.0 MiB        7614           for neighbor in current.neighbors:
    65    110.3 MiB      0.0 MiB        6768               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.3 MiB      0.0 MiB        3384                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.3 MiB      0.0 MiB        3384                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.3 MiB      0.0 MiB        6768               if temp_g_score < g_score[neighbor]:
    71    110.3 MiB      0.0 MiB        1115                   came_from[neighbor] = current
    72    110.3 MiB      0.0 MiB        1115                   g_score[neighbor] = temp_g_score
    73    110.3 MiB      0.0 MiB        1115                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.3 MiB      0.0 MiB        1115                   if neighbor not in open_set_hash:
    75    110.3 MiB      0.0 MiB        1115                       count += 1
    76    110.3 MiB      0.0 MiB        1115                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.3 MiB      0.0 MiB        1115                       open_set_hash.add(neighbor)
    78                                                             
    79    110.3 MiB      0.0 MiB         846           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.3 MiB      0.0 MiB         846           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.4 MiB    110.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.4 MiB   -968.5 MiB         257       for row in grid:
    30    110.4 MiB -248073.8 MiB       65792           for spot in row:
    31    110.4 MiB -247107.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.3 MiB     -5.2 MiB           1       count = 0
    34    105.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.3 MiB      0.0 MiB           1       came_from = {}
    37    106.3 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.5 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.5 MiB     -6.6 MiB         784       while not open_set.empty():
    47    109.5 MiB     -6.6 MiB         784           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.5 MiB     -6.6 MiB         784           current = open_set.get()[2]
    53    109.5 MiB     -6.6 MiB         784           open_set_hash.remove(current)
    54                                         
    55    109.5 MiB     -6.6 MiB         784           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.5 MiB     -6.6 MiB         784           if current == end:
    60    109.5 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.5 MiB    -58.6 MiB        7047           for neighbor in current.neighbors:
    65    109.5 MiB    -52.0 MiB        6264               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.5 MiB    -26.2 MiB        3132                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.5 MiB    -25.9 MiB        3132                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.5 MiB    -52.1 MiB        6264               if temp_g_score < g_score[neighbor]:
    71    109.5 MiB     -8.6 MiB        1010                   came_from[neighbor] = current
    72    109.5 MiB     -8.6 MiB        1010                   g_score[neighbor] = temp_g_score
    73    109.5 MiB     -8.6 MiB        1010                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.5 MiB     -8.6 MiB        1010                   if neighbor not in open_set_hash:
    75    109.5 MiB     -8.6 MiB        1010                       count += 1
    76    109.5 MiB     -8.6 MiB        1010                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.5 MiB     -8.6 MiB        1010                       open_set_hash.add(neighbor)
    78                                                             
    79    109.5 MiB     -6.6 MiB         783           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.5 MiB     -6.6 MiB         783           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.5 MiB    109.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.5 MiB   -870.4 MiB         257       for row in grid:
    30    109.5 MiB -222885.9 MiB       65792           for spot in row:
    31    109.5 MiB -222018.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.4 MiB     -4.0 MiB           1       count = 0
    34    105.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.4 MiB      0.0 MiB           1       came_from = {}
    37    105.7 MiB  -4228.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.6 MiB     -0.2 MiB           1       g_score[start] = 0
    39    108.3 MiB      2.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.3 MiB      0.0 MiB        2232       while not open_set.empty():
    47    108.3 MiB      0.0 MiB        2232           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.3 MiB      0.0 MiB        2232           current = open_set.get()[2]
    53    108.3 MiB      0.0 MiB        2232           open_set_hash.remove(current)
    54                                         
    55    108.3 MiB      0.0 MiB        2232           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.3 MiB      0.0 MiB        2232           if current == end:
    60    108.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.3 MiB      0.0 MiB       20079           for neighbor in current.neighbors:
    65    108.3 MiB      0.0 MiB       17848               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.3 MiB      0.0 MiB        8924                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.3 MiB      0.0 MiB        8924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.3 MiB      0.0 MiB       17848               if temp_g_score < g_score[neighbor]:
    71    108.3 MiB      0.0 MiB        2550                   came_from[neighbor] = current
    72    108.3 MiB      0.0 MiB        2550                   g_score[neighbor] = temp_g_score
    73    108.3 MiB      0.0 MiB        2550                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.3 MiB      0.0 MiB        2550                   if neighbor not in open_set_hash:
    75    108.3 MiB      0.0 MiB        2550                       count += 1
    76    108.3 MiB      0.0 MiB        2550                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.3 MiB      0.0 MiB        2550                       open_set_hash.add(neighbor)
    78                                                             
    79    108.3 MiB      0.0 MiB        2231           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.3 MiB      0.0 MiB        2231           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.7 MiB    109.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.7 MiB   -211.5 MiB         257       for row in grid:
    30    109.7 MiB -53902.6 MiB       65792           for spot in row:
    31    109.7 MiB -53692.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.5 MiB     -2.2 MiB           1       count = 0
    34    107.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.5 MiB      0.0 MiB           1       came_from = {}
    37    109.7 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.5 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.5 MiB      0.0 MiB         973       while not open_set.empty():
    47    112.5 MiB      0.0 MiB         973           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.5 MiB      0.0 MiB         973           current = open_set.get()[2]
    53    112.5 MiB      0.0 MiB         973           open_set_hash.remove(current)
    54                                         
    55    112.5 MiB      0.0 MiB         973           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.5 MiB      0.0 MiB         973           if current == end:
    60    112.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.5 MiB      0.0 MiB        8748           for neighbor in current.neighbors:
    65    112.5 MiB      0.0 MiB        7776               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.5 MiB      0.0 MiB        3888                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.5 MiB      0.0 MiB        3888                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.5 MiB      0.0 MiB        7776               if temp_g_score < g_score[neighbor]:
    71    112.5 MiB      0.0 MiB        1277                   came_from[neighbor] = current
    72    112.5 MiB      0.0 MiB        1277                   g_score[neighbor] = temp_g_score
    73    112.5 MiB      0.0 MiB        1277                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.5 MiB      0.0 MiB        1277                   if neighbor not in open_set_hash:
    75    112.5 MiB      0.0 MiB        1277                       count += 1
    76    112.5 MiB      0.0 MiB        1277                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.5 MiB      0.0 MiB        1277                       open_set_hash.add(neighbor)
    78                                                             
    79    112.5 MiB      0.0 MiB         972           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.5 MiB      0.0 MiB         972           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.5 MiB    112.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.5 MiB   -397.4 MiB         257       for row in grid:
    30    112.5 MiB -101964.2 MiB       65792           for spot in row:
    31    112.5 MiB -101568.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.3 MiB     -2.2 MiB           1       count = 0
    34    110.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.3 MiB      0.0 MiB           1       came_from = {}
    37    113.1 MiB -17182.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.0 MiB     -1.1 MiB           1       g_score[start] = 0
    39    114.5 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.5 MiB   -600.9 MiB        7350       while not open_set.empty():
    47    114.5 MiB   -600.9 MiB        7350           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.5 MiB   -600.9 MiB        7350           current = open_set.get()[2]
    53    114.5 MiB   -600.9 MiB        7350           open_set_hash.remove(current)
    54                                         
    55    114.5 MiB   -600.9 MiB        7350           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.5 MiB   -600.9 MiB        7350           if current == end:
    60    114.1 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.5 MiB  -5406.3 MiB       66141           for neighbor in current.neighbors:
    65    114.5 MiB  -4805.6 MiB       58792               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.5 MiB  -2403.2 MiB       29396                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.5 MiB  -2402.4 MiB       29396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.5 MiB  -4805.6 MiB       58792               if temp_g_score < g_score[neighbor]:
    71    114.5 MiB   -643.2 MiB        7866                   came_from[neighbor] = current
    72    114.5 MiB   -643.2 MiB        7866                   g_score[neighbor] = temp_g_score
    73    114.5 MiB   -643.3 MiB        7866                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.5 MiB   -643.3 MiB        7866                   if neighbor not in open_set_hash:
    75    114.5 MiB   -643.3 MiB        7866                       count += 1
    76    114.5 MiB   -643.3 MiB        7866                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.5 MiB   -643.3 MiB        7866                       open_set_hash.add(neighbor)
    78                                                             
    79    114.5 MiB   -600.9 MiB        7349           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.5 MiB   -600.9 MiB        7349           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.4 MiB    114.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.4 MiB      0.0 MiB         257       for row in grid:
    30    114.4 MiB      0.0 MiB       65792           for spot in row:
    31    114.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.4 MiB      0.0 MiB           1       count = 0
    34    114.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.4 MiB      0.0 MiB           1       came_from = {}
    37    115.3 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.3 MiB -276079.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.3 MiB    -10.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.4 MiB      0.0 MiB        2520       while not open_set.empty():
    47    107.4 MiB      0.0 MiB        2520           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.4 MiB      0.0 MiB        2520           current = open_set.get()[2]
    53    107.4 MiB      0.0 MiB        2520           open_set_hash.remove(current)
    54                                         
    55    107.4 MiB      0.0 MiB        2520           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.4 MiB      0.0 MiB        2520           if current == end:
    60    107.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.4 MiB      0.0 MiB       22671           for neighbor in current.neighbors:
    65    107.4 MiB      0.0 MiB       20152               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.4 MiB      0.0 MiB       10076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.4 MiB      0.0 MiB       10076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.4 MiB      0.0 MiB       20152               if temp_g_score < g_score[neighbor]:
    71    107.4 MiB      0.1 MiB        2824                   came_from[neighbor] = current
    72    107.4 MiB      0.0 MiB        2824                   g_score[neighbor] = temp_g_score
    73    107.4 MiB      0.0 MiB        2824                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.4 MiB      0.0 MiB        2824                   if neighbor not in open_set_hash:
    75    107.4 MiB      0.0 MiB        2824                       count += 1
    76    107.4 MiB      0.0 MiB        2824                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.4 MiB      0.0 MiB        2824                       open_set_hash.add(neighbor)
    78                                                             
    79    107.4 MiB      0.0 MiB        2519           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.4 MiB      0.0 MiB        2519           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.4 MiB    107.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.4 MiB   -239.0 MiB         257       for row in grid:
    30    107.4 MiB -60331.6 MiB       65792           for spot in row:
    31    107.4 MiB -60098.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.5 MiB     -7.9 MiB           1       count = 0
    34     99.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.5 MiB      0.0 MiB           1       came_from = {}
    37    103.1 MiB -28015.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.8 MiB     -1.4 MiB           1       g_score[start] = 0
    39    104.6 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.6 MiB      0.0 MiB         315       while not open_set.empty():
    47    104.6 MiB      0.0 MiB         315           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.6 MiB      0.0 MiB         315           current = open_set.get()[2]
    53    104.6 MiB      0.0 MiB         315           open_set_hash.remove(current)
    54                                         
    55    104.6 MiB      0.0 MiB         315           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.6 MiB      0.0 MiB         315           if current == end:
    60    104.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.6 MiB      0.0 MiB        2826           for neighbor in current.neighbors:
    65    104.6 MiB      0.0 MiB        2512               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.6 MiB      0.0 MiB        1256                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.6 MiB      0.0 MiB        1256                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.6 MiB      0.0 MiB        2512               if temp_g_score < g_score[neighbor]:
    71    104.6 MiB      0.0 MiB         419                   came_from[neighbor] = current
    72    104.6 MiB      0.0 MiB         419                   g_score[neighbor] = temp_g_score
    73    104.6 MiB      0.0 MiB         419                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.6 MiB      0.0 MiB         419                   if neighbor not in open_set_hash:
    75    104.6 MiB      0.0 MiB         419                       count += 1
    76    104.6 MiB      0.0 MiB         419                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.6 MiB      0.0 MiB         419                       open_set_hash.add(neighbor)
    78                                                             
    79    104.6 MiB      0.0 MiB         314           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.6 MiB      0.0 MiB         314           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.6 MiB    105.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.6 MiB      0.0 MiB         257       for row in grid:
    30    105.6 MiB      0.0 MiB       65792           for spot in row:
    31    105.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.6 MiB      0.0 MiB           1       count = 0
    34    105.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.6 MiB      0.0 MiB           1       came_from = {}
    37    106.8 MiB      1.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.4 MiB      1.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.4 MiB      0.0 MiB         481       while not open_set.empty():
    47    108.4 MiB      0.0 MiB         481           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.4 MiB      0.0 MiB         481           current = open_set.get()[2]
    53    108.4 MiB      0.0 MiB         481           open_set_hash.remove(current)
    54                                         
    55    108.4 MiB      0.0 MiB         481           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.4 MiB      0.0 MiB         481           if current == end:
    60    108.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.4 MiB      0.0 MiB        4320           for neighbor in current.neighbors:
    65    108.4 MiB      0.0 MiB        3840               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.4 MiB      0.0 MiB        1920                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.4 MiB      0.0 MiB        1920                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.4 MiB      0.0 MiB        3840               if temp_g_score < g_score[neighbor]:
    71    108.4 MiB      0.0 MiB         605                   came_from[neighbor] = current
    72    108.4 MiB      0.0 MiB         605                   g_score[neighbor] = temp_g_score
    73    108.4 MiB      0.0 MiB         605                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.4 MiB      0.0 MiB         605                   if neighbor not in open_set_hash:
    75    108.4 MiB      0.0 MiB         605                       count += 1
    76    108.4 MiB      0.0 MiB         605                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.4 MiB      0.0 MiB         605                       open_set_hash.add(neighbor)
    78                                                             
    79    108.4 MiB      0.0 MiB         480           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.4 MiB      0.0 MiB         480           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.4 MiB    108.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.4 MiB   -468.6 MiB         257       for row in grid:
    30    108.4 MiB -120414.8 MiB       65792           for spot in row:
    31    108.4 MiB -119948.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.5 MiB     -1.9 MiB           1       count = 0
    34    106.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.5 MiB      0.0 MiB           1       came_from = {}
    37    110.4 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.0 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.0 MiB      0.0 MiB         504       while not open_set.empty():
    47    111.0 MiB      0.0 MiB         504           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.0 MiB      0.0 MiB         504           current = open_set.get()[2]
    53    111.0 MiB      0.0 MiB         504           open_set_hash.remove(current)
    54                                         
    55    111.0 MiB      0.0 MiB         504           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.0 MiB      0.0 MiB         504           if current == end:
    60    111.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.0 MiB      0.0 MiB        4527           for neighbor in current.neighbors:
    65    111.0 MiB      0.0 MiB        4024               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.0 MiB      0.0 MiB        2012                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.0 MiB      0.0 MiB        2012                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.0 MiB      0.0 MiB        4024               if temp_g_score < g_score[neighbor]:
    71    111.0 MiB      0.0 MiB         674                   came_from[neighbor] = current
    72    111.0 MiB      0.0 MiB         674                   g_score[neighbor] = temp_g_score
    73    111.0 MiB      0.0 MiB         674                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.0 MiB      0.0 MiB         674                   if neighbor not in open_set_hash:
    75    111.0 MiB      0.0 MiB         674                       count += 1
    76    111.0 MiB      0.0 MiB         674                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.0 MiB      0.0 MiB         674                       open_set_hash.add(neighbor)
    78                                                             
    79    111.0 MiB      0.0 MiB         503           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.0 MiB      0.0 MiB         503           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.4 MiB    111.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.4 MiB   -324.8 MiB         257       for row in grid:
    30    111.4 MiB -83218.9 MiB       65792           for spot in row:
    31    111.4 MiB -82896.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.8 MiB     -2.6 MiB           1       count = 0
    34    108.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.8 MiB      0.0 MiB           1       came_from = {}
    37    108.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.8 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.8 MiB  -2138.6 MiB        2700       while not open_set.empty():
    47    111.8 MiB  -2138.6 MiB        2700           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.8 MiB  -2138.6 MiB        2700           current = open_set.get()[2]
    53    111.8 MiB  -2138.6 MiB        2700           open_set_hash.remove(current)
    54                                         
    55    111.8 MiB  -2138.6 MiB        2700           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.8 MiB  -2138.6 MiB        2700           if current == end:
    60    110.0 MiB     -1.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.8 MiB -19234.5 MiB       24291           for neighbor in current.neighbors:
    65    111.8 MiB -17096.5 MiB       21592               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.8 MiB  -8549.8 MiB       10796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.8 MiB  -8547.0 MiB       10796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.8 MiB -17097.4 MiB       21592               if temp_g_score < g_score[neighbor]:
    71    111.8 MiB  -2606.4 MiB        3334                   came_from[neighbor] = current
    72    111.8 MiB  -2606.4 MiB        3334                   g_score[neighbor] = temp_g_score
    73    111.8 MiB  -2606.4 MiB        3334                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.8 MiB  -2606.4 MiB        3334                   if neighbor not in open_set_hash:
    75    111.8 MiB  -2606.4 MiB        3334                       count += 1
    76    111.8 MiB  -2606.4 MiB        3334                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.8 MiB  -2606.6 MiB        3334                       open_set_hash.add(neighbor)
    78                                                             
    79    111.8 MiB  -2138.6 MiB        2699           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.8 MiB  -2138.6 MiB        2699           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.0 MiB    110.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.0 MiB      0.0 MiB         257       for row in grid:
    30    110.0 MiB      0.0 MiB       65792           for spot in row:
    31    110.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.0 MiB      0.0 MiB           1       count = 0
    34    110.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.0 MiB      0.0 MiB           1       came_from = {}
    37    110.7 MiB      0.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.4 MiB      0.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.4 MiB -14395.2 MiB        7614       while not open_set.empty():
    47    111.4 MiB -14395.5 MiB        7614           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.4 MiB -14396.2 MiB        7614           current = open_set.get()[2]
    53    111.4 MiB -14396.6 MiB        7614           open_set_hash.remove(current)
    54                                         
    55    111.4 MiB -14396.8 MiB        7614           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.4 MiB -14396.8 MiB        7614           if current == end:
    60    109.4 MiB     -2.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.4 MiB -129553.3 MiB       68517           for neighbor in current.neighbors:
    65    111.4 MiB -115158.8 MiB       60904               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.4 MiB -57579.5 MiB       30452                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.4 MiB -57579.3 MiB       30452                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.4 MiB -115158.8 MiB       60904               if temp_g_score < g_score[neighbor]:
    71    111.4 MiB -15075.3 MiB        8110                   came_from[neighbor] = current
    72    111.4 MiB -15075.3 MiB        8110                   g_score[neighbor] = temp_g_score
    73    111.4 MiB -15075.3 MiB        8110                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.4 MiB -15075.3 MiB        8110                   if neighbor not in open_set_hash:
    75    111.4 MiB -15075.3 MiB        8110                       count += 1
    76    111.4 MiB -15075.3 MiB        8110                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.4 MiB -15075.3 MiB        8110                       open_set_hash.add(neighbor)
    78                                                             
    79    111.4 MiB -14394.6 MiB        7613           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.4 MiB -14394.8 MiB        7613           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.5 MiB    109.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.5 MiB  -1425.4 MiB         257       for row in grid:
    30    109.5 MiB -365006.0 MiB       65792           for spot in row:
    31    109.5 MiB -363586.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.3 MiB    -10.2 MiB           1       count = 0
    34     99.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.3 MiB      0.0 MiB           1       came_from = {}
    37    103.1 MiB  -2276.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.7 MiB     -0.3 MiB           1       g_score[start] = 0
    39    103.1 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.1 MiB      0.0 MiB         300       while not open_set.empty():
    47    103.1 MiB      0.0 MiB         300           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.1 MiB      0.0 MiB         300           current = open_set.get()[2]
    53    103.1 MiB      0.0 MiB         300           open_set_hash.remove(current)
    54                                         
    55    103.1 MiB      0.0 MiB         300           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.1 MiB      0.0 MiB         300           if current == end:
    60    103.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.1 MiB      0.0 MiB        2691           for neighbor in current.neighbors:
    65    103.1 MiB      0.0 MiB        2392               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.1 MiB      0.0 MiB        1196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.1 MiB      0.0 MiB        1196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.1 MiB      0.0 MiB        2392               if temp_g_score < g_score[neighbor]:
    71    103.1 MiB      0.0 MiB         422                   came_from[neighbor] = current
    72    103.1 MiB      0.0 MiB         422                   g_score[neighbor] = temp_g_score
    73    103.1 MiB      0.0 MiB         422                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.1 MiB      0.0 MiB         422                   if neighbor not in open_set_hash:
    75    103.1 MiB      0.0 MiB         422                       count += 1
    76    103.1 MiB      0.0 MiB         422                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.1 MiB      0.0 MiB         422                       open_set_hash.add(neighbor)
    78                                                             
    79    103.1 MiB      0.0 MiB         299           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.1 MiB      0.0 MiB         299           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.1 MiB    103.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.1 MiB      0.0 MiB         257       for row in grid:
    30    103.1 MiB      0.0 MiB       65792           for spot in row:
    31    103.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.1 MiB      0.0 MiB           1       count = 0
    34    103.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.1 MiB      0.0 MiB           1       came_from = {}
    37    104.4 MiB -21581.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.0 MiB     -0.5 MiB           1       g_score[start] = 0
    39    106.2 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.2 MiB      0.0 MiB        1764       while not open_set.empty():
    47    106.2 MiB      0.0 MiB        1764           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.2 MiB      0.0 MiB        1764           current = open_set.get()[2]
    53    106.2 MiB      0.0 MiB        1764           open_set_hash.remove(current)
    54                                         
    55    106.2 MiB      0.0 MiB        1764           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.2 MiB      0.0 MiB        1764           if current == end:
    60    106.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.2 MiB      0.0 MiB       15867           for neighbor in current.neighbors:
    65    106.2 MiB      0.0 MiB       14104               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.2 MiB      0.0 MiB        7052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.2 MiB      0.0 MiB        7052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.2 MiB      0.0 MiB       14104               if temp_g_score < g_score[neighbor]:
    71    106.2 MiB      0.1 MiB        2104                   came_from[neighbor] = current
    72    106.2 MiB      0.0 MiB        2104                   g_score[neighbor] = temp_g_score
    73    106.2 MiB      0.0 MiB        2104                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.2 MiB      0.0 MiB        2104                   if neighbor not in open_set_hash:
    75    106.2 MiB      0.0 MiB        2104                       count += 1
    76    106.2 MiB      0.0 MiB        2104                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.2 MiB      0.0 MiB        2104                       open_set_hash.add(neighbor)
    78                                                             
    79    106.2 MiB      0.0 MiB        1763           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.2 MiB      0.0 MiB        1763           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.6 MiB    110.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.6 MiB   -463.8 MiB         257       for row in grid:
    30    110.6 MiB -118721.0 MiB       65792           for spot in row:
    31    110.6 MiB -118259.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.2 MiB     -3.4 MiB           1       count = 0
    34    107.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.2 MiB      0.0 MiB           1       came_from = {}
    37    108.3 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.2 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.2 MiB      0.0 MiB         616       while not open_set.empty():
    47    111.2 MiB      0.0 MiB         616           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.2 MiB      0.0 MiB         616           current = open_set.get()[2]
    53    111.2 MiB      0.0 MiB         616           open_set_hash.remove(current)
    54                                         
    55    111.2 MiB      0.0 MiB         616           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.2 MiB      0.0 MiB         616           if current == end:
    60    111.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.2 MiB      0.0 MiB        5535           for neighbor in current.neighbors:
    65    111.2 MiB      0.0 MiB        4920               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.2 MiB      0.0 MiB        2460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.2 MiB      0.0 MiB        2460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.2 MiB      0.0 MiB        4920               if temp_g_score < g_score[neighbor]:
    71    111.2 MiB      0.0 MiB         818                   came_from[neighbor] = current
    72    111.2 MiB      0.0 MiB         818                   g_score[neighbor] = temp_g_score
    73    111.2 MiB      0.0 MiB         818                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.2 MiB      0.0 MiB         818                   if neighbor not in open_set_hash:
    75    111.2 MiB      0.0 MiB         818                       count += 1
    76    111.2 MiB      0.0 MiB         818                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.2 MiB      0.0 MiB         818                       open_set_hash.add(neighbor)
    78                                                             
    79    111.2 MiB      0.0 MiB         615           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.2 MiB      0.0 MiB         615           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.2 MiB    111.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.2 MiB    -70.1 MiB         257       for row in grid:
    30    111.2 MiB -17882.8 MiB       65792           for spot in row:
    31    111.2 MiB -17813.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.6 MiB     -0.6 MiB           1       count = 0
    34    110.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.6 MiB      0.0 MiB           1       came_from = {}
    37    111.6 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.4 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.4 MiB      0.0 MiB         616       while not open_set.empty():
    47    114.4 MiB      0.0 MiB         616           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.4 MiB      0.0 MiB         616           current = open_set.get()[2]
    53    114.4 MiB      0.0 MiB         616           open_set_hash.remove(current)
    54                                         
    55    114.4 MiB      0.0 MiB         616           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.4 MiB      0.0 MiB         616           if current == end:
    60    114.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.4 MiB      0.0 MiB        5535           for neighbor in current.neighbors:
    65    114.4 MiB      0.0 MiB        4920               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.4 MiB      0.0 MiB        2460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.4 MiB      0.0 MiB        2460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.4 MiB      0.0 MiB        4920               if temp_g_score < g_score[neighbor]:
    71    114.4 MiB      0.0 MiB         770                   came_from[neighbor] = current
    72    114.4 MiB      0.0 MiB         770                   g_score[neighbor] = temp_g_score
    73    114.4 MiB      0.0 MiB         770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.4 MiB      0.0 MiB         770                   if neighbor not in open_set_hash:
    75    114.4 MiB      0.0 MiB         770                       count += 1
    76    114.4 MiB      0.0 MiB         770                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.4 MiB      0.0 MiB         770                       open_set_hash.add(neighbor)
    78                                                             
    79    114.4 MiB      0.0 MiB         615           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.4 MiB      0.0 MiB         615           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.6 MiB    114.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.6 MiB    -43.6 MiB         257       for row in grid:
    30    114.6 MiB -11196.6 MiB       65792           for spot in row:
    31    114.6 MiB -11153.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.3 MiB     -0.3 MiB           1       count = 0
    34    114.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.3 MiB      0.0 MiB           1       came_from = {}
    37    114.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.1 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.1 MiB  -6643.4 MiB        4300       while not open_set.empty():
    47    117.1 MiB  -6643.4 MiB        4300           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.1 MiB  -6643.5 MiB        4300           current = open_set.get()[2]
    53    117.1 MiB  -6643.5 MiB        4300           open_set_hash.remove(current)
    54                                         
    55    117.1 MiB  -6643.5 MiB        4300           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.1 MiB  -6643.5 MiB        4300           if current == end:
    60    114.8 MiB     -2.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.1 MiB -59777.9 MiB       38691           for neighbor in current.neighbors:
    65    117.1 MiB -53134.8 MiB       34392               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.1 MiB -26570.7 MiB       17196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.1 MiB -26564.4 MiB       17196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.1 MiB -53135.4 MiB       34392               if temp_g_score < g_score[neighbor]:
    71    117.1 MiB  -7014.9 MiB        4670                   came_from[neighbor] = current
    72    117.1 MiB  -7014.9 MiB        4670                   g_score[neighbor] = temp_g_score
    73    117.1 MiB  -7014.9 MiB        4670                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.1 MiB  -7015.0 MiB        4670                   if neighbor not in open_set_hash:
    75    117.1 MiB  -7015.3 MiB        4670                       count += 1
    76    117.1 MiB  -7015.7 MiB        4670                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.1 MiB  -7015.8 MiB        4670                       open_set_hash.add(neighbor)
    78                                                             
    79    117.1 MiB  -6643.4 MiB        4299           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.1 MiB  -6643.4 MiB        4299           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.8 MiB    114.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.8 MiB      0.0 MiB         257       for row in grid:
    30    114.8 MiB      0.0 MiB       65792           for spot in row:
    31    114.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.8 MiB      0.0 MiB           1       count = 0
    34    114.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.8 MiB      0.0 MiB           1       came_from = {}
    37    115.7 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.8 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.8 MiB      0.0 MiB         318       while not open_set.empty():
    47    115.8 MiB      0.0 MiB         318           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.8 MiB      0.0 MiB         318           current = open_set.get()[2]
    53    115.8 MiB      0.0 MiB         318           open_set_hash.remove(current)
    54                                         
    55    115.8 MiB      0.0 MiB         318           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.8 MiB      0.0 MiB         318           if current == end:
    60    115.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.8 MiB      0.0 MiB        2853           for neighbor in current.neighbors:
    65    115.8 MiB      0.0 MiB        2536               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.8 MiB      0.0 MiB        1268                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.8 MiB      0.0 MiB        1268                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.8 MiB      0.0 MiB        2536               if temp_g_score < g_score[neighbor]:
    71    115.8 MiB      0.0 MiB         446                   came_from[neighbor] = current
    72    115.8 MiB      0.0 MiB         446                   g_score[neighbor] = temp_g_score
    73    115.8 MiB      0.0 MiB         446                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.8 MiB      0.0 MiB         446                   if neighbor not in open_set_hash:
    75    115.8 MiB      0.0 MiB         446                       count += 1
    76    115.8 MiB      0.0 MiB         446                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.8 MiB      0.0 MiB         446                       open_set_hash.add(neighbor)
    78                                                             
    79    115.8 MiB      0.0 MiB         317           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.8 MiB      0.0 MiB         317           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.9 MiB    115.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.9 MiB  -1126.3 MiB         257       for row in grid:
    30    115.9 MiB -286082.6 MiB       65792           for spot in row:
    31    115.9 MiB -284974.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.9 MiB    -27.0 MiB           1       count = 0
    34     88.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.9 MiB      0.0 MiB           1       came_from = {}
    37     93.6 MiB -10150.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.2 MiB  -6679.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.3 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.5 MiB    -40.3 MiB          75       while not open_set.empty():
    47     98.5 MiB    -40.4 MiB          75           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.5 MiB    -40.4 MiB          75           current = open_set.get()[2]
    53     98.5 MiB    -40.4 MiB          75           open_set_hash.remove(current)
    54                                         
    55     98.5 MiB    -40.4 MiB          75           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.5 MiB    -40.4 MiB          75           if current == end:
    60     97.8 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.5 MiB   -361.9 MiB         666           for neighbor in current.neighbors:
    65     98.5 MiB   -327.1 MiB         592               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.5 MiB   -164.2 MiB         296                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.5 MiB   -163.1 MiB         296                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.5 MiB   -323.9 MiB         592               if temp_g_score < g_score[neighbor]:
    71     98.5 MiB    -71.6 MiB         143                   came_from[neighbor] = current
    72     98.5 MiB    -73.2 MiB         143                   g_score[neighbor] = temp_g_score
    73     98.5 MiB    -73.2 MiB         143                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.5 MiB    -73.2 MiB         143                   if neighbor not in open_set_hash:
    75     98.5 MiB    -73.3 MiB         143                       count += 1
    76     98.5 MiB    -73.3 MiB         143                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.5 MiB    -73.3 MiB         143                       open_set_hash.add(neighbor)
    78                                                             
    79     98.5 MiB    -41.2 MiB          74           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.5 MiB    -40.4 MiB          74           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.9 MiB     97.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.0 MiB     -0.0 MiB         257       for row in grid:
    30    101.0 MiB    -13.9 MiB       65792           for spot in row:
    31    101.0 MiB    -10.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.0 MiB      0.0 MiB           1       count = 0
    34    101.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.0 MiB      0.0 MiB           1       came_from = {}
    37    102.1 MiB -777059.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     86.6 MiB    -15.5 MiB           1       g_score[start] = 0
    39     88.5 MiB -56262.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     88.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     88.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     88.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     88.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     88.5 MiB -312481.5 MiB       10336       while not open_set.empty():
    47     88.5 MiB -312482.8 MiB       10336           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     88.5 MiB -312483.9 MiB       10336           current = open_set.get()[2]
    53     88.5 MiB -312484.8 MiB       10336           open_set_hash.remove(current)
    54                                         
    55     88.5 MiB -312486.1 MiB       10336           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     88.5 MiB -312486.7 MiB       10336           if current == end:
    60     30.5 MiB    -58.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     31.9 MiB      1.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     88.5 MiB -2811989.5 MiB       93015           for neighbor in current.neighbors:
    65     88.5 MiB -2499512.1 MiB       82680               if current.row != neighbor.row and current.col != neighbor.col:
    66     88.5 MiB -1249790.7 MiB       41340                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     88.5 MiB -1249728.5 MiB       41340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     88.5 MiB -2499528.5 MiB       82680               if temp_g_score < g_score[neighbor]:
    71     88.5 MiB -331626.2 MiB       11030                   came_from[neighbor] = current
    72     88.5 MiB -331627.4 MiB       11030                   g_score[neighbor] = temp_g_score
    73     88.5 MiB -331630.6 MiB       11030                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     88.5 MiB -331631.5 MiB       11030                   if neighbor not in open_set_hash:
    75     88.5 MiB -331632.2 MiB       11030                       count += 1
    76     88.5 MiB -331640.4 MiB       11030                       open_set.put((f_score[neighbor], count, neighbor))
    77     88.5 MiB -331641.0 MiB       11030                       open_set_hash.add(neighbor)
    78                                                             
    79     88.5 MiB -312480.5 MiB       10335           if draw is not None:
    80                                                     draw()
    81                                         
    82     88.5 MiB -312480.8 MiB       10335           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.3 MiB     91.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.3 MiB      0.0 MiB         257       for row in grid:
    30     91.3 MiB      0.0 MiB       65792           for spot in row:
    31     91.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.3 MiB      0.0 MiB           1       count = 0
    34     91.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.3 MiB      0.0 MiB           1       came_from = {}
    37     96.2 MiB -22802.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.0 MiB     -1.2 MiB           1       g_score[start] = 0
    39     99.4 MiB  -1366.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.5 MiB      0.0 MiB        1116       while not open_set.empty():
    47     99.5 MiB      0.0 MiB        1116           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.5 MiB      0.0 MiB        1116           current = open_set.get()[2]
    53     99.5 MiB      0.0 MiB        1116           open_set_hash.remove(current)
    54                                         
    55     99.5 MiB      0.0 MiB        1116           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.5 MiB      0.0 MiB        1116           if current == end:
    60     99.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.5 MiB      0.0 MiB       10035           for neighbor in current.neighbors:
    65     99.5 MiB      0.0 MiB        8920               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.5 MiB      0.0 MiB        4460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.5 MiB      0.0 MiB        4460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.5 MiB      0.0 MiB        8920               if temp_g_score < g_score[neighbor]:
    71     99.5 MiB      0.1 MiB        1398                   came_from[neighbor] = current
    72     99.5 MiB      0.0 MiB        1398                   g_score[neighbor] = temp_g_score
    73     99.5 MiB      0.0 MiB        1398                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.5 MiB      0.0 MiB        1398                   if neighbor not in open_set_hash:
    75     99.5 MiB      0.0 MiB        1398                       count += 1
    76     99.5 MiB      0.0 MiB        1398                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.5 MiB      0.0 MiB        1398                       open_set_hash.add(neighbor)
    78                                                             
    79     99.5 MiB      0.0 MiB        1115           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.5 MiB      0.0 MiB        1115           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.5 MiB     99.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.5 MiB      0.0 MiB         257       for row in grid:
    30     99.5 MiB      0.0 MiB       65792           for spot in row:
    31     99.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.5 MiB      0.0 MiB           1       count = 0
    34     99.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.5 MiB      0.0 MiB           1       came_from = {}
    37    102.3 MiB -24650.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.4 MiB   -396.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.3 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.4 MiB  -3736.8 MiB       11620       while not open_set.empty():
    47    106.4 MiB  -3736.8 MiB       11620           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.4 MiB  -3736.8 MiB       11620           current = open_set.get()[2]
    53    106.4 MiB  -3736.8 MiB       11620           open_set_hash.remove(current)
    54                                         
    55    106.4 MiB  -3736.8 MiB       11620           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.4 MiB  -3736.8 MiB       11620           if current == end:
    60    105.7 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.4 MiB -33626.5 MiB      104571           for neighbor in current.neighbors:
    65    106.4 MiB -29889.8 MiB       92952               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.4 MiB -14945.3 MiB       46476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.4 MiB -14944.6 MiB       46476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.4 MiB -29889.9 MiB       92952               if temp_g_score < g_score[neighbor]:
    71    106.4 MiB  -3884.5 MiB       12230                   came_from[neighbor] = current
    72    106.4 MiB  -3884.5 MiB       12230                   g_score[neighbor] = temp_g_score
    73    106.4 MiB  -3884.5 MiB       12230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.4 MiB  -3884.5 MiB       12230                   if neighbor not in open_set_hash:
    75    106.4 MiB  -3884.5 MiB       12230                       count += 1
    76    106.4 MiB  -3884.6 MiB       12230                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.4 MiB  -3884.7 MiB       12230                       open_set_hash.add(neighbor)
    78                                                             
    79    106.4 MiB  -3736.8 MiB       11619           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.4 MiB  -3736.8 MiB       11619           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


