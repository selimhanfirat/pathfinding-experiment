Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.1 MiB     67.1 MiB           1   @profile(stream=open('logs/A*/num_goals/3.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     71.0 MiB      0.0 MiB         257       for row in grid:
    30     71.0 MiB      0.0 MiB       65792           for spot in row:
    31     71.0 MiB      3.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.0 MiB      0.0 MiB           1       count = 0
    34     71.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.0 MiB      0.0 MiB           1       came_from = {}
    37     77.9 MiB      6.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     77.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     78.1 MiB -855881.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.7 MiB    -12.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.7 MiB     -2.3 MiB        7442       while not open_set.empty():
    47     67.7 MiB     -2.3 MiB        7442           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.7 MiB     -2.3 MiB        7442           current = open_set.get()[2]
    53     67.7 MiB     -2.3 MiB        7442           open_set_hash.remove(current)
    54                                         
    55     67.7 MiB     -2.3 MiB        7442           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.7 MiB     -2.3 MiB        7442           if current == end:
    60     67.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.8 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.7 MiB    -19.6 MiB       66969           for neighbor in current.neighbors:
    65     67.7 MiB    -18.7 MiB       59528               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.7 MiB     -9.4 MiB       29764                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.7 MiB     -9.4 MiB       29764                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.7 MiB    -18.8 MiB       59528               if temp_g_score < g_score[neighbor]:
    71     67.7 MiB     -2.2 MiB        7928                   came_from[neighbor] = current
    72     67.7 MiB     -2.6 MiB        7928                   g_score[neighbor] = temp_g_score
    73     67.7 MiB     -2.6 MiB        7928                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.7 MiB     -2.6 MiB        7928                   if neighbor not in open_set_hash:
    75     67.7 MiB     -2.6 MiB        7928                       count += 1
    76     67.7 MiB     -2.5 MiB        7928                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.7 MiB     -2.6 MiB        7928                       open_set_hash.add(neighbor)
    78                                                             
    79     67.7 MiB     -2.3 MiB        7441           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.7 MiB     -2.3 MiB        7441           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.9 MiB     67.9 MiB           1   @profile(stream=open('logs/A*/num_goals/3.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.0 MiB  -1964.5 MiB         257       for row in grid:
    30     68.0 MiB -503251.3 MiB       65792           for spot in row:
    31     68.0 MiB -501292.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.0 MiB     -9.0 MiB           1       count = 0
    34     59.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.0 MiB      0.0 MiB           1       came_from = {}
    37     64.0 MiB   -124.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.0 MiB     -0.1 MiB           1       g_score[start] = 0
    39     69.8 MiB      5.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.1 MiB -41552.5 MiB        8970       while not open_set.empty():
    47     70.1 MiB -41558.2 MiB        8970           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.1 MiB -41558.7 MiB        8970           current = open_set.get()[2]
    53     70.1 MiB -41558.9 MiB        8970           open_set_hash.remove(current)
    54                                         
    55     70.1 MiB -41559.1 MiB        8970           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.1 MiB -41559.3 MiB        8970           if current == end:
    60     58.1 MiB    -12.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.1 MiB -373948.8 MiB       80721           for neighbor in current.neighbors:
    65     70.1 MiB -332397.1 MiB       71752               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.1 MiB -166204.6 MiB       35876                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.1 MiB -166193.3 MiB       35876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.1 MiB -332399.0 MiB       71752               if temp_g_score < g_score[neighbor]:
    71     70.1 MiB -43668.8 MiB        9584                   came_from[neighbor] = current
    72     70.1 MiB -43669.2 MiB        9584                   g_score[neighbor] = temp_g_score
    73     70.1 MiB -43669.2 MiB        9584                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.1 MiB -43669.2 MiB        9584                   if neighbor not in open_set_hash:
    75     70.1 MiB -43669.2 MiB        9584                       count += 1
    76     70.1 MiB -43669.2 MiB        9584                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.1 MiB -43670.5 MiB        9584                       open_set_hash.add(neighbor)
    78                                                             
    79     70.1 MiB -41552.5 MiB        8969           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.1 MiB -41552.5 MiB        8969           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.2 MiB     59.2 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.9 MiB   -687.2 MiB         257       for row in grid:
    30     60.9 MiB -176210.2 MiB       65792           for spot in row:
    31     60.9 MiB -175526.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     53.4 MiB     -7.5 MiB           1       count = 0
    34     53.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     53.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     53.4 MiB      0.0 MiB           1       came_from = {}
    37     56.7 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.9 MiB   -485.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.9 MiB      0.0 MiB         552       while not open_set.empty():
    47     60.9 MiB      0.0 MiB         552           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.9 MiB      0.0 MiB         552           current = open_set.get()[2]
    53     60.9 MiB      0.0 MiB         552           open_set_hash.remove(current)
    54                                         
    55     60.9 MiB      0.0 MiB         552           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.9 MiB      0.0 MiB         552           if current == end:
    60     60.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.9 MiB      0.0 MiB        4959           for neighbor in current.neighbors:
    65     60.9 MiB      0.0 MiB        4408               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.9 MiB      0.0 MiB        2204                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.9 MiB      0.0 MiB        2204                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.9 MiB      0.0 MiB        4408               if temp_g_score < g_score[neighbor]:
    71     60.9 MiB      0.0 MiB         758                   came_from[neighbor] = current
    72     60.9 MiB      0.0 MiB         758                   g_score[neighbor] = temp_g_score
    73     60.9 MiB      0.0 MiB         758                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.9 MiB      0.0 MiB         758                   if neighbor not in open_set_hash:
    75     60.9 MiB      0.0 MiB         758                       count += 1
    76     60.9 MiB      0.0 MiB         758                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.9 MiB      0.0 MiB         758                       open_set_hash.add(neighbor)
    78                                                             
    79     60.9 MiB      0.0 MiB         551           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.9 MiB      0.0 MiB         551           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.8 MiB     95.8 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.0 MiB  -3528.6 MiB         257       for row in grid:
    30     96.1 MiB -903649.0 MiB       65792           for spot in row:
    31     96.1 MiB -900123.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.2 MiB    -10.8 MiB           1       count = 0
    34     85.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     85.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     85.2 MiB      0.0 MiB           1       came_from = {}
    37     91.7 MiB  -6710.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.2 MiB   -535.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.0 MiB      0.0 MiB        2277       while not open_set.empty():
    47    100.0 MiB      0.0 MiB        2277           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.0 MiB      0.0 MiB        2277           current = open_set.get()[2]
    53    100.0 MiB      0.0 MiB        2277           open_set_hash.remove(current)
    54                                         
    55    100.0 MiB      0.0 MiB        2277           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.0 MiB      0.0 MiB        2277           if current == end:
    60    100.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.0 MiB      1.1 MiB       20484           for neighbor in current.neighbors:
    65    100.0 MiB      0.6 MiB       18208               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.0 MiB      0.0 MiB        9104                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.0 MiB      0.0 MiB        9104                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.0 MiB      0.0 MiB       18208               if temp_g_score < g_score[neighbor]:
    71    100.0 MiB      0.1 MiB        2617                   came_from[neighbor] = current
    72    100.0 MiB      0.0 MiB        2617                   g_score[neighbor] = temp_g_score
    73    100.0 MiB      0.0 MiB        2617                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.0 MiB      0.0 MiB        2617                   if neighbor not in open_set_hash:
    75    100.0 MiB      0.0 MiB        2617                       count += 1
    76    100.0 MiB      0.0 MiB        2617                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.0 MiB      0.0 MiB        2617                       open_set_hash.add(neighbor)
    78                                                             
    79    100.0 MiB      0.0 MiB        2276           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.0 MiB      0.0 MiB        2276           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.0 MiB    100.0 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.9 MiB  -5203.6 MiB         257       for row in grid:
    30    100.9 MiB -1330372.1 MiB       65792           for spot in row:
    31    100.9 MiB -1325199.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     50.1 MiB    -50.8 MiB           1       count = 0
    34     50.2 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     50.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     50.2 MiB      0.0 MiB           1       came_from = {}
    37     56.1 MiB   -276.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.8 MiB      5.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.9 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.0 MiB      0.0 MiB         522       while not open_set.empty():
    47     62.0 MiB      0.0 MiB         522           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.0 MiB      0.0 MiB         522           current = open_set.get()[2]
    53     62.0 MiB      0.0 MiB         522           open_set_hash.remove(current)
    54                                         
    55     62.0 MiB      0.0 MiB         522           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.0 MiB      0.0 MiB         522           if current == end:
    60     62.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.0 MiB      0.0 MiB        4689           for neighbor in current.neighbors:
    65     62.0 MiB      0.0 MiB        4168               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.0 MiB      0.0 MiB        2084                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.0 MiB      0.0 MiB        2084                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.0 MiB      0.0 MiB        4168               if temp_g_score < g_score[neighbor]:
    71     62.0 MiB      0.1 MiB         650                   came_from[neighbor] = current
    72     62.0 MiB      0.0 MiB         650                   g_score[neighbor] = temp_g_score
    73     62.0 MiB      0.0 MiB         650                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.0 MiB      0.0 MiB         650                   if neighbor not in open_set_hash:
    75     62.0 MiB      0.0 MiB         650                       count += 1
    76     62.0 MiB      0.0 MiB         650                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.0 MiB      0.0 MiB         650                       open_set_hash.add(neighbor)
    78                                                             
    79     62.0 MiB      0.0 MiB         521           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.0 MiB      0.0 MiB         521           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.1 MiB     62.1 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.4 MiB  -1741.0 MiB         257       for row in grid:
    30     63.4 MiB -446265.5 MiB       65792           for spot in row:
    31     63.4 MiB -444527.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     51.4 MiB    -12.0 MiB           1       count = 0
    34     51.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     51.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     51.4 MiB      0.0 MiB           1       came_from = {}
    37     56.4 MiB -28121.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     53.8 MiB     -2.6 MiB           1       g_score[start] = 0
    39     58.8 MiB      5.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     58.9 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     58.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     58.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     58.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.0 MiB      0.0 MiB         296       while not open_set.empty():
    47     59.0 MiB      0.0 MiB         296           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.0 MiB      0.0 MiB         296           current = open_set.get()[2]
    53     59.0 MiB      0.0 MiB         296           open_set_hash.remove(current)
    54                                         
    55     59.0 MiB      0.0 MiB         296           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.0 MiB      0.0 MiB         296           if current == end:
    60     59.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.0 MiB      0.0 MiB        2655           for neighbor in current.neighbors:
    65     59.0 MiB      0.0 MiB        2360               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.0 MiB      0.0 MiB        1180                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.0 MiB      0.0 MiB        1180                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.0 MiB      0.0 MiB        2360               if temp_g_score < g_score[neighbor]:
    71     59.0 MiB      0.1 MiB         598                   came_from[neighbor] = current
    72     59.0 MiB      0.0 MiB         598                   g_score[neighbor] = temp_g_score
    73     59.0 MiB      0.0 MiB         598                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.0 MiB      0.0 MiB         598                   if neighbor not in open_set_hash:
    75     59.0 MiB      0.0 MiB         598                       count += 1
    76     59.0 MiB      0.0 MiB         598                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.0 MiB      0.0 MiB         598                       open_set_hash.add(neighbor)
    78                                                             
    79     59.0 MiB      0.0 MiB         295           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.0 MiB      0.0 MiB         295           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.9 MiB    100.9 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.9 MiB  -1826.7 MiB         257       for row in grid:
    30    100.9 MiB -466056.6 MiB       65792           for spot in row:
    31    100.9 MiB -464244.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     79.0 MiB    -21.9 MiB           1       count = 0
    34     79.0 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     79.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     79.1 MiB      0.0 MiB           1       came_from = {}
    37     81.5 MiB -80101.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     79.4 MiB     -2.1 MiB           1       g_score[start] = 0
    39     86.4 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     86.5 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     86.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     86.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     86.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     86.8 MiB -201031.4 MiB       10500       while not open_set.empty():
    47     86.8 MiB -201031.6 MiB       10500           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     86.8 MiB -201031.8 MiB       10500           current = open_set.get()[2]
    53     86.8 MiB -201031.9 MiB       10500           open_set_hash.remove(current)
    54                                         
    55     86.8 MiB -201032.1 MiB       10500           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     86.8 MiB -201032.3 MiB       10500           if current == end:
    60     56.5 MiB    -30.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     86.8 MiB -1809130.6 MiB       94491           for neighbor in current.neighbors:
    65     86.8 MiB -1608106.1 MiB       83992               if current.row != neighbor.row and current.col != neighbor.col:
    66     86.8 MiB -804086.6 MiB       41996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     86.8 MiB -804026.0 MiB       41996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     86.8 MiB -1608118.7 MiB       83992               if temp_g_score < g_score[neighbor]:
    71     86.8 MiB -209294.6 MiB       11108                   came_from[neighbor] = current
    72     86.8 MiB -209295.5 MiB       11108                   g_score[neighbor] = temp_g_score
    73     86.8 MiB -209296.4 MiB       11108                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     86.8 MiB -209296.9 MiB       11108                   if neighbor not in open_set_hash:
    75     86.8 MiB -209298.4 MiB       11108                       count += 1
    76     86.8 MiB -209291.9 MiB       11108                       open_set.put((f_score[neighbor], count, neighbor))
    77     86.8 MiB -209292.2 MiB       11108                       open_set_hash.add(neighbor)
    78                                                             
    79     86.8 MiB -201031.2 MiB       10499           if draw is not None:
    80                                                     draw()
    81                                         
    82     86.8 MiB -201031.3 MiB       10499           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     57.8 MiB     57.8 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.0 MiB   -507.2 MiB         257       for row in grid:
    30     58.0 MiB -130292.5 MiB       65792           for spot in row:
    31     58.0 MiB -129790.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.1 MiB     -1.9 MiB           1       count = 0
    34     56.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     56.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.1 MiB      0.0 MiB           1       came_from = {}
    37     61.1 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.5 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.6 MiB      0.0 MiB        1036       while not open_set.empty():
    47     65.6 MiB      0.0 MiB        1036           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.6 MiB      0.0 MiB        1036           current = open_set.get()[2]
    53     65.6 MiB      0.0 MiB        1036           open_set_hash.remove(current)
    54                                         
    55     65.6 MiB      0.0 MiB        1036           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.6 MiB      0.0 MiB        1036           if current == end:
    60     65.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.6 MiB      0.0 MiB        9315           for neighbor in current.neighbors:
    65     65.6 MiB      0.0 MiB        8280               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.6 MiB      0.0 MiB        4140                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.6 MiB      0.0 MiB        4140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.6 MiB      0.0 MiB        8280               if temp_g_score < g_score[neighbor]:
    71     65.6 MiB      0.0 MiB        1358                   came_from[neighbor] = current
    72     65.6 MiB      0.0 MiB        1358                   g_score[neighbor] = temp_g_score
    73     65.6 MiB      0.0 MiB        1358                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.6 MiB      0.0 MiB        1358                   if neighbor not in open_set_hash:
    75     65.6 MiB      0.0 MiB        1358                       count += 1
    76     65.6 MiB      0.0 MiB        1358                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.6 MiB      0.0 MiB        1358                       open_set_hash.add(neighbor)
    78                                                             
    79     65.6 MiB      0.0 MiB        1035           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.6 MiB      0.0 MiB        1035           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     65.6 MiB     65.6 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     65.6 MiB     -5.2 MiB         257       for row in grid:
    30     65.6 MiB  -1231.4 MiB       65792           for spot in row:
    31     65.6 MiB  -1226.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     65.1 MiB     -0.6 MiB           1       count = 0
    34     65.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     65.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     65.1 MiB      0.0 MiB           1       came_from = {}
    37     65.7 MiB -38887.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.9 MiB     -2.8 MiB           1       g_score[start] = 0
    39     67.2 MiB  -6496.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.2 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.2 MiB   -121.4 MiB         158       while not open_set.empty():
    47     67.2 MiB   -121.4 MiB         158           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.2 MiB   -121.4 MiB         158           current = open_set.get()[2]
    53     67.2 MiB   -121.4 MiB         158           open_set_hash.remove(current)
    54                                         
    55     67.2 MiB   -121.4 MiB         158           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.2 MiB   -121.4 MiB         158           if current == end:
    60     65.8 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.2 MiB  -1087.0 MiB        1413           for neighbor in current.neighbors:
    65     67.2 MiB   -965.7 MiB        1256               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.2 MiB   -485.6 MiB         628                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.2 MiB   -481.5 MiB         628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.2 MiB   -967.1 MiB        1256               if temp_g_score < g_score[neighbor]:
    71     67.2 MiB   -241.4 MiB         322                   came_from[neighbor] = current
    72     67.2 MiB   -241.4 MiB         322                   g_score[neighbor] = temp_g_score
    73     67.2 MiB   -241.4 MiB         322                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.2 MiB   -241.4 MiB         322                   if neighbor not in open_set_hash:
    75     67.2 MiB   -241.4 MiB         322                       count += 1
    76     67.2 MiB   -241.3 MiB         322                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.2 MiB   -241.3 MiB         322                       open_set_hash.add(neighbor)
    78                                                             
    79     67.2 MiB   -121.4 MiB         157           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.2 MiB   -121.4 MiB         157           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.9 MiB    107.9 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.9 MiB  -1193.4 MiB         257       for row in grid:
    30    107.9 MiB -304891.4 MiB       65792           for spot in row:
    31    107.9 MiB -303703.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.3 MiB    -13.6 MiB           1       count = 0
    34     94.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.3 MiB      0.0 MiB           1       came_from = {}
    37     98.8 MiB -27180.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.2 MiB     -1.6 MiB           1       g_score[start] = 0
    39     98.9 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.0 MiB -631437.3 MiB       14382       while not open_set.empty():
    47     99.0 MiB -631437.8 MiB       14382           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.0 MiB -631438.8 MiB       14382           current = open_set.get()[2]
    53     99.0 MiB -631443.3 MiB       14382           open_set_hash.remove(current)
    54                                         
    55     99.0 MiB -631443.6 MiB       14382           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.0 MiB -631444.3 MiB       14382           if current == end:
    60     51.6 MiB    -47.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     51.7 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.0 MiB -5682778.8 MiB      129429           for neighbor in current.neighbors:
    65     99.0 MiB -5051356.6 MiB      115048               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.0 MiB -2525729.2 MiB       57524                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.0 MiB -2525635.6 MiB       57524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.0 MiB -5051371.9 MiB      115048               if temp_g_score < g_score[neighbor]:
    71     99.0 MiB -650766.1 MiB       15070                   came_from[neighbor] = current
    72     99.0 MiB -650766.8 MiB       15070                   g_score[neighbor] = temp_g_score
    73     99.0 MiB -650770.3 MiB       15070                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.0 MiB -650771.0 MiB       15070                   if neighbor not in open_set_hash:
    75     99.0 MiB -650771.6 MiB       15070                       count += 1
    76     99.0 MiB -650755.8 MiB       15070                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.0 MiB -650756.2 MiB       15070                       open_set_hash.add(neighbor)
    78                                                             
    79     99.0 MiB -631436.1 MiB       14381           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.0 MiB -631436.7 MiB       14381           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     54.7 MiB     54.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     59.5 MiB    -57.1 MiB         257       for row in grid:
    30     59.5 MiB -14718.8 MiB       65792           for spot in row:
    31     59.5 MiB -14657.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.5 MiB      0.0 MiB           1       count = 0
    34     59.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.6 MiB      0.0 MiB           1       came_from = {}
    37     64.5 MiB  -3513.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.8 MiB     -0.8 MiB           1       g_score[start] = 0
    39     68.3 MiB  -7820.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.4 MiB  -5664.2 MiB        6693       while not open_set.empty():
    47     68.4 MiB  -5664.2 MiB        6693           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.4 MiB  -5664.2 MiB        6693           current = open_set.get()[2]
    53     68.4 MiB  -5664.2 MiB        6693           open_set_hash.remove(current)
    54                                         
    55     68.4 MiB  -5664.2 MiB        6693           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.4 MiB  -5664.2 MiB        6693           if current == end:
    60     67.8 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.4 MiB -50977.0 MiB       60228           for neighbor in current.neighbors:
    65     68.4 MiB -45312.8 MiB       53536               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.4 MiB -22656.6 MiB       26768                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.4 MiB -22656.3 MiB       26768                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.4 MiB -45313.5 MiB       53536               if temp_g_score < g_score[neighbor]:
    71     68.4 MiB  -6052.8 MiB        7217                   came_from[neighbor] = current
    72     68.4 MiB  -6052.8 MiB        7217                   g_score[neighbor] = temp_g_score
    73     68.4 MiB  -6052.8 MiB        7217                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.4 MiB  -6052.8 MiB        7217                   if neighbor not in open_set_hash:
    75     68.4 MiB  -6052.8 MiB        7217                       count += 1
    76     68.4 MiB  -6052.8 MiB        7217                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.4 MiB  -6052.7 MiB        7217                       open_set_hash.add(neighbor)
    78                                                             
    79     68.4 MiB  -5664.2 MiB        6692           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.4 MiB  -5664.2 MiB        6692           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.8 MiB     67.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.8 MiB   -393.3 MiB         257       for row in grid:
    30     67.8 MiB -100754.8 MiB       65792           for spot in row:
    31     67.8 MiB -100363.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.7 MiB     -3.0 MiB           1       count = 0
    34     64.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     64.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     64.7 MiB      0.0 MiB           1       came_from = {}
    37     69.7 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.5 MiB -10001.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.5 MiB -11639.8 MiB        2560       while not open_set.empty():
    47     71.5 MiB -11639.8 MiB        2560           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.5 MiB -11639.8 MiB        2560           current = open_set.get()[2]
    53     71.5 MiB -11639.8 MiB        2560           open_set_hash.remove(current)
    54                                         
    55     71.5 MiB -11639.8 MiB        2560           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.5 MiB -11640.0 MiB        2560           if current == end:
    60     65.9 MiB     -5.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.5 MiB -104723.9 MiB       23031           for neighbor in current.neighbors:
    65     71.5 MiB -93085.4 MiB       20472               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.5 MiB -46545.8 MiB       10236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.5 MiB -46540.2 MiB       10236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.5 MiB -93086.6 MiB       20472               if temp_g_score < g_score[neighbor]:
    71     71.5 MiB -13123.3 MiB        2942                   came_from[neighbor] = current
    72     71.5 MiB -13123.4 MiB        2942                   g_score[neighbor] = temp_g_score
    73     71.5 MiB -13123.5 MiB        2942                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.5 MiB -13123.5 MiB        2942                   if neighbor not in open_set_hash:
    75     71.5 MiB -13123.5 MiB        2942                       count += 1
    76     71.5 MiB -13124.4 MiB        2942                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.5 MiB -13124.8 MiB        2942                       open_set_hash.add(neighbor)
    78                                                             
    79     71.5 MiB -11639.8 MiB        2559           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.5 MiB -11639.8 MiB        2559           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.4 MiB    107.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.4 MiB   -176.9 MiB         257       for row in grid:
    30    107.4 MiB -44639.3 MiB       65792           for spot in row:
    31    107.4 MiB -44465.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.2 MiB     -5.2 MiB           1       count = 0
    34    102.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.2 MiB      0.0 MiB           1       came_from = {}
    37    102.8 MiB -75389.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.5 MiB     -2.3 MiB           1       g_score[start] = 0
    39    102.9 MiB -80058.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     95.1 MiB     -7.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     95.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     95.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     95.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.5 MiB -18542.8 MiB         612       while not open_set.empty():
    47     95.5 MiB -18542.9 MiB         612           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.5 MiB -18543.0 MiB         612           current = open_set.get()[2]
    53     95.5 MiB -18543.1 MiB         612           open_set_hash.remove(current)
    54                                         
    55     95.5 MiB -18543.1 MiB         612           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.5 MiB -18543.1 MiB         612           if current == end:
    60     43.6 MiB    -51.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     43.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.5 MiB -166582.9 MiB        5499           for neighbor in current.neighbors:
    65     95.5 MiB -148055.3 MiB        4888               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.5 MiB -74108.3 MiB        2444                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.5 MiB -73961.2 MiB        2444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.5 MiB -148072.9 MiB        4888               if temp_g_score < g_score[neighbor]:
    71     95.5 MiB -22577.5 MiB         782                   came_from[neighbor] = current
    72     95.5 MiB -22577.6 MiB         782                   g_score[neighbor] = temp_g_score
    73     95.5 MiB -22577.4 MiB         782                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.5 MiB -22577.5 MiB         782                   if neighbor not in open_set_hash:
    75     95.5 MiB -22577.6 MiB         782                       count += 1
    76     95.5 MiB -22577.8 MiB         782                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.5 MiB -22577.8 MiB         782                       open_set_hash.add(neighbor)
    78                                                             
    79     95.5 MiB -18541.2 MiB         611           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.5 MiB -18542.8 MiB         611           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     49.9 MiB     49.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     55.5 MiB   -683.2 MiB         257       for row in grid:
    30     55.5 MiB -174359.8 MiB       65792           for spot in row:
    31     55.5 MiB -173681.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     51.1 MiB     -4.4 MiB           1       count = 0
    34     51.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     51.4 MiB      0.1 MiB           1       open_set.put((0, count, start))
    36     51.4 MiB      0.0 MiB           1       came_from = {}
    37     57.1 MiB -17633.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.0 MiB     -0.1 MiB           1       g_score[start] = 0
    39     57.4 MiB -249485.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     55.7 MiB     -1.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     55.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     55.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     55.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     56.2 MiB      0.0 MiB         270       while not open_set.empty():
    47     56.2 MiB      0.0 MiB         270           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     56.2 MiB      0.0 MiB         270           current = open_set.get()[2]
    53     56.2 MiB      0.0 MiB         270           open_set_hash.remove(current)
    54                                         
    55     56.2 MiB      0.0 MiB         270           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     56.2 MiB      0.0 MiB         270           if current == end:
    60     56.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     56.2 MiB      0.0 MiB        2421           for neighbor in current.neighbors:
    65     56.2 MiB      0.1 MiB        2152               if current.row != neighbor.row and current.col != neighbor.col:
    66     56.2 MiB      0.0 MiB        1076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     56.2 MiB      0.0 MiB        1076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     56.2 MiB      0.0 MiB        2152               if temp_g_score < g_score[neighbor]:
    71     56.2 MiB      0.1 MiB         494                   came_from[neighbor] = current
    72     56.2 MiB      0.0 MiB         494                   g_score[neighbor] = temp_g_score
    73     56.2 MiB      0.0 MiB         494                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     56.2 MiB      0.0 MiB         494                   if neighbor not in open_set_hash:
    75     56.2 MiB      0.0 MiB         494                       count += 1
    76     56.2 MiB      0.1 MiB         494                       open_set.put((f_score[neighbor], count, neighbor))
    77     56.2 MiB      0.1 MiB         494                       open_set_hash.add(neighbor)
    78                                                             
    79     56.2 MiB      0.0 MiB         269           if draw is not None:
    80                                                     draw()
    81                                         
    82     56.2 MiB      0.0 MiB         269           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     58.9 MiB     58.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.6 MiB  -3080.4 MiB         257       for row in grid:
    30     61.6 MiB -791136.2 MiB       65792           for spot in row:
    31     61.6 MiB -788050.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     54.9 MiB     -6.7 MiB           1       count = 0
    34     55.2 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     55.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     55.5 MiB      0.0 MiB           1       came_from = {}
    37     62.0 MiB      6.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.3 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.4 MiB      0.0 MiB         164       while not open_set.empty():
    47     66.4 MiB      0.0 MiB         164           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.4 MiB      0.0 MiB         164           current = open_set.get()[2]
    53     66.4 MiB      0.0 MiB         164           open_set_hash.remove(current)
    54                                         
    55     66.4 MiB      0.0 MiB         164           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.4 MiB      0.0 MiB         164           if current == end:
    60     66.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.4 MiB      0.0 MiB        1467           for neighbor in current.neighbors:
    65     66.4 MiB      0.0 MiB        1304               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.4 MiB      0.0 MiB         652                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.4 MiB      0.0 MiB         652                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.4 MiB      0.0 MiB        1304               if temp_g_score < g_score[neighbor]:
    71     66.4 MiB      0.0 MiB         494                   came_from[neighbor] = current
    72     66.4 MiB      0.0 MiB         494                   g_score[neighbor] = temp_g_score
    73     66.4 MiB      0.0 MiB         494                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.4 MiB      0.0 MiB         494                   if neighbor not in open_set_hash:
    75     66.4 MiB      0.0 MiB         494                       count += 1
    76     66.4 MiB      0.0 MiB         494                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.4 MiB      0.1 MiB         494                       open_set_hash.add(neighbor)
    78                                                             
    79     66.4 MiB      0.0 MiB         163           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.4 MiB      0.0 MiB         163           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.0 MiB    107.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.0 MiB   -275.5 MiB         257       for row in grid:
    30    107.0 MiB -69948.4 MiB       65792           for spot in row:
    31    107.0 MiB -69673.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.6 MiB     -4.3 MiB           1       count = 0
    34    102.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.6 MiB      0.0 MiB           1       came_from = {}
    37    103.1 MiB -96752.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.8 MiB     -0.3 MiB           1       g_score[start] = 0
    39    106.6 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.7 MiB   -120.3 MiB        1526       while not open_set.empty():
    47    106.7 MiB   -120.3 MiB        1526           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.7 MiB   -120.3 MiB        1526           current = open_set.get()[2]
    53    106.7 MiB   -120.4 MiB        1526           open_set_hash.remove(current)
    54                                         
    55    106.7 MiB   -120.4 MiB        1526           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.7 MiB   -120.4 MiB        1526           if current == end:
    60    106.2 MiB     -0.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.7 MiB  -1081.8 MiB       13725           for neighbor in current.neighbors:
    65    106.7 MiB   -961.6 MiB       12200               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.7 MiB   -481.0 MiB        6100                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.7 MiB   -480.6 MiB        6100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.7 MiB   -961.7 MiB       12200               if temp_g_score < g_score[neighbor]:
    71    106.7 MiB   -153.7 MiB        1988                   came_from[neighbor] = current
    72    106.7 MiB   -153.8 MiB        1988                   g_score[neighbor] = temp_g_score
    73    106.7 MiB   -153.8 MiB        1988                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.7 MiB   -153.8 MiB        1988                   if neighbor not in open_set_hash:
    75    106.7 MiB   -153.8 MiB        1988                       count += 1
    76    106.7 MiB   -153.8 MiB        1988                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.7 MiB   -153.8 MiB        1988                       open_set_hash.add(neighbor)
    78                                                             
    79    106.7 MiB   -120.3 MiB        1525           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.7 MiB   -120.3 MiB        1525           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB  -4252.9 MiB         257       for row in grid:
    30    106.2 MiB -1090040.6 MiB       65792           for spot in row:
    31    106.2 MiB -1085802.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.9 MiB    -20.4 MiB           1       count = 0
    34     86.2 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     86.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     86.4 MiB      0.0 MiB           1       came_from = {}
    37     90.2 MiB -21217.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.9 MiB     -1.2 MiB           1       g_score[start] = 0
    39     92.0 MiB -348625.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.5 MiB    -21.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.7 MiB      0.0 MiB           6       while not open_set.empty():
    47     70.7 MiB      0.0 MiB           6           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.7 MiB      0.0 MiB           6           current = open_set.get()[2]
    53     70.7 MiB      0.0 MiB           6           open_set_hash.remove(current)
    54                                         
    55     70.7 MiB      0.0 MiB           6           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.7 MiB      0.0 MiB           6           if current == end:
    60     70.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.7 MiB      0.0 MiB          45           for neighbor in current.neighbors:
    65     70.7 MiB      0.0 MiB          40               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.7 MiB      0.0 MiB          20                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.7 MiB      0.0 MiB          20                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.7 MiB      0.0 MiB          40               if temp_g_score < g_score[neighbor]:
    71     70.7 MiB      0.1 MiB          28                   came_from[neighbor] = current
    72     70.7 MiB      0.0 MiB          28                   g_score[neighbor] = temp_g_score
    73     70.7 MiB      0.0 MiB          28                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.7 MiB      0.0 MiB          28                   if neighbor not in open_set_hash:
    75     70.7 MiB      0.0 MiB          28                       count += 1
    76     70.7 MiB      0.0 MiB          28                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.7 MiB      0.0 MiB          28                       open_set_hash.add(neighbor)
    78                                                             
    79     70.7 MiB      0.0 MiB           5           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.7 MiB      0.0 MiB           5           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     71.0 MiB     71.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     73.9 MiB  -2681.7 MiB         257       for row in grid:
    30     73.9 MiB -686443.3 MiB       65792           for spot in row:
    31     73.9 MiB -683771.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.2 MiB    -16.6 MiB           1       count = 0
    34     57.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.3 MiB      0.0 MiB           1       came_from = {}
    37     62.0 MiB      4.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.2 MiB   -415.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.2 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.4 MiB -344849.9 MiB       13113       while not open_set.empty():
    47     66.4 MiB -344850.2 MiB       13113           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.4 MiB -344850.6 MiB       13113           current = open_set.get()[2]
    53     66.4 MiB -344850.8 MiB       13113           open_set_hash.remove(current)
    54                                         
    55     66.4 MiB -344851.1 MiB       13113           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.4 MiB -344851.5 MiB       13113           if current == end:
    60     53.8 MiB    -12.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     54.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.4 MiB -3103622.5 MiB      118008           for neighbor in current.neighbors:
    65     66.4 MiB -2758777.0 MiB      104896               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.4 MiB -1379414.7 MiB       52448                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.4 MiB -1379368.5 MiB       52448                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.4 MiB -2758789.7 MiB      104896               if temp_g_score < g_score[neighbor]:
    71     66.4 MiB -357099.8 MiB       13765                   came_from[neighbor] = current
    72     66.4 MiB -357100.4 MiB       13765                   g_score[neighbor] = temp_g_score
    73     66.4 MiB -357100.8 MiB       13765                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.4 MiB -357102.3 MiB       13765                   if neighbor not in open_set_hash:
    75     66.4 MiB -357103.1 MiB       13765                       count += 1
    76     66.4 MiB -357086.1 MiB       13765                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.4 MiB -357086.7 MiB       13765                       open_set_hash.add(neighbor)
    78                                                             
    79     66.4 MiB -344849.1 MiB       13112           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.4 MiB -344849.6 MiB       13112           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.8 MiB     99.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.8 MiB    -10.6 MiB         257       for row in grid:
    30     99.8 MiB  -2716.6 MiB       65792           for spot in row:
    31     99.8 MiB  -2706.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.8 MiB     -0.0 MiB           1       count = 0
    34     99.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.8 MiB      0.0 MiB           1       came_from = {}
    37    102.3 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.3 MiB      5.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.3 MiB      0.0 MiB        1027       while not open_set.empty():
    47    107.3 MiB      0.0 MiB        1027           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.3 MiB      0.0 MiB        1027           current = open_set.get()[2]
    53    107.3 MiB      0.0 MiB        1027           open_set_hash.remove(current)
    54                                         
    55    107.3 MiB      0.0 MiB        1027           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.3 MiB      0.0 MiB        1027           if current == end:
    60    107.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.3 MiB      0.0 MiB        9234           for neighbor in current.neighbors:
    65    107.3 MiB      0.0 MiB        8208               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.3 MiB      0.0 MiB        4104                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.3 MiB      0.0 MiB        4104                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.3 MiB      0.0 MiB        8208               if temp_g_score < g_score[neighbor]:
    71    107.3 MiB      0.0 MiB        1235                   came_from[neighbor] = current
    72    107.3 MiB      0.0 MiB        1235                   g_score[neighbor] = temp_g_score
    73    107.3 MiB      0.0 MiB        1235                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.3 MiB      0.0 MiB        1235                   if neighbor not in open_set_hash:
    75    107.3 MiB      0.0 MiB        1235                       count += 1
    76    107.3 MiB      0.0 MiB        1235                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.3 MiB      0.0 MiB        1235                       open_set_hash.add(neighbor)
    78                                                             
    79    107.3 MiB      0.0 MiB        1026           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.3 MiB      0.0 MiB        1026           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.3 MiB    107.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.3 MiB    -66.3 MiB         257       for row in grid:
    30    107.3 MiB -16963.0 MiB       65792           for spot in row:
    31    107.3 MiB -16897.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.0 MiB     -0.3 MiB           1       count = 0
    34    107.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.0 MiB      0.0 MiB           1       came_from = {}
    37    108.9 MiB -28746.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.5 MiB     -1.4 MiB           1       g_score[start] = 0
    39    112.3 MiB   -302.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.3 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.3 MiB      0.0 MiB         510       while not open_set.empty():
    47    112.3 MiB      0.0 MiB         510           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.3 MiB      0.0 MiB         510           current = open_set.get()[2]
    53    112.3 MiB      0.0 MiB         510           open_set_hash.remove(current)
    54                                         
    55    112.3 MiB      0.0 MiB         510           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.3 MiB      0.0 MiB         510           if current == end:
    60    112.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.3 MiB      0.0 MiB        4581           for neighbor in current.neighbors:
    65    112.3 MiB      0.0 MiB        4072               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.3 MiB      0.0 MiB        2036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.3 MiB      0.0 MiB        2036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.3 MiB      0.0 MiB        4072               if temp_g_score < g_score[neighbor]:
    71    112.3 MiB      0.0 MiB         702                   came_from[neighbor] = current
    72    112.3 MiB      0.0 MiB         702                   g_score[neighbor] = temp_g_score
    73    112.3 MiB      0.0 MiB         702                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.3 MiB      0.0 MiB         702                   if neighbor not in open_set_hash:
    75    112.3 MiB      0.0 MiB         702                       count += 1
    76    112.3 MiB      0.0 MiB         702                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.3 MiB      0.0 MiB         702                       open_set_hash.add(neighbor)
    78                                                             
    79    112.3 MiB      0.0 MiB         509           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.3 MiB      0.0 MiB         509           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.3 MiB    112.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.3 MiB      0.0 MiB         257       for row in grid:
    30    112.3 MiB      0.0 MiB       65792           for spot in row:
    31    112.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.3 MiB      0.0 MiB           1       count = 0
    34    112.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.3 MiB      0.0 MiB           1       came_from = {}
    37    114.3 MiB   -776.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.2 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.2 MiB     -1.6 MiB         112       while not open_set.empty():
    47    115.2 MiB    -55.4 MiB         112           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.2 MiB    -55.4 MiB         112           current = open_set.get()[2]
    53    115.1 MiB    -55.4 MiB         112           open_set_hash.remove(current)
    54                                         
    55    115.1 MiB    -51.9 MiB         112           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.1 MiB    -51.9 MiB         112           if current == end:
    60    114.7 MiB     -0.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.1 MiB   -423.0 MiB         999           for neighbor in current.neighbors:
    65    115.1 MiB   -413.4 MiB         888               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.9 MiB   -207.1 MiB         444                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.1 MiB   -206.3 MiB         444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.1 MiB   -309.3 MiB         888               if temp_g_score < g_score[neighbor]:
    71    115.1 MiB   -156.1 MiB         338                   came_from[neighbor] = current
    72    115.1 MiB   -156.1 MiB         338                   g_score[neighbor] = temp_g_score
    73    115.1 MiB   -156.1 MiB         338                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.1 MiB   -150.9 MiB         338                   if neighbor not in open_set_hash:
    75    115.1 MiB   -150.9 MiB         338                       count += 1
    76    115.0 MiB   -151.1 MiB         338                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.0 MiB   -130.0 MiB         338                       open_set_hash.add(neighbor)
    78                                                             
    79    114.7 MiB    -51.9 MiB         111           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.7 MiB     -1.6 MiB         111           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.7 MiB    115.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.7 MiB   -572.3 MiB         257       for row in grid:
    30    115.7 MiB -146550.9 MiB       65792           for spot in row:
    31    115.7 MiB -145980.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.7 MiB     -3.0 MiB           1       count = 0
    34    112.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.7 MiB      0.0 MiB           1       came_from = {}
    37    114.8 MiB -22119.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.8 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.8 MiB -10334.0 MiB        3496       while not open_set.empty():
    47    116.8 MiB -10334.0 MiB        3496           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.8 MiB -10334.0 MiB        3496           current = open_set.get()[2]
    53    116.8 MiB -10334.0 MiB        3496           open_set_hash.remove(current)
    54                                         
    55    116.8 MiB -10334.0 MiB        3496           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.8 MiB -10334.0 MiB        3496           if current == end:
    60    113.2 MiB     -3.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.8 MiB -92989.0 MiB       31455           for neighbor in current.neighbors:
    65    116.8 MiB -82655.6 MiB       27960               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.8 MiB -41332.5 MiB       13980                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.8 MiB -41323.6 MiB       13980                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.8 MiB -82656.9 MiB       27960               if temp_g_score < g_score[neighbor]:
    71    116.8 MiB -11235.2 MiB        3890                   came_from[neighbor] = current
    72    116.8 MiB -11235.5 MiB        3890                   g_score[neighbor] = temp_g_score
    73    116.8 MiB -11235.9 MiB        3890                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.8 MiB -11236.0 MiB        3890                   if neighbor not in open_set_hash:
    75    116.8 MiB -11236.1 MiB        3890                       count += 1
    76    116.8 MiB -11236.1 MiB        3890                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.8 MiB -11236.1 MiB        3890                       open_set_hash.add(neighbor)
    78                                                             
    79    116.8 MiB -10334.0 MiB        3495           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.8 MiB -10334.0 MiB        3495           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.2 MiB    113.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.2 MiB   -501.0 MiB         257       for row in grid:
    30    113.2 MiB -128204.1 MiB       65792           for spot in row:
    31    113.2 MiB -127704.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.6 MiB     -2.6 MiB           1       count = 0
    34    110.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.6 MiB      0.0 MiB           1       came_from = {}
    37    114.4 MiB  -1450.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.9 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.0 MiB      0.0 MiB        3712       while not open_set.empty():
    47    117.0 MiB      0.0 MiB        3712           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.0 MiB      0.0 MiB        3712           current = open_set.get()[2]
    53    117.0 MiB      0.0 MiB        3712           open_set_hash.remove(current)
    54                                         
    55    117.0 MiB      0.0 MiB        3712           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.0 MiB      0.0 MiB        3712           if current == end:
    60    117.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    117.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.0 MiB      0.0 MiB       33399           for neighbor in current.neighbors:
    65    117.0 MiB      0.0 MiB       29688               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.0 MiB      0.0 MiB       14844                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.0 MiB      0.0 MiB       14844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.0 MiB      0.0 MiB       29688               if temp_g_score < g_score[neighbor]:
    71    117.0 MiB      0.0 MiB        4082                   came_from[neighbor] = current
    72    117.0 MiB      0.0 MiB        4082                   g_score[neighbor] = temp_g_score
    73    117.0 MiB      0.0 MiB        4082                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.0 MiB      0.0 MiB        4082                   if neighbor not in open_set_hash:
    75    117.0 MiB      0.0 MiB        4082                       count += 1
    76    117.0 MiB      0.0 MiB        4082                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.0 MiB      0.0 MiB        4082                       open_set_hash.add(neighbor)
    78                                                             
    79    117.0 MiB      0.0 MiB        3711           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.0 MiB      0.0 MiB        3711           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    117.0 MiB    117.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    117.0 MiB  -1447.4 MiB         257       for row in grid:
    30    117.0 MiB -370150.2 MiB       65792           for spot in row:
    31    117.0 MiB -368712.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.8 MiB    -13.1 MiB           1       count = 0
    34    103.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.8 MiB      0.0 MiB           1       came_from = {}
    37    106.8 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.3 MiB  -1256.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.3 MiB      0.0 MiB         264       while not open_set.empty():
    47    108.3 MiB      0.0 MiB         264           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.3 MiB      0.0 MiB         264           current = open_set.get()[2]
    53    108.3 MiB      0.0 MiB         264           open_set_hash.remove(current)
    54                                         
    55    108.3 MiB      0.0 MiB         264           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.3 MiB      0.0 MiB         264           if current == end:
    60    108.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.3 MiB      0.0 MiB        2367           for neighbor in current.neighbors:
    65    108.3 MiB      0.0 MiB        2104               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.3 MiB      0.0 MiB        1052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.3 MiB      0.0 MiB        1052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.3 MiB      0.0 MiB        2104               if temp_g_score < g_score[neighbor]:
    71    108.3 MiB      0.0 MiB         360                   came_from[neighbor] = current
    72    108.3 MiB      0.0 MiB         360                   g_score[neighbor] = temp_g_score
    73    108.3 MiB      0.0 MiB         360                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.3 MiB      0.0 MiB         360                   if neighbor not in open_set_hash:
    75    108.3 MiB      0.0 MiB         360                       count += 1
    76    108.3 MiB      0.0 MiB         360                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.3 MiB      0.0 MiB         360                       open_set_hash.add(neighbor)
    78                                                             
    79    108.3 MiB      0.0 MiB         263           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.3 MiB      0.0 MiB         263           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.5 MiB    108.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.5 MiB   -182.8 MiB         257       for row in grid:
    30    108.5 MiB -46829.4 MiB       65792           for spot in row:
    31    108.5 MiB -46647.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.0 MiB     -1.5 MiB           1       count = 0
    34    107.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.0 MiB      0.0 MiB           1       came_from = {}
    37    111.6 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.1 MiB -17558.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.1 MiB   -308.5 MiB        2088       while not open_set.empty():
    47    114.1 MiB   -308.5 MiB        2088           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.1 MiB   -308.5 MiB        2088           current = open_set.get()[2]
    53    114.1 MiB   -308.5 MiB        2088           open_set_hash.remove(current)
    54                                         
    55    114.1 MiB   -308.5 MiB        2088           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.1 MiB   -308.5 MiB        2088           if current == end:
    60    113.9 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.1 MiB  -2775.6 MiB       18783           for neighbor in current.neighbors:
    65    114.1 MiB  -2467.1 MiB       16696               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.1 MiB  -1233.7 MiB        8348                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.1 MiB  -1233.4 MiB        8348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.1 MiB  -2467.1 MiB       16696               if temp_g_score < g_score[neighbor]:
    71    114.1 MiB   -338.6 MiB        2356                   came_from[neighbor] = current
    72    114.1 MiB   -338.6 MiB        2356                   g_score[neighbor] = temp_g_score
    73    114.1 MiB   -338.6 MiB        2356                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.1 MiB   -338.6 MiB        2356                   if neighbor not in open_set_hash:
    75    114.1 MiB   -338.7 MiB        2356                       count += 1
    76    114.1 MiB   -338.7 MiB        2356                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.1 MiB   -338.7 MiB        2356                       open_set_hash.add(neighbor)
    78                                                             
    79    114.1 MiB   -308.5 MiB        2087           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.1 MiB   -308.5 MiB        2087           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.9 MiB    113.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.9 MiB    -65.3 MiB         257       for row in grid:
    30    113.9 MiB -16610.8 MiB       65792           for spot in row:
    31    113.9 MiB -16545.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.1 MiB     -0.7 MiB           1       count = 0
    34    113.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.1 MiB      0.0 MiB           1       came_from = {}
    37    114.7 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.1 MiB  -3114.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.1 MiB  -3023.2 MiB         700       while not open_set.empty():
    47    118.1 MiB  -3023.2 MiB         700           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.1 MiB  -3023.2 MiB         700           current = open_set.get()[2]
    53    118.1 MiB  -3023.2 MiB         700           open_set_hash.remove(current)
    54                                         
    55    118.1 MiB  -3023.2 MiB         700           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.1 MiB  -3023.2 MiB         700           if current == end:
    60    113.6 MiB     -4.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.1 MiB -27192.8 MiB        6291           for neighbor in current.neighbors:
    65    118.1 MiB -24170.3 MiB        5592               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.1 MiB -12087.7 MiB        2796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.1 MiB -12084.6 MiB        2796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.1 MiB -24173.1 MiB        5592               if temp_g_score < g_score[neighbor]:
    71    118.1 MiB  -4237.9 MiB         998                   came_from[neighbor] = current
    72    118.1 MiB  -4237.9 MiB         998                   g_score[neighbor] = temp_g_score
    73    118.1 MiB  -4237.9 MiB         998                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.1 MiB  -4237.9 MiB         998                   if neighbor not in open_set_hash:
    75    118.1 MiB  -4237.9 MiB         998                       count += 1
    76    118.1 MiB  -4237.9 MiB         998                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.1 MiB  -4237.9 MiB         998                       open_set_hash.add(neighbor)
    78                                                             
    79    118.1 MiB  -3023.2 MiB         699           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.1 MiB  -3023.2 MiB         699           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.6 MiB    113.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.6 MiB    -84.4 MiB         257       for row in grid:
    30    113.6 MiB -21597.8 MiB       65792           for spot in row:
    31    113.6 MiB -21513.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.1 MiB     -0.5 MiB           1       count = 0
    34    113.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.1 MiB      0.0 MiB           1       came_from = {}
    37    113.4 MiB -119280.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.0 MiB     -0.5 MiB           1       g_score[start] = 0
    39    116.5 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.5 MiB -24581.2 MiB        7906       while not open_set.empty():
    47    116.5 MiB -24581.2 MiB        7906           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.5 MiB -24581.2 MiB        7906           current = open_set.get()[2]
    53    116.5 MiB -24581.2 MiB        7906           open_set_hash.remove(current)
    54                                         
    55    116.5 MiB -24581.2 MiB        7906           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.5 MiB -24581.2 MiB        7906           if current == end:
    60    109.0 MiB     -7.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.5 MiB -221180.6 MiB       71145           for neighbor in current.neighbors:
    65    116.5 MiB -196600.8 MiB       63240               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.5 MiB -98305.7 MiB       31620                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.5 MiB -98296.2 MiB       31620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.5 MiB -196602.9 MiB       63240               if temp_g_score < g_score[neighbor]:
    71    116.5 MiB -25711.5 MiB        8408                   came_from[neighbor] = current
    72    116.5 MiB -25711.5 MiB        8408                   g_score[neighbor] = temp_g_score
    73    116.5 MiB -25713.2 MiB        8408                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.5 MiB -25713.5 MiB        8408                   if neighbor not in open_set_hash:
    75    116.5 MiB -25714.0 MiB        8408                       count += 1
    76    116.5 MiB -25714.6 MiB        8408                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.5 MiB -25714.8 MiB        8408                       open_set_hash.add(neighbor)
    78                                                             
    79    116.5 MiB -24581.2 MiB        7905           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.5 MiB -24581.2 MiB        7905           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.5 MiB    111.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.5 MiB    -29.4 MiB         257       for row in grid:
    30    111.5 MiB  -6688.8 MiB       65792           for spot in row:
    31    111.5 MiB  -6662.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.9 MiB     -3.7 MiB           1       count = 0
    34    107.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.9 MiB      0.0 MiB           1       came_from = {}
    37    110.6 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.0 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.1 MiB -17507.7 MiB        5610       while not open_set.empty():
    47    113.1 MiB -17507.7 MiB        5610           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.1 MiB -17507.7 MiB        5610           current = open_set.get()[2]
    53    113.1 MiB -17507.8 MiB        5610           open_set_hash.remove(current)
    54                                         
    55    113.1 MiB -17508.0 MiB        5610           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.1 MiB -17508.0 MiB        5610           if current == end:
    60    108.3 MiB     -4.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.1 MiB -157537.8 MiB       50481           for neighbor in current.neighbors:
    65    113.1 MiB -140032.0 MiB       44872               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.1 MiB -70018.9 MiB       22436                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.1 MiB -70013.1 MiB       22436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.1 MiB -140032.1 MiB       44872               if temp_g_score < g_score[neighbor]:
    71    113.1 MiB -19832.3 MiB        6416                   came_from[neighbor] = current
    72    113.1 MiB -19832.4 MiB        6416                   g_score[neighbor] = temp_g_score
    73    113.1 MiB -19832.4 MiB        6416                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.1 MiB -19833.9 MiB        6416                   if neighbor not in open_set_hash:
    75    113.1 MiB -19833.9 MiB        6416                       count += 1
    76    113.1 MiB -19833.9 MiB        6416                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.1 MiB -19833.9 MiB        6416                       open_set_hash.add(neighbor)
    78                                                             
    79    113.1 MiB -17507.5 MiB        5609           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.1 MiB -17507.6 MiB        5609           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.3 MiB    108.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.3 MiB     -5.8 MiB         257       for row in grid:
    30    108.3 MiB  -1472.8 MiB       65792           for spot in row:
    31    108.3 MiB  -1467.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.3 MiB     -0.0 MiB           1       count = 0
    34    108.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.3 MiB      0.0 MiB           1       came_from = {}
    37    109.7 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.7 MiB -87128.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.5 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.5 MiB      0.0 MiB        1212       while not open_set.empty():
    47    110.5 MiB      0.0 MiB        1212           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.5 MiB      0.0 MiB        1212           current = open_set.get()[2]
    53    110.5 MiB      0.0 MiB        1212           open_set_hash.remove(current)
    54                                         
    55    110.5 MiB      0.0 MiB        1212           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.5 MiB      0.0 MiB        1212           if current == end:
    60    110.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.5 MiB      0.0 MiB       10899           for neighbor in current.neighbors:
    65    110.5 MiB      0.0 MiB        9688               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.5 MiB      0.0 MiB        4844                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.5 MiB      0.0 MiB        4844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.5 MiB      0.0 MiB        9688               if temp_g_score < g_score[neighbor]:
    71    110.5 MiB      0.0 MiB        2030                   came_from[neighbor] = current
    72    110.5 MiB      0.0 MiB        2030                   g_score[neighbor] = temp_g_score
    73    110.5 MiB      0.0 MiB        2030                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.5 MiB      0.0 MiB        2030                   if neighbor not in open_set_hash:
    75    110.5 MiB      0.0 MiB        2030                       count += 1
    76    110.5 MiB      0.0 MiB        2030                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.5 MiB      0.0 MiB        2030                       open_set_hash.add(neighbor)
    78                                                             
    79    110.5 MiB      0.0 MiB        1211           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.5 MiB      0.0 MiB        1211           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.5 MiB    110.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.5 MiB    -52.8 MiB         257       for row in grid:
    30    110.5 MiB -13462.9 MiB       65792           for spot in row:
    31    110.5 MiB -13411.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.2 MiB     -1.3 MiB           1       count = 0
    34    109.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.2 MiB      0.0 MiB           1       came_from = {}
    37    110.9 MiB  -3463.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.7 MiB     -0.2 MiB           1       g_score[start] = 0
    39    111.0 MiB -199775.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.4 MiB     -1.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.4 MiB  -6250.1 MiB        1410       while not open_set.empty():
    47    109.4 MiB -17324.2 MiB        1410           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.4 MiB -17327.4 MiB        1410           current = open_set.get()[2]
    53    109.4 MiB -17305.4 MiB        1410           open_set_hash.remove(current)
    54                                         
    55    109.4 MiB -17305.4 MiB        1410           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.3 MiB -17305.4 MiB        1410           if current == end:
    60     97.5 MiB    -11.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.0 MiB -144348.9 MiB       12681           for neighbor in current.neighbors:
    65    108.8 MiB -133983.8 MiB       11272               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.5 MiB -65767.7 MiB        5636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.7 MiB -65750.9 MiB        5636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.5 MiB -90482.1 MiB       11272               if temp_g_score < g_score[neighbor]:
    71    108.5 MiB -18770.6 MiB        1656                   came_from[neighbor] = current
    72    108.2 MiB -18745.3 MiB        1656                   g_score[neighbor] = temp_g_score
    73    107.9 MiB -18280.5 MiB        1656                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.9 MiB -17841.0 MiB        1656                   if neighbor not in open_set_hash:
    75    107.9 MiB -17841.4 MiB        1656                       count += 1
    76    107.6 MiB -17713.1 MiB        1656                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.5 MiB -17299.5 MiB        1656                       open_set_hash.add(neighbor)
    78                                                             
    79    101.5 MiB -16750.8 MiB        1409           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.5 MiB  -6249.7 MiB        1409           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.7 MiB    107.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.7 MiB  -1433.6 MiB         257       for row in grid:
    30    107.7 MiB -367114.1 MiB       65792           for spot in row:
    31    107.7 MiB -365689.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.8 MiB    -11.8 MiB           1       count = 0
    34     95.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.8 MiB      0.0 MiB           1       came_from = {}
    37    100.3 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.5 MiB   -136.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.1 MiB     -0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.3 MiB    -99.9 MiB         591       while not open_set.empty():
    47    103.3 MiB    -99.9 MiB         591           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.3 MiB   -100.1 MiB         591           current = open_set.get()[2]
    53    103.3 MiB   -100.1 MiB         591           open_set_hash.remove(current)
    54                                         
    55    103.3 MiB   -100.1 MiB         591           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.3 MiB   -100.1 MiB         591           if current == end:
    60    102.6 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.3 MiB   -897.8 MiB        5310           for neighbor in current.neighbors:
    65    103.3 MiB   -798.1 MiB        4720               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.3 MiB   -399.5 MiB        2360                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.3 MiB   -398.6 MiB        2360                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.3 MiB   -798.2 MiB        4720               if temp_g_score < g_score[neighbor]:
    71    103.3 MiB   -166.0 MiB         995                   came_from[neighbor] = current
    72    103.3 MiB   -166.0 MiB         995                   g_score[neighbor] = temp_g_score
    73    103.3 MiB   -166.0 MiB         995                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.3 MiB   -166.0 MiB         995                   if neighbor not in open_set_hash:
    75    103.3 MiB   -166.0 MiB         995                       count += 1
    76    103.3 MiB   -166.0 MiB         995                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.3 MiB   -166.0 MiB         995                       open_set_hash.add(neighbor)
    78                                                             
    79    103.3 MiB    -99.9 MiB         590           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.3 MiB    -99.9 MiB         590           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.6 MiB    102.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.0 MiB     -2.9 MiB         257       for row in grid:
    30    103.0 MiB   -732.7 MiB       65792           for spot in row:
    31    103.0 MiB   -729.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.9 MiB     -0.1 MiB           1       count = 0
    34    102.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.9 MiB      0.0 MiB           1       came_from = {}
    37    104.8 MiB  -3660.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.6 MiB     -0.2 MiB           1       g_score[start] = 0
    39    105.5 MiB -24522.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.1 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.1 MiB      0.0 MiB         230       while not open_set.empty():
    47    105.1 MiB      0.0 MiB         230           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.1 MiB      0.0 MiB         230           current = open_set.get()[2]
    53    105.1 MiB      0.0 MiB         230           open_set_hash.remove(current)
    54                                         
    55    105.1 MiB      0.0 MiB         230           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.1 MiB      0.0 MiB         230           if current == end:
    60    105.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.1 MiB      0.0 MiB        2061           for neighbor in current.neighbors:
    65    105.1 MiB      0.0 MiB        1832               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.1 MiB      0.0 MiB         916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.1 MiB      0.0 MiB         916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.1 MiB      0.0 MiB        1832               if temp_g_score < g_score[neighbor]:
    71    105.1 MiB      0.0 MiB         340                   came_from[neighbor] = current
    72    105.1 MiB      0.0 MiB         340                   g_score[neighbor] = temp_g_score
    73    105.1 MiB      0.0 MiB         340                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.1 MiB      0.0 MiB         340                   if neighbor not in open_set_hash:
    75    105.1 MiB      0.0 MiB         340                       count += 1
    76    105.1 MiB      0.0 MiB         340                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.1 MiB      0.0 MiB         340                       open_set_hash.add(neighbor)
    78                                                             
    79    105.1 MiB      0.0 MiB         229           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.1 MiB      0.0 MiB         229           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.1 MiB    105.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.1 MiB   -330.4 MiB         257       for row in grid:
    30    105.1 MiB -84506.2 MiB       65792           for spot in row:
    31    105.1 MiB -84177.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.0 MiB     -2.0 MiB           1       count = 0
    34    103.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.0 MiB      0.0 MiB           1       came_from = {}
    37    105.9 MiB    -60.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.5 MiB -52878.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.5 MiB -23964.5 MiB        4158       while not open_set.empty():
    47    106.5 MiB -23964.5 MiB        4158           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.5 MiB -23964.5 MiB        4158           current = open_set.get()[2]
    53    106.5 MiB -23964.5 MiB        4158           open_set_hash.remove(current)
    54                                         
    55    106.5 MiB -23964.5 MiB        4158           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.5 MiB -23964.5 MiB        4158           if current == end:
    60     97.0 MiB     -9.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.5 MiB -215632.8 MiB       37413           for neighbor in current.neighbors:
    65    106.5 MiB -191670.1 MiB       33256               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.5 MiB -95846.6 MiB       16628                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.5 MiB -95824.2 MiB       16628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.5 MiB -191672.5 MiB       33256               if temp_g_score < g_score[neighbor]:
    71    106.5 MiB -25630.5 MiB        4522                   came_from[neighbor] = current
    72    106.5 MiB -25632.0 MiB        4522                   g_score[neighbor] = temp_g_score
    73    106.5 MiB -25632.4 MiB        4522                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.5 MiB -25632.6 MiB        4522                   if neighbor not in open_set_hash:
    75    106.5 MiB -25632.8 MiB        4522                       count += 1
    76    106.5 MiB -25633.0 MiB        4522                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.5 MiB -25633.0 MiB        4522                       open_set_hash.add(neighbor)
    78                                                             
    79    106.5 MiB -23964.5 MiB        4157           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.5 MiB -23964.5 MiB        4157           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.1 MiB    108.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.1 MiB   -512.2 MiB         257       for row in grid:
    30    108.1 MiB -131445.2 MiB       65792           for spot in row:
    31    108.1 MiB -130934.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.8 MiB     -2.3 MiB           1       count = 0
    34    105.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.8 MiB      0.0 MiB           1       came_from = {}
    37    110.0 MiB   -242.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.3 MiB   -331.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.3 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.4 MiB  -5710.4 MiB        3171       while not open_set.empty():
    47    113.4 MiB  -5710.8 MiB        3171           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.4 MiB  -5712.5 MiB        3171           current = open_set.get()[2]
    53    113.4 MiB  -5713.2 MiB        3171           open_set_hash.remove(current)
    54                                         
    55    113.4 MiB  -5713.8 MiB        3171           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.4 MiB  -5714.2 MiB        3171           if current == end:
    60     88.4 MiB    -25.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     88.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.4 MiB -51282.7 MiB       28530           for neighbor in current.neighbors:
    65    113.4 MiB -45577.4 MiB       25360               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.4 MiB -22813.9 MiB       12680                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.4 MiB -22766.3 MiB       12680                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.4 MiB -45586.9 MiB       25360               if temp_g_score < g_score[neighbor]:
    71    113.4 MiB  -6663.9 MiB        3555                   came_from[neighbor] = current
    72    113.4 MiB  -6664.3 MiB        3555                   g_score[neighbor] = temp_g_score
    73    113.4 MiB  -6664.5 MiB        3555                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.4 MiB  -6664.8 MiB        3555                   if neighbor not in open_set_hash:
    75    113.4 MiB  -6665.0 MiB        3555                       count += 1
    76    113.4 MiB  -6665.3 MiB        3555                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.4 MiB  -6665.4 MiB        3555                       open_set_hash.add(neighbor)
    78                                                             
    79    113.4 MiB  -5710.1 MiB        3170           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.4 MiB  -5710.2 MiB        3170           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.6 MiB     89.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     89.7 MiB  -1697.1 MiB         257       for row in grid:
    30     89.7 MiB -434988.8 MiB       65792           for spot in row:
    31     89.7 MiB -433303.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     75.6 MiB    -14.0 MiB           1       count = 0
    34     75.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.6 MiB      0.0 MiB           1       came_from = {}
    37     78.4 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     78.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     82.5 MiB      4.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     82.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     82.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     82.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     82.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     82.6 MiB  -1685.6 MiB        3024       while not open_set.empty():
    47     82.6 MiB  -1685.6 MiB        3024           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     82.6 MiB  -1685.6 MiB        3024           current = open_set.get()[2]
    53     82.6 MiB  -1685.6 MiB        3024           open_set_hash.remove(current)
    54                                         
    55     82.6 MiB  -1685.6 MiB        3024           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     82.6 MiB  -1685.6 MiB        3024           if current == end:
    60     80.7 MiB     -1.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     80.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     82.6 MiB -15167.0 MiB       27207           for neighbor in current.neighbors:
    65     82.6 MiB -13481.3 MiB       24184               if current.row != neighbor.row and current.col != neighbor.col:
    66     82.6 MiB  -6742.6 MiB       12092                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     82.6 MiB  -6738.8 MiB       12092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     82.6 MiB -13481.3 MiB       24184               if temp_g_score < g_score[neighbor]:
    71     82.6 MiB  -1878.7 MiB        3394                   came_from[neighbor] = current
    72     82.6 MiB  -1878.8 MiB        3394                   g_score[neighbor] = temp_g_score
    73     82.6 MiB  -1878.8 MiB        3394                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     82.6 MiB  -1878.8 MiB        3394                   if neighbor not in open_set_hash:
    75     82.6 MiB  -1878.8 MiB        3394                       count += 1
    76     82.6 MiB  -1879.1 MiB        3394                       open_set.put((f_score[neighbor], count, neighbor))
    77     82.6 MiB  -1879.6 MiB        3394                       open_set_hash.add(neighbor)
    78                                                             
    79     82.6 MiB  -1685.6 MiB        3023           if draw is not None:
    80                                                     draw()
    81                                         
    82     82.6 MiB  -1685.6 MiB        3023           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     80.7 MiB     80.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     80.7 MiB   -136.9 MiB         257       for row in grid:
    30     80.7 MiB -33790.5 MiB       65792           for spot in row:
    31     80.7 MiB -33659.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.8 MiB     -8.9 MiB           1       count = 0
    34     71.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.8 MiB      0.0 MiB           1       came_from = {}
    37     73.4 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     77.0 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     77.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     77.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     77.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     77.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     77.0 MiB      0.0 MiB        1155       while not open_set.empty():
    47     77.0 MiB      0.0 MiB        1155           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     77.0 MiB      0.0 MiB        1155           current = open_set.get()[2]
    53     77.0 MiB      0.0 MiB        1155           open_set_hash.remove(current)
    54                                         
    55     77.0 MiB      0.0 MiB        1155           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     77.0 MiB      0.0 MiB        1155           if current == end:
    60     77.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     77.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     77.0 MiB      0.0 MiB       10386           for neighbor in current.neighbors:
    65     77.0 MiB      0.0 MiB        9232               if current.row != neighbor.row and current.col != neighbor.col:
    66     77.0 MiB      0.0 MiB        4616                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     77.0 MiB      0.0 MiB        4616                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     77.0 MiB      0.0 MiB        9232               if temp_g_score < g_score[neighbor]:
    71     77.0 MiB      0.0 MiB        1595                   came_from[neighbor] = current
    72     77.0 MiB      0.0 MiB        1595                   g_score[neighbor] = temp_g_score
    73     77.0 MiB      0.0 MiB        1595                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     77.0 MiB      0.0 MiB        1595                   if neighbor not in open_set_hash:
    75     77.0 MiB      0.0 MiB        1595                       count += 1
    76     77.0 MiB      0.0 MiB        1595                       open_set.put((f_score[neighbor], count, neighbor))
    77     77.0 MiB      0.0 MiB        1595                       open_set_hash.add(neighbor)
    78                                                             
    79     77.0 MiB      0.0 MiB        1154           if draw is not None:
    80                                                     draw()
    81                                         
    82     77.0 MiB      0.0 MiB        1154           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.7 MiB    109.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.7 MiB    -98.9 MiB         257       for row in grid:
    30    109.7 MiB -25378.9 MiB       65792           for spot in row:
    31    109.7 MiB -25280.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.1 MiB     -0.6 MiB           1       count = 0
    34    109.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.1 MiB      0.0 MiB           1       came_from = {}
    37    110.4 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.1 MiB      2.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.1 MiB  -1279.9 MiB        7980       while not open_set.empty():
    47    113.1 MiB  -1279.9 MiB        7980           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.1 MiB  -1279.9 MiB        7980           current = open_set.get()[2]
    53    113.1 MiB  -1279.9 MiB        7980           open_set_hash.remove(current)
    54                                         
    55    113.1 MiB  -1279.9 MiB        7980           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.1 MiB  -1279.9 MiB        7980           if current == end:
    60    113.0 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.1 MiB -11517.0 MiB       71811           for neighbor in current.neighbors:
    65    113.1 MiB -10237.3 MiB       63832               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.1 MiB  -5118.4 MiB       31916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.1 MiB  -5118.9 MiB       31916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.1 MiB -10237.3 MiB       63832               if temp_g_score < g_score[neighbor]:
    71    113.1 MiB  -1332.8 MiB        8486                   came_from[neighbor] = current
    72    113.1 MiB  -1332.8 MiB        8486                   g_score[neighbor] = temp_g_score
    73    113.1 MiB  -1332.8 MiB        8486                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.1 MiB  -1332.8 MiB        8486                   if neighbor not in open_set_hash:
    75    113.1 MiB  -1332.8 MiB        8486                       count += 1
    76    113.1 MiB  -1332.8 MiB        8486                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.1 MiB  -1332.8 MiB        8486                       open_set_hash.add(neighbor)
    78                                                             
    79    113.1 MiB  -1279.8 MiB        7979           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.1 MiB  -1279.9 MiB        7979           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.0 MiB    113.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.0 MiB    -15.9 MiB         257       for row in grid:
    30    113.0 MiB  -3833.7 MiB       65792           for spot in row:
    31    113.0 MiB  -3819.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.4 MiB     -1.6 MiB           1       count = 0
    34    111.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.4 MiB      0.0 MiB           1       came_from = {}
    37    112.0 MiB -240277.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.0 MiB     -5.0 MiB           1       g_score[start] = 0
    39    110.3 MiB  -6122.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.3 MiB  -4944.7 MiB        1547       while not open_set.empty():
    47    110.3 MiB  -4944.7 MiB        1547           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.3 MiB  -4944.9 MiB        1547           current = open_set.get()[2]
    53    110.3 MiB  -4945.1 MiB        1547           open_set_hash.remove(current)
    54                                         
    55    110.3 MiB  -4945.2 MiB        1547           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.3 MiB  -4945.2 MiB        1547           if current == end:
    60    105.8 MiB     -4.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.3 MiB -44482.0 MiB       13914           for neighbor in current.neighbors:
    65    110.3 MiB -39537.9 MiB       12368               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.3 MiB -19774.0 MiB        6184                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.3 MiB -19764.5 MiB        6184                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.3 MiB -39539.1 MiB       12368               if temp_g_score < g_score[neighbor]:
    71    110.3 MiB  -5584.1 MiB        1795                   came_from[neighbor] = current
    72    110.3 MiB  -5584.4 MiB        1795                   g_score[neighbor] = temp_g_score
    73    110.3 MiB  -5584.8 MiB        1795                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.3 MiB  -5584.9 MiB        1795                   if neighbor not in open_set_hash:
    75    110.3 MiB  -5584.9 MiB        1795                       count += 1
    76    110.3 MiB  -5585.1 MiB        1795                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.3 MiB  -5585.4 MiB        1795                       open_set_hash.add(neighbor)
    78                                                             
    79    110.3 MiB  -4944.7 MiB        1546           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.3 MiB  -4944.7 MiB        1546           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.8 MiB    105.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.8 MiB   -452.4 MiB         257       for row in grid:
    30    105.8 MiB -115585.6 MiB       65792           for spot in row:
    31    105.8 MiB -115138.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.7 MiB     -7.1 MiB           1       count = 0
    34     98.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.7 MiB      0.0 MiB           1       came_from = {}
    37     99.8 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.2 MiB -111242.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     95.4 MiB     -4.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     95.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     95.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     95.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.5 MiB  -1383.7 MiB         410       while not open_set.empty():
    47     95.5 MiB  -1384.5 MiB         410           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.5 MiB  -1385.7 MiB         410           current = open_set.get()[2]
    53     95.5 MiB  -1386.3 MiB         410           open_set_hash.remove(current)
    54                                         
    55     95.5 MiB  -1386.9 MiB         410           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.5 MiB  -1387.5 MiB         410           if current == end:
    60     63.7 MiB    -31.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.5 MiB -12312.4 MiB        3681           for neighbor in current.neighbors:
    65     95.5 MiB -10934.9 MiB        3272               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.5 MiB  -5494.6 MiB        1636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.5 MiB  -5444.7 MiB        1636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.5 MiB -10943.0 MiB        3272               if temp_g_score < g_score[neighbor]:
    71     95.5 MiB  -1982.3 MiB         592                   came_from[neighbor] = current
    72     95.5 MiB  -1983.1 MiB         592                   g_score[neighbor] = temp_g_score
    73     95.5 MiB  -1984.4 MiB         592                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.5 MiB  -1985.3 MiB         592                   if neighbor not in open_set_hash:
    75     95.5 MiB  -1986.9 MiB         592                       count += 1
    76     95.5 MiB  -1988.8 MiB         592                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.5 MiB  -1989.9 MiB         592                       open_set_hash.add(neighbor)
    78                                                             
    79     95.5 MiB  -1382.3 MiB         409           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.5 MiB  -1382.9 MiB         409           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.7 MiB    105.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.7 MiB    -49.4 MiB         257       for row in grid:
    30    105.7 MiB -12649.1 MiB       65792           for spot in row:
    31    105.7 MiB -12599.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.5 MiB     -0.2 MiB           1       count = 0
    34    105.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.5 MiB      0.0 MiB           1       came_from = {}
    37    110.2 MiB    -47.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.5 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.5 MiB -30966.2 MiB        7614       while not open_set.empty():
    47    113.5 MiB -30966.2 MiB        7614           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.5 MiB -30966.4 MiB        7614           current = open_set.get()[2]
    53    113.5 MiB -30966.5 MiB        7614           open_set_hash.remove(current)
    54                                         
    55    113.5 MiB -30966.5 MiB        7614           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.5 MiB -30966.5 MiB        7614           if current == end:
    60    103.6 MiB    -10.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.5 MiB -278635.0 MiB       68517           for neighbor in current.neighbors:
    65    113.5 MiB -247669.8 MiB       60904               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.5 MiB -123847.0 MiB       30452                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.5 MiB -123827.2 MiB       30452                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.5 MiB -247675.7 MiB       60904               if temp_g_score < g_score[neighbor]:
    71    113.5 MiB -33584.4 MiB        8354                   came_from[neighbor] = current
    72    113.5 MiB -33584.4 MiB        8354                   g_score[neighbor] = temp_g_score
    73    113.5 MiB -33585.0 MiB        8354                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.5 MiB -33585.6 MiB        8354                   if neighbor not in open_set_hash:
    75    113.5 MiB -33586.1 MiB        8354                       count += 1
    76    113.5 MiB -33586.0 MiB        8354                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.5 MiB -33586.1 MiB        8354                       open_set_hash.add(neighbor)
    78                                                             
    79    113.5 MiB -30966.0 MiB        7613           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.5 MiB -30966.1 MiB        7613           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.7 MiB    103.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.7 MiB   -421.5 MiB         257       for row in grid:
    30    103.7 MiB -107924.4 MiB       65792           for spot in row:
    31    103.7 MiB -107504.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.0 MiB     -1.7 MiB           1       count = 0
    34    102.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.0 MiB      0.0 MiB           1       came_from = {}
    37    104.6 MiB -34169.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.1 MiB     -3.5 MiB           1       g_score[start] = 0
    39    105.5 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.5 MiB      0.0 MiB         728       while not open_set.empty():
    47    105.5 MiB      0.0 MiB         728           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.5 MiB      0.0 MiB         728           current = open_set.get()[2]
    53    105.5 MiB      0.0 MiB         728           open_set_hash.remove(current)
    54                                         
    55    105.5 MiB      0.0 MiB         728           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.5 MiB      0.0 MiB         728           if current == end:
    60    105.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.5 MiB      0.0 MiB        6543           for neighbor in current.neighbors:
    65    105.5 MiB      0.0 MiB        5816               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.5 MiB      0.0 MiB        2908                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.5 MiB      0.0 MiB        2908                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.5 MiB      0.0 MiB        5816               if temp_g_score < g_score[neighbor]:
    71    105.5 MiB      0.0 MiB         962                   came_from[neighbor] = current
    72    105.5 MiB      0.0 MiB         962                   g_score[neighbor] = temp_g_score
    73    105.5 MiB      0.0 MiB         962                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.5 MiB      0.0 MiB         962                   if neighbor not in open_set_hash:
    75    105.5 MiB      0.0 MiB         962                       count += 1
    76    105.5 MiB      0.0 MiB         962                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.5 MiB      0.0 MiB         962                       open_set_hash.add(neighbor)
    78                                                             
    79    105.5 MiB      0.0 MiB         727           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.5 MiB      0.0 MiB         727           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.5 MiB    105.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.5 MiB   -111.9 MiB         257       for row in grid:
    30    105.5 MiB -28653.7 MiB       65792           for spot in row:
    31    105.5 MiB -28542.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.0 MiB     -0.5 MiB           1       count = 0
    34    105.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.0 MiB      0.0 MiB           1       came_from = {}
    37    106.4 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.2 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.2 MiB      0.0 MiB         585       while not open_set.empty():
    47    109.2 MiB      0.0 MiB         585           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.2 MiB      0.0 MiB         585           current = open_set.get()[2]
    53    109.2 MiB      0.0 MiB         585           open_set_hash.remove(current)
    54                                         
    55    109.2 MiB      0.0 MiB         585           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.2 MiB      0.0 MiB         585           if current == end:
    60    109.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.2 MiB      0.0 MiB        5256           for neighbor in current.neighbors:
    65    109.2 MiB      0.0 MiB        4672               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.2 MiB      0.0 MiB        2336                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.2 MiB      0.0 MiB        2336                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.2 MiB      0.0 MiB        4672               if temp_g_score < g_score[neighbor]:
    71    109.2 MiB      0.0 MiB         769                   came_from[neighbor] = current
    72    109.2 MiB      0.0 MiB         769                   g_score[neighbor] = temp_g_score
    73    109.2 MiB      0.0 MiB         769                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.2 MiB      0.0 MiB         769                   if neighbor not in open_set_hash:
    75    109.2 MiB      0.0 MiB         769                       count += 1
    76    109.2 MiB      0.0 MiB         769                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.2 MiB      0.0 MiB         769                       open_set_hash.add(neighbor)
    78                                                             
    79    109.2 MiB      0.0 MiB         584           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.2 MiB      0.0 MiB         584           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    117.1 MiB    117.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    117.1 MiB   -808.6 MiB         257       for row in grid:
    30    117.1 MiB -207421.1 MiB       65792           for spot in row:
    31    117.1 MiB -206616.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.4 MiB     -4.7 MiB           1       count = 0
    34    112.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.4 MiB      0.0 MiB           1       came_from = {}
    37    115.5 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.9 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.9 MiB      0.0 MiB        1056       while not open_set.empty():
    47    118.9 MiB      0.0 MiB        1056           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.9 MiB      0.0 MiB        1056           current = open_set.get()[2]
    53    118.9 MiB      0.0 MiB        1056           open_set_hash.remove(current)
    54                                         
    55    118.9 MiB      0.0 MiB        1056           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.9 MiB      0.0 MiB        1056           if current == end:
    60    118.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    118.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.9 MiB      0.0 MiB        9495           for neighbor in current.neighbors:
    65    118.9 MiB      0.0 MiB        8440               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.9 MiB      0.0 MiB        4220                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.9 MiB      0.0 MiB        4220                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.9 MiB      0.0 MiB        8440               if temp_g_score < g_score[neighbor]:
    71    118.9 MiB      0.0 MiB        1278                   came_from[neighbor] = current
    72    118.9 MiB      0.0 MiB        1278                   g_score[neighbor] = temp_g_score
    73    118.9 MiB      0.0 MiB        1278                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.9 MiB      0.0 MiB        1278                   if neighbor not in open_set_hash:
    75    118.9 MiB      0.0 MiB        1278                       count += 1
    76    118.9 MiB      0.0 MiB        1278                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.9 MiB      0.0 MiB        1278                       open_set_hash.add(neighbor)
    78                                                             
    79    118.9 MiB      0.0 MiB        1055           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.9 MiB      0.0 MiB        1055           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.9 MiB    118.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.9 MiB   -180.2 MiB         257       for row in grid:
    30    118.9 MiB -46179.4 MiB       65792           for spot in row:
    31    118.9 MiB -45999.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    118.0 MiB     -0.9 MiB           1       count = 0
    34    118.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    118.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    118.0 MiB      0.0 MiB           1       came_from = {}
    37    118.0 MiB -238027.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.0 MiB     -4.1 MiB           1       g_score[start] = 0
    39    117.0 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.1 MiB      0.0 MiB        4698       while not open_set.empty():
    47    117.1 MiB      0.0 MiB        4698           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.1 MiB      0.0 MiB        4698           current = open_set.get()[2]
    53    117.1 MiB      0.0 MiB        4698           open_set_hash.remove(current)
    54                                         
    55    117.1 MiB      0.0 MiB        4698           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.1 MiB      0.0 MiB        4698           if current == end:
    60    117.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    117.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.1 MiB      0.0 MiB       42273           for neighbor in current.neighbors:
    65    117.1 MiB      0.0 MiB       37576               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.1 MiB      0.0 MiB       18788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.1 MiB      0.0 MiB       18788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.1 MiB      0.0 MiB       37576               if temp_g_score < g_score[neighbor]:
    71    117.1 MiB      0.1 MiB        5086                   came_from[neighbor] = current
    72    117.1 MiB      0.0 MiB        5086                   g_score[neighbor] = temp_g_score
    73    117.1 MiB      0.0 MiB        5086                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.1 MiB      0.0 MiB        5086                   if neighbor not in open_set_hash:
    75    117.1 MiB      0.0 MiB        5086                       count += 1
    76    117.1 MiB      0.0 MiB        5086                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.1 MiB      0.0 MiB        5086                       open_set_hash.add(neighbor)
    78                                                             
    79    117.1 MiB      0.0 MiB        4697           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.1 MiB      0.0 MiB        4697           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    117.1 MiB    117.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    117.1 MiB   -251.7 MiB         257       for row in grid:
    30    117.1 MiB -64056.4 MiB       65792           for spot in row:
    31    117.1 MiB -63806.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.2 MiB     -5.9 MiB           1       count = 0
    34    111.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.2 MiB      0.0 MiB           1       came_from = {}
    37    113.4 MiB   -733.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.9 MiB     -2.5 MiB           1       g_score[start] = 0
    39    115.0 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.2 MiB -22136.7 MiB        5152       while not open_set.empty():
    47    115.2 MiB -22136.7 MiB        5152           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.2 MiB -22136.7 MiB        5152           current = open_set.get()[2]
    53    115.2 MiB -22136.7 MiB        5152           open_set_hash.remove(current)
    54                                         
    55    115.2 MiB -22136.7 MiB        5152           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.2 MiB -22136.7 MiB        5152           if current == end:
    60     92.0 MiB    -23.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.2 MiB -199098.3 MiB       46359           for neighbor in current.neighbors:
    65    115.2 MiB -176975.8 MiB       41208               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.2 MiB -88524.4 MiB       20604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.2 MiB -88453.9 MiB       20604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.2 MiB -176978.7 MiB       41208               if temp_g_score < g_score[neighbor]:
    71    115.2 MiB -24177.6 MiB        5600                   came_from[neighbor] = current
    72    115.2 MiB -24177.7 MiB        5600                   g_score[neighbor] = temp_g_score
    73    115.2 MiB -24177.7 MiB        5600                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.2 MiB -24177.7 MiB        5600                   if neighbor not in open_set_hash:
    75    115.2 MiB -24177.7 MiB        5600                       count += 1
    76    115.2 MiB -24177.9 MiB        5600                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.2 MiB -24178.0 MiB        5600                       open_set_hash.add(neighbor)
    78                                                             
    79    115.2 MiB -22136.3 MiB        5151           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.2 MiB -22136.7 MiB        5151           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.9 MiB    112.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.9 MiB  -2037.8 MiB         257       for row in grid:
    30    112.9 MiB -522648.7 MiB       65792           for spot in row:
    31    112.9 MiB -520617.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.5 MiB    -10.4 MiB           1       count = 0
    34    102.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.5 MiB      0.0 MiB           1       came_from = {}
    37    104.0 MiB -45369.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.4 MiB     -1.5 MiB           1       g_score[start] = 0
    39    102.6 MiB -969183.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     82.7 MiB    -19.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     82.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     82.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     82.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     82.9 MiB -247349.2 MiB        7316       while not open_set.empty():
    47     82.9 MiB -247350.3 MiB        7316           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     82.9 MiB -247350.8 MiB        7316           current = open_set.get()[2]
    53     82.9 MiB -247350.9 MiB        7316           open_set_hash.remove(current)
    54                                         
    55     82.9 MiB -247351.1 MiB        7316           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     82.9 MiB -247351.4 MiB        7316           if current == end:
    60     54.9 MiB    -28.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     54.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     82.9 MiB -2225988.0 MiB       65835           for neighbor in current.neighbors:
    65     82.9 MiB -1978644.7 MiB       58520               if current.row != neighbor.row and current.col != neighbor.col:
    66     82.9 MiB -989357.4 MiB       29260                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     82.9 MiB -989292.8 MiB       29260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     82.9 MiB -1978654.2 MiB       58520               if temp_g_score < g_score[neighbor]:
    71     82.9 MiB -264972.5 MiB        7910                   came_from[neighbor] = current
    72     82.9 MiB -264984.4 MiB        7910                   g_score[neighbor] = temp_g_score
    73     82.9 MiB -264985.0 MiB        7910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     82.9 MiB -264986.1 MiB        7910                   if neighbor not in open_set_hash:
    75     82.9 MiB -264986.6 MiB        7910                       count += 1
    76     82.9 MiB -264978.0 MiB        7910                       open_set.put((f_score[neighbor], count, neighbor))
    77     82.9 MiB -264979.5 MiB        7910                       open_set_hash.add(neighbor)
    78                                                             
    79     82.9 MiB -247346.5 MiB        7315           if draw is not None:
    80                                                     draw()
    81                                         
    82     82.9 MiB -247346.9 MiB        7315           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     57.3 MiB     57.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.4 MiB      0.0 MiB         257       for row in grid:
    30     60.4 MiB      0.0 MiB       65792           for spot in row:
    31     60.4 MiB      3.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.4 MiB      0.0 MiB           1       count = 0
    34     60.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.4 MiB      0.0 MiB           1       came_from = {}
    37     65.3 MiB      4.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.7 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.0 MiB      0.0 MiB        1944       while not open_set.empty():
    47     68.0 MiB      0.0 MiB        1944           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.0 MiB      0.0 MiB        1944           current = open_set.get()[2]
    53     68.0 MiB      0.0 MiB        1944           open_set_hash.remove(current)
    54                                         
    55     68.0 MiB      0.0 MiB        1944           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.0 MiB      0.0 MiB        1944           if current == end:
    60     68.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.0 MiB      0.0 MiB       17487           for neighbor in current.neighbors:
    65     68.0 MiB      0.0 MiB       15544               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.0 MiB      0.0 MiB        7772                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.0 MiB      0.0 MiB        7772                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.0 MiB      0.0 MiB       15544               if temp_g_score < g_score[neighbor]:
    71     68.0 MiB      0.2 MiB        2194                   came_from[neighbor] = current
    72     68.0 MiB      0.0 MiB        2194                   g_score[neighbor] = temp_g_score
    73     68.0 MiB      0.0 MiB        2194                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.0 MiB      0.0 MiB        2194                   if neighbor not in open_set_hash:
    75     68.0 MiB      0.0 MiB        2194                       count += 1
    76     68.0 MiB      0.0 MiB        2194                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.0 MiB      0.0 MiB        2194                       open_set_hash.add(neighbor)
    78                                                             
    79     68.0 MiB      0.0 MiB        1943           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.0 MiB      0.0 MiB        1943           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     68.0 MiB     68.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.0 MiB   -276.4 MiB         257       for row in grid:
    30     68.0 MiB -70731.3 MiB       65792           for spot in row:
    31     68.0 MiB -70457.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     65.1 MiB     -2.9 MiB           1       count = 0
    34     65.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     65.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     65.1 MiB      0.0 MiB           1       came_from = {}
    37     68.3 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.1 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.1 MiB      0.0 MiB         294       while not open_set.empty():
    47     71.1 MiB      0.0 MiB         294           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.1 MiB      0.0 MiB         294           current = open_set.get()[2]
    53     71.1 MiB      0.0 MiB         294           open_set_hash.remove(current)
    54                                         
    55     71.1 MiB      0.0 MiB         294           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.1 MiB      0.0 MiB         294           if current == end:
    60     71.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.1 MiB      0.0 MiB        2637           for neighbor in current.neighbors:
    65     71.1 MiB      0.0 MiB        2344               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.1 MiB      0.0 MiB        1172                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.1 MiB      0.0 MiB        1172                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.1 MiB      0.0 MiB        2344               if temp_g_score < g_score[neighbor]:
    71     71.1 MiB      0.0 MiB         500                   came_from[neighbor] = current
    72     71.1 MiB      0.0 MiB         500                   g_score[neighbor] = temp_g_score
    73     71.1 MiB      0.0 MiB         500                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.1 MiB      0.0 MiB         500                   if neighbor not in open_set_hash:
    75     71.1 MiB      0.0 MiB         500                       count += 1
    76     71.1 MiB      0.0 MiB         500                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.1 MiB      0.0 MiB         500                       open_set_hash.add(neighbor)
    78                                                             
    79     71.1 MiB      0.0 MiB         293           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.1 MiB      0.0 MiB         293           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.2 MiB    104.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.2 MiB      0.0 MiB         257       for row in grid:
    30    104.2 MiB      0.0 MiB       65792           for spot in row:
    31    104.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.2 MiB      0.0 MiB           1       count = 0
    34    104.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.2 MiB      0.0 MiB           1       came_from = {}
    37    108.4 MiB      4.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.6 MiB      5.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.6 MiB      0.0 MiB         884       while not open_set.empty():
    47    113.6 MiB      0.0 MiB         884           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.6 MiB      0.0 MiB         884           current = open_set.get()[2]
    53    113.6 MiB      0.0 MiB         884           open_set_hash.remove(current)
    54                                         
    55    113.6 MiB      0.0 MiB         884           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.6 MiB      0.0 MiB         884           if current == end:
    60    113.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.6 MiB      0.0 MiB        7947           for neighbor in current.neighbors:
    65    113.6 MiB      0.0 MiB        7064               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.6 MiB      0.0 MiB        3532                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.6 MiB      0.0 MiB        3532                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.6 MiB      0.0 MiB        7064               if temp_g_score < g_score[neighbor]:
    71    113.6 MiB      0.0 MiB        1070                   came_from[neighbor] = current
    72    113.6 MiB      0.0 MiB        1070                   g_score[neighbor] = temp_g_score
    73    113.6 MiB      0.0 MiB        1070                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.6 MiB      0.0 MiB        1070                   if neighbor not in open_set_hash:
    75    113.6 MiB      0.0 MiB        1070                       count += 1
    76    113.6 MiB      0.0 MiB        1070                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.6 MiB      0.0 MiB        1070                       open_set_hash.add(neighbor)
    78                                                             
    79    113.6 MiB      0.0 MiB         883           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.6 MiB      0.0 MiB         883           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.6 MiB    113.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.6 MiB    -51.3 MiB         257       for row in grid:
    30    113.6 MiB -13037.5 MiB       65792           for spot in row:
    31    113.6 MiB -12987.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.6 MiB     -1.0 MiB           1       count = 0
    34    112.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.6 MiB      0.0 MiB           1       came_from = {}
    37    112.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.3 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.3 MiB   -438.2 MiB         506       while not open_set.empty():
    47    114.3 MiB   -438.2 MiB         506           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.3 MiB   -438.2 MiB         506           current = open_set.get()[2]
    53    114.3 MiB   -438.2 MiB         506           open_set_hash.remove(current)
    54                                         
    55    114.3 MiB   -438.2 MiB         506           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.3 MiB   -438.2 MiB         506           if current == end:
    60    113.1 MiB     -1.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.3 MiB  -3938.9 MiB        4545           for neighbor in current.neighbors:
    65    114.3 MiB  -3500.9 MiB        4040               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.3 MiB  -1752.8 MiB        2020                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.3 MiB  -1748.4 MiB        2020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.3 MiB  -3501.5 MiB        4040               if temp_g_score < g_score[neighbor]:
    71    114.3 MiB   -519.7 MiB         640                   came_from[neighbor] = current
    72    114.3 MiB   -519.7 MiB         640                   g_score[neighbor] = temp_g_score
    73    114.3 MiB   -519.7 MiB         640                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.3 MiB   -519.7 MiB         640                   if neighbor not in open_set_hash:
    75    114.3 MiB   -519.7 MiB         640                       count += 1
    76    114.3 MiB   -519.7 MiB         640                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.3 MiB   -519.7 MiB         640                       open_set_hash.add(neighbor)
    78                                                             
    79    114.3 MiB   -438.2 MiB         505           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.3 MiB   -438.2 MiB         505           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.1 MiB    113.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.1 MiB     -3.7 MiB         257       for row in grid:
    30    113.1 MiB   -958.6 MiB       65792           for spot in row:
    31    113.1 MiB   -954.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.1 MiB     -0.0 MiB           1       count = 0
    34    113.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.1 MiB      0.0 MiB           1       came_from = {}
    37    116.1 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.6 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.6 MiB -37504.2 MiB        6660       while not open_set.empty():
    47    118.6 MiB -37504.9 MiB        6660           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.6 MiB -37506.8 MiB        6660           current = open_set.get()[2]
    53    118.6 MiB -37508.3 MiB        6660           open_set_hash.remove(current)
    54                                         
    55    118.6 MiB -37509.1 MiB        6660           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.6 MiB -37510.0 MiB        6660           if current == end:
    60     93.1 MiB    -25.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.6 MiB -337439.5 MiB       59931           for neighbor in current.neighbors:
    65    118.6 MiB -299941.7 MiB       53272               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.6 MiB -149982.1 MiB       26636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.6 MiB -149962.4 MiB       26636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.6 MiB -299948.2 MiB       53272               if temp_g_score < g_score[neighbor]:
    71    118.6 MiB -40253.5 MiB        7166                   came_from[neighbor] = current
    72    118.6 MiB -40253.7 MiB        7166                   g_score[neighbor] = temp_g_score
    73    118.6 MiB -40253.9 MiB        7166                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.6 MiB -40254.6 MiB        7166                   if neighbor not in open_set_hash:
    75    118.6 MiB -40254.8 MiB        7166                       count += 1
    76    118.6 MiB -40255.2 MiB        7166                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.6 MiB -40255.4 MiB        7166                       open_set_hash.add(neighbor)
    78                                                             
    79    118.6 MiB -37501.8 MiB        6659           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.6 MiB -37503.3 MiB        6659           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.9 MiB     97.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.9 MiB    -18.2 MiB         257       for row in grid:
    30     97.9 MiB  -4613.0 MiB       65792           for spot in row:
    31     97.9 MiB  -4594.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.6 MiB     -0.3 MiB           1       count = 0
    34     97.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.6 MiB      0.0 MiB           1       came_from = {}
    37    101.8 MiB   -240.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.8 MiB     -0.0 MiB           1       g_score[start] = 0
    39    106.7 MiB      4.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.7 MiB -43111.2 MiB        7956       while not open_set.empty():
    47    106.7 MiB -43111.8 MiB        7956           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.7 MiB -43112.2 MiB        7956           current = open_set.get()[2]
    53    106.7 MiB -43112.2 MiB        7956           open_set_hash.remove(current)
    54                                         
    55    106.7 MiB -43112.4 MiB        7956           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.7 MiB -43112.5 MiB        7956           if current == end:
    60     91.3 MiB    -15.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     91.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.7 MiB -387922.2 MiB       71595           for neighbor in current.neighbors:
    65    106.7 MiB -344815.0 MiB       63640               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.7 MiB -172424.1 MiB       31820                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.7 MiB -172394.5 MiB       31820                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.7 MiB -344819.9 MiB       63640               if temp_g_score < g_score[neighbor]:
    71    106.7 MiB -45635.6 MiB        8460                   came_from[neighbor] = current
    72    106.7 MiB -45635.6 MiB        8460                   g_score[neighbor] = temp_g_score
    73    106.7 MiB -45636.7 MiB        8460                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.7 MiB -45636.8 MiB        8460                   if neighbor not in open_set_hash:
    75    106.7 MiB -45637.4 MiB        8460                       count += 1
    76    106.7 MiB -45638.7 MiB        8460                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.7 MiB -45639.4 MiB        8460                       open_set_hash.add(neighbor)
    78                                                             
    79    106.7 MiB -43110.1 MiB        7955           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.7 MiB -43110.8 MiB        7955           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.7 MiB     91.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.9 MiB    -25.9 MiB         257       for row in grid:
    30     91.9 MiB  -6656.6 MiB       65792           for spot in row:
    31     91.9 MiB  -6630.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.9 MiB      0.0 MiB           1       count = 0
    34     91.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.9 MiB      0.0 MiB           1       came_from = {}
    37     94.9 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.7 MiB      3.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.9 MiB  -4219.9 MiB        4240       while not open_set.empty():
    47     98.9 MiB  -4220.0 MiB        4240           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.9 MiB  -4220.1 MiB        4240           current = open_set.get()[2]
    53     98.9 MiB  -4220.2 MiB        4240           open_set_hash.remove(current)
    54                                         
    55     98.9 MiB  -4220.4 MiB        4240           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.9 MiB  -4220.6 MiB        4240           if current == end:
    60     92.6 MiB     -6.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.9 MiB -37949.0 MiB       38151           for neighbor in current.neighbors:
    65     98.9 MiB -33730.0 MiB       33912               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.9 MiB -16871.0 MiB       16956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.9 MiB -16860.3 MiB       16956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.9 MiB -33731.6 MiB       33912               if temp_g_score < g_score[neighbor]:
    71     98.9 MiB  -4652.7 MiB        4742                   came_from[neighbor] = current
    72     98.9 MiB  -4652.9 MiB        4742                   g_score[neighbor] = temp_g_score
    73     98.9 MiB  -4652.9 MiB        4742                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.9 MiB  -4653.0 MiB        4742                   if neighbor not in open_set_hash:
    75     98.9 MiB  -4653.0 MiB        4742                       count += 1
    76     98.9 MiB  -4653.8 MiB        4742                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.9 MiB  -4654.0 MiB        4742                       open_set_hash.add(neighbor)
    78                                                             
    79     98.9 MiB  -4219.5 MiB        4239           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.9 MiB  -4219.7 MiB        4239           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.6 MiB     92.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.6 MiB   -170.4 MiB         257       for row in grid:
    30     93.6 MiB -43670.5 MiB       65792           for spot in row:
    31     93.6 MiB -43500.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.5 MiB     -1.1 MiB           1       count = 0
    34     92.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.5 MiB      0.0 MiB           1       came_from = {}
    37     94.9 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.9 MiB -11419.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.0 MiB      0.0 MiB        1102       while not open_set.empty():
    47     98.0 MiB      0.0 MiB        1102           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.0 MiB      0.0 MiB        1102           current = open_set.get()[2]
    53     98.0 MiB      0.0 MiB        1102           open_set_hash.remove(current)
    54                                         
    55     98.0 MiB      0.0 MiB        1102           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.0 MiB      0.0 MiB        1102           if current == end:
    60     98.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.0 MiB      0.0 MiB        9909           for neighbor in current.neighbors:
    65     98.0 MiB      0.0 MiB        8808               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.0 MiB      0.0 MiB        4404                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.0 MiB      0.0 MiB        4404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.0 MiB      0.0 MiB        8808               if temp_g_score < g_score[neighbor]:
    71     98.0 MiB      0.0 MiB        1292                   came_from[neighbor] = current
    72     98.0 MiB      0.0 MiB        1292                   g_score[neighbor] = temp_g_score
    73     98.0 MiB      0.0 MiB        1292                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.0 MiB      0.0 MiB        1292                   if neighbor not in open_set_hash:
    75     98.0 MiB      0.0 MiB        1292                       count += 1
    76     98.0 MiB      0.0 MiB        1292                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.0 MiB      0.0 MiB        1292                       open_set_hash.add(neighbor)
    78                                                             
    79     98.0 MiB      0.0 MiB        1101           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.0 MiB      0.0 MiB        1101           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.3 MiB    104.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.3 MiB   -581.0 MiB         257       for row in grid:
    30    104.3 MiB -148738.3 MiB       65792           for spot in row:
    31    104.3 MiB -148158.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.8 MiB     -3.5 MiB           1       count = 0
    34    100.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.8 MiB      0.0 MiB           1       came_from = {}
    37    102.7 MiB      1.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.1 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.1 MiB      0.0 MiB         423       while not open_set.empty():
    47    106.1 MiB      0.0 MiB         423           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.1 MiB      0.0 MiB         423           current = open_set.get()[2]
    53    106.1 MiB      0.0 MiB         423           open_set_hash.remove(current)
    54                                         
    55    106.1 MiB      0.0 MiB         423           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.1 MiB      0.0 MiB         423           if current == end:
    60    106.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.1 MiB      0.0 MiB        3798           for neighbor in current.neighbors:
    65    106.1 MiB      0.0 MiB        3376               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.1 MiB      0.0 MiB        1688                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.1 MiB      0.0 MiB        1688                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.1 MiB      0.0 MiB        3376               if temp_g_score < g_score[neighbor]:
    71    106.1 MiB      0.0 MiB         991                   came_from[neighbor] = current
    72    106.1 MiB      0.0 MiB         991                   g_score[neighbor] = temp_g_score
    73    106.1 MiB      0.0 MiB         991                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.1 MiB      0.0 MiB         991                   if neighbor not in open_set_hash:
    75    106.1 MiB      0.0 MiB         991                       count += 1
    76    106.1 MiB      0.0 MiB         991                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.1 MiB      0.0 MiB         991                       open_set_hash.add(neighbor)
    78                                                             
    79    106.1 MiB      0.0 MiB         422           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.1 MiB      0.0 MiB         422           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.1 MiB    106.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.1 MiB    -19.4 MiB         257       for row in grid:
    30    106.1 MiB  -4962.6 MiB       65792           for spot in row:
    31    106.1 MiB  -4943.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.9 MiB     -0.2 MiB           1       count = 0
    34    105.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.9 MiB      0.0 MiB           1       came_from = {}
    37    107.1 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.2 MiB      1.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.2 MiB -19148.7 MiB        2924       while not open_set.empty():
    47    108.2 MiB -19148.7 MiB        2924           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.2 MiB -19149.1 MiB        2924           current = open_set.get()[2]
    53    108.2 MiB -19149.4 MiB        2924           open_set_hash.remove(current)
    54                                         
    55    108.2 MiB -19149.4 MiB        2924           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.2 MiB -19149.5 MiB        2924           if current == end:
    60    100.1 MiB     -8.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.2 MiB -172310.9 MiB       26307           for neighbor in current.neighbors:
    65    108.2 MiB -153162.9 MiB       23384               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.2 MiB -76589.7 MiB       11692                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.2 MiB -76576.6 MiB       11692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.2 MiB -153167.9 MiB       23384               if temp_g_score < g_score[neighbor]:
    71    108.2 MiB -20556.8 MiB        3230                   came_from[neighbor] = current
    72    108.2 MiB -20556.9 MiB        3230                   g_score[neighbor] = temp_g_score
    73    108.2 MiB -20557.5 MiB        3230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.2 MiB -20557.8 MiB        3230                   if neighbor not in open_set_hash:
    75    108.2 MiB -20557.8 MiB        3230                       count += 1
    76    108.2 MiB -20557.8 MiB        3230                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.2 MiB -20557.8 MiB        3230                       open_set_hash.add(neighbor)
    78                                                             
    79    108.2 MiB -19148.7 MiB        2923           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.2 MiB -19148.7 MiB        2923           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.1 MiB    100.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.1 MiB   -552.8 MiB         257       for row in grid:
    30    100.1 MiB -141499.2 MiB       65792           for spot in row:
    31    100.1 MiB -140948.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.5 MiB     -2.5 MiB           1       count = 0
    34     97.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.5 MiB      0.0 MiB           1       came_from = {}
    37     98.8 MiB -26564.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.9 MiB   -953.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.7 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.7 MiB   -125.8 MiB         793       while not open_set.empty():
    47    101.7 MiB   -125.8 MiB         793           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.7 MiB   -125.8 MiB         793           current = open_set.get()[2]
    53    101.7 MiB   -125.8 MiB         793           open_set_hash.remove(current)
    54                                         
    55    101.7 MiB   -125.8 MiB         793           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.7 MiB   -125.8 MiB         793           if current == end:
    60    101.4 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.7 MiB  -1130.9 MiB        7128           for neighbor in current.neighbors:
    65    101.7 MiB  -1005.1 MiB        6336               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.7 MiB   -503.0 MiB        3168                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.7 MiB   -502.1 MiB        3168                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.7 MiB  -1005.1 MiB        6336               if temp_g_score < g_score[neighbor]:
    71    101.7 MiB   -147.5 MiB         965                   came_from[neighbor] = current
    72    101.7 MiB   -147.5 MiB         965                   g_score[neighbor] = temp_g_score
    73    101.7 MiB   -147.5 MiB         965                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.7 MiB   -147.5 MiB         965                   if neighbor not in open_set_hash:
    75    101.7 MiB   -147.5 MiB         965                       count += 1
    76    101.7 MiB   -147.5 MiB         965                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.7 MiB   -147.5 MiB         965                       open_set_hash.add(neighbor)
    78                                                             
    79    101.7 MiB   -125.8 MiB         792           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.7 MiB   -125.8 MiB         792           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.4 MiB    102.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.4 MiB   -776.5 MiB         257       for row in grid:
    30    102.4 MiB -199407.7 MiB       65792           for spot in row:
    31    102.4 MiB -198633.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.3 MiB     -3.1 MiB           1       count = 0
    34     99.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.3 MiB      0.0 MiB           1       came_from = {}
    37    102.5 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.4 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.8 MiB      0.0 MiB        3965       while not open_set.empty():
    47    104.8 MiB      0.0 MiB        3965           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.8 MiB      0.0 MiB        3965           current = open_set.get()[2]
    53    104.8 MiB      0.0 MiB        3965           open_set_hash.remove(current)
    54                                         
    55    104.8 MiB      0.0 MiB        3965           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.8 MiB      0.0 MiB        3965           if current == end:
    60    104.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.8 MiB      0.0 MiB       35676           for neighbor in current.neighbors:
    65    104.8 MiB      0.0 MiB       31712               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.8 MiB      0.0 MiB       15856                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.8 MiB      0.0 MiB       15856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.8 MiB      0.0 MiB       31712               if temp_g_score < g_score[neighbor]:
    71    104.8 MiB      0.3 MiB        4337                   came_from[neighbor] = current
    72    104.8 MiB      0.0 MiB        4337                   g_score[neighbor] = temp_g_score
    73    104.8 MiB      0.0 MiB        4337                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.8 MiB      0.0 MiB        4337                   if neighbor not in open_set_hash:
    75    104.8 MiB      0.0 MiB        4337                       count += 1
    76    104.8 MiB      0.0 MiB        4337                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.8 MiB      0.0 MiB        4337                       open_set_hash.add(neighbor)
    78                                                             
    79    104.8 MiB      0.0 MiB        3964           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.8 MiB      0.0 MiB        3964           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.8 MiB    104.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.8 MiB     -3.4 MiB         257       for row in grid:
    30    104.8 MiB   -861.3 MiB       65792           for spot in row:
    31    104.8 MiB   -858.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.7 MiB     -0.0 MiB           1       count = 0
    34    104.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.7 MiB      0.0 MiB           1       came_from = {}
    37    107.1 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.4 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.5 MiB  -5259.5 MiB        5712       while not open_set.empty():
    47    108.5 MiB  -5259.5 MiB        5712           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.5 MiB  -5259.6 MiB        5712           current = open_set.get()[2]
    53    108.5 MiB  -5259.6 MiB        5712           open_set_hash.remove(current)
    54                                         
    55    108.5 MiB  -5259.6 MiB        5712           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.5 MiB  -5259.6 MiB        5712           if current == end:
    60    106.2 MiB     -2.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.5 MiB -47321.5 MiB       51399           for neighbor in current.neighbors:
    65    108.5 MiB -42062.4 MiB       45688               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.5 MiB -21032.7 MiB       22844                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.5 MiB -21029.7 MiB       22844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.5 MiB -42062.5 MiB       45688               if temp_g_score < g_score[neighbor]:
    71    108.5 MiB  -5565.1 MiB        6182                   came_from[neighbor] = current
    72    108.5 MiB  -5565.7 MiB        6182                   g_score[neighbor] = temp_g_score
    73    108.5 MiB  -5565.7 MiB        6182                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.5 MiB  -5565.7 MiB        6182                   if neighbor not in open_set_hash:
    75    108.5 MiB  -5565.7 MiB        6182                       count += 1
    76    108.5 MiB  -5565.7 MiB        6182                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.5 MiB  -5566.7 MiB        6182                       open_set_hash.add(neighbor)
    78                                                             
    79    108.5 MiB  -5259.2 MiB        5711           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.5 MiB  -5259.2 MiB        5711           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB   -226.5 MiB         257       for row in grid:
    30    106.2 MiB -57785.8 MiB       65792           for spot in row:
    31    106.2 MiB -57559.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.9 MiB     -2.4 MiB           1       count = 0
    34    103.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.9 MiB      0.0 MiB           1       came_from = {}
    37    105.8 MiB -12306.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.0 MiB     -0.7 MiB           1       g_score[start] = 0
    39    107.6 MiB  -9286.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.1 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.1 MiB  -8438.6 MiB        4356       while not open_set.empty():
    47    107.1 MiB  -8438.6 MiB        4356           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.1 MiB  -8438.6 MiB        4356           current = open_set.get()[2]
    53    107.1 MiB  -8438.6 MiB        4356           open_set_hash.remove(current)
    54                                         
    55    107.1 MiB  -8438.6 MiB        4356           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.1 MiB  -8438.6 MiB        4356           if current == end:
    60    105.0 MiB     -2.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.1 MiB -75937.1 MiB       39195           for neighbor in current.neighbors:
    65    107.1 MiB -67499.0 MiB       34840               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.1 MiB -33753.5 MiB       17420                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.1 MiB -33746.0 MiB       17420                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.1 MiB -67500.1 MiB       34840               if temp_g_score < g_score[neighbor]:
    71    107.1 MiB  -9970.8 MiB        5190                   came_from[neighbor] = current
    72    107.1 MiB  -9970.8 MiB        5190                   g_score[neighbor] = temp_g_score
    73    107.1 MiB  -9970.8 MiB        5190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.1 MiB  -9970.8 MiB        5190                   if neighbor not in open_set_hash:
    75    107.1 MiB  -9970.8 MiB        5190                       count += 1
    76    107.1 MiB  -9970.8 MiB        5190                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.1 MiB  -9970.7 MiB        5190                       open_set_hash.add(neighbor)
    78                                                             
    79    107.1 MiB  -8438.4 MiB        4355           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.1 MiB  -8438.4 MiB        4355           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.2 MiB    110.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.2 MiB    -87.0 MiB         257       for row in grid:
    30    110.2 MiB -22058.8 MiB       65792           for spot in row:
    31    110.2 MiB -21973.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.8 MiB     -2.4 MiB           1       count = 0
    34    107.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.8 MiB      0.0 MiB           1       came_from = {}
    37    111.2 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.3 MiB      1.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.3 MiB -146944.8 MiB       12467       while not open_set.empty():
    47    112.3 MiB -146945.2 MiB       12467           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.3 MiB -146946.2 MiB       12467           current = open_set.get()[2]
    53    112.3 MiB -146946.7 MiB       12467           open_set_hash.remove(current)
    54                                         
    55    112.3 MiB -146947.5 MiB       12467           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.3 MiB -146947.9 MiB       12467           if current == end:
    60     71.4 MiB    -40.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.3 MiB -1322301.3 MiB      112194           for neighbor in current.neighbors:
    65    112.3 MiB -1175364.5 MiB       99728               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.3 MiB -587728.3 MiB       49864                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.3 MiB -587649.7 MiB       49864                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.3 MiB -1175383.7 MiB       99728               if temp_g_score < g_score[neighbor]:
    71    112.3 MiB -154391.1 MiB       13195                   came_from[neighbor] = current
    72    112.3 MiB -154391.6 MiB       13195                   g_score[neighbor] = temp_g_score
    73    112.3 MiB -154392.5 MiB       13195                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.3 MiB -154392.9 MiB       13195                   if neighbor not in open_set_hash:
    75    112.3 MiB -154393.3 MiB       13195                       count += 1
    76    112.3 MiB -154394.2 MiB       13195                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.3 MiB -154394.7 MiB       13195                       open_set_hash.add(neighbor)
    78                                                             
    79    112.3 MiB -146942.6 MiB       12466           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.3 MiB -146943.4 MiB       12466           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     71.7 MiB     71.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     73.1 MiB     -9.9 MiB         257       for row in grid:
    30     73.1 MiB  -2555.7 MiB       65792           for spot in row:
    31     73.1 MiB  -2544.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     73.1 MiB     -0.0 MiB           1       count = 0
    34     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     73.1 MiB      0.0 MiB           1       came_from = {}
    37     75.0 MiB      1.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.5 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.6 MiB    -59.8 MiB        3999       while not open_set.empty():
    47     75.6 MiB    -59.8 MiB        3999           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.6 MiB    -59.8 MiB        3999           current = open_set.get()[2]
    53     75.6 MiB    -59.8 MiB        3999           open_set_hash.remove(current)
    54                                         
    55     75.6 MiB    -59.8 MiB        3999           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.6 MiB    -59.8 MiB        3999           if current == end:
    60     75.6 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.6 MiB   -537.8 MiB       35982           for neighbor in current.neighbors:
    65     75.6 MiB   -478.1 MiB       31984               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.6 MiB   -239.1 MiB       15992                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.6 MiB   -239.0 MiB       15992                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.6 MiB   -478.1 MiB       31984               if temp_g_score < g_score[neighbor]:
    71     75.6 MiB    -64.9 MiB        4355                   came_from[neighbor] = current
    72     75.6 MiB    -65.0 MiB        4355                   g_score[neighbor] = temp_g_score
    73     75.6 MiB    -65.0 MiB        4355                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.6 MiB    -65.0 MiB        4355                   if neighbor not in open_set_hash:
    75     75.6 MiB    -65.0 MiB        4355                       count += 1
    76     75.6 MiB    -65.0 MiB        4355                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.6 MiB    -65.0 MiB        4355                       open_set_hash.add(neighbor)
    78                                                             
    79     75.6 MiB    -59.8 MiB        3998           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.6 MiB    -59.8 MiB        3998           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.6 MiB     75.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.6 MiB   -446.7 MiB         257       for row in grid:
    30     75.6 MiB -114342.7 MiB       65792           for spot in row:
    31     75.6 MiB -113898.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.4 MiB     -3.2 MiB           1       count = 0
    34     72.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.4 MiB      0.0 MiB           1       came_from = {}
    37     75.5 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     77.9 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     77.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     77.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     77.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     77.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     78.0 MiB      0.0 MiB        2145       while not open_set.empty():
    47     78.0 MiB      0.0 MiB        2145           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     78.0 MiB      0.0 MiB        2145           current = open_set.get()[2]
    53     78.0 MiB      0.0 MiB        2145           open_set_hash.remove(current)
    54                                         
    55     78.0 MiB      0.0 MiB        2145           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     78.0 MiB      0.0 MiB        2145           if current == end:
    60     78.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     78.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     78.0 MiB      0.0 MiB       19296           for neighbor in current.neighbors:
    65     78.0 MiB      0.0 MiB       17152               if current.row != neighbor.row and current.col != neighbor.col:
    66     78.0 MiB      0.0 MiB        8576                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     78.0 MiB      0.0 MiB        8576                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     78.0 MiB      0.0 MiB       17152               if temp_g_score < g_score[neighbor]:
    71     78.0 MiB      0.0 MiB        2409                   came_from[neighbor] = current
    72     78.0 MiB      0.0 MiB        2409                   g_score[neighbor] = temp_g_score
    73     78.0 MiB      0.0 MiB        2409                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     78.0 MiB      0.0 MiB        2409                   if neighbor not in open_set_hash:
    75     78.0 MiB      0.0 MiB        2409                       count += 1
    76     78.0 MiB      0.0 MiB        2409                       open_set.put((f_score[neighbor], count, neighbor))
    77     78.0 MiB      0.0 MiB        2409                       open_set_hash.add(neighbor)
    78                                                             
    79     78.0 MiB      0.0 MiB        2144           if draw is not None:
    80                                                     draw()
    81                                         
    82     78.0 MiB      0.0 MiB        2144           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.2 MiB    109.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.2 MiB    -26.4 MiB         257       for row in grid:
    30    109.2 MiB  -6728.3 MiB       65792           for spot in row:
    31    109.2 MiB  -6702.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.9 MiB     -0.3 MiB           1       count = 0
    34    108.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.9 MiB      0.0 MiB           1       came_from = {}
    37    109.0 MiB -32825.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.9 MiB     -0.1 MiB           1       g_score[start] = 0
    39    111.4 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.4 MiB      0.0 MiB         658       while not open_set.empty():
    47    111.4 MiB      0.0 MiB         658           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.4 MiB      0.0 MiB         658           current = open_set.get()[2]
    53    111.4 MiB      0.0 MiB         658           open_set_hash.remove(current)
    54                                         
    55    111.4 MiB      0.0 MiB         658           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.4 MiB      0.0 MiB         658           if current == end:
    60    111.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.4 MiB      0.0 MiB        5913           for neighbor in current.neighbors:
    65    111.4 MiB      0.0 MiB        5256               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.4 MiB      0.0 MiB        2628                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.4 MiB      0.0 MiB        2628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.4 MiB      0.0 MiB        5256               if temp_g_score < g_score[neighbor]:
    71    111.4 MiB      0.0 MiB        1046                   came_from[neighbor] = current
    72    111.4 MiB      0.0 MiB        1046                   g_score[neighbor] = temp_g_score
    73    111.4 MiB      0.0 MiB        1046                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.4 MiB      0.0 MiB        1046                   if neighbor not in open_set_hash:
    75    111.4 MiB      0.0 MiB        1046                       count += 1
    76    111.4 MiB      0.0 MiB        1046                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.4 MiB      0.0 MiB        1046                       open_set_hash.add(neighbor)
    78                                                             
    79    111.4 MiB      0.0 MiB         657           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.4 MiB      0.0 MiB         657           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.4 MiB    111.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.4 MiB      0.0 MiB         257       for row in grid:
    30    111.4 MiB      0.0 MiB       65792           for spot in row:
    31    111.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.4 MiB      0.0 MiB           1       count = 0
    34    111.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.4 MiB      0.0 MiB           1       came_from = {}
    37    112.8 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.8 MiB      0.0 MiB        2952       while not open_set.empty():
    47    112.8 MiB      0.0 MiB        2952           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.8 MiB      0.0 MiB        2952           current = open_set.get()[2]
    53    112.8 MiB      0.0 MiB        2952           open_set_hash.remove(current)
    54                                         
    55    112.8 MiB      0.0 MiB        2952           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.8 MiB      0.0 MiB        2952           if current == end:
    60    112.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.8 MiB      0.0 MiB       26559           for neighbor in current.neighbors:
    65    112.8 MiB      0.0 MiB       23608               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.8 MiB      0.0 MiB       11804                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.8 MiB      0.0 MiB       11804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.8 MiB      0.0 MiB       23608               if temp_g_score < g_score[neighbor]:
    71    112.8 MiB      0.0 MiB        3350                   came_from[neighbor] = current
    72    112.8 MiB      0.0 MiB        3350                   g_score[neighbor] = temp_g_score
    73    112.8 MiB      0.0 MiB        3350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.8 MiB      0.0 MiB        3350                   if neighbor not in open_set_hash:
    75    112.8 MiB      0.0 MiB        3350                       count += 1
    76    112.8 MiB      0.0 MiB        3350                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.8 MiB      0.0 MiB        3350                       open_set_hash.add(neighbor)
    78                                                             
    79    112.8 MiB      0.0 MiB        2951           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.8 MiB      0.0 MiB        2951           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.8 MiB    112.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.8 MiB    -55.3 MiB         257       for row in grid:
    30    112.8 MiB -14182.4 MiB       65792           for spot in row:
    31    112.8 MiB -14127.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.5 MiB     -0.2 MiB           1       count = 0
    34    112.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.5 MiB      0.0 MiB           1       came_from = {}
    37    113.8 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.3 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.3 MiB      0.0 MiB        5375       while not open_set.empty():
    47    114.3 MiB      0.0 MiB        5375           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.3 MiB      0.0 MiB        5375           current = open_set.get()[2]
    53    114.3 MiB      0.0 MiB        5375           open_set_hash.remove(current)
    54                                         
    55    114.3 MiB      0.0 MiB        5375           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.3 MiB      0.0 MiB        5375           if current == end:
    60    114.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.3 MiB      0.0 MiB       48366           for neighbor in current.neighbors:
    65    114.3 MiB      0.0 MiB       42992               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.3 MiB      0.0 MiB       21496                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.3 MiB      0.0 MiB       21496                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.3 MiB      0.0 MiB       42992               if temp_g_score < g_score[neighbor]:
    71    114.3 MiB      0.0 MiB        5795                   came_from[neighbor] = current
    72    114.3 MiB      0.0 MiB        5795                   g_score[neighbor] = temp_g_score
    73    114.3 MiB      0.0 MiB        5795                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.3 MiB      0.0 MiB        5795                   if neighbor not in open_set_hash:
    75    114.3 MiB      0.0 MiB        5795                       count += 1
    76    114.3 MiB      0.0 MiB        5795                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.3 MiB      0.0 MiB        5795                       open_set_hash.add(neighbor)
    78                                                             
    79    114.3 MiB      0.0 MiB        5374           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.3 MiB      0.0 MiB        5374           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.5 MiB    115.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.5 MiB   -921.1 MiB         257       for row in grid:
    30    115.5 MiB -232215.8 MiB       65792           for spot in row:
    31    115.5 MiB -231317.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     82.7 MiB    -32.8 MiB           1       count = 0
    34     82.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     82.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     82.7 MiB      0.0 MiB           1       came_from = {}
    37     86.4 MiB -11721.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     86.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     90.4 MiB -16212.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     90.4 MiB      0.0 MiB          81       while not open_set.empty():
    47     90.4 MiB      0.0 MiB          81           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     90.4 MiB      0.0 MiB          81           current = open_set.get()[2]
    53     90.4 MiB      0.0 MiB          81           open_set_hash.remove(current)
    54                                         
    55     90.4 MiB      0.0 MiB          81           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     90.4 MiB      0.0 MiB          81           if current == end:
    60     90.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     90.4 MiB      0.0 MiB         720           for neighbor in current.neighbors:
    65     90.4 MiB      0.0 MiB         640               if current.row != neighbor.row and current.col != neighbor.col:
    66     90.4 MiB      0.0 MiB         320                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     90.4 MiB      0.0 MiB         320                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     90.4 MiB      0.0 MiB         640               if temp_g_score < g_score[neighbor]:
    71     90.4 MiB      0.0 MiB         145                   came_from[neighbor] = current
    72     90.4 MiB      0.0 MiB         145                   g_score[neighbor] = temp_g_score
    73     90.4 MiB      0.0 MiB         145                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     90.4 MiB      0.0 MiB         145                   if neighbor not in open_set_hash:
    75     90.4 MiB      0.0 MiB         145                       count += 1
    76     90.4 MiB      0.0 MiB         145                       open_set.put((f_score[neighbor], count, neighbor))
    77     90.4 MiB      0.0 MiB         145                       open_set_hash.add(neighbor)
    78                                                             
    79     90.4 MiB      0.0 MiB          80           if draw is not None:
    80                                                     draw()
    81                                         
    82     90.4 MiB      0.0 MiB          80           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.9 MiB     92.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.4 MiB   -529.8 MiB         257       for row in grid:
    30     96.4 MiB -135100.6 MiB       65792           for spot in row:
    31     96.4 MiB -134573.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.3 MiB     -9.1 MiB           1       count = 0
    34     87.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     87.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     87.3 MiB      0.0 MiB           1       came_from = {}
    37     88.6 MiB -20662.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     87.7 MiB     -0.9 MiB           1       g_score[start] = 0
    39     91.8 MiB  -5604.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     91.3 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     91.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     91.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     91.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     91.4 MiB  -4183.4 MiB        8176       while not open_set.empty():
    47     91.4 MiB  -4183.4 MiB        8176           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     91.4 MiB  -4183.4 MiB        8176           current = open_set.get()[2]
    53     91.4 MiB  -4183.4 MiB        8176           open_set_hash.remove(current)
    54                                         
    55     91.4 MiB  -4183.4 MiB        8176           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     91.4 MiB  -4184.4 MiB        8176           if current == end:
    60     87.6 MiB     -3.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     87.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     91.4 MiB -37630.1 MiB       73575           for neighbor in current.neighbors:
    65     91.4 MiB -33447.2 MiB       65400               if current.row != neighbor.row and current.col != neighbor.col:
    66     91.4 MiB -16725.3 MiB       32700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     91.4 MiB -16722.3 MiB       32700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     91.4 MiB -33447.7 MiB       65400               if temp_g_score < g_score[neighbor]:
    71     91.4 MiB  -4420.4 MiB        8768                   came_from[neighbor] = current
    72     91.4 MiB  -4421.3 MiB        8768                   g_score[neighbor] = temp_g_score
    73     91.4 MiB  -4422.2 MiB        8768                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     91.4 MiB  -4422.3 MiB        8768                   if neighbor not in open_set_hash:
    75     91.4 MiB  -4422.3 MiB        8768                       count += 1
    76     91.4 MiB  -4422.2 MiB        8768                       open_set.put((f_score[neighbor], count, neighbor))
    77     91.4 MiB  -4422.2 MiB        8768                       open_set_hash.add(neighbor)
    78                                                             
    79     91.4 MiB  -4183.4 MiB        8175           if draw is not None:
    80                                                     draw()
    81                                         
    82     91.4 MiB  -4183.4 MiB        8175           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     87.7 MiB     87.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     87.7 MiB  -5078.8 MiB         257       for row in grid:
    30     87.7 MiB -1304233.7 MiB       65792           for spot in row:
    31     87.7 MiB -1299175.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.8 MiB    -24.9 MiB           1       count = 0
    34     62.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.8 MiB      0.0 MiB           1       came_from = {}
    37     65.0 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.5 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.6 MiB      0.0 MiB        2205       while not open_set.empty():
    47     68.6 MiB      0.0 MiB        2205           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.6 MiB      0.0 MiB        2205           current = open_set.get()[2]
    53     68.6 MiB      0.0 MiB        2205           open_set_hash.remove(current)
    54                                         
    55     68.6 MiB      0.0 MiB        2205           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.6 MiB      0.0 MiB        2205           if current == end:
    60     68.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.6 MiB      0.0 MiB       19836           for neighbor in current.neighbors:
    65     68.6 MiB      0.0 MiB       17632               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.6 MiB      0.0 MiB        8816                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.6 MiB      0.0 MiB        8816                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.6 MiB      0.0 MiB       17632               if temp_g_score < g_score[neighbor]:
    71     68.6 MiB      0.0 MiB        2665                   came_from[neighbor] = current
    72     68.6 MiB      0.0 MiB        2665                   g_score[neighbor] = temp_g_score
    73     68.6 MiB      0.0 MiB        2665                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.6 MiB      0.0 MiB        2665                   if neighbor not in open_set_hash:
    75     68.6 MiB      0.0 MiB        2665                       count += 1
    76     68.6 MiB      0.0 MiB        2665                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.6 MiB      0.0 MiB        2665                       open_set_hash.add(neighbor)
    78                                                             
    79     68.6 MiB      0.0 MiB        2204           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.6 MiB      0.0 MiB        2204           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.9 MiB    105.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.9 MiB   -361.4 MiB         257       for row in grid:
    30    105.9 MiB -92388.1 MiB       65792           for spot in row:
    31    105.9 MiB -92028.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.1 MiB     -3.8 MiB           1       count = 0
    34    102.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.1 MiB      0.0 MiB           1       came_from = {}
    37    104.2 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.8 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.9 MiB      0.0 MiB         268       while not open_set.empty():
    47    107.9 MiB      0.0 MiB         268           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.9 MiB      0.0 MiB         268           current = open_set.get()[2]
    53    107.9 MiB      0.0 MiB         268           open_set_hash.remove(current)
    54                                         
    55    107.9 MiB      0.0 MiB         268           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.9 MiB      0.0 MiB         268           if current == end:
    60    107.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.9 MiB      0.0 MiB        2403           for neighbor in current.neighbors:
    65    107.9 MiB      0.0 MiB        2136               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.9 MiB      0.0 MiB        1068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.9 MiB      0.0 MiB        1068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.9 MiB      0.0 MiB        2136               if temp_g_score < g_score[neighbor]:
    71    107.9 MiB      0.0 MiB         542                   came_from[neighbor] = current
    72    107.9 MiB      0.0 MiB         542                   g_score[neighbor] = temp_g_score
    73    107.9 MiB      0.0 MiB         542                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.9 MiB      0.0 MiB         542                   if neighbor not in open_set_hash:
    75    107.9 MiB      0.0 MiB         542                       count += 1
    76    107.9 MiB      0.0 MiB         542                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.9 MiB      0.0 MiB         542                       open_set_hash.add(neighbor)
    78                                                             
    79    107.9 MiB      0.0 MiB         267           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.9 MiB      0.0 MiB         267           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.9 MiB    107.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.9 MiB    -62.5 MiB         257       for row in grid:
    30    107.9 MiB -16058.3 MiB       65792           for spot in row:
    31    107.9 MiB -15996.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.6 MiB     -0.2 MiB           1       count = 0
    34    107.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.6 MiB      0.0 MiB           1       came_from = {}
    37    110.8 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.7 MiB  -3615.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.8 MiB      0.0 MiB        4968       while not open_set.empty():
    47    112.8 MiB      0.0 MiB        4968           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.8 MiB      0.0 MiB        4968           current = open_set.get()[2]
    53    112.8 MiB      0.0 MiB        4968           open_set_hash.remove(current)
    54                                         
    55    112.8 MiB      0.0 MiB        4968           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.8 MiB      0.0 MiB        4968           if current == end:
    60    112.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.8 MiB      0.0 MiB       44703           for neighbor in current.neighbors:
    65    112.8 MiB      0.0 MiB       39736               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.8 MiB      0.0 MiB       19868                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.8 MiB      0.0 MiB       19868                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.8 MiB      0.0 MiB       39736               if temp_g_score < g_score[neighbor]:
    71    112.8 MiB      0.0 MiB        5366                   came_from[neighbor] = current
    72    112.8 MiB      0.0 MiB        5366                   g_score[neighbor] = temp_g_score
    73    112.8 MiB      0.0 MiB        5366                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.8 MiB      0.0 MiB        5366                   if neighbor not in open_set_hash:
    75    112.8 MiB      0.0 MiB        5366                       count += 1
    76    112.8 MiB      0.0 MiB        5366                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.8 MiB      0.0 MiB        5366                       open_set_hash.add(neighbor)
    78                                                             
    79    112.8 MiB      0.0 MiB        4967           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.8 MiB      0.0 MiB        4967           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.8 MiB    112.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.8 MiB      0.0 MiB         257       for row in grid:
    30    112.8 MiB      0.0 MiB       65792           for spot in row:
    31    112.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.8 MiB      0.0 MiB           1       count = 0
    34    112.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.8 MiB      0.0 MiB           1       came_from = {}
    37    113.1 MiB  -3741.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.5 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.8 MiB      0.0 MiB        8800       while not open_set.empty():
    47    113.8 MiB      0.0 MiB        8800           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.8 MiB      0.0 MiB        8800           current = open_set.get()[2]
    53    113.8 MiB      0.0 MiB        8800           open_set_hash.remove(current)
    54                                         
    55    113.8 MiB      0.0 MiB        8800           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.8 MiB      0.0 MiB        8800           if current == end:
    60    113.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.8 MiB      0.0 MiB       79191           for neighbor in current.neighbors:
    65    113.8 MiB      0.0 MiB       70392               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.8 MiB      0.0 MiB       35196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.8 MiB      0.0 MiB       35196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.8 MiB      0.0 MiB       70392               if temp_g_score < g_score[neighbor]:
    71    113.8 MiB      0.3 MiB        9602                   came_from[neighbor] = current
    72    113.8 MiB      0.0 MiB        9602                   g_score[neighbor] = temp_g_score
    73    113.8 MiB      0.0 MiB        9602                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.8 MiB      0.0 MiB        9602                   if neighbor not in open_set_hash:
    75    113.8 MiB      0.0 MiB        9602                       count += 1
    76    113.8 MiB      0.0 MiB        9602                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.8 MiB      0.0 MiB        9602                       open_set_hash.add(neighbor)
    78                                                             
    79    113.8 MiB      0.0 MiB        8799           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.8 MiB      0.0 MiB        8799           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.5 MiB    114.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.5 MiB      0.0 MiB         257       for row in grid:
    30    114.5 MiB      0.0 MiB       65792           for spot in row:
    31    114.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.5 MiB      0.0 MiB           1       count = 0
    34    114.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.5 MiB      0.0 MiB           1       came_from = {}
    37    115.6 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.7 MiB -60969.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.7 MiB     -1.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.7 MiB  -3776.5 MiB        1204       while not open_set.empty():
    47    114.7 MiB  -3776.5 MiB        1204           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.7 MiB  -3776.5 MiB        1204           current = open_set.get()[2]
    53    114.7 MiB  -3776.5 MiB        1204           open_set_hash.remove(current)
    54                                         
    55    114.7 MiB  -3776.5 MiB        1204           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.7 MiB  -3776.5 MiB        1204           if current == end:
    60    111.2 MiB     -3.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.7 MiB -33976.7 MiB       10827           for neighbor in current.neighbors:
    65    114.7 MiB -30201.2 MiB        9624               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.7 MiB -15104.8 MiB        4812                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.7 MiB -15098.7 MiB        4812                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.7 MiB -30203.7 MiB        9624               if temp_g_score < g_score[neighbor]:
    71    114.7 MiB  -4355.7 MiB        1430                   came_from[neighbor] = current
    72    114.7 MiB  -4355.7 MiB        1430                   g_score[neighbor] = temp_g_score
    73    114.7 MiB  -4355.7 MiB        1430                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.7 MiB  -4355.7 MiB        1430                   if neighbor not in open_set_hash:
    75    114.7 MiB  -4355.7 MiB        1430                       count += 1
    76    114.7 MiB  -4355.7 MiB        1430                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.7 MiB  -4355.7 MiB        1430                       open_set_hash.add(neighbor)
    78                                                             
    79    114.7 MiB  -3776.3 MiB        1203           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.7 MiB  -3776.5 MiB        1203           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.2 MiB    111.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.2 MiB   -672.8 MiB         257       for row in grid:
    30    111.2 MiB -171408.0 MiB       65792           for spot in row:
    31    111.2 MiB -170741.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.4 MiB     -7.9 MiB           1       count = 0
    34    103.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.4 MiB      0.0 MiB           1       came_from = {}
    37    106.6 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.7 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.7 MiB      0.0 MiB        1952       while not open_set.empty():
    47    109.7 MiB      0.0 MiB        1952           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.7 MiB      0.0 MiB        1952           current = open_set.get()[2]
    53    109.7 MiB      0.0 MiB        1952           open_set_hash.remove(current)
    54                                         
    55    109.7 MiB      0.0 MiB        1952           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.7 MiB      0.0 MiB        1952           if current == end:
    60    109.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.7 MiB      0.0 MiB       17559           for neighbor in current.neighbors:
    65    109.7 MiB      0.0 MiB       15608               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.7 MiB      0.0 MiB        7804                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.7 MiB      0.0 MiB        7804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.7 MiB      0.0 MiB       15608               if temp_g_score < g_score[neighbor]:
    71    109.7 MiB      0.0 MiB        2200                   came_from[neighbor] = current
    72    109.7 MiB      0.0 MiB        2200                   g_score[neighbor] = temp_g_score
    73    109.7 MiB      0.0 MiB        2200                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.7 MiB      0.0 MiB        2200                   if neighbor not in open_set_hash:
    75    109.7 MiB      0.0 MiB        2200                       count += 1
    76    109.7 MiB      0.0 MiB        2200                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.7 MiB      0.0 MiB        2200                       open_set_hash.add(neighbor)
    78                                                             
    79    109.7 MiB      0.0 MiB        1951           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.7 MiB      0.0 MiB        1951           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.7 MiB    109.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.7 MiB   -265.8 MiB         257       for row in grid:
    30    109.7 MiB -68096.3 MiB       65792           for spot in row:
    31    109.7 MiB -67832.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.7 MiB     -2.0 MiB           1       count = 0
    34    107.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.7 MiB      0.0 MiB           1       came_from = {}
    37    109.9 MiB -10030.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.0 MiB     -1.0 MiB           1       g_score[start] = 0
    39    110.7 MiB  -2138.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.7 MiB -47416.6 MiB        7685       while not open_set.empty():
    47    110.7 MiB -47416.8 MiB        7685           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.7 MiB -47417.2 MiB        7685           current = open_set.get()[2]
    53    110.7 MiB -47417.5 MiB        7685           open_set_hash.remove(current)
    54                                         
    55    110.7 MiB -47417.6 MiB        7685           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.7 MiB -47417.6 MiB        7685           if current == end:
    60     92.3 MiB    -18.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.7 MiB -426646.4 MiB       69156           for neighbor in current.neighbors:
    65    110.7 MiB -379232.6 MiB       61472               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.7 MiB -189633.1 MiB       30736                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.7 MiB -189601.5 MiB       30736                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.7 MiB -379238.3 MiB       61472               if temp_g_score < g_score[neighbor]:
    71    110.7 MiB -50109.9 MiB        8185                   came_from[neighbor] = current
    72    110.7 MiB -50110.1 MiB        8185                   g_score[neighbor] = temp_g_score
    73    110.7 MiB -50110.5 MiB        8185                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.7 MiB -50110.9 MiB        8185                   if neighbor not in open_set_hash:
    75    110.7 MiB -50111.1 MiB        8185                       count += 1
    76    110.7 MiB -50113.4 MiB        8185                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.7 MiB -50114.1 MiB        8185                       open_set_hash.add(neighbor)
    78                                                             
    79    110.7 MiB -47415.9 MiB        7684           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.7 MiB -47416.3 MiB        7684           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.8 MiB    103.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.8 MiB   -274.5 MiB         257       for row in grid:
    30    103.8 MiB -70103.1 MiB       65792           for spot in row:
    31    103.8 MiB -69829.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.9 MiB     -1.9 MiB           1       count = 0
    34    101.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.9 MiB      0.0 MiB           1       came_from = {}
    37    103.8 MiB      1.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.0 MiB      4.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.0 MiB      0.0 MiB        1560       while not open_set.empty():
    47    108.0 MiB      0.0 MiB        1560           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.0 MiB      0.0 MiB        1560           current = open_set.get()[2]
    53    108.0 MiB      0.0 MiB        1560           open_set_hash.remove(current)
    54                                         
    55    108.0 MiB      0.0 MiB        1560           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.0 MiB      0.0 MiB        1560           if current == end:
    60    108.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.0 MiB      0.0 MiB       14031           for neighbor in current.neighbors:
    65    108.0 MiB      0.0 MiB       12472               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.0 MiB      0.0 MiB        6236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.0 MiB      0.0 MiB        6236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.0 MiB      0.0 MiB       12472               if temp_g_score < g_score[neighbor]:
    71    108.0 MiB      0.0 MiB        1826                   came_from[neighbor] = current
    72    108.0 MiB      0.0 MiB        1826                   g_score[neighbor] = temp_g_score
    73    108.0 MiB      0.0 MiB        1826                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.0 MiB      0.0 MiB        1826                   if neighbor not in open_set_hash:
    75    108.0 MiB      0.0 MiB        1826                       count += 1
    76    108.0 MiB      0.0 MiB        1826                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.0 MiB      0.0 MiB        1826                       open_set_hash.add(neighbor)
    78                                                             
    79    108.0 MiB      0.0 MiB        1559           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.0 MiB      0.0 MiB        1559           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.0 MiB    108.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.0 MiB      0.0 MiB         257       for row in grid:
    30    108.0 MiB      0.0 MiB       65792           for spot in row:
    31    108.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.0 MiB      0.0 MiB           1       count = 0
    34    108.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.0 MiB      0.0 MiB           1       came_from = {}
    37    108.8 MiB      0.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.9 MiB   -132.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.9 MiB  -5488.1 MiB        5187       while not open_set.empty():
    47    111.9 MiB  -5488.1 MiB        5187           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.9 MiB  -5488.1 MiB        5187           current = open_set.get()[2]
    53    111.9 MiB  -5488.1 MiB        5187           open_set_hash.remove(current)
    54                                         
    55    111.9 MiB  -5488.1 MiB        5187           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.9 MiB  -5488.1 MiB        5187           if current == end:
    60    110.5 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.9 MiB -49381.6 MiB       46674           for neighbor in current.neighbors:
    65    111.9 MiB -43893.5 MiB       41488               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.9 MiB -21946.8 MiB       20744                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.9 MiB -21946.7 MiB       20744                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.9 MiB -43893.5 MiB       41488               if temp_g_score < g_score[neighbor]:
    71    111.9 MiB  -5866.8 MiB        5663                   came_from[neighbor] = current
    72    111.9 MiB  -5866.8 MiB        5663                   g_score[neighbor] = temp_g_score
    73    111.9 MiB  -5866.8 MiB        5663                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.9 MiB  -5866.8 MiB        5663                   if neighbor not in open_set_hash:
    75    111.9 MiB  -5866.8 MiB        5663                       count += 1
    76    111.9 MiB  -5868.4 MiB        5663                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.9 MiB  -5868.4 MiB        5663                       open_set_hash.add(neighbor)
    78                                                             
    79    111.9 MiB  -5488.1 MiB        5186           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.9 MiB  -5488.1 MiB        5186           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.5 MiB    110.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.5 MiB      0.0 MiB         257       for row in grid:
    30    110.5 MiB      0.0 MiB       65792           for spot in row:
    31    110.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.5 MiB      0.0 MiB           1       count = 0
    34    110.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.5 MiB      0.0 MiB           1       came_from = {}
    37    110.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.5 MiB -17084.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.6 MiB      0.0 MiB        4230       while not open_set.empty():
    47    110.6 MiB      0.0 MiB        4230           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.6 MiB      0.0 MiB        4230           current = open_set.get()[2]
    53    110.6 MiB      0.0 MiB        4230           open_set_hash.remove(current)
    54                                         
    55    110.6 MiB      0.0 MiB        4230           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.6 MiB      0.0 MiB        4230           if current == end:
    60    110.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.6 MiB      0.0 MiB       38061           for neighbor in current.neighbors:
    65    110.6 MiB      0.0 MiB       33832               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.6 MiB      0.0 MiB       16916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.6 MiB      0.0 MiB       16916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.6 MiB      0.0 MiB       33832               if temp_g_score < g_score[neighbor]:
    71    110.6 MiB      0.1 MiB        4596                   came_from[neighbor] = current
    72    110.6 MiB      0.0 MiB        4596                   g_score[neighbor] = temp_g_score
    73    110.6 MiB      0.0 MiB        4596                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.6 MiB      0.0 MiB        4596                   if neighbor not in open_set_hash:
    75    110.6 MiB      0.0 MiB        4596                       count += 1
    76    110.6 MiB      0.0 MiB        4596                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.6 MiB      0.0 MiB        4596                       open_set_hash.add(neighbor)
    78                                                             
    79    110.6 MiB      0.0 MiB        4229           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.6 MiB      0.0 MiB        4229           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.3 MiB    113.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.3 MiB   -853.7 MiB         257       for row in grid:
    30    113.3 MiB -217989.1 MiB       65792           for spot in row:
    31    113.3 MiB -217144.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.2 MiB    -12.1 MiB           1       count = 0
    34    101.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.2 MiB      0.0 MiB           1       came_from = {}
    37    103.0 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.0 MiB   -151.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.0 MiB  -5491.0 MiB        5084       while not open_set.empty():
    47    105.0 MiB  -5491.0 MiB        5084           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.0 MiB  -5491.0 MiB        5084           current = open_set.get()[2]
    53    105.0 MiB  -5491.0 MiB        5084           open_set_hash.remove(current)
    54                                         
    55    105.0 MiB  -5491.0 MiB        5084           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.0 MiB  -5491.0 MiB        5084           if current == end:
    60    102.0 MiB     -3.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.0 MiB -49405.0 MiB       45747           for neighbor in current.neighbors:
    65    105.0 MiB -43915.1 MiB       40664               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.0 MiB -21959.9 MiB       20332                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.0 MiB -21956.1 MiB       20332                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.0 MiB -43917.0 MiB       40664               if temp_g_score < g_score[neighbor]:
    71    105.0 MiB  -5845.5 MiB        5494                   came_from[neighbor] = current
    72    105.0 MiB  -5845.5 MiB        5494                   g_score[neighbor] = temp_g_score
    73    105.0 MiB  -5845.5 MiB        5494                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.0 MiB  -5845.5 MiB        5494                   if neighbor not in open_set_hash:
    75    105.0 MiB  -5845.5 MiB        5494                       count += 1
    76    105.0 MiB  -5845.5 MiB        5494                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.0 MiB  -5845.6 MiB        5494                       open_set_hash.add(neighbor)
    78                                                             
    79    105.0 MiB  -5490.7 MiB        5083           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.0 MiB  -5490.9 MiB        5083           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.0 MiB    102.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.1 MiB      0.0 MiB         257       for row in grid:
    30    102.1 MiB      0.0 MiB       65792           for spot in row:
    31    102.1 MiB      0.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.1 MiB      0.0 MiB           1       count = 0
    34    102.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.1 MiB      0.0 MiB           1       came_from = {}
    37    104.0 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.9 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.9 MiB      0.0 MiB        1560       while not open_set.empty():
    47    106.9 MiB      0.0 MiB        1560           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.9 MiB      0.0 MiB        1560           current = open_set.get()[2]
    53    106.9 MiB      0.0 MiB        1560           open_set_hash.remove(current)
    54                                         
    55    106.9 MiB      0.0 MiB        1560           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.9 MiB      0.0 MiB        1560           if current == end:
    60    106.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.9 MiB      0.0 MiB       14031           for neighbor in current.neighbors:
    65    106.9 MiB      0.0 MiB       12472               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.9 MiB      0.0 MiB        6236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.9 MiB      0.0 MiB        6236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.9 MiB      0.0 MiB       12472               if temp_g_score < g_score[neighbor]:
    71    106.9 MiB      0.0 MiB        2004                   came_from[neighbor] = current
    72    106.9 MiB      0.0 MiB        2004                   g_score[neighbor] = temp_g_score
    73    106.9 MiB      0.0 MiB        2004                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.9 MiB      0.0 MiB        2004                   if neighbor not in open_set_hash:
    75    106.9 MiB      0.0 MiB        2004                       count += 1
    76    106.9 MiB      0.0 MiB        2004                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.9 MiB      0.0 MiB        2004                       open_set_hash.add(neighbor)
    78                                                             
    79    106.9 MiB      0.0 MiB        1559           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.9 MiB      0.0 MiB        1559           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.9 MiB    106.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.9 MiB   -159.4 MiB         257       for row in grid:
    30    106.9 MiB -40881.5 MiB       65792           for spot in row:
    31    106.9 MiB -40722.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.3 MiB     -0.6 MiB           1       count = 0
    34    106.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.3 MiB      0.0 MiB           1       came_from = {}
    37    108.7 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.2 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.2 MiB   -171.6 MiB        3268       while not open_set.empty():
    47    111.2 MiB   -171.6 MiB        3268           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.2 MiB   -171.6 MiB        3268           current = open_set.get()[2]
    53    111.2 MiB   -171.6 MiB        3268           open_set_hash.remove(current)
    54                                         
    55    111.2 MiB   -171.6 MiB        3268           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.2 MiB   -171.6 MiB        3268           if current == end:
    60    110.9 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.2 MiB  -1542.3 MiB       29403           for neighbor in current.neighbors:
    65    111.2 MiB  -1370.7 MiB       26136               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.2 MiB   -685.8 MiB       13068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.2 MiB   -685.2 MiB       13068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.2 MiB  -1371.0 MiB       26136               if temp_g_score < g_score[neighbor]:
    71    111.2 MiB   -190.6 MiB        3590                   came_from[neighbor] = current
    72    111.2 MiB   -190.6 MiB        3590                   g_score[neighbor] = temp_g_score
    73    111.2 MiB   -190.6 MiB        3590                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.2 MiB   -190.6 MiB        3590                   if neighbor not in open_set_hash:
    75    111.2 MiB   -190.6 MiB        3590                       count += 1
    76    111.2 MiB   -190.6 MiB        3590                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.2 MiB   -190.6 MiB        3590                       open_set_hash.add(neighbor)
    78                                                             
    79    111.2 MiB   -171.6 MiB        3267           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.2 MiB   -171.6 MiB        3267           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.7 MiB    111.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.7 MiB      0.0 MiB         257       for row in grid:
    30    111.7 MiB      0.0 MiB       65792           for spot in row:
    31    111.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.7 MiB      0.0 MiB           1       count = 0
    34    111.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.7 MiB      0.0 MiB           1       came_from = {}
    37    113.0 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.0 MiB -155887.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.4 MiB     -2.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.4 MiB      0.0 MiB         747       while not open_set.empty():
    47    110.4 MiB      0.0 MiB         747           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.4 MiB      0.0 MiB         747           current = open_set.get()[2]
    53    110.4 MiB      0.0 MiB         747           open_set_hash.remove(current)
    54                                         
    55    110.4 MiB      0.0 MiB         747           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.4 MiB      0.0 MiB         747           if current == end:
    60    110.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.4 MiB      0.0 MiB        6714           for neighbor in current.neighbors:
    65    110.4 MiB      0.0 MiB        5968               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.4 MiB      0.0 MiB        2984                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.4 MiB      0.0 MiB        2984                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.4 MiB      0.0 MiB        5968               if temp_g_score < g_score[neighbor]:
    71    110.4 MiB      0.0 MiB        1095                   came_from[neighbor] = current
    72    110.4 MiB      0.0 MiB        1095                   g_score[neighbor] = temp_g_score
    73    110.4 MiB      0.0 MiB        1095                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.4 MiB      0.0 MiB        1095                   if neighbor not in open_set_hash:
    75    110.4 MiB      0.0 MiB        1095                       count += 1
    76    110.4 MiB      0.0 MiB        1095                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.4 MiB      0.0 MiB        1095                       open_set_hash.add(neighbor)
    78                                                             
    79    110.4 MiB      0.0 MiB         746           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.4 MiB      0.0 MiB         746           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.4 MiB    110.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.4 MiB      0.0 MiB         257       for row in grid:
    30    110.4 MiB      0.0 MiB       65792           for spot in row:
    31    110.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.4 MiB      0.0 MiB           1       count = 0
    34    110.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.4 MiB      0.0 MiB           1       came_from = {}
    37    112.4 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.6 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.6 MiB  -1649.9 MiB         858       while not open_set.empty():
    47    115.6 MiB  -1649.9 MiB         858           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.6 MiB  -1649.9 MiB         858           current = open_set.get()[2]
    53    115.6 MiB  -1649.9 MiB         858           open_set_hash.remove(current)
    54                                         
    55    115.6 MiB  -1649.9 MiB         858           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.6 MiB  -1649.9 MiB         858           if current == end:
    60    112.5 MiB     -3.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.6 MiB -14833.7 MiB        7713           for neighbor in current.neighbors:
    65    115.6 MiB -13184.1 MiB        6856               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.6 MiB  -6596.1 MiB        3428                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.6 MiB  -6588.5 MiB        3428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.6 MiB -13185.7 MiB        6856               if temp_g_score < g_score[neighbor]:
    71    115.6 MiB  -1969.6 MiB        1056                   came_from[neighbor] = current
    72    115.6 MiB  -1969.6 MiB        1056                   g_score[neighbor] = temp_g_score
    73    115.6 MiB  -1969.6 MiB        1056                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.6 MiB  -1969.6 MiB        1056                   if neighbor not in open_set_hash:
    75    115.6 MiB  -1969.6 MiB        1056                       count += 1
    76    115.6 MiB  -1969.7 MiB        1056                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.6 MiB  -1969.9 MiB        1056                       open_set_hash.add(neighbor)
    78                                                             
    79    115.6 MiB  -1649.9 MiB         857           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.6 MiB  -1649.9 MiB         857           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.5 MiB    112.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.5 MiB      0.0 MiB         257       for row in grid:
    30    112.5 MiB      0.0 MiB       65792           for spot in row:
    31    112.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.5 MiB      0.0 MiB           1       count = 0
    34    112.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.5 MiB      0.0 MiB           1       came_from = {}
    37    113.9 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.4 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.4 MiB      0.0 MiB         845       while not open_set.empty():
    47    114.4 MiB      0.0 MiB         845           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.4 MiB      0.0 MiB         845           current = open_set.get()[2]
    53    114.4 MiB      0.0 MiB         845           open_set_hash.remove(current)
    54                                         
    55    114.4 MiB      0.0 MiB         845           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.4 MiB      0.0 MiB         845           if current == end:
    60    114.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.4 MiB      0.0 MiB        7596           for neighbor in current.neighbors:
    65    114.4 MiB      0.0 MiB        6752               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.4 MiB      0.0 MiB        3376                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.4 MiB      0.0 MiB        3376                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.4 MiB      0.0 MiB        6752               if temp_g_score < g_score[neighbor]:
    71    114.4 MiB      0.0 MiB        1201                   came_from[neighbor] = current
    72    114.4 MiB      0.0 MiB        1201                   g_score[neighbor] = temp_g_score
    73    114.4 MiB      0.0 MiB        1201                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.4 MiB      0.0 MiB        1201                   if neighbor not in open_set_hash:
    75    114.4 MiB      0.0 MiB        1201                       count += 1
    76    114.4 MiB      0.0 MiB        1201                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.4 MiB      0.0 MiB        1201                       open_set_hash.add(neighbor)
    78                                                             
    79    114.4 MiB      0.0 MiB         844           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.4 MiB      0.0 MiB         844           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.7 MiB    115.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.7 MiB  -1071.8 MiB         257       for row in grid:
    30    115.7 MiB -274786.9 MiB       65792           for spot in row:
    31    115.7 MiB -273720.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.0 MiB     -6.7 MiB           1       count = 0
    34    109.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.0 MiB      0.0 MiB           1       came_from = {}
    37    110.4 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.9 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.9 MiB      0.0 MiB         770       while not open_set.empty():
    47    112.9 MiB      0.0 MiB         770           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.9 MiB      0.0 MiB         770           current = open_set.get()[2]
    53    112.9 MiB      0.0 MiB         770           open_set_hash.remove(current)
    54                                         
    55    112.9 MiB      0.0 MiB         770           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.9 MiB      0.0 MiB         770           if current == end:
    60    112.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.9 MiB      0.0 MiB        6921           for neighbor in current.neighbors:
    65    112.9 MiB      0.0 MiB        6152               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.9 MiB      0.0 MiB        3076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.9 MiB      0.0 MiB        3076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.9 MiB      0.0 MiB        6152               if temp_g_score < g_score[neighbor]:
    71    112.9 MiB      0.0 MiB        1016                   came_from[neighbor] = current
    72    112.9 MiB      0.0 MiB        1016                   g_score[neighbor] = temp_g_score
    73    112.9 MiB      0.0 MiB        1016                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.9 MiB      0.0 MiB        1016                   if neighbor not in open_set_hash:
    75    112.9 MiB      0.0 MiB        1016                       count += 1
    76    112.9 MiB      0.0 MiB        1016                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.9 MiB      0.0 MiB        1016                       open_set_hash.add(neighbor)
    78                                                             
    79    112.9 MiB      0.0 MiB         769           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.9 MiB      0.0 MiB         769           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.9 MiB    112.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.9 MiB   -375.2 MiB         257       for row in grid:
    30    112.9 MiB -96144.7 MiB       65792           for spot in row:
    31    112.9 MiB -95772.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.8 MiB     -4.1 MiB           1       count = 0
    34    108.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.8 MiB      0.0 MiB           1       came_from = {}
    37    111.6 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.5 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.5 MiB   -588.1 MiB        2001       while not open_set.empty():
    47    113.5 MiB   -588.1 MiB        2001           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.5 MiB   -588.1 MiB        2001           current = open_set.get()[2]
    53    113.5 MiB   -588.1 MiB        2001           open_set_hash.remove(current)
    54                                         
    55    113.5 MiB   -588.1 MiB        2001           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.5 MiB   -588.1 MiB        2001           if current == end:
    60    112.8 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.5 MiB  -5290.0 MiB       18000           for neighbor in current.neighbors:
    65    113.5 MiB  -4701.9 MiB       16000               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.5 MiB  -2351.5 MiB        8000                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.5 MiB  -2350.4 MiB        8000                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.5 MiB  -4702.2 MiB       16000               if temp_g_score < g_score[neighbor]:
    71    113.5 MiB   -688.8 MiB        2393                   came_from[neighbor] = current
    72    113.5 MiB   -688.8 MiB        2393                   g_score[neighbor] = temp_g_score
    73    113.5 MiB   -689.0 MiB        2393                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.5 MiB   -689.0 MiB        2393                   if neighbor not in open_set_hash:
    75    113.5 MiB   -689.0 MiB        2393                       count += 1
    76    113.5 MiB   -689.0 MiB        2393                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.5 MiB   -689.0 MiB        2393                       open_set_hash.add(neighbor)
    78                                                             
    79    113.5 MiB   -588.1 MiB        2000           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.5 MiB   -588.1 MiB        2000           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.8 MiB    112.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.8 MiB      0.0 MiB         257       for row in grid:
    30    112.8 MiB      0.0 MiB       65792           for spot in row:
    31    112.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.8 MiB      0.0 MiB           1       count = 0
    34    112.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.8 MiB      0.0 MiB           1       came_from = {}
    37    112.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.7 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.7 MiB  -4796.1 MiB        7303       while not open_set.empty():
    47    113.7 MiB  -4796.1 MiB        7303           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.7 MiB  -4796.1 MiB        7303           current = open_set.get()[2]
    53    113.7 MiB  -4796.1 MiB        7303           open_set_hash.remove(current)
    54                                         
    55    113.7 MiB  -4796.1 MiB        7303           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.7 MiB  -4796.1 MiB        7303           if current == end:
    60    113.0 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.7 MiB -43161.1 MiB       65718           for neighbor in current.neighbors:
    65    113.7 MiB -38365.5 MiB       58416               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.7 MiB -19184.1 MiB       29208                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.7 MiB -19181.4 MiB       29208                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.7 MiB -38365.6 MiB       58416               if temp_g_score < g_score[neighbor]:
    71    113.7 MiB  -5036.0 MiB        7787                   came_from[neighbor] = current
    72    113.7 MiB  -5036.0 MiB        7787                   g_score[neighbor] = temp_g_score
    73    113.7 MiB  -5036.0 MiB        7787                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.7 MiB  -5036.0 MiB        7787                   if neighbor not in open_set_hash:
    75    113.7 MiB  -5036.0 MiB        7787                       count += 1
    76    113.7 MiB  -5036.0 MiB        7787                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.7 MiB  -5036.0 MiB        7787                       open_set_hash.add(neighbor)
    78                                                             
    79    113.7 MiB  -4796.1 MiB        7302           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.7 MiB  -4796.1 MiB        7302           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.0 MiB    114.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.0 MiB      0.0 MiB         257       for row in grid:
    30    114.0 MiB      0.0 MiB       65792           for spot in row:
    31    114.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.0 MiB      0.0 MiB           1       count = 0
    34    114.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.0 MiB      0.0 MiB           1       came_from = {}
    37    114.1 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.9 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.9 MiB  -7309.6 MiB        2520       while not open_set.empty():
    47    114.9 MiB  -7310.1 MiB        2520           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.9 MiB  -7310.9 MiB        2520           current = open_set.get()[2]
    53    114.9 MiB  -7310.9 MiB        2520           open_set_hash.remove(current)
    54                                         
    55    114.9 MiB  -7310.9 MiB        2520           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.9 MiB  -7310.9 MiB        2520           if current == end:
    60    112.0 MiB     -2.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.9 MiB -65772.8 MiB       22671           for neighbor in current.neighbors:
    65    114.9 MiB -58464.0 MiB       20152               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.9 MiB -29231.9 MiB       10076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.9 MiB -29232.1 MiB       10076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.9 MiB -58464.9 MiB       20152               if temp_g_score < g_score[neighbor]:
    71    114.9 MiB  -8037.0 MiB        2806                   came_from[neighbor] = current
    72    114.9 MiB  -8037.0 MiB        2806                   g_score[neighbor] = temp_g_score
    73    114.9 MiB  -8037.0 MiB        2806                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.9 MiB  -8037.0 MiB        2806                   if neighbor not in open_set_hash:
    75    114.9 MiB  -8037.0 MiB        2806                       count += 1
    76    114.9 MiB  -8037.0 MiB        2806                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.9 MiB  -8037.0 MiB        2806                       open_set_hash.add(neighbor)
    78                                                             
    79    114.9 MiB  -7309.0 MiB        2519           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.9 MiB  -7309.2 MiB        2519           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.0 MiB    112.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.0 MiB      0.0 MiB         257       for row in grid:
    30    112.0 MiB      0.0 MiB       65792           for spot in row:
    31    112.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.0 MiB      0.0 MiB           1       count = 0
    34    112.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.0 MiB      0.0 MiB           1       came_from = {}
    37    112.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.6 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.6 MiB      0.0 MiB          64       while not open_set.empty():
    47    114.6 MiB      0.0 MiB          64           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.6 MiB      0.0 MiB          64           current = open_set.get()[2]
    53    114.6 MiB      0.0 MiB          64           open_set_hash.remove(current)
    54                                         
    55    114.6 MiB      0.0 MiB          64           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.6 MiB      0.0 MiB          64           if current == end:
    60    114.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.6 MiB      0.0 MiB         567           for neighbor in current.neighbors:
    65    114.6 MiB      0.0 MiB         504               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.6 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.6 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.6 MiB      0.0 MiB         504               if temp_g_score < g_score[neighbor]:
    71    114.6 MiB      0.0 MiB         134                   came_from[neighbor] = current
    72    114.6 MiB      0.0 MiB         134                   g_score[neighbor] = temp_g_score
    73    114.6 MiB      0.0 MiB         134                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.6 MiB      0.0 MiB         134                   if neighbor not in open_set_hash:
    75    114.6 MiB      0.0 MiB         134                       count += 1
    76    114.6 MiB      0.0 MiB         134                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.6 MiB      0.0 MiB         134                       open_set_hash.add(neighbor)
    78                                                             
    79    114.6 MiB      0.0 MiB          63           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.6 MiB      0.0 MiB          63           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.6 MiB    114.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.6 MiB    -43.5 MiB         257       for row in grid:
    30    114.6 MiB -10328.6 MiB       65792           for spot in row:
    31    114.6 MiB -10292.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.6 MiB    -10.0 MiB           1       count = 0
    34    104.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.6 MiB      0.0 MiB           1       came_from = {}
    37    104.9 MiB -594356.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.9 MiB    -10.0 MiB           1       g_score[start] = 0
    39     96.5 MiB -61318.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.4 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.0 MiB      0.0 MiB         222       while not open_set.empty():
    47     97.0 MiB      0.0 MiB         222           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.0 MiB      0.0 MiB         222           current = open_set.get()[2]
    53     97.0 MiB      0.0 MiB         222           open_set_hash.remove(current)
    54                                         
    55     97.0 MiB      0.0 MiB         222           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.0 MiB      0.0 MiB         222           if current == end:
    60     97.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.0 MiB      0.1 MiB        1989           for neighbor in current.neighbors:
    65     97.0 MiB      0.3 MiB        1768               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.0 MiB      0.0 MiB         884                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.0 MiB      0.0 MiB         884                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.0 MiB      0.0 MiB        1768               if temp_g_score < g_score[neighbor]:
    71     97.0 MiB      0.0 MiB         380                   came_from[neighbor] = current
    72     97.0 MiB      0.0 MiB         380                   g_score[neighbor] = temp_g_score
    73     97.0 MiB      0.0 MiB         380                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.0 MiB      0.0 MiB         380                   if neighbor not in open_set_hash:
    75     97.0 MiB      0.0 MiB         380                       count += 1
    76     97.0 MiB      0.1 MiB         380                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.0 MiB      0.0 MiB         380                       open_set_hash.add(neighbor)
    78                                                             
    79     97.0 MiB      0.0 MiB         221           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.0 MiB      0.0 MiB         221           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.6 MiB    107.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.6 MiB   -199.9 MiB         257       for row in grid:
    30    107.6 MiB -51177.8 MiB       65792           for spot in row:
    31    107.6 MiB -50979.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.0 MiB     -1.6 MiB           1       count = 0
    34    106.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.0 MiB      0.0 MiB           1       came_from = {}
    37    109.8 MiB -102360.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.9 MiB     -7.9 MiB           1       g_score[start] = 0
    39    103.1 MiB -95095.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.8 MiB     -4.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.9 MiB  -1785.7 MiB         387       while not open_set.empty():
    47     98.9 MiB  -1785.7 MiB         387           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.9 MiB  -1785.7 MiB         387           current = open_set.get()[2]
    53     98.9 MiB  -1785.7 MiB         387           open_set_hash.remove(current)
    54                                         
    55     98.9 MiB  -1785.7 MiB         387           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.9 MiB  -1786.0 MiB         387           if current == end:
    60     93.5 MiB     -5.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.9 MiB -16028.8 MiB        3474           for neighbor in current.neighbors:
    65     98.9 MiB -14248.4 MiB        3088               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.9 MiB  -7126.7 MiB        1544                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.9 MiB  -7121.7 MiB        1544                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.9 MiB -14248.3 MiB        3088               if temp_g_score < g_score[neighbor]:
    71     98.9 MiB  -2563.5 MiB         575                   came_from[neighbor] = current
    72     98.9 MiB  -2563.5 MiB         575                   g_score[neighbor] = temp_g_score
    73     98.9 MiB  -2563.5 MiB         575                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.9 MiB  -2563.5 MiB         575                   if neighbor not in open_set_hash:
    75     98.9 MiB  -2563.5 MiB         575                       count += 1
    76     98.9 MiB  -2563.5 MiB         575                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.9 MiB  -2563.5 MiB         575                       open_set_hash.add(neighbor)
    78                                                             
    79     98.9 MiB  -1785.7 MiB         386           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.9 MiB  -1785.7 MiB         386           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.7 MiB     93.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.8 MiB  -5428.3 MiB         257       for row in grid:
    30     94.8 MiB -1391505.6 MiB       65792           for spot in row:
    31     94.8 MiB -1386095.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.5 MiB    -28.3 MiB           1       count = 0
    34     66.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.5 MiB      0.0 MiB           1       came_from = {}
    37     71.5 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.0 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.0 MiB      0.0 MiB         432       while not open_set.empty():
    47     75.0 MiB      0.0 MiB         432           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.0 MiB      0.0 MiB         432           current = open_set.get()[2]
    53     75.0 MiB      0.0 MiB         432           open_set_hash.remove(current)
    54                                         
    55     75.0 MiB      0.0 MiB         432           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.0 MiB      0.0 MiB         432           if current == end:
    60     75.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.0 MiB      0.0 MiB        3879           for neighbor in current.neighbors:
    65     75.0 MiB      0.0 MiB        3448               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.0 MiB      0.0 MiB        1724                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.0 MiB      0.0 MiB        1724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.0 MiB      0.0 MiB        3448               if temp_g_score < g_score[neighbor]:
    71     75.0 MiB      0.0 MiB         662                   came_from[neighbor] = current
    72     75.0 MiB      0.0 MiB         662                   g_score[neighbor] = temp_g_score
    73     75.0 MiB      0.0 MiB         662                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.0 MiB      0.0 MiB         662                   if neighbor not in open_set_hash:
    75     75.0 MiB      0.0 MiB         662                       count += 1
    76     75.0 MiB      0.0 MiB         662                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.0 MiB      0.0 MiB         662                       open_set_hash.add(neighbor)
    78                                                             
    79     75.0 MiB      0.0 MiB         431           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.0 MiB      0.0 MiB         431           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.0 MiB     75.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.0 MiB  -4571.0 MiB         257       for row in grid:
    30     75.0 MiB -1170560.9 MiB       65792           for spot in row:
    31     75.0 MiB -1166018.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     33.7 MiB    -41.3 MiB           1       count = 0
    34     34.1 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     34.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     34.3 MiB      0.0 MiB           1       came_from = {}
    37     42.8 MiB      8.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     42.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     47.6 MiB      4.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     47.8 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     47.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     47.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     47.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     48.4 MiB  -1494.9 MiB        1708       while not open_set.empty():
    47     48.4 MiB  -1495.0 MiB        1708           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     48.4 MiB  -1495.0 MiB        1708           current = open_set.get()[2]
    53     48.4 MiB  -1495.0 MiB        1708           open_set_hash.remove(current)
    54                                         
    55     48.4 MiB  -1495.0 MiB        1708           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     48.4 MiB  -1495.0 MiB        1708           if current == end:
    60     47.5 MiB     -0.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     48.4 MiB -13447.6 MiB       15363           for neighbor in current.neighbors:
    65     48.4 MiB -11952.5 MiB       13656               if current.row != neighbor.row and current.col != neighbor.col:
    66     48.4 MiB  -5976.9 MiB        6828                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     48.4 MiB  -5976.1 MiB        6828                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     48.4 MiB -11953.0 MiB       13656               if temp_g_score < g_score[neighbor]:
    71     48.4 MiB  -1719.3 MiB        2006                   came_from[neighbor] = current
    72     48.4 MiB  -1719.3 MiB        2006                   g_score[neighbor] = temp_g_score
    73     48.4 MiB  -1719.3 MiB        2006                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     48.4 MiB  -1719.3 MiB        2006                   if neighbor not in open_set_hash:
    75     48.4 MiB  -1719.3 MiB        2006                       count += 1
    76     48.4 MiB  -1719.9 MiB        2006                       open_set.put((f_score[neighbor], count, neighbor))
    77     48.4 MiB  -1720.0 MiB        2006                       open_set_hash.add(neighbor)
    78                                                             
    79     48.4 MiB  -1494.9 MiB        1707           if draw is not None:
    80                                                     draw()
    81                                         
    82     48.4 MiB  -1494.9 MiB        1707           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.2 MiB     95.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.2 MiB    -30.1 MiB         257       for row in grid:
    30     95.2 MiB  -7712.8 MiB       65792           for spot in row:
    31     95.2 MiB  -7682.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.1 MiB     -0.1 MiB           1       count = 0
    34     95.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.1 MiB      0.0 MiB           1       came_from = {}
    37     99.7 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.5 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.6 MiB      0.0 MiB        3090       while not open_set.empty():
    47    102.6 MiB      0.0 MiB        3090           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.6 MiB      0.0 MiB        3090           current = open_set.get()[2]
    53    102.6 MiB      0.0 MiB        3090           open_set_hash.remove(current)
    54                                         
    55    102.6 MiB      0.0 MiB        3090           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.6 MiB      0.0 MiB        3090           if current == end:
    60    102.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.6 MiB      0.0 MiB       27801           for neighbor in current.neighbors:
    65    102.6 MiB      0.0 MiB       24712               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.6 MiB      0.0 MiB       12356                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.6 MiB      0.0 MiB       12356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.6 MiB      0.0 MiB       24712               if temp_g_score < g_score[neighbor]:
    71    102.6 MiB      0.0 MiB        3560                   came_from[neighbor] = current
    72    102.6 MiB      0.0 MiB        3560                   g_score[neighbor] = temp_g_score
    73    102.6 MiB      0.0 MiB        3560                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.6 MiB      0.0 MiB        3560                   if neighbor not in open_set_hash:
    75    102.6 MiB      0.0 MiB        3560                       count += 1
    76    102.6 MiB      0.0 MiB        3560                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.6 MiB      0.0 MiB        3560                       open_set_hash.add(neighbor)
    78                                                             
    79    102.6 MiB      0.0 MiB        3089           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.6 MiB      0.0 MiB        3089           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.6 MiB    102.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.6 MiB      0.0 MiB         257       for row in grid:
    30    102.6 MiB      0.0 MiB       65792           for spot in row:
    31    102.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.6 MiB      0.0 MiB           1       count = 0
    34    102.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.6 MiB      0.0 MiB           1       came_from = {}
    37    105.8 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.5 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.6 MiB      0.0 MiB        4450       while not open_set.empty():
    47    109.6 MiB      0.0 MiB        4450           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.6 MiB      0.0 MiB        4450           current = open_set.get()[2]
    53    109.6 MiB      0.0 MiB        4450           open_set_hash.remove(current)
    54                                         
    55    109.6 MiB      0.0 MiB        4450           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.6 MiB      0.0 MiB        4450           if current == end:
    60    109.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.6 MiB      0.0 MiB       40041           for neighbor in current.neighbors:
    65    109.6 MiB      0.0 MiB       35592               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.6 MiB      0.0 MiB       17796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.6 MiB      0.0 MiB       17796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.6 MiB      0.0 MiB       35592               if temp_g_score < g_score[neighbor]:
    71    109.6 MiB      0.0 MiB        4904                   came_from[neighbor] = current
    72    109.6 MiB      0.0 MiB        4904                   g_score[neighbor] = temp_g_score
    73    109.6 MiB      0.0 MiB        4904                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.6 MiB      0.0 MiB        4904                   if neighbor not in open_set_hash:
    75    109.6 MiB      0.0 MiB        4904                       count += 1
    76    109.6 MiB      0.0 MiB        4904                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.6 MiB      0.0 MiB        4904                       open_set_hash.add(neighbor)
    78                                                             
    79    109.6 MiB      0.0 MiB        4449           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.6 MiB      0.0 MiB        4449           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.6 MiB    109.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.6 MiB   -944.1 MiB         257       for row in grid:
    30    109.6 MiB -242080.3 MiB       65792           for spot in row:
    31    109.6 MiB -241138.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.6 MiB     -4.0 MiB           1       count = 0
    34    105.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.6 MiB      0.0 MiB           1       came_from = {}
    37    106.2 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.1 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.1 MiB -80869.1 MiB        7904       while not open_set.empty():
    47    109.1 MiB -80869.5 MiB        7904           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.1 MiB -80870.7 MiB        7904           current = open_set.get()[2]
    53    109.1 MiB -80870.9 MiB        7904           open_set_hash.remove(current)
    54                                         
    55    109.1 MiB -80871.3 MiB        7904           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.1 MiB -80871.4 MiB        7904           if current == end:
    60     87.9 MiB    -21.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     88.0 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.1 MiB -727720.5 MiB       71127           for neighbor in current.neighbors:
    65    109.1 MiB -646856.0 MiB       63224               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.1 MiB -323449.1 MiB       31612                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.1 MiB -323411.4 MiB       31612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.1 MiB -646863.5 MiB       63224               if temp_g_score < g_score[neighbor]:
    71    109.1 MiB -84939.0 MiB        8414                   came_from[neighbor] = current
    72    109.1 MiB -84939.4 MiB        8414                   g_score[neighbor] = temp_g_score
    73    109.1 MiB -84939.5 MiB        8414                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.1 MiB -84940.5 MiB        8414                   if neighbor not in open_set_hash:
    75    109.1 MiB -84940.9 MiB        8414                       count += 1
    76    109.1 MiB -84941.5 MiB        8414                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.1 MiB -84941.8 MiB        8414                       open_set_hash.add(neighbor)
    78                                                             
    79    109.1 MiB -80868.6 MiB        7903           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.1 MiB -80869.0 MiB        7903           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.8 MiB     97.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.8 MiB   -201.0 MiB         257       for row in grid:
    30     97.8 MiB -51130.1 MiB       65792           for spot in row:
    31     97.8 MiB -50932.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.7 MiB     -4.1 MiB           1       count = 0
    34     93.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.7 MiB      0.0 MiB           1       came_from = {}
    37     97.5 MiB   -115.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.4 MiB  -1631.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.4 MiB -13735.0 MiB        5880       while not open_set.empty():
    47    100.4 MiB -13735.1 MiB        5880           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.4 MiB -13735.2 MiB        5880           current = open_set.get()[2]
    53    100.4 MiB -13735.2 MiB        5880           open_set_hash.remove(current)
    54                                         
    55    100.4 MiB -13735.4 MiB        5880           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.4 MiB -13735.4 MiB        5880           if current == end:
    60     97.7 MiB     -2.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.4 MiB -123612.3 MiB       52911           for neighbor in current.neighbors:
    65    100.4 MiB -109878.8 MiB       47032               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.4 MiB -54940.1 MiB       23516                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.4 MiB -54939.2 MiB       23516                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.4 MiB -109879.6 MiB       47032               if temp_g_score < g_score[neighbor]:
    71    100.4 MiB -14486.3 MiB        6326                   came_from[neighbor] = current
    72    100.4 MiB -14486.3 MiB        6326                   g_score[neighbor] = temp_g_score
    73    100.4 MiB -14486.3 MiB        6326                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.4 MiB -14486.3 MiB        6326                   if neighbor not in open_set_hash:
    75    100.4 MiB -14486.3 MiB        6326                       count += 1
    76    100.4 MiB -14486.3 MiB        6326                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.4 MiB -14486.2 MiB        6326                       open_set_hash.add(neighbor)
    78                                                             
    79    100.4 MiB -13735.0 MiB        5879           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.4 MiB -13735.0 MiB        5879           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.7 MiB     97.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.7 MiB      0.0 MiB         257       for row in grid:
    30     97.7 MiB      0.0 MiB       65792           for spot in row:
    31     97.7 MiB      0.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.7 MiB      0.0 MiB           1       count = 0
    34     97.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.7 MiB      0.0 MiB           1       came_from = {}
    37     99.2 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.8 MiB -13080.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.8 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.8 MiB -16893.7 MiB        3186       while not open_set.empty():
    47    102.8 MiB -16894.1 MiB        3186           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.8 MiB -16897.1 MiB        3186           current = open_set.get()[2]
    53    102.8 MiB -16897.2 MiB        3186           open_set_hash.remove(current)
    54                                         
    55    102.8 MiB -16897.2 MiB        3186           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.8 MiB -16897.2 MiB        3186           if current == end:
    60     90.0 MiB    -12.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.8 MiB -152002.3 MiB       28665           for neighbor in current.neighbors:
    65    102.8 MiB -135110.5 MiB       25480               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.8 MiB -67566.8 MiB       12740                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.8 MiB -67545.4 MiB       12740                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.8 MiB -135113.8 MiB       25480               if temp_g_score < g_score[neighbor]:
    71    102.8 MiB -18210.6 MiB        3518                   came_from[neighbor] = current
    72    102.8 MiB -18210.8 MiB        3518                   g_score[neighbor] = temp_g_score
    73    102.8 MiB -18210.9 MiB        3518                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.8 MiB -18211.2 MiB        3518                   if neighbor not in open_set_hash:
    75    102.8 MiB -18211.2 MiB        3518                       count += 1
    76    102.8 MiB -18211.8 MiB        3518                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.8 MiB -18211.8 MiB        3518                       open_set_hash.add(neighbor)
    78                                                             
    79    102.8 MiB -16893.5 MiB        3185           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.8 MiB -16893.6 MiB        3185           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.9 MiB     90.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.0 MiB    -55.3 MiB         257       for row in grid:
    30     94.0 MiB -14228.5 MiB       65792           for spot in row:
    31     94.0 MiB -14171.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.0 MiB      0.0 MiB           1       count = 0
    34     94.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.0 MiB      0.0 MiB           1       came_from = {}
    37     95.6 MiB -1010201.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     54.0 MiB    -41.6 MiB           1       g_score[start] = 0
    39     58.5 MiB -11857.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     57.9 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     57.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     57.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     57.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     57.9 MiB  -8149.5 MiB        3364       while not open_set.empty():
    47     57.9 MiB  -8149.5 MiB        3364           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     57.9 MiB  -8149.5 MiB        3364           current = open_set.get()[2]
    53     57.9 MiB  -8149.5 MiB        3364           open_set_hash.remove(current)
    54                                         
    55     57.9 MiB  -8149.5 MiB        3364           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     57.9 MiB  -8149.5 MiB        3364           if current == end:
    60     55.4 MiB     -2.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     57.9 MiB -73335.0 MiB       30267           for neighbor in current.neighbors:
    65     57.9 MiB -65188.2 MiB       26904               if current.row != neighbor.row and current.col != neighbor.col:
    66     57.9 MiB -32594.2 MiB       13452                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     57.9 MiB -32594.0 MiB       13452                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     57.9 MiB -65188.2 MiB       26904               if temp_g_score < g_score[neighbor]:
    71     57.9 MiB  -8825.1 MiB        3710                   came_from[neighbor] = current
    72     57.9 MiB  -8825.1 MiB        3710                   g_score[neighbor] = temp_g_score
    73     57.9 MiB  -8825.1 MiB        3710                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     57.9 MiB  -8825.1 MiB        3710                   if neighbor not in open_set_hash:
    75     57.9 MiB  -8825.1 MiB        3710                       count += 1
    76     57.9 MiB  -8825.1 MiB        3710                       open_set.put((f_score[neighbor], count, neighbor))
    77     57.9 MiB  -8825.0 MiB        3710                       open_set_hash.add(neighbor)
    78                                                             
    79     57.9 MiB  -8148.4 MiB        3363           if draw is not None:
    80                                                     draw()
    81                                         
    82     57.9 MiB  -8149.5 MiB        3363           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.4 MiB     96.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.4 MiB      0.0 MiB         257       for row in grid:
    30     96.4 MiB      0.0 MiB       65792           for spot in row:
    31     96.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.4 MiB      0.0 MiB           1       count = 0
    34     96.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.4 MiB      0.0 MiB           1       came_from = {}
    37     98.3 MiB      1.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.2 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.3 MiB      0.0 MiB        6215       while not open_set.empty():
    47    100.3 MiB      0.0 MiB        6215           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.3 MiB      0.0 MiB        6215           current = open_set.get()[2]
    53    100.3 MiB      0.0 MiB        6215           open_set_hash.remove(current)
    54                                         
    55    100.3 MiB      0.0 MiB        6215           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.3 MiB      0.0 MiB        6215           if current == end:
    60    100.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.3 MiB      0.0 MiB       55926           for neighbor in current.neighbors:
    65    100.3 MiB      0.0 MiB       49712               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.3 MiB      0.0 MiB       24856                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.3 MiB      0.0 MiB       24856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.3 MiB      0.0 MiB       49712               if temp_g_score < g_score[neighbor]:
    71    100.3 MiB      0.1 MiB        6659                   came_from[neighbor] = current
    72    100.3 MiB      0.0 MiB        6659                   g_score[neighbor] = temp_g_score
    73    100.3 MiB      0.0 MiB        6659                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.3 MiB      0.0 MiB        6659                   if neighbor not in open_set_hash:
    75    100.3 MiB      0.0 MiB        6659                       count += 1
    76    100.3 MiB      0.0 MiB        6659                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.3 MiB      0.0 MiB        6659                       open_set_hash.add(neighbor)
    78                                                             
    79    100.3 MiB      0.0 MiB        6214           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.3 MiB      0.0 MiB        6214           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.3 MiB      0.0 MiB         257       for row in grid:
    30    100.3 MiB      0.0 MiB       65792           for spot in row:
    31    100.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.3 MiB      0.0 MiB           1       count = 0
    34    100.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.3 MiB      0.0 MiB           1       came_from = {}
    37    102.0 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.4 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.5 MiB      0.0 MiB         775       while not open_set.empty():
    47    104.5 MiB      0.0 MiB         775           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.5 MiB      0.0 MiB         775           current = open_set.get()[2]
    53    104.5 MiB      0.0 MiB         775           open_set_hash.remove(current)
    54                                         
    55    104.5 MiB      0.0 MiB         775           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.5 MiB      0.0 MiB         775           if current == end:
    60    104.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.5 MiB      0.0 MiB        6966           for neighbor in current.neighbors:
    65    104.5 MiB      0.0 MiB        6192               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.5 MiB      0.0 MiB        3096                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.5 MiB      0.0 MiB        3096                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.5 MiB      0.0 MiB        6192               if temp_g_score < g_score[neighbor]:
    71    104.5 MiB      0.1 MiB        1403                   came_from[neighbor] = current
    72    104.5 MiB      0.0 MiB        1403                   g_score[neighbor] = temp_g_score
    73    104.5 MiB      0.0 MiB        1403                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.5 MiB      0.0 MiB        1403                   if neighbor not in open_set_hash:
    75    104.5 MiB      0.0 MiB        1403                       count += 1
    76    104.5 MiB      0.0 MiB        1403                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.5 MiB      0.0 MiB        1403                       open_set_hash.add(neighbor)
    78                                                             
    79    104.5 MiB      0.0 MiB         774           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.5 MiB      0.0 MiB         774           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.5 MiB    104.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.5 MiB   -219.1 MiB         257       for row in grid:
    30    104.5 MiB -56113.1 MiB       65792           for spot in row:
    31    104.5 MiB -55896.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.9 MiB     -2.6 MiB           1       count = 0
    34    101.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.9 MiB      0.0 MiB           1       came_from = {}
    37    104.7 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.5 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.5 MiB      0.0 MiB         192       while not open_set.empty():
    47    106.5 MiB      0.0 MiB         192           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.5 MiB      0.0 MiB         192           current = open_set.get()[2]
    53    106.5 MiB      0.0 MiB         192           open_set_hash.remove(current)
    54                                         
    55    106.5 MiB      0.0 MiB         192           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.5 MiB      0.0 MiB         192           if current == end:
    60    106.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.5 MiB      0.0 MiB        1719           for neighbor in current.neighbors:
    65    106.5 MiB      0.0 MiB        1528               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.5 MiB      0.0 MiB         764                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.5 MiB      0.0 MiB         764                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.5 MiB      0.0 MiB        1528               if temp_g_score < g_score[neighbor]:
    71    106.5 MiB      0.0 MiB         270                   came_from[neighbor] = current
    72    106.5 MiB      0.0 MiB         270                   g_score[neighbor] = temp_g_score
    73    106.5 MiB      0.0 MiB         270                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.5 MiB      0.0 MiB         270                   if neighbor not in open_set_hash:
    75    106.5 MiB      0.0 MiB         270                       count += 1
    76    106.5 MiB      0.0 MiB         270                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.5 MiB      0.0 MiB         270                       open_set_hash.add(neighbor)
    78                                                             
    79    106.5 MiB      0.0 MiB         191           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.5 MiB      0.0 MiB         191           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.1 MiB    107.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.1 MiB      0.0 MiB         257       for row in grid:
    30    107.1 MiB      0.0 MiB       65792           for spot in row:
    31    107.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.1 MiB      0.0 MiB           1       count = 0
    34    107.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.1 MiB      0.0 MiB           1       came_from = {}
    37    110.6 MiB      3.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.8 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.8 MiB      0.0 MiB         234       while not open_set.empty():
    47    113.8 MiB      0.0 MiB         234           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.8 MiB      0.0 MiB         234           current = open_set.get()[2]
    53    113.8 MiB      0.0 MiB         234           open_set_hash.remove(current)
    54                                         
    55    113.8 MiB      0.0 MiB         234           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.8 MiB      0.0 MiB         234           if current == end:
    60    113.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.8 MiB      0.0 MiB        2097           for neighbor in current.neighbors:
    65    113.8 MiB      0.0 MiB        1864               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.8 MiB      0.0 MiB         932                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.8 MiB      0.0 MiB         932                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.8 MiB      0.0 MiB        1864               if temp_g_score < g_score[neighbor]:
    71    113.8 MiB      0.0 MiB         354                   came_from[neighbor] = current
    72    113.8 MiB      0.0 MiB         354                   g_score[neighbor] = temp_g_score
    73    113.8 MiB      0.0 MiB         354                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.8 MiB      0.0 MiB         354                   if neighbor not in open_set_hash:
    75    113.8 MiB      0.0 MiB         354                       count += 1
    76    113.8 MiB      0.0 MiB         354                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.8 MiB      0.0 MiB         354                       open_set_hash.add(neighbor)
    78                                                             
    79    113.8 MiB      0.0 MiB         233           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.8 MiB      0.0 MiB         233           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.8 MiB    113.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.8 MiB   -322.6 MiB         257       for row in grid:
    30    113.8 MiB -82610.1 MiB       65792           for spot in row:
    31    113.8 MiB -82289.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.9 MiB     -2.9 MiB           1       count = 0
    34    110.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.9 MiB      0.0 MiB           1       came_from = {}
    37    112.8 MiB      1.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.8 MiB  -5398.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.8 MiB   -535.2 MiB         596       while not open_set.empty():
    47    115.8 MiB   -535.2 MiB         596           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.8 MiB   -535.2 MiB         596           current = open_set.get()[2]
    53    115.8 MiB   -535.2 MiB         596           open_set_hash.remove(current)
    54                                         
    55    115.8 MiB   -535.2 MiB         596           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.8 MiB   -535.2 MiB         596           if current == end:
    60    114.3 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.8 MiB  -4809.9 MiB        5355           for neighbor in current.neighbors:
    65    115.8 MiB  -4275.2 MiB        4760               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.8 MiB  -2139.0 MiB        2380                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.8 MiB  -2136.4 MiB        2380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.8 MiB  -4275.9 MiB        4760               if temp_g_score < g_score[neighbor]:
    71    115.8 MiB   -802.9 MiB         908                   came_from[neighbor] = current
    72    115.8 MiB   -802.9 MiB         908                   g_score[neighbor] = temp_g_score
    73    115.8 MiB   -802.9 MiB         908                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.8 MiB   -802.9 MiB         908                   if neighbor not in open_set_hash:
    75    115.8 MiB   -802.9 MiB         908                       count += 1
    76    115.8 MiB   -802.9 MiB         908                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.8 MiB   -802.9 MiB         908                       open_set_hash.add(neighbor)
    78                                                             
    79    115.8 MiB   -534.9 MiB         595           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.8 MiB   -535.1 MiB         595           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.3 MiB    114.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.3 MiB    -59.9 MiB         257       for row in grid:
    30    114.3 MiB -15275.7 MiB       65792           for spot in row:
    31    114.3 MiB -15216.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.6 MiB     -0.7 MiB           1       count = 0
    34    113.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.6 MiB      0.0 MiB           1       came_from = {}
    37    114.5 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.1 MiB     -4.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.0 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.1 MiB -32030.4 MiB        5733       while not open_set.empty():
    47    118.1 MiB -32030.9 MiB        5733           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.1 MiB -32031.2 MiB        5733           current = open_set.get()[2]
    53    118.1 MiB -32031.6 MiB        5733           open_set_hash.remove(current)
    54                                         
    55    118.1 MiB -32032.0 MiB        5733           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.1 MiB -32032.6 MiB        5733           if current == end:
    60     95.0 MiB    -23.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.1 MiB -288168.0 MiB       51588           for neighbor in current.neighbors:
    65    118.1 MiB -256142.4 MiB       45856               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.1 MiB -128088.7 MiB       22928                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.1 MiB -128058.8 MiB       22928                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.1 MiB -256149.5 MiB       45856               if temp_g_score < g_score[neighbor]:
    71    118.1 MiB -34334.1 MiB        6221                   came_from[neighbor] = current
    72    118.1 MiB -34334.5 MiB        6221                   g_score[neighbor] = temp_g_score
    73    118.1 MiB -34335.3 MiB        6221                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.1 MiB -34335.7 MiB        6221                   if neighbor not in open_set_hash:
    75    118.1 MiB -34336.3 MiB        6221                       count += 1
    76    118.1 MiB -34337.6 MiB        6221                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.1 MiB -34338.7 MiB        6221                       open_set_hash.add(neighbor)
    78                                                             
    79    118.1 MiB -32030.1 MiB        5732           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.1 MiB -32030.2 MiB        5732           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.9 MiB     96.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.9 MiB   -915.0 MiB         257       for row in grid:
    30     96.9 MiB -234704.6 MiB       65792           for spot in row:
    31     96.9 MiB -233792.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.3 MiB     -3.6 MiB           1       count = 0
    34     93.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.3 MiB      0.0 MiB           1       came_from = {}
    37     97.1 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.2 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.3 MiB      0.0 MiB        3525       while not open_set.empty():
    47    100.3 MiB      0.0 MiB        3525           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.3 MiB      0.0 MiB        3525           current = open_set.get()[2]
    53    100.3 MiB      0.0 MiB        3525           open_set_hash.remove(current)
    54                                         
    55    100.3 MiB      0.0 MiB        3525           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.3 MiB      0.0 MiB        3525           if current == end:
    60    100.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.3 MiB      0.0 MiB       31716           for neighbor in current.neighbors:
    65    100.3 MiB      0.0 MiB       28192               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.3 MiB      0.0 MiB       14096                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.3 MiB      0.0 MiB       14096                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.3 MiB      0.0 MiB       28192               if temp_g_score < g_score[neighbor]:
    71    100.3 MiB      0.0 MiB        4137                   came_from[neighbor] = current
    72    100.3 MiB      0.0 MiB        4137                   g_score[neighbor] = temp_g_score
    73    100.3 MiB      0.0 MiB        4137                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.3 MiB      0.0 MiB        4137                   if neighbor not in open_set_hash:
    75    100.3 MiB      0.0 MiB        4137                       count += 1
    76    100.3 MiB      0.0 MiB        4137                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.3 MiB      0.0 MiB        4137                       open_set_hash.add(neighbor)
    78                                                             
    79    100.3 MiB      0.0 MiB        3524           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.3 MiB      0.0 MiB        3524           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.3 MiB      0.0 MiB         257       for row in grid:
    30    100.3 MiB      0.0 MiB       65792           for spot in row:
    31    100.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.3 MiB      0.0 MiB           1       count = 0
    34    100.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.3 MiB      0.0 MiB           1       came_from = {}
    37    101.6 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.8 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.8 MiB    -23.9 MiB        3381       while not open_set.empty():
    47    103.8 MiB    -23.9 MiB        3381           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.8 MiB    -23.9 MiB        3381           current = open_set.get()[2]
    53    103.8 MiB    -23.9 MiB        3381           open_set_hash.remove(current)
    54                                         
    55    103.8 MiB    -23.9 MiB        3381           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.8 MiB    -23.9 MiB        3381           if current == end:
    60    103.8 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.8 MiB   -214.5 MiB       30420           for neighbor in current.neighbors:
    65    103.8 MiB   -190.7 MiB       27040               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.8 MiB    -95.4 MiB       13520                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.8 MiB    -95.2 MiB       13520                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.8 MiB   -190.7 MiB       27040               if temp_g_score < g_score[neighbor]:
    71    103.8 MiB    -27.8 MiB        4013                   came_from[neighbor] = current
    72    103.8 MiB    -27.9 MiB        4013                   g_score[neighbor] = temp_g_score
    73    103.8 MiB    -27.9 MiB        4013                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.8 MiB    -27.9 MiB        4013                   if neighbor not in open_set_hash:
    75    103.8 MiB    -27.9 MiB        4013                       count += 1
    76    103.8 MiB    -27.9 MiB        4013                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.8 MiB    -27.9 MiB        4013                       open_set_hash.add(neighbor)
    78                                                             
    79    103.8 MiB    -23.9 MiB        3380           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.8 MiB    -23.9 MiB        3380           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.8 MiB    103.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.8 MiB  -1131.3 MiB         257       for row in grid:
    30    103.8 MiB -289205.5 MiB       65792           for spot in row:
    31    103.8 MiB -288082.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.6 MiB    -11.2 MiB           1       count = 0
    34     92.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.6 MiB      0.0 MiB           1       came_from = {}
    37     96.4 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.8 MiB   -949.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.7 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.8 MiB      0.0 MiB         448       while not open_set.empty():
    47     99.8 MiB      0.0 MiB         448           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.8 MiB      0.0 MiB         448           current = open_set.get()[2]
    53     99.8 MiB      0.0 MiB         448           open_set_hash.remove(current)
    54                                         
    55     99.8 MiB      0.0 MiB         448           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.8 MiB      0.0 MiB         448           if current == end:
    60     99.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.8 MiB      0.0 MiB        4023           for neighbor in current.neighbors:
    65     99.8 MiB      0.0 MiB        3576               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.8 MiB      0.0 MiB        1788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.8 MiB      0.0 MiB        1788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.8 MiB      0.0 MiB        3576               if temp_g_score < g_score[neighbor]:
    71     99.8 MiB      0.0 MiB         686                   came_from[neighbor] = current
    72     99.8 MiB      0.0 MiB         686                   g_score[neighbor] = temp_g_score
    73     99.8 MiB      0.0 MiB         686                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.8 MiB      0.0 MiB         686                   if neighbor not in open_set_hash:
    75     99.8 MiB      0.0 MiB         686                       count += 1
    76     99.8 MiB      0.0 MiB         686                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.8 MiB      0.0 MiB         686                       open_set_hash.add(neighbor)
    78                                                             
    79     99.8 MiB      0.0 MiB         447           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.8 MiB      0.0 MiB         447           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.4 MiB    100.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.4 MiB      0.0 MiB         257       for row in grid:
    30    100.4 MiB      0.0 MiB       65792           for spot in row:
    31    100.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.4 MiB      0.0 MiB           1       count = 0
    34    100.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.4 MiB      0.0 MiB           1       came_from = {}
    37    101.5 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.3 MiB   -435.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.2 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.5 MiB      0.0 MiB        5830       while not open_set.empty():
    47    103.5 MiB      0.0 MiB        5830           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.5 MiB      0.0 MiB        5830           current = open_set.get()[2]
    53    103.5 MiB      0.0 MiB        5830           open_set_hash.remove(current)
    54                                         
    55    103.5 MiB      0.0 MiB        5830           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.5 MiB      0.0 MiB        5830           if current == end:
    60    103.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.5 MiB      0.0 MiB       52461           for neighbor in current.neighbors:
    65    103.5 MiB      0.0 MiB       46632               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.5 MiB      0.0 MiB       23316                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.5 MiB      0.0 MiB       23316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.5 MiB      0.0 MiB       46632               if temp_g_score < g_score[neighbor]:
    71    103.5 MiB      0.2 MiB        6260                   came_from[neighbor] = current
    72    103.5 MiB      0.0 MiB        6260                   g_score[neighbor] = temp_g_score
    73    103.5 MiB      0.0 MiB        6260                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.5 MiB      0.0 MiB        6260                   if neighbor not in open_set_hash:
    75    103.5 MiB      0.0 MiB        6260                       count += 1
    76    103.5 MiB      0.0 MiB        6260                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.5 MiB      0.0 MiB        6260                       open_set_hash.add(neighbor)
    78                                                             
    79    103.5 MiB      0.0 MiB        5829           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.5 MiB      0.0 MiB        5829           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.5 MiB    103.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.5 MiB -10250.5 MiB         257       for row in grid:
    30    103.5 MiB -2630020.0 MiB       65792           for spot in row:
    31    103.5 MiB -2619804.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     48.4 MiB    -55.1 MiB           1       count = 0
    34     48.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     48.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     48.4 MiB      0.0 MiB           1       came_from = {}
    37     53.6 MiB      5.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     53.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     59.2 MiB      5.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     59.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     59.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     59.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     59.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.0 MiB  -1661.6 MiB        5502       while not open_set.empty():
    47     60.0 MiB  -1661.6 MiB        5502           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.0 MiB  -1661.6 MiB        5502           current = open_set.get()[2]
    53     60.0 MiB  -1661.6 MiB        5502           open_set_hash.remove(current)
    54                                         
    55     60.0 MiB  -1661.6 MiB        5502           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.0 MiB  -1661.6 MiB        5502           if current == end:
    60     59.0 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.0 MiB -14950.3 MiB       49509           for neighbor in current.neighbors:
    65     60.0 MiB -13289.2 MiB       44008               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.0 MiB  -6646.2 MiB       22004                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.0 MiB  -6643.2 MiB       22004                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.0 MiB -13290.0 MiB       44008               if temp_g_score < g_score[neighbor]:
    71     60.0 MiB  -1777.3 MiB        5930                   came_from[neighbor] = current
    72     60.0 MiB  -1777.5 MiB        5930                   g_score[neighbor] = temp_g_score
    73     60.0 MiB  -1777.5 MiB        5930                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.0 MiB  -1777.5 MiB        5930                   if neighbor not in open_set_hash:
    75     60.0 MiB  -1777.5 MiB        5930                       count += 1
    76     60.0 MiB  -1777.5 MiB        5930                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.0 MiB  -1777.4 MiB        5930                       open_set_hash.add(neighbor)
    78                                                             
    79     60.0 MiB  -1661.6 MiB        5501           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.0 MiB  -1661.6 MiB        5501           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     60.2 MiB     60.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.3 MiB   -155.5 MiB         257       for row in grid:
    30     61.3 MiB -39798.1 MiB       65792           for spot in row:
    31     61.3 MiB -39645.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.6 MiB     -0.7 MiB           1       count = 0
    34     60.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.6 MiB      0.0 MiB           1       came_from = {}
    37     61.7 MiB    -73.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.0 MiB  -1045.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.0 MiB  -8067.8 MiB        3315       while not open_set.empty():
    47     65.0 MiB  -8069.4 MiB        3315           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.0 MiB  -8069.4 MiB        3315           current = open_set.get()[2]
    53     65.0 MiB  -8069.4 MiB        3315           open_set_hash.remove(current)
    54                                         
    55     65.0 MiB  -8069.4 MiB        3315           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.0 MiB  -8069.4 MiB        3315           if current == end:
    60     61.4 MiB     -3.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.0 MiB -72596.9 MiB       29826           for neighbor in current.neighbors:
    65     65.0 MiB -64529.4 MiB       26512               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.0 MiB -32265.6 MiB       13256                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.0 MiB -32263.9 MiB       13256                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.0 MiB -64530.1 MiB       26512               if temp_g_score < g_score[neighbor]:
    71     65.0 MiB  -8697.0 MiB        3675                   came_from[neighbor] = current
    72     65.0 MiB  -8697.0 MiB        3675                   g_score[neighbor] = temp_g_score
    73     65.0 MiB  -8697.1 MiB        3675                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.0 MiB  -8697.2 MiB        3675                   if neighbor not in open_set_hash:
    75     65.0 MiB  -8698.0 MiB        3675                       count += 1
    76     65.0 MiB  -8698.0 MiB        3675                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.0 MiB  -8698.0 MiB        3675                       open_set_hash.add(neighbor)
    78                                                             
    79     65.0 MiB  -8067.6 MiB        3314           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.0 MiB  -8067.7 MiB        3314           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.5 MiB     99.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.5 MiB      0.0 MiB         257       for row in grid:
    30     99.5 MiB      0.0 MiB       65792           for spot in row:
    31     99.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.5 MiB      0.0 MiB           1       count = 0
    34     99.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.5 MiB      0.0 MiB           1       came_from = {}
    37    102.2 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.5 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.5 MiB      0.0 MiB         242       while not open_set.empty():
    47    103.5 MiB      0.0 MiB         242           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.5 MiB      0.0 MiB         242           current = open_set.get()[2]
    53    103.5 MiB      0.0 MiB         242           open_set_hash.remove(current)
    54                                         
    55    103.5 MiB      0.0 MiB         242           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.5 MiB      0.0 MiB         242           if current == end:
    60    103.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.5 MiB      0.0 MiB        2169           for neighbor in current.neighbors:
    65    103.5 MiB      0.0 MiB        1928               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.5 MiB      0.0 MiB         964                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.5 MiB      0.0 MiB         964                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.5 MiB      0.0 MiB        1928               if temp_g_score < g_score[neighbor]:
    71    103.5 MiB      0.0 MiB         490                   came_from[neighbor] = current
    72    103.5 MiB      0.0 MiB         490                   g_score[neighbor] = temp_g_score
    73    103.5 MiB      0.0 MiB         490                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.5 MiB      0.0 MiB         490                   if neighbor not in open_set_hash:
    75    103.5 MiB      0.0 MiB         490                       count += 1
    76    103.5 MiB      0.0 MiB         490                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.5 MiB      0.0 MiB         490                       open_set_hash.add(neighbor)
    78                                                             
    79    103.5 MiB      0.0 MiB         241           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.5 MiB      0.0 MiB         241           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.5 MiB    103.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.5 MiB      0.0 MiB         257       for row in grid:
    30    103.5 MiB      0.0 MiB       65792           for spot in row:
    31    103.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.5 MiB      0.0 MiB           1       count = 0
    34    103.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.5 MiB      0.0 MiB           1       came_from = {}
    37    105.1 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.1 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.1 MiB      0.0 MiB         110       while not open_set.empty():
    47    109.1 MiB      0.0 MiB         110           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.1 MiB      0.0 MiB         110           current = open_set.get()[2]
    53    109.1 MiB      0.0 MiB         110           open_set_hash.remove(current)
    54                                         
    55    109.1 MiB      0.0 MiB         110           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.1 MiB      0.0 MiB         110           if current == end:
    60    109.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.1 MiB      0.0 MiB         981           for neighbor in current.neighbors:
    65    109.1 MiB      0.0 MiB         872               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.1 MiB      0.0 MiB         436                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.1 MiB      0.0 MiB         436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.1 MiB      0.0 MiB         872               if temp_g_score < g_score[neighbor]:
    71    109.1 MiB      0.0 MiB         170                   came_from[neighbor] = current
    72    109.1 MiB      0.0 MiB         170                   g_score[neighbor] = temp_g_score
    73    109.1 MiB      0.0 MiB         170                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.1 MiB      0.0 MiB         170                   if neighbor not in open_set_hash:
    75    109.1 MiB      0.0 MiB         170                       count += 1
    76    109.1 MiB      0.0 MiB         170                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.1 MiB      0.0 MiB         170                       open_set_hash.add(neighbor)
    78                                                             
    79    109.1 MiB      0.0 MiB         109           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.1 MiB      0.0 MiB         109           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.1 MiB    109.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.1 MiB    -59.3 MiB         257       for row in grid:
    30    109.1 MiB -15206.6 MiB       65792           for spot in row:
    31    109.1 MiB -15147.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.4 MiB     -0.8 MiB           1       count = 0
    34    108.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.4 MiB      0.0 MiB           1       came_from = {}
    37    109.8 MiB -71463.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.8 MiB     -0.0 MiB           1       g_score[start] = 0
    39    112.1 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.1 MiB      0.0 MiB         560       while not open_set.empty():
    47    112.1 MiB      0.0 MiB         560           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.1 MiB      0.0 MiB         560           current = open_set.get()[2]
    53    112.1 MiB      0.0 MiB         560           open_set_hash.remove(current)
    54                                         
    55    112.1 MiB      0.0 MiB         560           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.1 MiB      0.0 MiB         560           if current == end:
    60    112.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.1 MiB      0.0 MiB        5031           for neighbor in current.neighbors:
    65    112.1 MiB      0.0 MiB        4472               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.1 MiB      0.0 MiB        2236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.1 MiB      0.0 MiB        2236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.1 MiB      0.0 MiB        4472               if temp_g_score < g_score[neighbor]:
    71    112.1 MiB      0.0 MiB         694                   came_from[neighbor] = current
    72    112.1 MiB      0.0 MiB         694                   g_score[neighbor] = temp_g_score
    73    112.1 MiB      0.0 MiB         694                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.1 MiB      0.0 MiB         694                   if neighbor not in open_set_hash:
    75    112.1 MiB      0.0 MiB         694                       count += 1
    76    112.1 MiB      0.0 MiB         694                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.1 MiB      0.0 MiB         694                       open_set_hash.add(neighbor)
    78                                                             
    79    112.1 MiB      0.0 MiB         559           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.1 MiB      0.0 MiB         559           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.6 MiB    112.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.6 MiB      0.0 MiB         257       for row in grid:
    30    112.6 MiB      0.0 MiB       65792           for spot in row:
    31    112.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.6 MiB      0.0 MiB           1       count = 0
    34    112.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.6 MiB      0.0 MiB           1       came_from = {}
    37    113.2 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.2 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.2 MiB    -73.9 MiB        1050       while not open_set.empty():
    47    115.2 MiB    -73.9 MiB        1050           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.2 MiB    -73.9 MiB        1050           current = open_set.get()[2]
    53    115.2 MiB    -73.9 MiB        1050           open_set_hash.remove(current)
    54                                         
    55    115.2 MiB    -73.9 MiB        1050           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.2 MiB    -73.9 MiB        1050           if current == end:
    60    115.1 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.2 MiB   -664.0 MiB        9441           for neighbor in current.neighbors:
    65    115.2 MiB   -590.2 MiB        8392               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.2 MiB   -295.1 MiB        4196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.2 MiB   -295.1 MiB        4196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.2 MiB   -590.2 MiB        8392               if temp_g_score < g_score[neighbor]:
    71    115.2 MiB   -132.7 MiB        1898                   came_from[neighbor] = current
    72    115.2 MiB   -132.7 MiB        1898                   g_score[neighbor] = temp_g_score
    73    115.2 MiB   -132.7 MiB        1898                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.2 MiB   -132.7 MiB        1898                   if neighbor not in open_set_hash:
    75    115.2 MiB   -132.7 MiB        1898                       count += 1
    76    115.2 MiB   -132.7 MiB        1898                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.2 MiB   -132.7 MiB        1898                       open_set_hash.add(neighbor)
    78                                                             
    79    115.2 MiB    -73.8 MiB        1049           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.2 MiB    -73.8 MiB        1049           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.1 MiB    115.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.1 MiB   -440.9 MiB         257       for row in grid:
    30    115.1 MiB -112972.1 MiB       65792           for spot in row:
    31    115.1 MiB -112532.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.0 MiB     -2.1 MiB           1       count = 0
    34    113.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.0 MiB      0.0 MiB           1       came_from = {}
    37    113.9 MiB      0.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.8 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.8 MiB -49676.5 MiB        9230       while not open_set.empty():
    47    115.8 MiB -49676.5 MiB        9230           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.8 MiB -49676.7 MiB        9230           current = open_set.get()[2]
    53    115.8 MiB -49676.7 MiB        9230           open_set_hash.remove(current)
    54                                         
    55    115.8 MiB -49676.9 MiB        9230           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.8 MiB -49676.9 MiB        9230           if current == end:
    60    104.8 MiB    -11.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.8 MiB -447039.8 MiB       83061           for neighbor in current.neighbors:
    65    115.8 MiB -397366.8 MiB       73832               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.8 MiB -198695.5 MiB       36916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.8 MiB -198672.9 MiB       36916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.8 MiB -397369.9 MiB       73832               if temp_g_score < g_score[neighbor]:
    71    115.8 MiB -51870.1 MiB        9772                   came_from[neighbor] = current
    72    115.8 MiB -51870.2 MiB        9772                   g_score[neighbor] = temp_g_score
    73    115.8 MiB -51870.4 MiB        9772                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.8 MiB -51870.8 MiB        9772                   if neighbor not in open_set_hash:
    75    115.8 MiB -51871.3 MiB        9772                       count += 1
    76    115.8 MiB -51872.1 MiB        9772                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.8 MiB -51872.2 MiB        9772                       open_set_hash.add(neighbor)
    78                                                             
    79    115.8 MiB -49676.4 MiB        9229           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.8 MiB -49676.4 MiB        9229           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.8 MiB    104.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.8 MiB   -427.7 MiB         257       for row in grid:
    30    104.8 MiB -109331.6 MiB       65792           for spot in row:
    31    104.8 MiB -108906.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.2 MiB     -2.5 MiB           1       count = 0
    34    102.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.2 MiB      0.0 MiB           1       came_from = {}
    37    102.8 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.1 MiB -123673.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.7 MiB     -6.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.7 MiB -70132.3 MiB        1674       while not open_set.empty():
    47     97.7 MiB -70132.9 MiB        1674           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.7 MiB -70144.3 MiB        1674           current = open_set.get()[2]
    53     97.7 MiB -70145.1 MiB        1674           open_set_hash.remove(current)
    54                                         
    55     97.7 MiB -70146.0 MiB        1674           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.7 MiB -70146.5 MiB        1674           if current == end:
    60     25.4 MiB    -72.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     25.6 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.7 MiB -630926.5 MiB       15057           for neighbor in current.neighbors:
    65     97.7 MiB -560813.0 MiB       13384               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.7 MiB -280476.6 MiB        6692                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.7 MiB -280344.1 MiB        6692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.7 MiB -560828.6 MiB       13384               if temp_g_score < g_score[neighbor]:
    71     97.7 MiB -79187.1 MiB        1950                   came_from[neighbor] = current
    72     97.7 MiB -79188.8 MiB        1950                   g_score[neighbor] = temp_g_score
    73     97.7 MiB -79190.5 MiB        1950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.7 MiB -79193.3 MiB        1950                   if neighbor not in open_set_hash:
    75     97.7 MiB -79194.2 MiB        1950                       count += 1
    76     97.7 MiB -79197.2 MiB        1950                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.7 MiB -79199.0 MiB        1950                       open_set_hash.add(neighbor)
    78                                                             
    79     97.7 MiB -70129.2 MiB        1673           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.7 MiB -70129.8 MiB        1673           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.8 MiB     93.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.8 MiB   -673.7 MiB         257       for row in grid:
    30     93.8 MiB -172392.3 MiB       65792           for spot in row:
    31     93.8 MiB -171721.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.1 MiB     -4.7 MiB           1       count = 0
    34     89.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     89.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     89.5 MiB      0.0 MiB           1       came_from = {}
    37     91.8 MiB -168492.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     79.6 MiB    -12.2 MiB           1       g_score[start] = 0
    39     80.0 MiB -2647174.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     36.6 MiB    -43.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     36.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     36.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     36.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     40.3 MiB   -968.6 MiB        5481       while not open_set.empty():
    47     40.3 MiB   -968.7 MiB        5481           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     40.3 MiB   -968.8 MiB        5481           current = open_set.get()[2]
    53     40.3 MiB   -969.1 MiB        5481           open_set_hash.remove(current)
    54                                         
    55     40.3 MiB   -969.3 MiB        5481           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     40.3 MiB   -969.3 MiB        5481           if current == end:
    60     40.1 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     40.2 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     40.3 MiB  -8727.1 MiB       49320           for neighbor in current.neighbors:
    65     40.3 MiB  -7756.4 MiB       43840               if current.row != neighbor.row and current.col != neighbor.col:
    66     40.3 MiB  -3880.6 MiB       21920                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     40.3 MiB  -3878.2 MiB       21920                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     40.3 MiB  -7759.5 MiB       43840               if temp_g_score < g_score[neighbor]:
    71     40.3 MiB  -1031.8 MiB        5953                   came_from[neighbor] = current
    72     40.3 MiB  -1032.0 MiB        5953                   g_score[neighbor] = temp_g_score
    73     40.3 MiB  -1032.5 MiB        5953                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     40.3 MiB  -1032.6 MiB        5953                   if neighbor not in open_set_hash:
    75     40.3 MiB  -1032.6 MiB        5953                       count += 1
    76     40.3 MiB  -1032.5 MiB        5953                       open_set.put((f_score[neighbor], count, neighbor))
    77     40.3 MiB  -1032.7 MiB        5953                       open_set_hash.add(neighbor)
    78                                                             
    79     40.3 MiB   -970.9 MiB        5480           if draw is not None:
    80                                                     draw()
    81                                         
    82     40.3 MiB   -968.7 MiB        5480           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     43.1 MiB     43.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     54.8 MiB   -189.4 MiB         257       for row in grid:
    30     54.8 MiB -48629.7 MiB       65792           for spot in row:
    31     54.8 MiB -48428.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     53.4 MiB     -1.5 MiB           1       count = 0
    34     53.4 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     53.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     53.4 MiB      0.0 MiB           1       came_from = {}
    37     57.2 MiB  -9456.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.2 MiB     -0.0 MiB           1       g_score[start] = 0
    39     62.6 MiB  -6138.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.8 MiB     -1.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.1 MiB    -72.8 MiB        1512       while not open_set.empty():
    47     61.1 MiB    -72.8 MiB        1512           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.1 MiB    -72.8 MiB        1512           current = open_set.get()[2]
    53     61.1 MiB    -72.8 MiB        1512           open_set_hash.remove(current)
    54                                         
    55     61.1 MiB    -72.8 MiB        1512           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.1 MiB    -72.8 MiB        1512           if current == end:
    60     60.9 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.1 MiB   -659.0 MiB       13599           for neighbor in current.neighbors:
    65     61.1 MiB   -586.3 MiB       12088               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.1 MiB   -293.3 MiB        6044                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.1 MiB   -293.2 MiB        6044                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.1 MiB   -586.5 MiB       12088               if temp_g_score < g_score[neighbor]:
    71     61.1 MiB    -86.2 MiB        1782                   came_from[neighbor] = current
    72     61.1 MiB    -86.4 MiB        1782                   g_score[neighbor] = temp_g_score
    73     61.1 MiB    -86.4 MiB        1782                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.1 MiB    -86.4 MiB        1782                   if neighbor not in open_set_hash:
    75     61.1 MiB    -86.4 MiB        1782                       count += 1
    76     61.1 MiB    -86.4 MiB        1782                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.1 MiB    -86.3 MiB        1782                       open_set_hash.add(neighbor)
    78                                                             
    79     61.1 MiB    -73.3 MiB        1511           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.1 MiB    -72.8 MiB        1511           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.0 MiB     61.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.2 MiB   -131.6 MiB         257       for row in grid:
    30     61.2 MiB -32123.4 MiB       65792           for spot in row:
    31     61.2 MiB -31996.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.5 MiB     -8.7 MiB           1       count = 0
    34     52.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     52.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     52.9 MiB      0.0 MiB           1       came_from = {}
    37     53.5 MiB -1032410.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     26.5 MiB    -27.0 MiB           1       g_score[start] = 0
    39     32.2 MiB  -8607.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     31.9 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     31.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     31.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     31.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     40.2 MiB    -46.3 MiB        3942       while not open_set.empty():
    47     40.2 MiB    -46.3 MiB        3942           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     40.2 MiB    -46.3 MiB        3942           current = open_set.get()[2]
    53     40.2 MiB    -46.3 MiB        3942           open_set_hash.remove(current)
    54                                         
    55     40.2 MiB    -46.4 MiB        3942           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     40.2 MiB    -46.5 MiB        3942           if current == end:
    60     40.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     40.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     40.2 MiB   -415.2 MiB       35469           for neighbor in current.neighbors:
    65     40.2 MiB   -366.2 MiB       31528               if current.row != neighbor.row and current.col != neighbor.col:
    66     40.2 MiB   -185.6 MiB       15764                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     40.2 MiB   -185.7 MiB       15764                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     40.2 MiB   -371.3 MiB       31528               if temp_g_score < g_score[neighbor]:
    71     40.2 MiB    -52.3 MiB        4302                   came_from[neighbor] = current
    72     40.2 MiB    -52.7 MiB        4302                   g_score[neighbor] = temp_g_score
    73     40.2 MiB    -52.7 MiB        4302                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     40.2 MiB    -52.7 MiB        4302                   if neighbor not in open_set_hash:
    75     40.2 MiB    -52.7 MiB        4302                       count += 1
    76     40.2 MiB    -52.5 MiB        4302                       open_set.put((f_score[neighbor], count, neighbor))
    77     40.2 MiB    -52.6 MiB        4302                       open_set_hash.add(neighbor)
    78                                                             
    79     40.2 MiB    -46.3 MiB        3941           if draw is not None:
    80                                                     draw()
    81                                         
    82     40.2 MiB    -46.3 MiB        3941           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.8 MiB     89.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     89.8 MiB     -5.0 MiB         257       for row in grid:
    30     89.8 MiB  -1286.2 MiB       65792           for spot in row:
    31     89.8 MiB  -1281.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.8 MiB     -0.0 MiB           1       count = 0
    34     89.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     89.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     89.8 MiB      0.0 MiB           1       came_from = {}
    37     94.2 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.3 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.5 MiB     -5.1 MiB        7015       while not open_set.empty():
    47     97.5 MiB     -5.1 MiB        7015           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.5 MiB     -5.1 MiB        7015           current = open_set.get()[2]
    53     97.5 MiB     -5.1 MiB        7015           open_set_hash.remove(current)
    54                                         
    55     97.5 MiB     -5.1 MiB        7015           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.5 MiB     -5.1 MiB        7015           if current == end:
    60     97.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.5 MiB    -45.8 MiB       63126           for neighbor in current.neighbors:
    65     97.5 MiB    -40.7 MiB       56112               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.5 MiB    -20.4 MiB       28056                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.5 MiB    -20.3 MiB       28056                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.5 MiB    -40.7 MiB       56112               if temp_g_score < g_score[neighbor]:
    71     97.5 MiB     -5.0 MiB        7487                   came_from[neighbor] = current
    72     97.5 MiB     -5.2 MiB        7487                   g_score[neighbor] = temp_g_score
    73     97.5 MiB     -5.2 MiB        7487                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.5 MiB     -5.2 MiB        7487                   if neighbor not in open_set_hash:
    75     97.5 MiB     -5.2 MiB        7487                       count += 1
    76     97.5 MiB     -5.2 MiB        7487                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.5 MiB     -5.2 MiB        7487                       open_set_hash.add(neighbor)
    78                                                             
    79     97.5 MiB     -5.1 MiB        7014           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.5 MiB     -5.1 MiB        7014           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.5 MiB     97.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.5 MiB  -3233.6 MiB         257       for row in grid:
    30     97.5 MiB -829642.8 MiB       65792           for spot in row:
    31     97.5 MiB -826419.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     82.0 MiB    -15.6 MiB           1       count = 0
    34     82.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     82.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     82.0 MiB      0.0 MiB           1       came_from = {}
    37     84.6 MiB -859845.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     50.8 MiB    -33.8 MiB           1       g_score[start] = 0
    39     53.7 MiB -140865.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     47.2 MiB     -6.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     47.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     47.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     47.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     47.8 MiB -12470.3 MiB        4536       while not open_set.empty():
    47     47.8 MiB -12470.5 MiB        4536           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     47.8 MiB -12470.8 MiB        4536           current = open_set.get()[2]
    53     47.8 MiB -12471.1 MiB        4536           open_set_hash.remove(current)
    54                                         
    55     47.8 MiB -12471.1 MiB        4536           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     47.8 MiB -12471.2 MiB        4536           if current == end:
    60     44.9 MiB     -2.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     45.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     47.8 MiB -112220.6 MiB       40815           for neighbor in current.neighbors:
    65     47.8 MiB -99750.9 MiB       36280               if current.row != neighbor.row and current.col != neighbor.col:
    66     47.8 MiB -49878.4 MiB       18140                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     47.8 MiB -49874.2 MiB       18140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     47.8 MiB -99752.1 MiB       36280               if temp_g_score < g_score[neighbor]:
    71     47.8 MiB -13481.7 MiB        4970                   came_from[neighbor] = current
    72     47.8 MiB -13481.8 MiB        4970                   g_score[neighbor] = temp_g_score
    73     47.8 MiB -13481.8 MiB        4970                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     47.8 MiB -13481.8 MiB        4970                   if neighbor not in open_set_hash:
    75     47.8 MiB -13481.8 MiB        4970                       count += 1
    76     47.8 MiB -13481.8 MiB        4970                       open_set.put((f_score[neighbor], count, neighbor))
    77     47.8 MiB -13481.8 MiB        4970                       open_set_hash.add(neighbor)
    78                                                             
    79     47.8 MiB -12470.7 MiB        4535           if draw is not None:
    80                                                     draw()
    81                                         
    82     47.8 MiB -12470.2 MiB        4535           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     48.6 MiB     48.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     52.1 MiB      0.0 MiB         257       for row in grid:
    30     52.1 MiB      0.0 MiB       65792           for spot in row:
    31     52.1 MiB      3.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.1 MiB      0.0 MiB           1       count = 0
    34     52.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.1 MiB      0.0 MiB           1       came_from = {}
    37     54.4 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     54.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     58.6 MiB      4.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     58.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     58.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     58.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     58.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.2 MiB      0.0 MiB        6016       while not open_set.empty():
    47     59.2 MiB      0.0 MiB        6016           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.2 MiB      0.0 MiB        6016           current = open_set.get()[2]
    53     59.2 MiB      0.0 MiB        6016           open_set_hash.remove(current)
    54                                         
    55     59.2 MiB      0.0 MiB        6016           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.2 MiB      0.0 MiB        6016           if current == end:
    60     59.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.2 MiB      0.0 MiB       54135           for neighbor in current.neighbors:
    65     59.2 MiB      0.0 MiB       48120               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.2 MiB      0.0 MiB       24060                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.2 MiB      0.0 MiB       24060                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.2 MiB      0.0 MiB       48120               if temp_g_score < g_score[neighbor]:
    71     59.2 MiB      0.5 MiB        6458                   came_from[neighbor] = current
    72     59.2 MiB      0.0 MiB        6458                   g_score[neighbor] = temp_g_score
    73     59.2 MiB      0.0 MiB        6458                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.2 MiB      0.0 MiB        6458                   if neighbor not in open_set_hash:
    75     59.2 MiB      0.0 MiB        6458                       count += 1
    76     59.2 MiB      0.0 MiB        6458                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.2 MiB      0.1 MiB        6458                       open_set_hash.add(neighbor)
    78                                                             
    79     59.2 MiB      0.0 MiB        6015           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.2 MiB      0.0 MiB        6015           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.7 MiB     98.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.7 MiB      0.0 MiB         257       for row in grid:
    30     98.7 MiB      0.0 MiB       65792           for spot in row:
    31     98.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.7 MiB      0.0 MiB           1       count = 0
    34     98.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.7 MiB      0.0 MiB           1       came_from = {}
    37    100.3 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.2 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.2 MiB      0.0 MiB         605       while not open_set.empty():
    47    103.2 MiB      0.0 MiB         605           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.2 MiB      0.0 MiB         605           current = open_set.get()[2]
    53    103.2 MiB      0.0 MiB         605           open_set_hash.remove(current)
    54                                         
    55    103.2 MiB      0.0 MiB         605           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.2 MiB      0.0 MiB         605           if current == end:
    60    103.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.2 MiB      0.0 MiB        5436           for neighbor in current.neighbors:
    65    103.2 MiB      0.0 MiB        4832               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.2 MiB      0.0 MiB        2416                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.2 MiB      0.0 MiB        2416                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.2 MiB      0.0 MiB        4832               if temp_g_score < g_score[neighbor]:
    71    103.2 MiB      0.0 MiB         865                   came_from[neighbor] = current
    72    103.2 MiB      0.0 MiB         865                   g_score[neighbor] = temp_g_score
    73    103.2 MiB      0.0 MiB         865                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.2 MiB      0.0 MiB         865                   if neighbor not in open_set_hash:
    75    103.2 MiB      0.0 MiB         865                       count += 1
    76    103.2 MiB      0.0 MiB         865                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.2 MiB      0.0 MiB         865                       open_set_hash.add(neighbor)
    78                                                             
    79    103.2 MiB      0.0 MiB         604           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.2 MiB      0.0 MiB         604           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.2 MiB    103.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.2 MiB   -501.9 MiB         257       for row in grid:
    30    103.2 MiB -128230.5 MiB       65792           for spot in row:
    31    103.2 MiB -127732.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.4 MiB     -3.9 MiB           1       count = 0
    34     99.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.4 MiB      0.0 MiB           1       came_from = {}
    37    103.9 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.8 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.0 MiB      0.0 MiB        3055       while not open_set.empty():
    47    105.0 MiB      0.0 MiB        3055           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.0 MiB      0.0 MiB        3055           current = open_set.get()[2]
    53    105.0 MiB      0.0 MiB        3055           open_set_hash.remove(current)
    54                                         
    55    105.0 MiB      0.0 MiB        3055           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.0 MiB      0.0 MiB        3055           if current == end:
    60    105.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.0 MiB      0.0 MiB       27486           for neighbor in current.neighbors:
    65    105.0 MiB      0.0 MiB       24432               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.0 MiB      0.0 MiB       12216                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.0 MiB      0.0 MiB       12216                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.0 MiB      0.0 MiB       24432               if temp_g_score < g_score[neighbor]:
    71    105.0 MiB      0.1 MiB        3407                   came_from[neighbor] = current
    72    105.0 MiB      0.0 MiB        3407                   g_score[neighbor] = temp_g_score
    73    105.0 MiB      0.0 MiB        3407                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.0 MiB      0.0 MiB        3407                   if neighbor not in open_set_hash:
    75    105.0 MiB      0.0 MiB        3407                       count += 1
    76    105.0 MiB      0.0 MiB        3407                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.0 MiB      0.0 MiB        3407                       open_set_hash.add(neighbor)
    78                                                             
    79    105.0 MiB      0.0 MiB        3054           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.0 MiB      0.0 MiB        3054           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.0 MiB    105.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.0 MiB   -347.3 MiB         257       for row in grid:
    30    105.0 MiB -86599.0 MiB       65792           for spot in row:
    31    105.0 MiB -86261.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.5 MiB    -13.5 MiB           1       count = 0
    34     91.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.5 MiB      0.0 MiB           1       came_from = {}
    37     93.3 MiB -58838.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     89.4 MiB     -3.9 MiB           1       g_score[start] = 0
    39     89.4 MiB -2065972.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     45.5 MiB    -43.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     45.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     45.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     45.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     47.4 MiB    -90.6 MiB         370       while not open_set.empty():
    47     47.4 MiB    -90.7 MiB         370           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     47.4 MiB    -90.6 MiB         370           current = open_set.get()[2]
    53     47.4 MiB    -90.7 MiB         370           open_set_hash.remove(current)
    54                                         
    55     47.4 MiB    -90.7 MiB         370           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     47.4 MiB    -90.7 MiB         370           if current == end:
    60     47.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     47.4 MiB   -810.9 MiB        3321           for neighbor in current.neighbors:
    65     47.4 MiB   -719.4 MiB        2952               if current.row != neighbor.row and current.col != neighbor.col:
    66     47.4 MiB   -361.4 MiB        1476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     47.4 MiB   -359.0 MiB        1476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     47.4 MiB   -720.4 MiB        2952               if temp_g_score < g_score[neighbor]:
    71     47.4 MiB   -127.7 MiB         536                   came_from[neighbor] = current
    72     47.4 MiB   -127.8 MiB         536                   g_score[neighbor] = temp_g_score
    73     47.4 MiB   -127.8 MiB         536                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     47.4 MiB   -127.8 MiB         536                   if neighbor not in open_set_hash:
    75     47.4 MiB   -127.8 MiB         536                       count += 1
    76     47.4 MiB   -127.6 MiB         536                       open_set.put((f_score[neighbor], count, neighbor))
    77     47.4 MiB   -127.7 MiB         536                       open_set_hash.add(neighbor)
    78                                                             
    79     47.4 MiB    -90.7 MiB         369           if draw is not None:
    80                                                     draw()
    81                                         
    82     47.4 MiB    -90.7 MiB         369           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.2 MiB     93.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.2 MiB   -748.6 MiB         257       for row in grid:
    30     93.2 MiB -191705.5 MiB       65792           for spot in row:
    31     93.2 MiB -190963.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     86.3 MiB     -7.0 MiB           1       count = 0
    34     86.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     86.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     86.3 MiB      0.0 MiB           1       came_from = {}
    37     90.9 MiB  -5727.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     90.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.6 MiB  -1263.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.1 MiB    -56.2 MiB        4557       while not open_set.empty():
    47     95.1 MiB    -56.2 MiB        4557           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.1 MiB    -56.2 MiB        4557           current = open_set.get()[2]
    53     95.1 MiB    -56.2 MiB        4557           open_set_hash.remove(current)
    54                                         
    55     95.1 MiB    -56.2 MiB        4557           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.1 MiB    -56.2 MiB        4557           if current == end:
    60     94.9 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.1 MiB   -505.5 MiB       41004           for neighbor in current.neighbors:
    65     95.1 MiB   -449.2 MiB       36448               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.1 MiB   -224.9 MiB       18224                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.1 MiB   -224.4 MiB       18224                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.1 MiB   -449.5 MiB       36448               if temp_g_score < g_score[neighbor]:
    71     95.1 MiB    -63.9 MiB        4937                   came_from[neighbor] = current
    72     95.1 MiB    -64.2 MiB        4937                   g_score[neighbor] = temp_g_score
    73     95.1 MiB    -64.2 MiB        4937                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.1 MiB    -64.2 MiB        4937                   if neighbor not in open_set_hash:
    75     95.1 MiB    -64.2 MiB        4937                       count += 1
    76     95.1 MiB    -64.2 MiB        4937                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.1 MiB    -64.1 MiB        4937                       open_set_hash.add(neighbor)
    78                                                             
    79     95.1 MiB    -56.2 MiB        4556           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.1 MiB    -56.2 MiB        4556           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.9 MiB     94.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.1 MiB    -73.1 MiB         257       for row in grid:
    30     95.1 MiB -18622.6 MiB       65792           for spot in row:
    31     95.1 MiB -18550.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.5 MiB     -1.6 MiB           1       count = 0
    34     93.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.5 MiB      0.0 MiB           1       came_from = {}
    37     95.1 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.0 MiB      3.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.1 MiB    -27.6 MiB        5500       while not open_set.empty():
    47     99.1 MiB    -27.6 MiB        5500           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.1 MiB    -27.6 MiB        5500           current = open_set.get()[2]
    53     99.1 MiB    -27.6 MiB        5500           open_set_hash.remove(current)
    54                                         
    55     99.1 MiB    -27.6 MiB        5500           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.1 MiB    -27.6 MiB        5500           if current == end:
    60     99.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.1 MiB   -248.2 MiB       49491           for neighbor in current.neighbors:
    65     99.1 MiB   -220.6 MiB       43992               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.1 MiB   -110.3 MiB       21996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.1 MiB   -110.3 MiB       21996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.1 MiB   -220.7 MiB       43992               if temp_g_score < g_score[neighbor]:
    71     99.1 MiB    -28.8 MiB        5924                   came_from[neighbor] = current
    72     99.1 MiB    -28.8 MiB        5924                   g_score[neighbor] = temp_g_score
    73     99.1 MiB    -28.8 MiB        5924                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.1 MiB    -28.8 MiB        5924                   if neighbor not in open_set_hash:
    75     99.1 MiB    -28.8 MiB        5924                       count += 1
    76     99.1 MiB    -28.8 MiB        5924                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.1 MiB    -28.8 MiB        5924                       open_set_hash.add(neighbor)
    78                                                             
    79     99.1 MiB    -27.6 MiB        5499           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.1 MiB    -27.6 MiB        5499           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.1 MiB     99.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.1 MiB   -129.0 MiB         257       for row in grid:
    30     99.1 MiB -32738.8 MiB       65792           for spot in row:
    31     99.1 MiB -32612.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.7 MiB     -4.4 MiB           1       count = 0
    34     94.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.7 MiB      0.0 MiB           1       came_from = {}
    37     94.8 MiB -157903.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     89.8 MiB     -5.0 MiB           1       g_score[start] = 0
    39     91.8 MiB -1382327.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     59.1 MiB    -32.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     59.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     59.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     59.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.0 MiB    -75.5 MiB        4770       while not open_set.empty():
    47     60.0 MiB    -75.5 MiB        4770           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.0 MiB    -75.5 MiB        4770           current = open_set.get()[2]
    53     60.0 MiB    -75.5 MiB        4770           open_set_hash.remove(current)
    54                                         
    55     60.0 MiB    -75.5 MiB        4770           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.0 MiB    -75.5 MiB        4770           if current == end:
    60     60.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.0 MiB   -679.8 MiB       42921           for neighbor in current.neighbors:
    65     60.0 MiB   -603.9 MiB       38152               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.0 MiB   -302.2 MiB       19076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.0 MiB   -302.1 MiB       19076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.0 MiB   -604.4 MiB       38152               if temp_g_score < g_score[neighbor]:
    71     60.0 MiB    -80.5 MiB        5160                   came_from[neighbor] = current
    72     60.0 MiB    -80.5 MiB        5160                   g_score[neighbor] = temp_g_score
    73     60.0 MiB    -80.5 MiB        5160                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.0 MiB    -80.5 MiB        5160                   if neighbor not in open_set_hash:
    75     60.0 MiB    -80.5 MiB        5160                       count += 1
    76     60.0 MiB    -80.1 MiB        5160                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.0 MiB    -80.4 MiB        5160                       open_set_hash.add(neighbor)
    78                                                             
    79     60.0 MiB    -75.5 MiB        4769           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.0 MiB    -75.5 MiB        4769           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.9 MiB     97.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.9 MiB      0.0 MiB         257       for row in grid:
    30     97.9 MiB      0.0 MiB       65792           for spot in row:
    31     97.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.9 MiB      0.0 MiB           1       count = 0
    34     97.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.9 MiB      0.0 MiB           1       came_from = {}
    37    101.0 MiB   -202.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.1 MiB      1.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.1 MiB      0.0 MiB         480       while not open_set.empty():
    47    102.1 MiB      0.0 MiB         480           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.1 MiB      0.0 MiB         480           current = open_set.get()[2]
    53    102.1 MiB      0.0 MiB         480           open_set_hash.remove(current)
    54                                         
    55    102.1 MiB      0.0 MiB         480           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.1 MiB      0.0 MiB         480           if current == end:
    60    102.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.1 MiB      0.0 MiB        4311           for neighbor in current.neighbors:
    65    102.1 MiB      0.0 MiB        3832               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.1 MiB      0.0 MiB        1916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.1 MiB      0.0 MiB        1916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.1 MiB      0.0 MiB        3832               if temp_g_score < g_score[neighbor]:
    71    102.1 MiB      0.0 MiB         606                   came_from[neighbor] = current
    72    102.1 MiB      0.0 MiB         606                   g_score[neighbor] = temp_g_score
    73    102.1 MiB      0.0 MiB         606                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.1 MiB      0.0 MiB         606                   if neighbor not in open_set_hash:
    75    102.1 MiB      0.0 MiB         606                       count += 1
    76    102.1 MiB      0.0 MiB         606                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.1 MiB      0.0 MiB         606                       open_set_hash.add(neighbor)
    78                                                             
    79    102.1 MiB      0.0 MiB         479           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.1 MiB      0.0 MiB         479           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.1 MiB    102.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.1 MiB  -1214.5 MiB         257       for row in grid:
    30    102.1 MiB -310932.2 MiB       65792           for spot in row:
    31    102.1 MiB -309722.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.0 MiB     -6.1 MiB           1       count = 0
    34     96.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.0 MiB      0.0 MiB           1       came_from = {}
    37    100.3 MiB  -1863.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.8 MiB -49188.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.3 MiB     -3.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.4 MiB      0.0 MiB         594       while not open_set.empty():
    47     98.4 MiB      0.0 MiB         594           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.4 MiB      0.0 MiB         594           current = open_set.get()[2]
    53     98.4 MiB      0.0 MiB         594           open_set_hash.remove(current)
    54                                         
    55     98.4 MiB      0.0 MiB         594           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.4 MiB      0.0 MiB         594           if current == end:
    60     98.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.4 MiB      0.0 MiB        5337           for neighbor in current.neighbors:
    65     98.4 MiB      0.0 MiB        4744               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.4 MiB      0.0 MiB        2372                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.4 MiB      0.0 MiB        2372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.4 MiB      0.0 MiB        4744               if temp_g_score < g_score[neighbor]:
    71     98.4 MiB      0.1 MiB         814                   came_from[neighbor] = current
    72     98.4 MiB      0.0 MiB         814                   g_score[neighbor] = temp_g_score
    73     98.4 MiB      0.0 MiB         814                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.4 MiB      0.0 MiB         814                   if neighbor not in open_set_hash:
    75     98.4 MiB      0.0 MiB         814                       count += 1
    76     98.4 MiB      0.0 MiB         814                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.4 MiB      0.0 MiB         814                       open_set_hash.add(neighbor)
    78                                                             
    79     98.4 MiB      0.0 MiB         593           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.4 MiB      0.0 MiB         593           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.4 MiB     98.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.4 MiB    -59.3 MiB         257       for row in grid:
    30     98.4 MiB -15187.0 MiB       65792           for spot in row:
    31     98.4 MiB -15128.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.0 MiB     -0.4 MiB           1       count = 0
    34     98.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.0 MiB      0.0 MiB           1       came_from = {}
    37    101.7 MiB  -1170.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.2 MiB   -263.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.2 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.2 MiB      0.0 MiB        2067       while not open_set.empty():
    47    105.2 MiB      0.0 MiB        2067           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.2 MiB      0.0 MiB        2067           current = open_set.get()[2]
    53    105.2 MiB      0.0 MiB        2067           open_set_hash.remove(current)
    54                                         
    55    105.2 MiB      0.0 MiB        2067           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.2 MiB      0.0 MiB        2067           if current == end:
    60    105.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.2 MiB      0.0 MiB       18594           for neighbor in current.neighbors:
    65    105.2 MiB      0.0 MiB       16528               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.2 MiB      0.0 MiB        8264                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.2 MiB      0.0 MiB        8264                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.2 MiB      0.0 MiB       16528               if temp_g_score < g_score[neighbor]:
    71    105.2 MiB      0.0 MiB        2327                   came_from[neighbor] = current
    72    105.2 MiB      0.0 MiB        2327                   g_score[neighbor] = temp_g_score
    73    105.2 MiB      0.0 MiB        2327                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.2 MiB      0.0 MiB        2327                   if neighbor not in open_set_hash:
    75    105.2 MiB      0.0 MiB        2327                       count += 1
    76    105.2 MiB      0.0 MiB        2327                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.2 MiB      0.0 MiB        2327                       open_set_hash.add(neighbor)
    78                                                             
    79    105.2 MiB      0.0 MiB        2066           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.2 MiB      0.0 MiB        2066           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB   -467.6 MiB         257       for row in grid:
    30    106.2 MiB -119875.8 MiB       65792           for spot in row:
    31    106.2 MiB -119408.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.7 MiB     -3.5 MiB           1       count = 0
    34    102.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.7 MiB      0.0 MiB           1       came_from = {}
    37    103.1 MiB      0.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.3 MiB -55887.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.6 MiB     -2.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.6 MiB  -1601.9 MiB        2808       while not open_set.empty():
    47    103.6 MiB  -1601.9 MiB        2808           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.6 MiB  -1601.9 MiB        2808           current = open_set.get()[2]
    53    103.6 MiB  -1601.9 MiB        2808           open_set_hash.remove(current)
    54                                         
    55    103.6 MiB  -1601.9 MiB        2808           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.6 MiB  -1601.9 MiB        2808           if current == end:
    60    102.2 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.6 MiB -14413.0 MiB       25263           for neighbor in current.neighbors:
    65    103.6 MiB -12811.2 MiB       22456               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.6 MiB  -6406.9 MiB       11228                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.6 MiB  -6405.4 MiB       11228                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.6 MiB -12812.5 MiB       22456               if temp_g_score < g_score[neighbor]:
    71    103.6 MiB  -1866.1 MiB        3322                   came_from[neighbor] = current
    72    103.6 MiB  -1866.1 MiB        3322                   g_score[neighbor] = temp_g_score
    73    103.6 MiB  -1866.1 MiB        3322                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.6 MiB  -1866.1 MiB        3322                   if neighbor not in open_set_hash:
    75    103.6 MiB  -1866.1 MiB        3322                       count += 1
    76    103.6 MiB  -1866.1 MiB        3322                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.6 MiB  -1866.1 MiB        3322                       open_set_hash.add(neighbor)
    78                                                             
    79    103.6 MiB  -1601.7 MiB        2807           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.6 MiB  -1601.9 MiB        2807           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.2 MiB    102.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.2 MiB     -5.2 MiB         257       for row in grid:
    30    102.2 MiB  -1327.1 MiB       65792           for spot in row:
    31    102.2 MiB  -1321.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.1 MiB     -0.0 MiB           1       count = 0
    34    102.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.1 MiB      0.0 MiB           1       came_from = {}
    37    103.3 MiB  -3245.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.5 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.5 MiB      0.0 MiB         147       while not open_set.empty():
    47    103.5 MiB      0.0 MiB         147           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.5 MiB      0.0 MiB         147           current = open_set.get()[2]
    53    103.5 MiB      0.0 MiB         147           open_set_hash.remove(current)
    54                                         
    55    103.5 MiB      0.0 MiB         147           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.5 MiB      0.0 MiB         147           if current == end:
    60    103.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.5 MiB      0.0 MiB        1314           for neighbor in current.neighbors:
    65    103.5 MiB      0.0 MiB        1168               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.5 MiB      0.0 MiB         584                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.5 MiB      0.0 MiB         584                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.5 MiB      0.0 MiB        1168               if temp_g_score < g_score[neighbor]:
    71    103.5 MiB      0.0 MiB         215                   came_from[neighbor] = current
    72    103.5 MiB      0.0 MiB         215                   g_score[neighbor] = temp_g_score
    73    103.5 MiB      0.0 MiB         215                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.5 MiB      0.0 MiB         215                   if neighbor not in open_set_hash:
    75    103.5 MiB      0.0 MiB         215                       count += 1
    76    103.5 MiB      0.0 MiB         215                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.5 MiB      0.0 MiB         215                       open_set_hash.add(neighbor)
    78                                                             
    79    103.5 MiB      0.0 MiB         146           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.5 MiB      0.0 MiB         146           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.5 MiB    103.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.5 MiB   -808.9 MiB         257       for row in grid:
    30    103.5 MiB -207522.9 MiB       65792           for spot in row:
    31    103.5 MiB -206718.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.3 MiB     -6.1 MiB           1       count = 0
    34     97.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.3 MiB      0.0 MiB           1       came_from = {}
    37     97.3 MiB -326516.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     90.5 MiB     -6.8 MiB           1       g_score[start] = 0
    39     94.3 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.3 MiB -14952.7 MiB        6848       while not open_set.empty():
    47     94.3 MiB -14953.0 MiB        6848           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.3 MiB -14953.8 MiB        6848           current = open_set.get()[2]
    53     94.3 MiB -14954.0 MiB        6848           open_set_hash.remove(current)
    54                                         
    55     94.3 MiB -14954.2 MiB        6848           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.3 MiB -14954.2 MiB        6848           if current == end:
    60     80.7 MiB    -13.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     80.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.3 MiB -134492.5 MiB       61623           for neighbor in current.neighbors:
    65     94.3 MiB -119543.7 MiB       54776               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.3 MiB -59781.1 MiB       27388                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.3 MiB -59764.2 MiB       27388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.3 MiB -119546.8 MiB       54776               if temp_g_score < g_score[neighbor]:
    71     94.3 MiB -16176.9 MiB        7316                   came_from[neighbor] = current
    72     94.3 MiB -16177.7 MiB        7316                   g_score[neighbor] = temp_g_score
    73     94.3 MiB -16178.3 MiB        7316                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.3 MiB -16178.6 MiB        7316                   if neighbor not in open_set_hash:
    75     94.3 MiB -16179.0 MiB        7316                       count += 1
    76     94.3 MiB -16179.5 MiB        7316                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.3 MiB -16179.9 MiB        7316                       open_set_hash.add(neighbor)
    78                                                             
    79     94.3 MiB -14952.0 MiB        6847           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.3 MiB -14952.2 MiB        6847           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.9 MiB     96.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.9 MiB    -38.5 MiB         257       for row in grid:
    30     96.9 MiB  -9872.0 MiB       65792           for spot in row:
    31     96.9 MiB  -9833.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.7 MiB     -0.2 MiB           1       count = 0
    34     96.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.7 MiB      0.0 MiB           1       came_from = {}
    37     98.8 MiB  -9397.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.1 MiB      3.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.2 MiB -27270.5 MiB        9548       while not open_set.empty():
    47    102.2 MiB -27271.5 MiB        9548           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.2 MiB -27271.8 MiB        9548           current = open_set.get()[2]
    53    102.2 MiB -27271.9 MiB        9548           open_set_hash.remove(current)
    54                                         
    55    102.2 MiB -27272.0 MiB        9548           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.2 MiB -27272.0 MiB        9548           if current == end:
    60     96.7 MiB     -5.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.2 MiB -244333.4 MiB       85695           for neighbor in current.neighbors:
    65    102.2 MiB -217064.6 MiB       76148               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.2 MiB -108356.4 MiB       38036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.2 MiB -108708.3 MiB       38112                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.2 MiB -217064.8 MiB       76148               if temp_g_score < g_score[neighbor]:
    71    102.2 MiB -28404.1 MiB       10118                   came_from[neighbor] = current
    72    102.2 MiB -28404.2 MiB       10118                   g_score[neighbor] = temp_g_score
    73    102.2 MiB -28404.2 MiB       10118                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.2 MiB -28404.2 MiB       10118                   if neighbor not in open_set_hash:
    75    102.2 MiB -28404.2 MiB       10118                       count += 1
    76    102.2 MiB -28405.1 MiB       10118                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.2 MiB -28405.6 MiB       10118                       open_set_hash.add(neighbor)
    78                                                             
    79    102.2 MiB -27269.0 MiB        9547           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.2 MiB -27269.0 MiB        9547           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.7 MiB     96.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.9 MiB      0.0 MiB         257       for row in grid:
    30     96.9 MiB      0.0 MiB       65792           for spot in row:
    31     96.9 MiB      0.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.9 MiB      0.0 MiB           1       count = 0
    34     96.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.9 MiB      0.0 MiB           1       came_from = {}
    37     97.8 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.2 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.2 MiB      0.0 MiB        1014       while not open_set.empty():
    47    100.2 MiB      0.0 MiB        1014           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.2 MiB      0.0 MiB        1014           current = open_set.get()[2]
    53    100.2 MiB      0.0 MiB        1014           open_set_hash.remove(current)
    54                                         
    55    100.2 MiB      0.0 MiB        1014           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.2 MiB      0.0 MiB        1014           if current == end:
    60    100.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.2 MiB      0.0 MiB        9117           for neighbor in current.neighbors:
    65    100.2 MiB      0.0 MiB        8104               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.2 MiB      0.0 MiB        4052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.2 MiB      0.0 MiB        4052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.2 MiB      0.0 MiB        8104               if temp_g_score < g_score[neighbor]:
    71    100.2 MiB      0.0 MiB        1220                   came_from[neighbor] = current
    72    100.2 MiB      0.0 MiB        1220                   g_score[neighbor] = temp_g_score
    73    100.2 MiB      0.0 MiB        1220                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.2 MiB      0.0 MiB        1220                   if neighbor not in open_set_hash:
    75    100.2 MiB      0.0 MiB        1220                       count += 1
    76    100.2 MiB      0.0 MiB        1220                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.2 MiB      0.0 MiB        1220                       open_set_hash.add(neighbor)
    78                                                             
    79    100.2 MiB      0.0 MiB        1013           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.2 MiB      0.0 MiB        1013           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.2 MiB    100.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.2 MiB      0.0 MiB         257       for row in grid:
    30    100.2 MiB      0.0 MiB       65792           for spot in row:
    31    100.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.2 MiB      0.0 MiB           1       count = 0
    34    100.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.2 MiB      0.0 MiB           1       came_from = {}
    37    100.8 MiB -113106.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.6 MiB     -2.2 MiB           1       g_score[start] = 0
    39    102.7 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.7 MiB  -1516.6 MiB        2444       while not open_set.empty():
    47    102.7 MiB  -1516.6 MiB        2444           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.7 MiB  -1516.6 MiB        2444           current = open_set.get()[2]
    53    102.7 MiB  -1516.6 MiB        2444           open_set_hash.remove(current)
    54                                         
    55    102.7 MiB  -1516.6 MiB        2444           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.7 MiB  -1516.6 MiB        2444           if current == end:
    60    102.0 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.7 MiB -13646.1 MiB       21987           for neighbor in current.neighbors:
    65    102.7 MiB -12129.8 MiB       19544               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.7 MiB  -6065.9 MiB        9772                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.7 MiB  -6064.0 MiB        9772                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.7 MiB -12129.8 MiB       19544               if temp_g_score < g_score[neighbor]:
    71    102.7 MiB  -1675.3 MiB        2734                   came_from[neighbor] = current
    72    102.7 MiB  -1675.4 MiB        2734                   g_score[neighbor] = temp_g_score
    73    102.7 MiB  -1675.4 MiB        2734                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.7 MiB  -1675.4 MiB        2734                   if neighbor not in open_set_hash:
    75    102.7 MiB  -1675.5 MiB        2734                       count += 1
    76    102.7 MiB  -1675.5 MiB        2734                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.7 MiB  -1675.5 MiB        2734                       open_set_hash.add(neighbor)
    78                                                             
    79    102.7 MiB  -1516.6 MiB        2443           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.7 MiB  -1516.6 MiB        2443           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.8 MiB    106.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.8 MiB  -2587.1 MiB         257       for row in grid:
    30    106.8 MiB -663703.0 MiB       65792           for spot in row:
    31    106.8 MiB -661125.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.3 MiB    -12.5 MiB           1       count = 0
    34     94.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.3 MiB      0.0 MiB           1       came_from = {}
    37     96.9 MiB -166949.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     87.5 MiB     -9.4 MiB           1       g_score[start] = 0
    39     87.7 MiB -1966455.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     54.2 MiB    -33.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     54.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     54.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     54.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.7 MiB   -310.1 MiB        1170       while not open_set.empty():
    47     55.7 MiB   -310.2 MiB        1170           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.7 MiB   -310.2 MiB        1170           current = open_set.get()[2]
    53     55.7 MiB   -310.3 MiB        1170           open_set_hash.remove(current)
    54                                         
    55     55.7 MiB   -310.3 MiB        1170           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.7 MiB   -310.3 MiB        1170           if current == end:
    60     53.4 MiB     -2.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     53.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.7 MiB  -2783.0 MiB       10521           for neighbor in current.neighbors:
    65     55.7 MiB  -2472.5 MiB        9352               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.7 MiB  -1238.4 MiB        4676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.7 MiB  -1235.9 MiB        4676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.7 MiB  -2474.4 MiB        9352               if temp_g_score < g_score[neighbor]:
    71     55.7 MiB   -373.4 MiB        1366                   came_from[neighbor] = current
    72     55.7 MiB   -373.5 MiB        1366                   g_score[neighbor] = temp_g_score
    73     55.7 MiB   -373.5 MiB        1366                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.7 MiB   -373.6 MiB        1366                   if neighbor not in open_set_hash:
    75     55.7 MiB   -373.6 MiB        1366                       count += 1
    76     55.7 MiB   -373.8 MiB        1366                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.7 MiB   -373.7 MiB        1366                       open_set_hash.add(neighbor)
    78                                                             
    79     55.7 MiB   -310.1 MiB        1169           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.7 MiB   -310.1 MiB        1169           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     56.1 MiB     56.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.3 MiB   -159.7 MiB         257       for row in grid:
    30     58.3 MiB -40315.0 MiB       65792           for spot in row:
    31     58.3 MiB -40157.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     55.3 MiB     -2.9 MiB           1       count = 0
    34     55.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     55.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     55.4 MiB      0.0 MiB           1       came_from = {}
    37     59.2 MiB  -7604.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.6 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.7 MiB      0.0 MiB        1044       while not open_set.empty():
    47     61.7 MiB      0.0 MiB        1044           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.7 MiB      0.0 MiB        1044           current = open_set.get()[2]
    53     61.7 MiB      0.0 MiB        1044           open_set_hash.remove(current)
    54                                         
    55     61.7 MiB      0.0 MiB        1044           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.7 MiB      0.0 MiB        1044           if current == end:
    60     61.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.7 MiB      0.0 MiB        9387           for neighbor in current.neighbors:
    65     61.7 MiB      0.0 MiB        8344               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.7 MiB      0.0 MiB        4172                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.7 MiB      0.0 MiB        4172                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.7 MiB      0.0 MiB        8344               if temp_g_score < g_score[neighbor]:
    71     61.7 MiB      0.0 MiB        1310                   came_from[neighbor] = current
    72     61.7 MiB      0.0 MiB        1310                   g_score[neighbor] = temp_g_score
    73     61.7 MiB      0.0 MiB        1310                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.7 MiB      0.0 MiB        1310                   if neighbor not in open_set_hash:
    75     61.7 MiB      0.0 MiB        1310                       count += 1
    76     61.7 MiB      0.1 MiB        1310                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.7 MiB      0.0 MiB        1310                       open_set_hash.add(neighbor)
    78                                                             
    79     61.7 MiB      0.0 MiB        1043           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.7 MiB      0.0 MiB        1043           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.7 MiB     61.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.7 MiB      0.0 MiB         257       for row in grid:
    30     61.7 MiB      0.0 MiB       65792           for spot in row:
    31     61.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.7 MiB      0.0 MiB           1       count = 0
    34     61.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.8 MiB      0.0 MiB           1       came_from = {}
    37     63.4 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.7 MiB -32751.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.2 MiB     -1.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.2 MiB      0.0 MiB        1176       while not open_set.empty():
    47     64.2 MiB      0.0 MiB        1176           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.2 MiB      0.0 MiB        1176           current = open_set.get()[2]
    53     64.2 MiB      0.0 MiB        1176           open_set_hash.remove(current)
    54                                         
    55     64.2 MiB      0.0 MiB        1176           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.2 MiB      0.0 MiB        1176           if current == end:
    60     64.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.2 MiB      0.0 MiB       10575           for neighbor in current.neighbors:
    65     64.2 MiB      0.0 MiB        9400               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.2 MiB      0.0 MiB        4700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.2 MiB      0.0 MiB        4700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.2 MiB      0.0 MiB        9400               if temp_g_score < g_score[neighbor]:
    71     64.2 MiB      0.0 MiB        1370                   came_from[neighbor] = current
    72     64.2 MiB      0.0 MiB        1370                   g_score[neighbor] = temp_g_score
    73     64.2 MiB      0.0 MiB        1370                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.2 MiB      0.0 MiB        1370                   if neighbor not in open_set_hash:
    75     64.2 MiB      0.0 MiB        1370                       count += 1
    76     64.2 MiB      0.0 MiB        1370                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.2 MiB      0.0 MiB        1370                       open_set_hash.add(neighbor)
    78                                                             
    79     64.2 MiB      0.0 MiB        1175           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.2 MiB      0.0 MiB        1175           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.6 MiB    105.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.6 MiB      0.0 MiB         257       for row in grid:
    30    105.6 MiB      0.0 MiB       65792           for spot in row:
    31    105.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.6 MiB      0.0 MiB           1       count = 0
    34    105.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.6 MiB      0.0 MiB           1       came_from = {}
    37    107.4 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.4 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.5 MiB  -3868.3 MiB        7954       while not open_set.empty():
    47    110.5 MiB  -3868.3 MiB        7954           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.5 MiB  -3868.3 MiB        7954           current = open_set.get()[2]
    53    110.5 MiB  -3868.3 MiB        7954           open_set_hash.remove(current)
    54                                         
    55    110.5 MiB  -3868.3 MiB        7954           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.5 MiB  -3868.3 MiB        7954           if current == end:
    60    109.2 MiB     -1.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.5 MiB -34808.0 MiB       71577           for neighbor in current.neighbors:
    65    110.5 MiB -30939.7 MiB       63624               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.5 MiB -15471.8 MiB       31812                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.5 MiB -15467.9 MiB       31812                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.5 MiB -30939.7 MiB       63624               if temp_g_score < g_score[neighbor]:
    71    110.5 MiB  -4062.1 MiB        8504                   came_from[neighbor] = current
    72    110.5 MiB  -4062.2 MiB        8504                   g_score[neighbor] = temp_g_score
    73    110.5 MiB  -4062.2 MiB        8504                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.5 MiB  -4063.1 MiB        8504                   if neighbor not in open_set_hash:
    75    110.5 MiB  -4063.5 MiB        8504                       count += 1
    76    110.5 MiB  -4063.5 MiB        8504                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.5 MiB  -4063.5 MiB        8504                       open_set_hash.add(neighbor)
    78                                                             
    79    110.5 MiB  -3868.3 MiB        7953           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.5 MiB  -3868.3 MiB        7953           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.2 MiB    109.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.2 MiB   -567.3 MiB         257       for row in grid:
    30    109.2 MiB -145405.2 MiB       65792           for spot in row:
    31    109.2 MiB -144841.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.9 MiB     -4.3 MiB           1       count = 0
    34    104.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.9 MiB      0.0 MiB           1       came_from = {}
    37    108.5 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.7 MiB  -4639.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.8 MiB      0.0 MiB        1880       while not open_set.empty():
    47    110.8 MiB      0.0 MiB        1880           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.8 MiB      0.0 MiB        1880           current = open_set.get()[2]
    53    110.8 MiB      0.0 MiB        1880           open_set_hash.remove(current)
    54                                         
    55    110.8 MiB      0.0 MiB        1880           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.8 MiB      0.0 MiB        1880           if current == end:
    60    110.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.8 MiB      0.0 MiB       16911           for neighbor in current.neighbors:
    65    110.8 MiB      0.0 MiB       15032               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.8 MiB      0.0 MiB        7516                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.8 MiB      0.0 MiB        7516                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.8 MiB      0.0 MiB       15032               if temp_g_score < g_score[neighbor]:
    71    110.8 MiB      0.1 MiB        2294                   came_from[neighbor] = current
    72    110.8 MiB      0.0 MiB        2294                   g_score[neighbor] = temp_g_score
    73    110.8 MiB      0.0 MiB        2294                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.8 MiB      0.0 MiB        2294                   if neighbor not in open_set_hash:
    75    110.8 MiB      0.0 MiB        2294                       count += 1
    76    110.8 MiB      0.0 MiB        2294                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.8 MiB      0.0 MiB        2294                       open_set_hash.add(neighbor)
    78                                                             
    79    110.8 MiB      0.0 MiB        1879           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.8 MiB      0.0 MiB        1879           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.8 MiB    110.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.8 MiB    -25.1 MiB         257       for row in grid:
    30    110.8 MiB  -6440.1 MiB       65792           for spot in row:
    31    110.8 MiB  -6415.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.5 MiB     -0.2 MiB           1       count = 0
    34    110.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.5 MiB      0.0 MiB           1       came_from = {}
    37    110.9 MiB -35419.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.7 MiB     -0.2 MiB           1       g_score[start] = 0
    39    113.2 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.2 MiB      0.0 MiB          63       while not open_set.empty():
    47    113.2 MiB      0.0 MiB          63           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.2 MiB      0.0 MiB          63           current = open_set.get()[2]
    53    113.2 MiB      0.0 MiB          63           open_set_hash.remove(current)
    54                                         
    55    113.2 MiB      0.0 MiB          63           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.2 MiB      0.0 MiB          63           if current == end:
    60    113.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.2 MiB      0.0 MiB         558           for neighbor in current.neighbors:
    65    113.2 MiB      0.0 MiB         496               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.2 MiB      0.0 MiB         248                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.2 MiB      0.0 MiB         248                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.2 MiB      0.0 MiB         496               if temp_g_score < g_score[neighbor]:
    71    113.2 MiB      0.0 MiB         111                   came_from[neighbor] = current
    72    113.2 MiB      0.0 MiB         111                   g_score[neighbor] = temp_g_score
    73    113.2 MiB      0.0 MiB         111                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.2 MiB      0.0 MiB         111                   if neighbor not in open_set_hash:
    75    113.2 MiB      0.0 MiB         111                       count += 1
    76    113.2 MiB      0.0 MiB         111                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.2 MiB      0.0 MiB         111                       open_set_hash.add(neighbor)
    78                                                             
    79    113.2 MiB      0.0 MiB          62           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.2 MiB      0.0 MiB          62           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.8 MiB    113.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.8 MiB      0.0 MiB         257       for row in grid:
    30    113.8 MiB      0.0 MiB       65792           for spot in row:
    31    113.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.8 MiB      0.0 MiB           1       count = 0
    34    113.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.8 MiB      0.0 MiB           1       came_from = {}
    37    116.2 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.6 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.6 MiB      0.0 MiB        1764       while not open_set.empty():
    47    116.6 MiB      0.0 MiB        1764           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.6 MiB      0.0 MiB        1764           current = open_set.get()[2]
    53    116.6 MiB      0.0 MiB        1764           open_set_hash.remove(current)
    54                                         
    55    116.6 MiB      0.0 MiB        1764           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.6 MiB      0.0 MiB        1764           if current == end:
    60    116.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.6 MiB      0.0 MiB       15867           for neighbor in current.neighbors:
    65    116.6 MiB      0.0 MiB       14104               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.6 MiB      0.0 MiB        7052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.6 MiB      0.0 MiB        7052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.6 MiB      0.0 MiB       14104               if temp_g_score < g_score[neighbor]:
    71    116.6 MiB      0.0 MiB        2190                   came_from[neighbor] = current
    72    116.6 MiB      0.0 MiB        2190                   g_score[neighbor] = temp_g_score
    73    116.6 MiB      0.0 MiB        2190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.6 MiB      0.0 MiB        2190                   if neighbor not in open_set_hash:
    75    116.6 MiB      0.0 MiB        2190                       count += 1
    76    116.6 MiB      0.0 MiB        2190                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.6 MiB      0.0 MiB        2190                       open_set_hash.add(neighbor)
    78                                                             
    79    116.6 MiB      0.0 MiB        1763           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.6 MiB      0.0 MiB        1763           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.6 MiB    116.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.6 MiB  -1227.0 MiB         257       for row in grid:
    30    116.6 MiB -313647.6 MiB       65792           for spot in row:
    31    116.6 MiB -312433.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.7 MiB    -16.9 MiB           1       count = 0
    34     99.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.7 MiB      0.0 MiB           1       came_from = {}
    37     99.8 MiB -278651.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.7 MiB     -8.1 MiB           1       g_score[start] = 0
    39     92.6 MiB -250916.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     85.3 MiB     -7.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     85.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     85.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     85.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     85.9 MiB      0.0 MiB         726       while not open_set.empty():
    47     85.9 MiB      0.0 MiB         726           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     85.9 MiB      0.0 MiB         726           current = open_set.get()[2]
    53     85.9 MiB      0.0 MiB         726           open_set_hash.remove(current)
    54                                         
    55     85.9 MiB      0.0 MiB         726           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     85.9 MiB      0.0 MiB         726           if current == end:
    60     85.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     85.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     85.9 MiB      0.1 MiB        6525           for neighbor in current.neighbors:
    65     85.9 MiB      0.2 MiB        5800               if current.row != neighbor.row and current.col != neighbor.col:
    66     85.9 MiB      0.0 MiB        2900                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     85.9 MiB      0.0 MiB        2900                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     85.9 MiB      0.1 MiB        5800               if temp_g_score < g_score[neighbor]:
    71     85.9 MiB      0.0 MiB         900                   came_from[neighbor] = current
    72     85.9 MiB      0.0 MiB         900                   g_score[neighbor] = temp_g_score
    73     85.9 MiB      0.0 MiB         900                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     85.9 MiB      0.0 MiB         900                   if neighbor not in open_set_hash:
    75     85.9 MiB      0.0 MiB         900                       count += 1
    76     85.9 MiB      0.0 MiB         900                       open_set.put((f_score[neighbor], count, neighbor))
    77     85.9 MiB      0.0 MiB         900                       open_set_hash.add(neighbor)
    78                                                             
    79     85.9 MiB      0.0 MiB         725           if draw is not None:
    80                                                     draw()
    81                                         
    82     85.9 MiB      0.0 MiB         725           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.0 MiB     89.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.6 MiB    -20.1 MiB         257       for row in grid:
    30     94.6 MiB  -4970.0 MiB       65792           for spot in row:
    31     94.6 MiB  -4945.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.1 MiB     -0.4 MiB           1       count = 0
    34     94.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.2 MiB      0.0 MiB           1       came_from = {}
    37     96.3 MiB -72949.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.0 MiB     -1.4 MiB           1       g_score[start] = 0
    39     98.7 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.7 MiB -17019.0 MiB         550       while not open_set.empty():
    47     98.7 MiB -17019.7 MiB         550           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.7 MiB -17021.0 MiB         550           current = open_set.get()[2]
    53     98.7 MiB -17022.3 MiB         550           open_set_hash.remove(current)
    54                                         
    55     98.7 MiB -17023.3 MiB         550           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.7 MiB -17024.0 MiB         550           if current == end:
    60     44.4 MiB    -54.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     44.8 MiB      0.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.7 MiB -152907.2 MiB        4941           for neighbor in current.neighbors:
    65     98.7 MiB -135898.4 MiB        4392               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.7 MiB -67992.4 MiB        2196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.7 MiB -67918.4 MiB        2196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.7 MiB -135920.0 MiB        4392               if temp_g_score < g_score[neighbor]:
    71     98.7 MiB -30541.0 MiB         998                   came_from[neighbor] = current
    72     98.7 MiB -30542.5 MiB         998                   g_score[neighbor] = temp_g_score
    73     98.7 MiB -30544.3 MiB         998                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.7 MiB -30545.3 MiB         998                   if neighbor not in open_set_hash:
    75     98.7 MiB -30546.3 MiB         998                       count += 1
    76     98.7 MiB -30548.2 MiB         998                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.7 MiB -30549.2 MiB         998                       open_set_hash.add(neighbor)
    78                                                             
    79     98.7 MiB -17017.3 MiB         549           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.7 MiB -17018.1 MiB         549           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.3 MiB     94.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.3 MiB   -670.4 MiB         257       for row in grid:
    30     94.3 MiB -171537.6 MiB       65792           for spot in row:
    31     94.3 MiB -170871.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.0 MiB     -5.3 MiB           1       count = 0
    34     89.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     89.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     89.0 MiB      0.0 MiB           1       came_from = {}
    37     92.6 MiB   -182.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.3 MiB      5.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.4 MiB   -512.8 MiB        1798       while not open_set.empty():
    47     98.4 MiB   -512.8 MiB        1798           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.4 MiB   -512.8 MiB        1798           current = open_set.get()[2]
    53     98.4 MiB   -512.8 MiB        1798           open_set_hash.remove(current)
    54                                         
    55     98.4 MiB   -512.8 MiB        1798           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.4 MiB   -512.8 MiB        1798           if current == end:
    60     96.9 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.4 MiB  -4608.0 MiB       16173           for neighbor in current.neighbors:
    65     98.4 MiB  -4095.5 MiB       14376               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.4 MiB  -2050.5 MiB        7188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.4 MiB  -2045.2 MiB        7188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.4 MiB  -4096.0 MiB       14376               if temp_g_score < g_score[neighbor]:
    71     98.4 MiB   -586.4 MiB        2036                   came_from[neighbor] = current
    72     98.4 MiB   -586.6 MiB        2036                   g_score[neighbor] = temp_g_score
    73     98.4 MiB   -586.9 MiB        2036                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.4 MiB   -587.0 MiB        2036                   if neighbor not in open_set_hash:
    75     98.4 MiB   -587.0 MiB        2036                       count += 1
    76     98.4 MiB   -587.0 MiB        2036                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.4 MiB   -587.0 MiB        2036                       open_set_hash.add(neighbor)
    78                                                             
    79     98.4 MiB   -512.8 MiB        1797           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.4 MiB   -512.8 MiB        1797           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.0 MiB     97.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.9 MiB   -501.2 MiB         257       for row in grid:
    30     97.9 MiB -128381.6 MiB       65792           for spot in row:
    31     97.9 MiB -127883.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.0 MiB     -4.9 MiB           1       count = 0
    34     93.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.0 MiB      0.0 MiB           1       came_from = {}
    37     95.7 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.6 MiB -141206.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     95.3 MiB     -1.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     95.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     95.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     95.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.6 MiB   -616.2 MiB        6966       while not open_set.empty():
    47     95.6 MiB   -616.2 MiB        6966           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.6 MiB   -616.2 MiB        6966           current = open_set.get()[2]
    53     95.6 MiB   -616.2 MiB        6966           open_set_hash.remove(current)
    54                                         
    55     95.6 MiB   -616.2 MiB        6966           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.6 MiB   -616.2 MiB        6966           if current == end:
    60     95.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.6 MiB  -5546.0 MiB       62685           for neighbor in current.neighbors:
    65     95.6 MiB  -4929.7 MiB       55720               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.6 MiB  -2464.7 MiB       27860                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.6 MiB  -2465.0 MiB       27860                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.6 MiB  -4929.8 MiB       55720               if temp_g_score < g_score[neighbor]:
    71     95.6 MiB   -651.6 MiB        7460                   came_from[neighbor] = current
    72     95.6 MiB   -651.9 MiB        7460                   g_score[neighbor] = temp_g_score
    73     95.6 MiB   -651.9 MiB        7460                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.6 MiB   -651.9 MiB        7460                   if neighbor not in open_set_hash:
    75     95.6 MiB   -651.9 MiB        7460                       count += 1
    76     95.6 MiB   -651.9 MiB        7460                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.6 MiB   -651.9 MiB        7460                       open_set_hash.add(neighbor)
    78                                                             
    79     95.6 MiB   -616.2 MiB        6965           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.6 MiB   -616.2 MiB        6965           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.6 MiB     95.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.6 MiB   -157.0 MiB         257       for row in grid:
    30     95.6 MiB -40318.6 MiB       65792           for spot in row:
    31     95.6 MiB -40162.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.9 MiB     -0.7 MiB           1       count = 0
    34     94.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.9 MiB      0.0 MiB           1       came_from = {}
    37     99.6 MiB      4.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.2 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.2 MiB      0.0 MiB         183       while not open_set.empty():
    47    103.2 MiB      0.0 MiB         183           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.2 MiB      0.0 MiB         183           current = open_set.get()[2]
    53    103.2 MiB      0.0 MiB         183           open_set_hash.remove(current)
    54                                         
    55    103.2 MiB      0.0 MiB         183           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.2 MiB      0.0 MiB         183           if current == end:
    60    103.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.2 MiB      0.0 MiB        1638           for neighbor in current.neighbors:
    65    103.2 MiB      0.0 MiB        1456               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.2 MiB      0.0 MiB         728                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.2 MiB      0.0 MiB         728                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.2 MiB      0.0 MiB        1456               if temp_g_score < g_score[neighbor]:
    71    103.2 MiB      0.0 MiB         551                   came_from[neighbor] = current
    72    103.2 MiB      0.0 MiB         551                   g_score[neighbor] = temp_g_score
    73    103.2 MiB      0.0 MiB         551                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.2 MiB      0.0 MiB         551                   if neighbor not in open_set_hash:
    75    103.2 MiB      0.0 MiB         551                       count += 1
    76    103.2 MiB      0.0 MiB         551                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.2 MiB      0.0 MiB         551                       open_set_hash.add(neighbor)
    78                                                             
    79    103.2 MiB      0.0 MiB         182           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.2 MiB      0.0 MiB         182           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


