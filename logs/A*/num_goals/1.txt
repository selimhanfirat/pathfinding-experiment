Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.2 MiB     67.2 MiB           1   @profile(stream=open('logs/A*/num_goals/1.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     70.4 MiB   -416.7 MiB         257       for row in grid:
    30     70.4 MiB -105678.5 MiB       65792           for spot in row:
    31     70.4 MiB -105263.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.4 MiB     -8.0 MiB           1       count = 0
    34     62.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.4 MiB      0.0 MiB           1       came_from = {}
    37     69.3 MiB      6.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     72.2 MiB -81926.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.4 MiB      0.0 MiB        2052       while not open_set.empty():
    47     72.4 MiB      0.0 MiB        2052           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.4 MiB      0.0 MiB        2052           current = open_set.get()[2]
    53     72.4 MiB      0.0 MiB        2052           open_set_hash.remove(current)
    54                                         
    55     72.4 MiB      0.0 MiB        2052           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.4 MiB      0.0 MiB        2052           if current == end:
    60     72.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.4 MiB      0.0 MiB       18459           for neighbor in current.neighbors:
    65     72.4 MiB      0.0 MiB       16408               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.4 MiB      0.0 MiB        8204                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.4 MiB      0.0 MiB        8204                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.4 MiB      0.0 MiB       16408               if temp_g_score < g_score[neighbor]:
    71     72.4 MiB      0.1 MiB        2342                   came_from[neighbor] = current
    72     72.4 MiB      0.0 MiB        2342                   g_score[neighbor] = temp_g_score
    73     72.4 MiB      0.0 MiB        2342                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.4 MiB      0.0 MiB        2342                   if neighbor not in open_set_hash:
    75     72.4 MiB      0.0 MiB        2342                       count += 1
    76     72.4 MiB      0.0 MiB        2342                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.4 MiB      0.0 MiB        2342                       open_set_hash.add(neighbor)
    78                                                             
    79     72.4 MiB      0.0 MiB        2051           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.4 MiB      0.0 MiB        2051           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.5 MiB     96.5 MiB           1   @profile(stream=open('logs/A*/num_goals/1.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.5 MiB      0.0 MiB         257       for row in grid:
    30    100.5 MiB      0.0 MiB       65792           for spot in row:
    31    100.5 MiB      4.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.5 MiB      0.0 MiB           1       count = 0
    34    100.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.5 MiB      0.0 MiB           1       came_from = {}
    37    106.4 MiB      5.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.8 MiB      5.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.8 MiB -61663.8 MiB        5593       while not open_set.empty():
    47    111.8 MiB -61664.0 MiB        5593           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.8 MiB -61664.5 MiB        5593           current = open_set.get()[2]
    53    111.8 MiB -61664.7 MiB        5593           open_set_hash.remove(current)
    54                                         
    55    111.8 MiB -61665.0 MiB        5593           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.8 MiB -61665.3 MiB        5593           if current == end:
    60     93.8 MiB    -18.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.8 MiB -554869.4 MiB       50328           for neighbor in current.neighbors:
    65    111.8 MiB -493210.3 MiB       44736               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.8 MiB -246623.5 MiB       22368                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.8 MiB -246590.9 MiB       22368                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.8 MiB -493216.8 MiB       44736               if temp_g_score < g_score[neighbor]:
    71    111.8 MiB -65137.9 MiB        6017                   came_from[neighbor] = current
    72    111.8 MiB -65138.2 MiB        6017                   g_score[neighbor] = temp_g_score
    73    111.8 MiB -65138.3 MiB        6017                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.8 MiB -65138.6 MiB        6017                   if neighbor not in open_set_hash:
    75    111.8 MiB -65138.7 MiB        6017                       count += 1
    76    111.8 MiB -65139.1 MiB        6017                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.8 MiB -65139.4 MiB        6017                       open_set_hash.add(neighbor)
    78                                                             
    79    111.8 MiB -61663.2 MiB        5592           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.8 MiB -61663.6 MiB        5592           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.6 MiB     99.6 MiB           1   @profile(stream=open('logs/A*/num_goals/2.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.6 MiB   -102.8 MiB         257       for row in grid:
    30     99.6 MiB -26409.1 MiB       65792           for spot in row:
    31     99.6 MiB -26306.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.3 MiB     -0.3 MiB           1       count = 0
    34     99.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.3 MiB      0.0 MiB           1       came_from = {}
    37    103.1 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.1 MiB  -1772.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.1 MiB   -206.3 MiB         770       while not open_set.empty():
    47    108.1 MiB   -206.3 MiB         770           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.1 MiB   -206.4 MiB         770           current = open_set.get()[2]
    53    108.1 MiB   -206.4 MiB         770           open_set_hash.remove(current)
    54                                         
    55    108.1 MiB   -206.4 MiB         770           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.1 MiB   -206.4 MiB         770           if current == end:
    60    107.1 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.1 MiB  -1853.5 MiB        6921           for neighbor in current.neighbors:
    65    108.1 MiB  -1647.5 MiB        6152               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.1 MiB   -824.8 MiB        3076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.1 MiB   -823.0 MiB        3076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.1 MiB  -1647.8 MiB        6152               if temp_g_score < g_score[neighbor]:
    71    108.1 MiB   -252.9 MiB         962                   came_from[neighbor] = current
    72    108.1 MiB   -252.9 MiB         962                   g_score[neighbor] = temp_g_score
    73    108.1 MiB   -252.9 MiB         962                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.1 MiB   -252.9 MiB         962                   if neighbor not in open_set_hash:
    75    108.1 MiB   -252.9 MiB         962                       count += 1
    76    108.1 MiB   -252.9 MiB         962                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.1 MiB   -252.9 MiB         962                       open_set_hash.add(neighbor)
    78                                                             
    79    108.1 MiB   -206.3 MiB         769           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.1 MiB   -206.3 MiB         769           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.5 MiB    110.5 MiB           1   @profile(stream=open('logs/A*/num_goals/2.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.5 MiB   -463.0 MiB         257       for row in grid:
    30    110.5 MiB -118893.6 MiB       65792           for spot in row:
    31    110.5 MiB -118432.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.3 MiB     -2.3 MiB           1       count = 0
    34    108.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.3 MiB      0.0 MiB           1       came_from = {}
    37    110.5 MiB -73403.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.4 MiB     -2.1 MiB           1       g_score[start] = 0
    39    109.2 MiB -438905.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.7 MiB    -12.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.4 MiB  -7983.5 MiB        2184       while not open_set.empty():
    47     97.4 MiB  -7983.5 MiB        2184           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.4 MiB  -7983.5 MiB        2184           current = open_set.get()[2]
    53     97.4 MiB  -7983.6 MiB        2184           open_set_hash.remove(current)
    54                                         
    55     97.4 MiB  -7983.6 MiB        2184           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.4 MiB  -7983.6 MiB        2184           if current == end:
    60     93.4 MiB     -4.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.5 MiB -72280.3 MiB       19647           for neighbor in current.neighbors:
    65     97.5 MiB -64109.7 MiB       17464               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.4 MiB -32188.4 MiB        8732                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.5 MiB -32180.9 MiB        8732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.5 MiB -64111.9 MiB       17464               if temp_g_score < g_score[neighbor]:
    71     97.5 MiB  -8827.7 MiB        2454                   came_from[neighbor] = current
    72     97.5 MiB  -8827.8 MiB        2454                   g_score[neighbor] = temp_g_score
    73     97.5 MiB  -8828.1 MiB        2454                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.5 MiB  -8828.3 MiB        2454                   if neighbor not in open_set_hash:
    75     97.5 MiB  -8828.8 MiB        2454                       count += 1
    76     97.4 MiB  -8829.3 MiB        2454                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.4 MiB  -8758.5 MiB        2454                       open_set_hash.add(neighbor)
    78                                                             
    79     97.4 MiB  -8015.8 MiB        2183           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.4 MiB  -7983.5 MiB        2183           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.6 MiB    108.6 MiB           1   @profile(stream=open('logs/A*/num_goals/3.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.6 MiB   -527.0 MiB         257       for row in grid:
    30    108.6 MiB -134901.0 MiB       65792           for spot in row:
    31    108.6 MiB -134374.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.8 MiB     -2.8 MiB           1       count = 0
    34    105.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.8 MiB      0.0 MiB           1       came_from = {}
    37    107.1 MiB    -48.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.9 MiB   -466.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.3 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.4 MiB      0.0 MiB        4698       while not open_set.empty():
    47    111.4 MiB      0.0 MiB        4698           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.4 MiB      0.0 MiB        4698           current = open_set.get()[2]
    53    111.4 MiB      0.0 MiB        4698           open_set_hash.remove(current)
    54                                         
    55    111.4 MiB      0.0 MiB        4698           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.4 MiB      0.0 MiB        4698           if current == end:
    60    111.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.4 MiB      0.0 MiB       42273           for neighbor in current.neighbors:
    65    111.4 MiB      0.0 MiB       37576               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.4 MiB      0.0 MiB       18788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.4 MiB      0.0 MiB       18788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.4 MiB      0.0 MiB       37576               if temp_g_score < g_score[neighbor]:
    71    111.4 MiB      0.2 MiB        5136                   came_from[neighbor] = current
    72    111.4 MiB      0.0 MiB        5136                   g_score[neighbor] = temp_g_score
    73    111.4 MiB      0.0 MiB        5136                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.4 MiB      0.0 MiB        5136                   if neighbor not in open_set_hash:
    75    111.4 MiB      0.0 MiB        5136                       count += 1
    76    111.4 MiB      0.0 MiB        5136                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.4 MiB      0.0 MiB        5136                       open_set_hash.add(neighbor)
    78                                                             
    79    111.4 MiB      0.0 MiB        4697           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.4 MiB      0.0 MiB        4697           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.0 MiB    112.0 MiB           1   @profile(stream=open('logs/A*/num_goals/3.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.0 MiB      0.0 MiB         257       for row in grid:
    30    112.0 MiB      0.0 MiB       65792           for spot in row:
    31    112.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.0 MiB      0.0 MiB           1       count = 0
    34    112.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.0 MiB      0.0 MiB           1       came_from = {}
    37    112.0 MiB -326490.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.0 MiB     -9.0 MiB           1       g_score[start] = 0
    39    103.1 MiB -439735.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     92.2 MiB    -10.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     92.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     92.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     92.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     92.4 MiB -37895.0 MiB        2808       while not open_set.empty():
    47     92.4 MiB -37895.7 MiB        2808           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     92.4 MiB -37896.6 MiB        2808           current = open_set.get()[2]
    53     92.4 MiB -37897.8 MiB        2808           open_set_hash.remove(current)
    54                                         
    55     92.4 MiB -37898.2 MiB        2808           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     92.4 MiB -37898.4 MiB        2808           if current == end:
    60     64.4 MiB    -28.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     92.4 MiB -340920.5 MiB       25263           for neighbor in current.neighbors:
    65     92.4 MiB -303031.5 MiB       22456               if current.row != neighbor.row and current.col != neighbor.col:
    66     92.4 MiB -151535.1 MiB       11228                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     92.4 MiB -151501.2 MiB       11228                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     92.4 MiB -303040.2 MiB       22456               if temp_g_score < g_score[neighbor]:
    71     92.4 MiB -41650.0 MiB        3136                   came_from[neighbor] = current
    72     92.4 MiB -41650.7 MiB        3136                   g_score[neighbor] = temp_g_score
    73     92.4 MiB -41651.6 MiB        3136                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     92.4 MiB -41652.3 MiB        3136                   if neighbor not in open_set_hash:
    75     92.4 MiB -41653.2 MiB        3136                       count += 1
    76     92.4 MiB -41654.4 MiB        3136                       open_set.put((f_score[neighbor], count, neighbor))
    77     92.4 MiB -41654.8 MiB        3136                       open_set_hash.add(neighbor)
    78                                                             
    79     92.4 MiB -37893.8 MiB        2807           if draw is not None:
    80                                                     draw()
    81                                         
    82     92.4 MiB -37894.2 MiB        2807           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.6 MiB    101.6 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.6 MiB     -7.0 MiB         257       for row in grid:
    30    101.6 MiB  -1757.0 MiB       65792           for spot in row:
    31    101.6 MiB  -1750.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.5 MiB     -0.1 MiB           1       count = 0
    34    101.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.5 MiB      0.0 MiB           1       came_from = {}
    37    106.4 MiB      4.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.1 MiB  -1011.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.0 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.0 MiB      0.0 MiB        1080       while not open_set.empty():
    47    111.0 MiB      0.0 MiB        1080           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.0 MiB      0.0 MiB        1080           current = open_set.get()[2]
    53    111.0 MiB      0.0 MiB        1080           open_set_hash.remove(current)
    54                                         
    55    111.0 MiB      0.0 MiB        1080           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.0 MiB      0.0 MiB        1080           if current == end:
    60    111.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.0 MiB      0.0 MiB        9711           for neighbor in current.neighbors:
    65    111.0 MiB      0.0 MiB        8632               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.0 MiB      0.0 MiB        4316                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.0 MiB      0.0 MiB        4316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.0 MiB      0.0 MiB        8632               if temp_g_score < g_score[neighbor]:
    71    111.0 MiB      0.0 MiB        1334                   came_from[neighbor] = current
    72    111.0 MiB      0.0 MiB        1334                   g_score[neighbor] = temp_g_score
    73    111.0 MiB      0.0 MiB        1334                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.0 MiB      0.0 MiB        1334                   if neighbor not in open_set_hash:
    75    111.0 MiB      0.0 MiB        1334                       count += 1
    76    111.0 MiB      0.0 MiB        1334                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.0 MiB      0.0 MiB        1334                       open_set_hash.add(neighbor)
    78                                                             
    79    111.0 MiB      0.0 MiB        1079           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.0 MiB      0.0 MiB        1079           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.7 MiB    111.7 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.7 MiB      0.0 MiB         257       for row in grid:
    30    111.7 MiB      0.0 MiB       65792           for spot in row:
    31    111.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.7 MiB      0.0 MiB           1       count = 0
    34    111.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.7 MiB      0.0 MiB           1       came_from = {}
    37    115.7 MiB   -409.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.9 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.9 MiB -44432.9 MiB        4140       while not open_set.empty():
    47    117.9 MiB -44433.4 MiB        4140           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.9 MiB -44434.1 MiB        4140           current = open_set.get()[2]
    53    117.9 MiB -44434.7 MiB        4140           open_set_hash.remove(current)
    54                                         
    55    117.9 MiB -44435.1 MiB        4140           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.9 MiB -44435.7 MiB        4140           if current == end:
    60     87.2 MiB    -30.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     87.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.9 MiB -399733.6 MiB       37251           for neighbor in current.neighbors:
    65    117.9 MiB -355309.8 MiB       33112               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.9 MiB -177683.4 MiB       16556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.9 MiB -177630.1 MiB       16556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.9 MiB -355318.8 MiB       33112               if temp_g_score < g_score[neighbor]:
    71    117.9 MiB -49418.1 MiB        4632                   came_from[neighbor] = current
    72    117.9 MiB -49419.0 MiB        4632                   g_score[neighbor] = temp_g_score
    73    117.9 MiB -49419.0 MiB        4632                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.9 MiB -49419.8 MiB        4632                   if neighbor not in open_set_hash:
    75    117.9 MiB -49421.7 MiB        4632                       count += 1
    76    117.9 MiB -49418.9 MiB        4632                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.9 MiB -49419.3 MiB        4632                       open_set_hash.add(neighbor)
    78                                                             
    79    117.9 MiB -44431.7 MiB        4139           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.9 MiB -44432.5 MiB        4139           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.1 MiB    106.1 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB  -5049.8 MiB         257       for row in grid:
    30    106.2 MiB -1294907.6 MiB       65792           for spot in row:
    31    106.2 MiB -1289878.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     69.2 MiB    -36.9 MiB           1       count = 0
    34     69.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     69.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     69.2 MiB      0.0 MiB           1       came_from = {}
    37     74.6 MiB  -1047.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     80.7 MiB      6.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     80.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     80.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     80.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     80.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     80.9 MiB -69955.7 MiB        9322       while not open_set.empty():
    47     80.9 MiB -69956.0 MiB        9322           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     80.9 MiB -69957.0 MiB        9322           current = open_set.get()[2]
    53     80.9 MiB -69957.3 MiB        9322           open_set_hash.remove(current)
    54                                         
    55     80.9 MiB -69957.7 MiB        9322           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     80.9 MiB -69960.6 MiB        9322           if current == end:
    60     72.4 MiB     -8.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     80.9 MiB -629572.3 MiB       83889           for neighbor in current.neighbors:
    65     80.9 MiB -559616.1 MiB       74568               if current.row != neighbor.row and current.col != neighbor.col:
    66     80.9 MiB -279810.8 MiB       37284                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     80.9 MiB -279805.7 MiB       37284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     80.9 MiB -559617.2 MiB       74568               if temp_g_score < g_score[neighbor]:
    71     80.9 MiB -72580.5 MiB        9872                   came_from[neighbor] = current
    72     80.9 MiB -72581.0 MiB        9872                   g_score[neighbor] = temp_g_score
    73     80.9 MiB -72581.0 MiB        9872                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     80.9 MiB -72581.0 MiB        9872                   if neighbor not in open_set_hash:
    75     80.9 MiB -72581.1 MiB        9872                       count += 1
    76     80.9 MiB -72581.5 MiB        9872                       open_set.put((f_score[neighbor], count, neighbor))
    77     80.9 MiB -72581.7 MiB        9872                       open_set_hash.add(neighbor)
    78                                                             
    79     80.9 MiB -69955.1 MiB        9321           if draw is not None:
    80                                                     draw()
    81                                         
    82     80.9 MiB -69955.3 MiB        9321           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.7 MiB    100.7 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.7 MiB  -3022.4 MiB         257       for row in grid:
    30    100.7 MiB -775407.2 MiB       65792           for spot in row:
    31    100.7 MiB -772394.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.2 MiB    -15.5 MiB           1       count = 0
    34     85.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     85.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     85.2 MiB      0.0 MiB           1       came_from = {}
    37     91.5 MiB      6.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.4 MiB -35072.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     92.6 MiB     -1.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     92.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     92.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     92.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.8 MiB -74399.7 MiB        3260       while not open_set.empty():
    47     95.8 MiB -74400.7 MiB        3260           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.8 MiB -74401.9 MiB        3260           current = open_set.get()[2]
    53     95.8 MiB -74402.7 MiB        3260           open_set_hash.remove(current)
    54                                         
    55     95.8 MiB -74403.6 MiB        3260           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.8 MiB -74404.6 MiB        3260           if current == end:
    60     42.6 MiB    -53.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     43.6 MiB      1.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.8 MiB -669336.8 MiB       29331           for neighbor in current.neighbors:
    65     95.8 MiB -594947.2 MiB       26072               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.8 MiB -297526.8 MiB       13036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.8 MiB -297429.3 MiB       13036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.8 MiB -594968.4 MiB       26072               if temp_g_score < g_score[neighbor]:
    71     95.8 MiB -89102.0 MiB        3950                   came_from[neighbor] = current
    72     95.8 MiB -89103.2 MiB        3950                   g_score[neighbor] = temp_g_score
    73     95.8 MiB -89104.0 MiB        3950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.8 MiB -89105.1 MiB        3950                   if neighbor not in open_set_hash:
    75     95.8 MiB -89106.3 MiB        3950                       count += 1
    76     95.8 MiB -89105.0 MiB        3950                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.8 MiB -89109.5 MiB        3950                       open_set_hash.add(neighbor)
    78                                                             
    79     95.8 MiB -74397.5 MiB        3259           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.8 MiB -74398.8 MiB        3259           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.6 MiB    100.6 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.6 MiB     -3.3 MiB         257       for row in grid:
    30    100.6 MiB   -848.0 MiB       65792           for spot in row:
    31    100.6 MiB   -844.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.6 MiB     -0.0 MiB           1       count = 0
    34    100.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.6 MiB      0.0 MiB           1       came_from = {}
    37    104.9 MiB  -7180.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.2 MiB     -0.7 MiB           1       g_score[start] = 0
    39    108.7 MiB      4.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.8 MiB    -77.2 MiB        3220       while not open_set.empty():
    47    108.8 MiB    -77.2 MiB        3220           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.8 MiB    -77.2 MiB        3220           current = open_set.get()[2]
    53    108.8 MiB    -77.2 MiB        3220           open_set_hash.remove(current)
    54                                         
    55    108.8 MiB    -77.2 MiB        3220           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.8 MiB    -77.2 MiB        3220           if current == end:
    60    107.9 MiB     -0.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.8 MiB   -692.9 MiB       28971           for neighbor in current.neighbors:
    65    108.8 MiB   -615.9 MiB       25752               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.8 MiB   -308.8 MiB       12876                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.8 MiB   -307.2 MiB       12876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.8 MiB   -616.2 MiB       25752               if temp_g_score < g_score[neighbor]:
    71    108.8 MiB    -96.7 MiB        3620                   came_from[neighbor] = current
    72    108.8 MiB    -96.7 MiB        3620                   g_score[neighbor] = temp_g_score
    73    108.8 MiB    -96.7 MiB        3620                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.8 MiB    -96.7 MiB        3620                   if neighbor not in open_set_hash:
    75    108.8 MiB    -96.7 MiB        3620                       count += 1
    76    108.8 MiB    -96.7 MiB        3620                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.8 MiB    -96.7 MiB        3620                       open_set_hash.add(neighbor)
    78                                                             
    79    108.8 MiB    -77.2 MiB        3219           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.8 MiB    -77.2 MiB        3219           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.0 MiB    113.0 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.0 MiB   -990.4 MiB         257       for row in grid:
    30    113.0 MiB -252934.1 MiB       65792           for spot in row:
    31    113.0 MiB -251946.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.9 MiB     -9.2 MiB           1       count = 0
    34    103.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.9 MiB      0.0 MiB           1       came_from = {}
    37    107.8 MiB -66925.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.7 MiB     -3.1 MiB           1       g_score[start] = 0
    39    109.1 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.1 MiB      0.0 MiB         336       while not open_set.empty():
    47    109.1 MiB      0.0 MiB         336           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.1 MiB      0.0 MiB         336           current = open_set.get()[2]
    53    109.1 MiB      0.0 MiB         336           open_set_hash.remove(current)
    54                                         
    55    109.1 MiB      0.0 MiB         336           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.1 MiB      0.0 MiB         336           if current == end:
    60    109.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.1 MiB      0.0 MiB        3015           for neighbor in current.neighbors:
    65    109.1 MiB      0.0 MiB        2680               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.1 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.1 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.1 MiB      0.0 MiB        2680               if temp_g_score < g_score[neighbor]:
    71    109.1 MiB      0.0 MiB         438                   came_from[neighbor] = current
    72    109.1 MiB      0.0 MiB         438                   g_score[neighbor] = temp_g_score
    73    109.1 MiB      0.0 MiB         438                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.1 MiB      0.0 MiB         438                   if neighbor not in open_set_hash:
    75    109.1 MiB      0.0 MiB         438                       count += 1
    76    109.1 MiB      0.0 MiB         438                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.1 MiB      0.0 MiB         438                       open_set_hash.add(neighbor)
    78                                                             
    79    109.1 MiB      0.0 MiB         335           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.1 MiB      0.0 MiB         335           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.0 MiB    110.0 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.0 MiB      0.0 MiB         257       for row in grid:
    30    110.0 MiB      0.0 MiB       65792           for spot in row:
    31    110.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.0 MiB      0.0 MiB           1       count = 0
    34    110.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.0 MiB      0.0 MiB           1       came_from = {}
    37    114.3 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.7 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.7 MiB      0.0 MiB         416       while not open_set.empty():
    47    115.7 MiB      0.0 MiB         416           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.7 MiB      0.0 MiB         416           current = open_set.get()[2]
    53    115.7 MiB      0.0 MiB         416           open_set_hash.remove(current)
    54                                         
    55    115.7 MiB      0.0 MiB         416           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.7 MiB      0.0 MiB         416           if current == end:
    60    115.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.7 MiB      0.0 MiB        3735           for neighbor in current.neighbors:
    65    115.7 MiB      0.0 MiB        3320               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.7 MiB      0.0 MiB        1660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.7 MiB      0.0 MiB        1660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.7 MiB      0.0 MiB        3320               if temp_g_score < g_score[neighbor]:
    71    115.7 MiB      0.0 MiB         638                   came_from[neighbor] = current
    72    115.7 MiB      0.0 MiB         638                   g_score[neighbor] = temp_g_score
    73    115.7 MiB      0.0 MiB         638                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.7 MiB      0.0 MiB         638                   if neighbor not in open_set_hash:
    75    115.7 MiB      0.0 MiB         638                       count += 1
    76    115.7 MiB      0.0 MiB         638                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.7 MiB      0.0 MiB         638                       open_set_hash.add(neighbor)
    78                                                             
    79    115.7 MiB      0.0 MiB         415           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.7 MiB      0.0 MiB         415           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.9 MiB    115.9 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.9 MiB  -8643.7 MiB         257       for row in grid:
    30    115.9 MiB -2208650.5 MiB       65792           for spot in row:
    31    115.9 MiB -2200045.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.2 MiB    -58.8 MiB           1       count = 0
    34     57.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     57.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.3 MiB      0.0 MiB           1       came_from = {}
    37     63.9 MiB -24160.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.2 MiB     -5.7 MiB           1       g_score[start] = 0
    39     62.2 MiB  -4467.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.6 MiB  -5150.5 MiB        2048       while not open_set.empty():
    47     62.6 MiB  -5150.6 MiB        2048           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.6 MiB  -5150.6 MiB        2048           current = open_set.get()[2]
    53     62.6 MiB  -5150.7 MiB        2048           open_set_hash.remove(current)
    54                                         
    55     62.6 MiB  -5150.7 MiB        2048           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.6 MiB  -5150.7 MiB        2048           if current == end:
    60     57.3 MiB     -5.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.6 MiB -46321.7 MiB       18423           for neighbor in current.neighbors:
    65     62.6 MiB -41171.7 MiB       16376               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.6 MiB -20589.2 MiB        8188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.6 MiB -20582.6 MiB        8188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.6 MiB -41172.5 MiB       16376               if temp_g_score < g_score[neighbor]:
    71     62.6 MiB  -5620.0 MiB        2302                   came_from[neighbor] = current
    72     62.6 MiB  -5620.3 MiB        2302                   g_score[neighbor] = temp_g_score
    73     62.6 MiB  -5620.5 MiB        2302                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.6 MiB  -5620.6 MiB        2302                   if neighbor not in open_set_hash:
    75     62.6 MiB  -5620.6 MiB        2302                       count += 1
    76     62.6 MiB  -5622.7 MiB        2302                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.6 MiB  -5623.2 MiB        2302                       open_set_hash.add(neighbor)
    78                                                             
    79     62.6 MiB  -5150.4 MiB        2047           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.6 MiB  -5150.4 MiB        2047           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.3 MiB    103.3 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.3 MiB  -1015.3 MiB         257       for row in grid:
    30    103.3 MiB -259404.0 MiB       65792           for spot in row:
    31    103.3 MiB -258394.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.7 MiB    -10.6 MiB           1       count = 0
    34     92.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.7 MiB      0.0 MiB           1       came_from = {}
    37     93.2 MiB -52637.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     89.9 MiB     -3.3 MiB           1       g_score[start] = 0
    39     90.9 MiB -82759.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.3 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     90.5 MiB    -45.6 MiB         994       while not open_set.empty():
    47     90.5 MiB    -45.6 MiB         994           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     90.5 MiB    -45.6 MiB         994           current = open_set.get()[2]
    53     90.5 MiB    -45.6 MiB         994           open_set_hash.remove(current)
    54                                         
    55     90.5 MiB    -45.6 MiB         994           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     90.5 MiB    -45.6 MiB         994           if current == end:
    60     90.3 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     90.5 MiB   -410.0 MiB        8937           for neighbor in current.neighbors:
    65     90.5 MiB   -364.3 MiB        7944               if current.row != neighbor.row and current.col != neighbor.col:
    66     90.5 MiB   -182.4 MiB        3972                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     90.5 MiB   -182.1 MiB        3972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     90.5 MiB   -364.5 MiB        7944               if temp_g_score < g_score[neighbor]:
    71     90.5 MiB    -59.2 MiB        1304                   came_from[neighbor] = current
    72     90.5 MiB    -59.2 MiB        1304                   g_score[neighbor] = temp_g_score
    73     90.5 MiB    -59.2 MiB        1304                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     90.5 MiB    -59.2 MiB        1304                   if neighbor not in open_set_hash:
    75     90.5 MiB    -59.2 MiB        1304                       count += 1
    76     90.5 MiB    -59.2 MiB        1304                       open_set.put((f_score[neighbor], count, neighbor))
    77     90.5 MiB    -59.2 MiB        1304                       open_set_hash.add(neighbor)
    78                                                             
    79     90.5 MiB    -45.6 MiB         993           if draw is not None:
    80                                                     draw()
    81                                         
    82     90.5 MiB    -45.6 MiB         993           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.6 MiB    107.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.6 MiB  -5302.7 MiB         257       for row in grid:
    30    107.6 MiB -1359538.9 MiB       65792           for spot in row:
    31    107.6 MiB -1354279.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.4 MiB    -48.2 MiB           1       count = 0
    34     59.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.5 MiB      0.0 MiB           1       came_from = {}
    37     66.0 MiB  -4653.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.6 MiB     -0.4 MiB           1       g_score[start] = 0
    39     66.0 MiB -95520.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.0 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.4 MiB -26729.6 MiB        3266       while not open_set.empty():
    47     66.4 MiB -26729.6 MiB        3266           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.4 MiB -26729.6 MiB        3266           current = open_set.get()[2]
    53     66.4 MiB -26729.7 MiB        3266           open_set_hash.remove(current)
    54                                         
    55     66.4 MiB -26729.7 MiB        3266           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.4 MiB -26729.7 MiB        3266           if current == end:
    60     43.7 MiB    -22.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     43.8 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.4 MiB -240462.2 MiB       29385           for neighbor in current.neighbors:
    65     66.4 MiB -213733.0 MiB       26120               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.4 MiB -106891.1 MiB       13060                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.4 MiB -106854.6 MiB       13060                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.4 MiB -213751.0 MiB       26120               if temp_g_score < g_score[neighbor]:
    71     66.4 MiB -29483.0 MiB        3640                   came_from[neighbor] = current
    72     66.4 MiB -29483.1 MiB        3640                   g_score[neighbor] = temp_g_score
    73     66.4 MiB -29483.1 MiB        3640                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.4 MiB -29483.1 MiB        3640                   if neighbor not in open_set_hash:
    75     66.4 MiB -29483.1 MiB        3640                       count += 1
    76     66.4 MiB -29483.1 MiB        3640                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.4 MiB -29483.1 MiB        3640                       open_set_hash.add(neighbor)
    78                                                             
    79     66.4 MiB -26729.3 MiB        3265           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.4 MiB -26729.6 MiB        3265           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.8 MiB     99.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.8 MiB   -116.3 MiB         257       for row in grid:
    30     99.8 MiB -29863.6 MiB       65792           for spot in row:
    31     99.8 MiB -29747.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.6 MiB     -1.2 MiB           1       count = 0
    34     98.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.6 MiB      0.0 MiB           1       came_from = {}
    37    103.0 MiB  -2689.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.2 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.2 MiB -15526.5 MiB       12192       while not open_set.empty():
    47    106.2 MiB -15526.5 MiB       12192           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.2 MiB -15526.5 MiB       12192           current = open_set.get()[2]
    53    106.2 MiB -15526.5 MiB       12192           open_set_hash.remove(current)
    54                                         
    55    106.2 MiB -15526.6 MiB       12192           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.2 MiB -15526.7 MiB       12192           if current == end:
    60    105.2 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.2 MiB -139737.1 MiB      109719           for neighbor in current.neighbors:
    65    106.2 MiB -124211.2 MiB       97528               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.2 MiB -62106.7 MiB       48764                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.2 MiB -62104.8 MiB       48764                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.2 MiB -124212.1 MiB       97528               if temp_g_score < g_score[neighbor]:
    71    106.2 MiB -15994.7 MiB       12828                   came_from[neighbor] = current
    72    106.2 MiB -15994.8 MiB       12828                   g_score[neighbor] = temp_g_score
    73    106.2 MiB -15995.0 MiB       12828                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.2 MiB -15995.0 MiB       12828                   if neighbor not in open_set_hash:
    75    106.2 MiB -15995.0 MiB       12828                       count += 1
    76    106.2 MiB -15994.0 MiB       12828                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.2 MiB -15993.9 MiB       12828                       open_set_hash.add(neighbor)
    78                                                             
    79    106.2 MiB -15526.4 MiB       12191           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.2 MiB -15526.4 MiB       12191           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.9 MiB    100.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.9 MiB   -391.3 MiB         257       for row in grid:
    30    100.9 MiB -100208.0 MiB       65792           for spot in row:
    31    100.9 MiB -99817.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.0 MiB     -1.9 MiB           1       count = 0
    34     99.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.0 MiB      0.0 MiB           1       came_from = {}
    37    101.7 MiB   -861.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.1 MiB -2462307.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     57.0 MiB    -45.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     57.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     57.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     57.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     57.7 MiB -122915.4 MiB       10980       while not open_set.empty():
    47     57.7 MiB -122916.4 MiB       10980           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     57.7 MiB -122916.8 MiB       10980           current = open_set.get()[2]
    53     57.7 MiB -122917.3 MiB       10980           open_set_hash.remove(current)
    54                                         
    55     57.7 MiB -122932.8 MiB       10980           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     57.7 MiB -122933.2 MiB       10980           if current == end:
    60     33.8 MiB    -24.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     35.3 MiB      1.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     57.7 MiB -1106169.4 MiB       98811           for neighbor in current.neighbors:
    65     57.7 MiB -983255.3 MiB       87832               if current.row != neighbor.row and current.col != neighbor.col:
    66     57.7 MiB -491631.4 MiB       43916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     57.7 MiB -491629.5 MiB       43916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     57.7 MiB -983266.2 MiB       87832               if temp_g_score < g_score[neighbor]:
    71     57.7 MiB -131443.3 MiB       11830                   came_from[neighbor] = current
    72     57.7 MiB -131444.7 MiB       11830                   g_score[neighbor] = temp_g_score
    73     57.7 MiB -131445.0 MiB       11830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     57.7 MiB -131445.7 MiB       11830                   if neighbor not in open_set_hash:
    75     57.7 MiB -131447.2 MiB       11830                       count += 1
    76     57.7 MiB -131429.2 MiB       11830                       open_set.put((f_score[neighbor], count, neighbor))
    77     57.7 MiB -131429.9 MiB       11830                       open_set_hash.add(neighbor)
    78                                                             
    79     57.7 MiB -122914.2 MiB       10979           if draw is not None:
    80                                                     draw()
    81                                         
    82     57.7 MiB -122914.8 MiB       10979           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.2 MiB     98.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.2 MiB    -89.8 MiB         257       for row in grid:
    30     98.2 MiB -23020.1 MiB       65792           for spot in row:
    31     98.2 MiB -22930.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.7 MiB     -0.5 MiB           1       count = 0
    34     97.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.7 MiB      0.0 MiB           1       came_from = {}
    37    100.8 MiB   -129.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.2 MiB  -1012.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.1 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.1 MiB    -19.8 MiB         154       while not open_set.empty():
    47    105.1 MiB    -19.8 MiB         154           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.1 MiB    -19.8 MiB         154           current = open_set.get()[2]
    53    105.1 MiB    -19.8 MiB         154           open_set_hash.remove(current)
    54                                         
    55    105.1 MiB    -19.8 MiB         154           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.1 MiB    -19.8 MiB         154           if current == end:
    60    105.0 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.1 MiB   -177.0 MiB        1377           for neighbor in current.neighbors:
    65    105.1 MiB   -157.3 MiB        1224               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.1 MiB    -78.8 MiB         612                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.1 MiB    -78.6 MiB         612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.1 MiB   -157.3 MiB        1224               if temp_g_score < g_score[neighbor]:
    71    105.1 MiB    -30.8 MiB         254                   came_from[neighbor] = current
    72    105.1 MiB    -30.8 MiB         254                   g_score[neighbor] = temp_g_score
    73    105.1 MiB    -30.8 MiB         254                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.1 MiB    -30.8 MiB         254                   if neighbor not in open_set_hash:
    75    105.1 MiB    -30.8 MiB         254                       count += 1
    76    105.1 MiB    -30.9 MiB         254                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.1 MiB    -30.9 MiB         254                       open_set_hash.add(neighbor)
    78                                                             
    79    105.1 MiB    -19.8 MiB         153           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.1 MiB    -19.8 MiB         153           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.0 MiB    106.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.0 MiB   -383.3 MiB         257       for row in grid:
    30    106.0 MiB -97824.2 MiB       65792           for spot in row:
    31    106.0 MiB -97445.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.6 MiB     -6.4 MiB           1       count = 0
    34     99.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.6 MiB      0.0 MiB           1       came_from = {}
    37    102.9 MiB   -174.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.0 MiB -19906.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.9 MiB     -1.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.0 MiB -181625.4 MiB        3434       while not open_set.empty():
    47    104.0 MiB -181626.3 MiB        3434           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.0 MiB -181627.9 MiB        3434           current = open_set.get()[2]
    53    104.0 MiB -181628.6 MiB        3434           open_set_hash.remove(current)
    54                                         
    55    104.0 MiB -181629.9 MiB        3434           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.0 MiB -181633.6 MiB        3434           if current == end:
    60     42.4 MiB    -61.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     42.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.0 MiB -1634340.7 MiB       30897           for neighbor in current.neighbors:
    65    104.0 MiB -1452740.0 MiB       27464               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.0 MiB -726413.7 MiB       13732                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.0 MiB -726334.2 MiB       13732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.0 MiB -1452758.8 MiB       27464               if temp_g_score < g_score[neighbor]:
    71    104.0 MiB -202851.6 MiB        3904                   came_from[neighbor] = current
    72    104.0 MiB -202852.5 MiB        3904                   g_score[neighbor] = temp_g_score
    73    104.0 MiB -202853.2 MiB        3904                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.0 MiB -202853.8 MiB        3904                   if neighbor not in open_set_hash:
    75    104.0 MiB -202854.0 MiB        3904                       count += 1
    76    104.0 MiB -202854.8 MiB        3904                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.0 MiB -202855.2 MiB        3904                       open_set_hash.add(neighbor)
    78                                                             
    79    104.0 MiB -181613.0 MiB        3433           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.0 MiB -181613.9 MiB        3433           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.4 MiB    106.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.4 MiB   -119.1 MiB         257       for row in grid:
    30    106.4 MiB -30335.5 MiB       65792           for spot in row:
    31    106.4 MiB -30219.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.0 MiB     -3.4 MiB           1       count = 0
    34    103.1 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35    103.3 MiB      0.1 MiB           1       open_set.put((0, count, start))
    36    103.3 MiB      0.0 MiB           1       came_from = {}
    37    107.0 MiB -10673.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.1 MiB   -366.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.2 MiB  -1713.9 MiB        2730       while not open_set.empty():
    47    111.2 MiB  -1713.9 MiB        2730           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.2 MiB  -1713.9 MiB        2730           current = open_set.get()[2]
    53    111.2 MiB  -1713.9 MiB        2730           open_set_hash.remove(current)
    54                                         
    55    111.2 MiB  -1713.9 MiB        2730           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.2 MiB  -1713.9 MiB        2730           if current == end:
    60    108.3 MiB     -2.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.2 MiB -15407.5 MiB       24561           for neighbor in current.neighbors:
    65    111.2 MiB -13693.9 MiB       21832               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.2 MiB  -6848.1 MiB       10916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.2 MiB  -6846.0 MiB       10916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.2 MiB -13694.3 MiB       21832               if temp_g_score < g_score[neighbor]:
    71    111.2 MiB  -1924.1 MiB        3072                   came_from[neighbor] = current
    72    111.2 MiB  -1924.4 MiB        3072                   g_score[neighbor] = temp_g_score
    73    111.2 MiB  -1924.6 MiB        3072                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.2 MiB  -1925.0 MiB        3072                   if neighbor not in open_set_hash:
    75    111.2 MiB  -1925.2 MiB        3072                       count += 1
    76    111.2 MiB  -1925.6 MiB        3072                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.2 MiB  -1925.6 MiB        3072                       open_set_hash.add(neighbor)
    78                                                             
    79    111.2 MiB  -1713.9 MiB        2729           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.2 MiB  -1713.9 MiB        2729           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.0 MiB    110.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.0 MiB  -2140.9 MiB         257       for row in grid:
    30    110.0 MiB -548488.3 MiB       65792           for spot in row:
    31    110.0 MiB -546356.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.9 MiB    -13.1 MiB           1       count = 0
    34     97.1 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     97.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     97.2 MiB      0.0 MiB           1       came_from = {}
    37     99.6 MiB -66344.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.9 MiB  -2244.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.1 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.3 MiB      0.0 MiB        1302       while not open_set.empty():
    47    104.3 MiB      0.0 MiB        1302           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.3 MiB      0.0 MiB        1302           current = open_set.get()[2]
    53    104.3 MiB      0.0 MiB        1302           open_set_hash.remove(current)
    54                                         
    55    104.3 MiB      0.0 MiB        1302           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.3 MiB      0.0 MiB        1302           if current == end:
    60    104.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.3 MiB      0.0 MiB       11709           for neighbor in current.neighbors:
    65    104.3 MiB      0.0 MiB       10408               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.3 MiB      0.0 MiB        5204                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.3 MiB      0.0 MiB        5204                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.3 MiB      0.0 MiB       10408               if temp_g_score < g_score[neighbor]:
    71    104.3 MiB      0.2 MiB        1542                   came_from[neighbor] = current
    72    104.3 MiB      0.0 MiB        1542                   g_score[neighbor] = temp_g_score
    73    104.3 MiB      0.0 MiB        1542                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.3 MiB      0.0 MiB        1542                   if neighbor not in open_set_hash:
    75    104.3 MiB      0.0 MiB        1542                       count += 1
    76    104.3 MiB      0.0 MiB        1542                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.3 MiB      0.0 MiB        1542                       open_set_hash.add(neighbor)
    78                                                             
    79    104.3 MiB      0.0 MiB        1301           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.3 MiB      0.0 MiB        1301           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.5 MiB    107.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.5 MiB      0.0 MiB         257       for row in grid:
    30    107.5 MiB      0.0 MiB       65792           for spot in row:
    31    107.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.5 MiB      0.0 MiB           1       count = 0
    34    107.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.5 MiB      0.0 MiB           1       came_from = {}
    37    108.3 MiB -28496.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.2 MiB     -0.1 MiB           1       g_score[start] = 0
    39    111.7 MiB    -79.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.7 MiB  -1723.9 MiB        1206       while not open_set.empty():
    47    111.7 MiB  -1723.9 MiB        1206           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.7 MiB  -1723.9 MiB        1206           current = open_set.get()[2]
    53    111.7 MiB  -1724.0 MiB        1206           open_set_hash.remove(current)
    54                                         
    55    111.7 MiB  -1725.7 MiB        1206           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.7 MiB  -1725.8 MiB        1206           if current == end:
    60    109.9 MiB     -1.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.7 MiB -15515.3 MiB       10845           for neighbor in current.neighbors:
    65    111.7 MiB -13791.4 MiB        9640               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.7 MiB  -6895.7 MiB        4820                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.7 MiB  -6895.7 MiB        4820                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.7 MiB -13791.4 MiB        9640               if temp_g_score < g_score[neighbor]:
    71    111.7 MiB  -1939.6 MiB        1410                   came_from[neighbor] = current
    72    111.7 MiB  -1939.6 MiB        1410                   g_score[neighbor] = temp_g_score
    73    111.7 MiB  -1939.6 MiB        1410                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.7 MiB  -1939.6 MiB        1410                   if neighbor not in open_set_hash:
    75    111.7 MiB  -1939.6 MiB        1410                       count += 1
    76    111.7 MiB  -1939.6 MiB        1410                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.7 MiB  -1939.6 MiB        1410                       open_set_hash.add(neighbor)
    78                                                             
    79    111.7 MiB  -1723.9 MiB        1205           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.7 MiB  -1723.9 MiB        1205           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.5 MiB    110.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.5 MiB      0.0 MiB         257       for row in grid:
    30    110.5 MiB      0.0 MiB       65792           for spot in row:
    31    110.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.5 MiB      0.0 MiB           1       count = 0
    34    110.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.5 MiB      0.0 MiB           1       came_from = {}
    37    113.9 MiB  -2819.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.0 MiB     -3.8 MiB           1       g_score[start] = 0
    39    114.4 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.4 MiB      0.0 MiB         143       while not open_set.empty():
    47    114.4 MiB      0.0 MiB         143           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.4 MiB      0.0 MiB         143           current = open_set.get()[2]
    53    114.4 MiB      0.0 MiB         143           open_set_hash.remove(current)
    54                                         
    55    114.4 MiB      0.0 MiB         143           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.4 MiB      0.0 MiB         143           if current == end:
    60    114.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.4 MiB      0.0 MiB        1278           for neighbor in current.neighbors:
    65    114.4 MiB      0.0 MiB        1136               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.4 MiB      0.0 MiB         568                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.4 MiB      0.0 MiB         568                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.4 MiB      0.0 MiB        1136               if temp_g_score < g_score[neighbor]:
    71    114.4 MiB      0.0 MiB         215                   came_from[neighbor] = current
    72    114.4 MiB      0.0 MiB         215                   g_score[neighbor] = temp_g_score
    73    114.4 MiB      0.0 MiB         215                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.4 MiB      0.0 MiB         215                   if neighbor not in open_set_hash:
    75    114.4 MiB      0.0 MiB         215                       count += 1
    76    114.4 MiB      0.0 MiB         215                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.4 MiB      0.0 MiB         215                       open_set_hash.add(neighbor)
    78                                                             
    79    114.4 MiB      0.0 MiB         142           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.4 MiB      0.0 MiB         142           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.4 MiB    115.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.4 MiB     -0.3 MiB         257       for row in grid:
    30    115.4 MiB    -83.2 MiB       65792           for spot in row:
    31    115.4 MiB    -82.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.4 MiB     -0.0 MiB           1       count = 0
    34    115.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.4 MiB      0.0 MiB           1       came_from = {}
    37    117.0 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    117.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    119.8 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    119.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    119.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    119.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    119.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    119.9 MiB      0.0 MiB        2800       while not open_set.empty():
    47    119.9 MiB      0.0 MiB        2800           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    119.9 MiB      0.0 MiB        2800           current = open_set.get()[2]
    53    119.9 MiB      0.0 MiB        2800           open_set_hash.remove(current)
    54                                         
    55    119.9 MiB      0.0 MiB        2800           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    119.9 MiB      0.0 MiB        2800           if current == end:
    60    119.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    119.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    119.9 MiB      0.0 MiB       25191           for neighbor in current.neighbors:
    65    119.9 MiB      0.0 MiB       22392               if current.row != neighbor.row and current.col != neighbor.col:
    66    119.9 MiB      0.0 MiB       11196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    119.9 MiB      0.0 MiB       11196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    119.9 MiB      0.0 MiB       22392               if temp_g_score < g_score[neighbor]:
    71    119.9 MiB      0.1 MiB        3110                   came_from[neighbor] = current
    72    119.9 MiB      0.0 MiB        3110                   g_score[neighbor] = temp_g_score
    73    119.9 MiB      0.0 MiB        3110                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    119.9 MiB      0.0 MiB        3110                   if neighbor not in open_set_hash:
    75    119.9 MiB      0.0 MiB        3110                       count += 1
    76    119.9 MiB      0.0 MiB        3110                       open_set.put((f_score[neighbor], count, neighbor))
    77    119.9 MiB      0.0 MiB        3110                       open_set_hash.add(neighbor)
    78                                                             
    79    119.9 MiB      0.0 MiB        2799           if draw is not None:
    80                                                     draw()
    81                                         
    82    119.9 MiB      0.0 MiB        2799           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    120.1 MiB    120.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    120.1 MiB   -754.6 MiB         257       for row in grid:
    30    120.1 MiB -193630.7 MiB       65792           for spot in row:
    31    120.1 MiB -192878.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.1 MiB     -4.9 MiB           1       count = 0
    34    115.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.1 MiB      0.0 MiB           1       came_from = {}
    37    117.6 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    117.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    119.3 MiB -32543.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.8 MiB     -2.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.8 MiB -12900.5 MiB        5928       while not open_set.empty():
    47    116.8 MiB -12900.5 MiB        5928           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.8 MiB -12900.5 MiB        5928           current = open_set.get()[2]
    53    116.8 MiB -12900.5 MiB        5928           open_set_hash.remove(current)
    54                                         
    55    116.8 MiB -12900.5 MiB        5928           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.8 MiB -12900.5 MiB        5928           if current == end:
    60    114.3 MiB     -2.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.8 MiB -116096.5 MiB       53343           for neighbor in current.neighbors:
    65    116.8 MiB -103196.7 MiB       47416               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.8 MiB -51601.9 MiB       23708                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.8 MiB -51595.4 MiB       23708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.8 MiB -103198.0 MiB       47416               if temp_g_score < g_score[neighbor]:
    71    116.8 MiB -14250.4 MiB        6626                   came_from[neighbor] = current
    72    116.8 MiB -14250.4 MiB        6626                   g_score[neighbor] = temp_g_score
    73    116.8 MiB -14250.4 MiB        6626                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.8 MiB -14250.4 MiB        6626                   if neighbor not in open_set_hash:
    75    116.8 MiB -14250.4 MiB        6626                       count += 1
    76    116.8 MiB -14250.4 MiB        6626                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.8 MiB -14250.4 MiB        6626                       open_set_hash.add(neighbor)
    78                                                             
    79    116.8 MiB -12900.5 MiB        5927           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.8 MiB -12900.5 MiB        5927           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.6 MiB    114.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.6 MiB   -300.8 MiB         257       for row in grid:
    30    114.6 MiB -76967.8 MiB       65792           for spot in row:
    31    114.6 MiB -76668.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.3 MiB     -2.3 MiB           1       count = 0
    34    112.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.3 MiB      0.0 MiB           1       came_from = {}
    37    114.4 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.9 MiB  -7064.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.9 MiB -46814.6 MiB       11392       while not open_set.empty():
    47    115.9 MiB -46814.6 MiB       11392           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.9 MiB -46814.8 MiB       11392           current = open_set.get()[2]
    53    115.9 MiB -46814.8 MiB       11392           open_set_hash.remove(current)
    54                                         
    55    115.9 MiB -46815.7 MiB       11392           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.9 MiB -46815.8 MiB       11392           if current == end:
    60    108.5 MiB     -7.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.9 MiB -421307.3 MiB      102519           for neighbor in current.neighbors:
    65    115.9 MiB -374494.1 MiB       91128               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.9 MiB -187254.0 MiB       45564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.9 MiB -187242.8 MiB       45564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.9 MiB -374498.1 MiB       91128               if temp_g_score < g_score[neighbor]:
    71    115.9 MiB -48910.3 MiB       12080                   came_from[neighbor] = current
    72    115.9 MiB -48910.3 MiB       12080                   g_score[neighbor] = temp_g_score
    73    115.9 MiB -48910.3 MiB       12080                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.9 MiB -48910.3 MiB       12080                   if neighbor not in open_set_hash:
    75    115.9 MiB -48910.3 MiB       12080                       count += 1
    76    115.9 MiB -48909.9 MiB       12080                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.9 MiB -48909.9 MiB       12080                       open_set_hash.add(neighbor)
    78                                                             
    79    115.9 MiB -46814.0 MiB       11391           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.9 MiB -46814.1 MiB       11391           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.3 MiB    110.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.3 MiB    -17.6 MiB         257       for row in grid:
    30    110.3 MiB  -4512.5 MiB       65792           for spot in row:
    31    110.3 MiB  -4494.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.1 MiB     -0.1 MiB           1       count = 0
    34    110.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.1 MiB      0.0 MiB           1       came_from = {}
    37    112.0 MiB    -62.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.0 MiB -127345.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.8 MiB     -3.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.8 MiB      0.0 MiB         930       while not open_set.empty():
    47    108.8 MiB      0.0 MiB         930           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.8 MiB      0.0 MiB         930           current = open_set.get()[2]
    53    108.8 MiB      0.0 MiB         930           open_set_hash.remove(current)
    54                                         
    55    108.8 MiB      0.0 MiB         930           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.8 MiB      0.0 MiB         930           if current == end:
    60    108.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.8 MiB      0.0 MiB        8361           for neighbor in current.neighbors:
    65    108.8 MiB      0.0 MiB        7432               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.8 MiB      0.0 MiB        3716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.8 MiB      0.0 MiB        3716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.8 MiB      0.0 MiB        7432               if temp_g_score < g_score[neighbor]:
    71    108.8 MiB      0.0 MiB        1154                   came_from[neighbor] = current
    72    108.8 MiB      0.0 MiB        1154                   g_score[neighbor] = temp_g_score
    73    108.8 MiB      0.0 MiB        1154                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.8 MiB      0.0 MiB        1154                   if neighbor not in open_set_hash:
    75    108.8 MiB      0.0 MiB        1154                       count += 1
    76    108.8 MiB      0.0 MiB        1154                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.8 MiB      0.0 MiB        1154                       open_set_hash.add(neighbor)
    78                                                             
    79    108.8 MiB      0.0 MiB         929           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.8 MiB      0.0 MiB         929           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.5 MiB    109.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.5 MiB    -56.0 MiB         257       for row in grid:
    30    109.5 MiB -14349.5 MiB       65792           for spot in row:
    31    109.5 MiB -14293.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.0 MiB     -0.5 MiB           1       count = 0
    34    109.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.0 MiB      0.0 MiB           1       came_from = {}
    37    109.5 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.6 MiB -22536.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.2 MiB     -0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.4 MiB   -214.8 MiB        8757       while not open_set.empty():
    47    109.4 MiB   -214.8 MiB        8757           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.4 MiB   -214.8 MiB        8757           current = open_set.get()[2]
    53    109.4 MiB   -214.8 MiB        8757           open_set_hash.remove(current)
    54                                         
    55    109.4 MiB   -214.8 MiB        8757           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.4 MiB   -214.8 MiB        8757           if current == end:
    60    108.2 MiB     -1.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.4 MiB  -1923.7 MiB       78804           for neighbor in current.neighbors:
    65    109.4 MiB  -1709.7 MiB       70048               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.4 MiB   -855.5 MiB       35024                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.4 MiB   -854.2 MiB       35024                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.4 MiB  -1709.7 MiB       70048               if temp_g_score < g_score[neighbor]:
    71    109.4 MiB   -255.5 MiB        9437                   came_from[neighbor] = current
    72    109.4 MiB   -255.7 MiB        9437                   g_score[neighbor] = temp_g_score
    73    109.4 MiB   -255.7 MiB        9437                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.4 MiB   -255.7 MiB        9437                   if neighbor not in open_set_hash:
    75    109.4 MiB   -255.7 MiB        9437                       count += 1
    76    109.4 MiB   -255.7 MiB        9437                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.4 MiB   -256.0 MiB        9437                       open_set_hash.add(neighbor)
    78                                                             
    79    109.4 MiB   -214.6 MiB        8756           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.4 MiB   -214.7 MiB        8756           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.5 MiB    112.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.5 MiB   -129.8 MiB         257       for row in grid:
    30    112.5 MiB -33256.4 MiB       65792           for spot in row:
    31    112.5 MiB -33127.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.6 MiB     -0.9 MiB           1       count = 0
    34    111.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.6 MiB      0.0 MiB           1       came_from = {}
    37    114.2 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.3 MiB  -7973.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.3 MiB   -318.8 MiB        4560       while not open_set.empty():
    47    115.3 MiB   -318.8 MiB        4560           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.3 MiB   -318.8 MiB        4560           current = open_set.get()[2]
    53    115.3 MiB   -318.8 MiB        4560           open_set_hash.remove(current)
    54                                         
    55    115.3 MiB   -318.8 MiB        4560           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.3 MiB   -318.8 MiB        4560           if current == end:
    60    115.1 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.3 MiB  -2867.7 MiB       41031           for neighbor in current.neighbors:
    65    115.3 MiB  -2549.0 MiB       36472               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.3 MiB  -1274.8 MiB       18236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.3 MiB  -1274.2 MiB       18236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.3 MiB  -2549.0 MiB       36472               if temp_g_score < g_score[neighbor]:
    71    115.3 MiB   -352.0 MiB        5114                   came_from[neighbor] = current
    72    115.3 MiB   -352.0 MiB        5114                   g_score[neighbor] = temp_g_score
    73    115.3 MiB   -352.0 MiB        5114                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.3 MiB   -352.0 MiB        5114                   if neighbor not in open_set_hash:
    75    115.3 MiB   -352.0 MiB        5114                       count += 1
    76    115.3 MiB   -352.0 MiB        5114                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.3 MiB   -352.0 MiB        5114                       open_set_hash.add(neighbor)
    78                                                             
    79    115.3 MiB   -318.8 MiB        4559           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.3 MiB   -318.8 MiB        4559           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.4 MiB    115.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.4 MiB    -23.4 MiB         257       for row in grid:
    30    115.4 MiB  -5981.5 MiB       65792           for spot in row:
    31    115.4 MiB  -5958.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.2 MiB     -0.2 MiB           1       count = 0
    34    115.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.2 MiB      0.0 MiB           1       came_from = {}
    37    115.4 MiB -56556.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.2 MiB     -0.1 MiB           1       g_score[start] = 0
    39    118.1 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.1 MiB  -8133.1 MiB        7257       while not open_set.empty():
    47    118.1 MiB  -8133.1 MiB        7257           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.1 MiB  -8133.1 MiB        7257           current = open_set.get()[2]
    53    118.1 MiB  -8133.1 MiB        7257           open_set_hash.remove(current)
    54                                         
    55    118.1 MiB  -8133.1 MiB        7257           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.1 MiB  -8133.1 MiB        7257           if current == end:
    60    115.4 MiB     -2.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.1 MiB -73183.3 MiB       65304           for neighbor in current.neighbors:
    65    118.1 MiB -65051.2 MiB       58048               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.1 MiB -32527.6 MiB       29024                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.1 MiB -32523.5 MiB       29024                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.1 MiB -65051.4 MiB       58048               if temp_g_score < g_score[neighbor]:
    71    118.1 MiB  -8554.9 MiB        7737                   came_from[neighbor] = current
    72    118.1 MiB  -8554.9 MiB        7737                   g_score[neighbor] = temp_g_score
    73    118.1 MiB  -8555.6 MiB        7737                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.1 MiB  -8555.6 MiB        7737                   if neighbor not in open_set_hash:
    75    118.1 MiB  -8555.6 MiB        7737                       count += 1
    76    118.1 MiB  -8555.6 MiB        7737                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.1 MiB  -8555.6 MiB        7737                       open_set_hash.add(neighbor)
    78                                                             
    79    118.1 MiB  -8133.1 MiB        7256           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.1 MiB  -8133.1 MiB        7256           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.5 MiB    115.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.5 MiB      0.0 MiB         257       for row in grid:
    30    115.5 MiB      0.0 MiB       65792           for spot in row:
    31    115.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.5 MiB      0.0 MiB           1       count = 0
    34    115.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.5 MiB      0.0 MiB           1       came_from = {}
    37    116.8 MiB -27108.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.4 MiB -40243.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.1 MiB     -4.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.1 MiB      0.0 MiB         126       while not open_set.empty():
    47    114.1 MiB      0.0 MiB         126           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.1 MiB      0.0 MiB         126           current = open_set.get()[2]
    53    114.1 MiB      0.0 MiB         126           open_set_hash.remove(current)
    54                                         
    55    114.1 MiB      0.0 MiB         126           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.1 MiB      0.0 MiB         126           if current == end:
    60    114.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.1 MiB      0.0 MiB        1125           for neighbor in current.neighbors:
    65    114.1 MiB      0.0 MiB        1000               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.1 MiB      0.0 MiB         500                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.1 MiB      0.0 MiB         500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.1 MiB      0.0 MiB        1000               if temp_g_score < g_score[neighbor]:
    71    114.1 MiB      0.0 MiB         220                   came_from[neighbor] = current
    72    114.1 MiB      0.0 MiB         220                   g_score[neighbor] = temp_g_score
    73    114.1 MiB      0.0 MiB         220                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.1 MiB      0.0 MiB         220                   if neighbor not in open_set_hash:
    75    114.1 MiB      0.0 MiB         220                       count += 1
    76    114.1 MiB      0.0 MiB         220                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.1 MiB      0.0 MiB         220                       open_set_hash.add(neighbor)
    78                                                             
    79    114.1 MiB      0.0 MiB         125           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.1 MiB      0.0 MiB         125           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.2 MiB    114.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.2 MiB  -1856.7 MiB         257       for row in grid:
    30    114.2 MiB -475080.8 MiB       65792           for spot in row:
    31    114.2 MiB -473233.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.8 MiB    -17.4 MiB           1       count = 0
    34     96.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.8 MiB      0.0 MiB           1       came_from = {}
    37    100.6 MiB  -8292.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.7 MiB -19849.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.7 MiB      0.0 MiB         374       while not open_set.empty():
    47    102.7 MiB      0.0 MiB         374           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.7 MiB      0.0 MiB         374           current = open_set.get()[2]
    53    102.7 MiB      0.0 MiB         374           open_set_hash.remove(current)
    54                                         
    55    102.7 MiB      0.0 MiB         374           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.7 MiB      0.0 MiB         374           if current == end:
    60    102.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.7 MiB      0.0 MiB        3357           for neighbor in current.neighbors:
    65    102.7 MiB      0.0 MiB        2984               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.7 MiB      0.0 MiB        1492                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.7 MiB      0.0 MiB        1492                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.7 MiB      0.0 MiB        2984               if temp_g_score < g_score[neighbor]:
    71    102.7 MiB      0.0 MiB         494                   came_from[neighbor] = current
    72    102.7 MiB      0.0 MiB         494                   g_score[neighbor] = temp_g_score
    73    102.7 MiB      0.0 MiB         494                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.7 MiB      0.0 MiB         494                   if neighbor not in open_set_hash:
    75    102.7 MiB      0.0 MiB         494                       count += 1
    76    102.7 MiB      0.0 MiB         494                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.7 MiB      0.0 MiB         494                       open_set_hash.add(neighbor)
    78                                                             
    79    102.7 MiB      0.0 MiB         373           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.7 MiB      0.0 MiB         373           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.8 MiB    104.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.8 MiB   -167.4 MiB         257       for row in grid:
    30    104.8 MiB -42844.1 MiB       65792           for spot in row:
    31    104.8 MiB -42678.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.2 MiB     -2.6 MiB           1       count = 0
    34    102.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.2 MiB      0.0 MiB           1       came_from = {}
    37    107.0 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.1 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.1 MiB      0.0 MiB         583       while not open_set.empty():
    47    110.1 MiB      0.0 MiB         583           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.1 MiB      0.0 MiB         583           current = open_set.get()[2]
    53    110.1 MiB      0.0 MiB         583           open_set_hash.remove(current)
    54                                         
    55    110.1 MiB      0.0 MiB         583           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.1 MiB      0.0 MiB         583           if current == end:
    60    110.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.1 MiB      0.0 MiB        5238           for neighbor in current.neighbors:
    65    110.1 MiB      0.0 MiB        4656               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.1 MiB      0.0 MiB        2328                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.1 MiB      0.0 MiB        2328                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.1 MiB      0.0 MiB        4656               if temp_g_score < g_score[neighbor]:
    71    110.1 MiB      0.0 MiB         731                   came_from[neighbor] = current
    72    110.1 MiB      0.0 MiB         731                   g_score[neighbor] = temp_g_score
    73    110.1 MiB      0.0 MiB         731                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.1 MiB      0.0 MiB         731                   if neighbor not in open_set_hash:
    75    110.1 MiB      0.0 MiB         731                       count += 1
    76    110.1 MiB      0.0 MiB         731                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.1 MiB      0.0 MiB         731                       open_set_hash.add(neighbor)
    78                                                             
    79    110.1 MiB      0.0 MiB         582           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.1 MiB      0.0 MiB         582           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.6 MiB    108.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.6 MiB   -208.0 MiB         257       for row in grid:
    30    108.6 MiB -53400.5 MiB       65792           for spot in row:
    31    108.6 MiB -53193.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.7 MiB     -1.9 MiB           1       count = 0
    34    106.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.7 MiB      0.0 MiB           1       came_from = {}
    37    111.4 MiB      4.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.5 MiB  -5127.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.4 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.4 MiB -11209.6 MiB        3040       while not open_set.empty():
    47    112.4 MiB -11209.6 MiB        3040           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.4 MiB -11209.6 MiB        3040           current = open_set.get()[2]
    53    112.4 MiB -11209.8 MiB        3040           open_set_hash.remove(current)
    54                                         
    55    112.4 MiB -11210.0 MiB        3040           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.4 MiB -11210.0 MiB        3040           if current == end:
    60    104.5 MiB     -7.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.4 MiB -100838.8 MiB       27351           for neighbor in current.neighbors:
    65    112.4 MiB -89633.7 MiB       24312               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.4 MiB -44823.5 MiB       12156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.4 MiB -44811.5 MiB       12156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.4 MiB -89635.9 MiB       24312               if temp_g_score < g_score[neighbor]:
    71    112.4 MiB -12504.5 MiB        3434                   came_from[neighbor] = current
    72    112.4 MiB -12504.5 MiB        3434                   g_score[neighbor] = temp_g_score
    73    112.4 MiB -12504.5 MiB        3434                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.4 MiB -12504.5 MiB        3434                   if neighbor not in open_set_hash:
    75    112.4 MiB -12504.5 MiB        3434                       count += 1
    76    112.4 MiB -12504.5 MiB        3434                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.4 MiB -12504.5 MiB        3434                       open_set_hash.add(neighbor)
    78                                                             
    79    112.4 MiB -11209.4 MiB        3039           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.4 MiB -11209.4 MiB        3039           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.0 MiB    105.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.0 MiB    -16.9 MiB         257       for row in grid:
    30    105.0 MiB  -4283.6 MiB       65792           for spot in row:
    31    105.0 MiB  -4266.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.6 MiB     -0.4 MiB           1       count = 0
    34    104.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.6 MiB      0.0 MiB           1       came_from = {}
    37    107.8 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.3 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.3 MiB      0.0 MiB         288       while not open_set.empty():
    47    111.3 MiB      0.0 MiB         288           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.3 MiB      0.0 MiB         288           current = open_set.get()[2]
    53    111.3 MiB      0.0 MiB         288           open_set_hash.remove(current)
    54                                         
    55    111.3 MiB      0.0 MiB         288           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.3 MiB      0.0 MiB         288           if current == end:
    60    111.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.3 MiB      0.0 MiB        2583           for neighbor in current.neighbors:
    65    111.3 MiB      0.0 MiB        2296               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.3 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.3 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.3 MiB      0.0 MiB        2296               if temp_g_score < g_score[neighbor]:
    71    111.3 MiB      0.0 MiB         386                   came_from[neighbor] = current
    72    111.3 MiB      0.0 MiB         386                   g_score[neighbor] = temp_g_score
    73    111.3 MiB      0.0 MiB         386                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.3 MiB      0.0 MiB         386                   if neighbor not in open_set_hash:
    75    111.3 MiB      0.0 MiB         386                       count += 1
    76    111.3 MiB      0.0 MiB         386                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.3 MiB      0.0 MiB         386                       open_set_hash.add(neighbor)
    78                                                             
    79    111.3 MiB      0.0 MiB         287           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.3 MiB      0.0 MiB         287           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.1 MiB    110.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.1 MiB      0.0 MiB         257       for row in grid:
    30    110.1 MiB      0.0 MiB       65792           for spot in row:
    31    110.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.1 MiB      0.0 MiB           1       count = 0
    34    110.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.1 MiB      0.0 MiB           1       came_from = {}
    37    111.5 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.9 MiB   -321.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.9 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.9 MiB      0.0 MiB         108       while not open_set.empty():
    47    114.9 MiB      0.0 MiB         108           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.9 MiB      0.0 MiB         108           current = open_set.get()[2]
    53    114.9 MiB      0.0 MiB         108           open_set_hash.remove(current)
    54                                         
    55    114.9 MiB      0.0 MiB         108           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.9 MiB      0.0 MiB         108           if current == end:
    60    114.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.9 MiB      0.0 MiB         963           for neighbor in current.neighbors:
    65    114.9 MiB      0.0 MiB         856               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.9 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.9 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.9 MiB      0.0 MiB         856               if temp_g_score < g_score[neighbor]:
    71    114.9 MiB      0.0 MiB         166                   came_from[neighbor] = current
    72    114.9 MiB      0.0 MiB         166                   g_score[neighbor] = temp_g_score
    73    114.9 MiB      0.0 MiB         166                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.9 MiB      0.0 MiB         166                   if neighbor not in open_set_hash:
    75    114.9 MiB      0.0 MiB         166                       count += 1
    76    114.9 MiB      0.0 MiB         166                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.9 MiB      0.0 MiB         166                       open_set_hash.add(neighbor)
    78                                                             
    79    114.9 MiB      0.0 MiB         107           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.9 MiB      0.0 MiB         107           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.1 MiB    115.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.1 MiB  -1335.9 MiB         257       for row in grid:
    30    115.1 MiB -342486.7 MiB       65792           for spot in row:
    31    115.1 MiB -341154.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.8 MiB     -6.3 MiB           1       count = 0
    34    108.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.8 MiB      0.0 MiB           1       came_from = {}
    37    111.2 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.5 MiB    -27.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.5 MiB      0.0 MiB        4730       while not open_set.empty():
    47    115.5 MiB      0.0 MiB        4730           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.5 MiB      0.0 MiB        4730           current = open_set.get()[2]
    53    115.5 MiB      0.0 MiB        4730           open_set_hash.remove(current)
    54                                         
    55    115.5 MiB      0.0 MiB        4730           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.5 MiB      0.0 MiB        4730           if current == end:
    60    115.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.5 MiB      0.0 MiB       42561           for neighbor in current.neighbors:
    65    115.5 MiB      0.0 MiB       37832               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.5 MiB      0.0 MiB       18916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.5 MiB      0.0 MiB       18916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.5 MiB      0.0 MiB       37832               if temp_g_score < g_score[neighbor]:
    71    115.5 MiB      0.0 MiB        5120                   came_from[neighbor] = current
    72    115.5 MiB      0.0 MiB        5120                   g_score[neighbor] = temp_g_score
    73    115.5 MiB      0.0 MiB        5120                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.5 MiB      0.0 MiB        5120                   if neighbor not in open_set_hash:
    75    115.5 MiB      0.0 MiB        5120                       count += 1
    76    115.5 MiB      0.0 MiB        5120                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.5 MiB      0.0 MiB        5120                       open_set_hash.add(neighbor)
    78                                                             
    79    115.5 MiB      0.0 MiB        4729           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.5 MiB      0.0 MiB        4729           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.3 MiB    118.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.3 MiB  -1478.6 MiB         257       for row in grid:
    30    118.3 MiB -379158.8 MiB       65792           for spot in row:
    31    118.3 MiB -377683.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.7 MiB     -6.6 MiB           1       count = 0
    34    111.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.7 MiB      0.0 MiB           1       came_from = {}
    37    114.6 MiB   -476.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.3 MiB -57327.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.5 MiB     -0.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.5 MiB      0.0 MiB         624       while not open_set.empty():
    47    115.5 MiB      0.0 MiB         624           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.5 MiB      0.0 MiB         624           current = open_set.get()[2]
    53    115.5 MiB      0.0 MiB         624           open_set_hash.remove(current)
    54                                         
    55    115.5 MiB      0.0 MiB         624           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.5 MiB      0.0 MiB         624           if current == end:
    60    115.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.5 MiB      0.0 MiB        5607           for neighbor in current.neighbors:
    65    115.5 MiB      0.0 MiB        4984               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.5 MiB      0.0 MiB        2492                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.5 MiB      0.0 MiB        2492                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.5 MiB      0.0 MiB        4984               if temp_g_score < g_score[neighbor]:
    71    115.5 MiB      0.0 MiB         770                   came_from[neighbor] = current
    72    115.5 MiB      0.0 MiB         770                   g_score[neighbor] = temp_g_score
    73    115.5 MiB      0.0 MiB         770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.5 MiB      0.0 MiB         770                   if neighbor not in open_set_hash:
    75    115.5 MiB      0.0 MiB         770                       count += 1
    76    115.5 MiB      0.0 MiB         770                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.5 MiB      0.0 MiB         770                       open_set_hash.add(neighbor)
    78                                                             
    79    115.5 MiB      0.0 MiB         623           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.5 MiB      0.0 MiB         623           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.5 MiB    114.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.5 MiB      0.0 MiB         257       for row in grid:
    30    114.5 MiB      0.0 MiB       65792           for spot in row:
    31    114.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.5 MiB      0.0 MiB           1       count = 0
    34    114.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.5 MiB      0.0 MiB           1       came_from = {}
    37    116.2 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    119.2 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    119.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    119.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    119.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    119.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    119.2 MiB  -7162.2 MiB        4366       while not open_set.empty():
    47    119.2 MiB  -7162.2 MiB        4366           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    119.2 MiB  -7162.2 MiB        4366           current = open_set.get()[2]
    53    119.2 MiB  -7162.2 MiB        4366           open_set_hash.remove(current)
    54                                         
    55    119.2 MiB  -7162.2 MiB        4366           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    119.2 MiB  -7162.2 MiB        4366           if current == end:
    60    117.5 MiB     -1.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    117.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    119.2 MiB -64448.2 MiB       39285           for neighbor in current.neighbors:
    65    119.2 MiB -57286.0 MiB       34920               if current.row != neighbor.row and current.col != neighbor.col:
    66    119.2 MiB -28643.9 MiB       17460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    119.2 MiB -28642.1 MiB       17460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    119.2 MiB -57286.0 MiB       34920               if temp_g_score < g_score[neighbor]:
    71    119.2 MiB  -7958.6 MiB        4910                   came_from[neighbor] = current
    72    119.2 MiB  -7958.6 MiB        4910                   g_score[neighbor] = temp_g_score
    73    119.2 MiB  -7958.6 MiB        4910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    119.2 MiB  -7958.7 MiB        4910                   if neighbor not in open_set_hash:
    75    119.2 MiB  -7960.3 MiB        4910                       count += 1
    76    119.2 MiB  -7960.3 MiB        4910                       open_set.put((f_score[neighbor], count, neighbor))
    77    119.2 MiB  -7960.3 MiB        4910                       open_set_hash.add(neighbor)
    78                                                             
    79    119.2 MiB  -7162.2 MiB        4365           if draw is not None:
    80                                                     draw()
    81                                         
    82    119.2 MiB  -7162.2 MiB        4365           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.3 MiB    115.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.3 MiB      0.0 MiB         257       for row in grid:
    30    115.3 MiB      0.0 MiB       65792           for spot in row:
    31    115.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.3 MiB      0.0 MiB           1       count = 0
    34    115.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.3 MiB      0.0 MiB           1       came_from = {}
    37    116.6 MiB  -6428.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.1 MiB     -0.5 MiB           1       g_score[start] = 0
    39    116.1 MiB -284691.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.7 MiB     -3.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.7 MiB   -671.9 MiB        1800       while not open_set.empty():
    47    112.7 MiB   -671.9 MiB        1800           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.7 MiB   -671.9 MiB        1800           current = open_set.get()[2]
    53    112.7 MiB   -671.9 MiB        1800           open_set_hash.remove(current)
    54                                         
    55    112.7 MiB   -671.9 MiB        1800           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.7 MiB   -671.9 MiB        1800           if current == end:
    60    111.7 MiB     -0.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.7 MiB  -6043.3 MiB       16191           for neighbor in current.neighbors:
    65    112.7 MiB  -5371.7 MiB       14392               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.7 MiB  -2686.7 MiB        7196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.7 MiB  -2685.2 MiB        7196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.7 MiB  -5372.0 MiB       14392               if temp_g_score < g_score[neighbor]:
    71    112.7 MiB   -894.7 MiB        2422                   came_from[neighbor] = current
    72    112.7 MiB   -894.8 MiB        2422                   g_score[neighbor] = temp_g_score
    73    112.7 MiB   -894.8 MiB        2422                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.7 MiB   -894.8 MiB        2422                   if neighbor not in open_set_hash:
    75    112.7 MiB   -894.8 MiB        2422                       count += 1
    76    112.7 MiB   -894.9 MiB        2422                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.7 MiB   -894.9 MiB        2422                       open_set_hash.add(neighbor)
    78                                                             
    79    112.7 MiB   -671.9 MiB        1799           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.7 MiB   -671.9 MiB        1799           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.7 MiB    112.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.7 MiB    -46.8 MiB         257       for row in grid:
    30    112.7 MiB -12009.8 MiB       65792           for spot in row:
    31    112.7 MiB -11963.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.5 MiB     -0.2 MiB           1       count = 0
    34    112.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.5 MiB      0.0 MiB           1       came_from = {}
    37    114.5 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.5 MiB -79200.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.9 MiB     -7.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.1 MiB      0.0 MiB         280       while not open_set.empty():
    47    109.1 MiB      0.0 MiB         280           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.1 MiB      0.0 MiB         280           current = open_set.get()[2]
    53    109.1 MiB      0.0 MiB         280           open_set_hash.remove(current)
    54                                         
    55    109.1 MiB      0.0 MiB         280           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.1 MiB      0.0 MiB         280           if current == end:
    60    109.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.1 MiB      0.0 MiB        2511           for neighbor in current.neighbors:
    65    109.1 MiB      0.0 MiB        2232               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.1 MiB      0.0 MiB        1116                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.1 MiB      0.0 MiB        1116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.1 MiB      0.1 MiB        2232               if temp_g_score < g_score[neighbor]:
    71    109.1 MiB      0.0 MiB         374                   came_from[neighbor] = current
    72    109.1 MiB      0.0 MiB         374                   g_score[neighbor] = temp_g_score
    73    109.1 MiB      0.0 MiB         374                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.1 MiB      0.0 MiB         374                   if neighbor not in open_set_hash:
    75    109.1 MiB      0.0 MiB         374                       count += 1
    76    109.1 MiB      0.0 MiB         374                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.1 MiB      0.0 MiB         374                       open_set_hash.add(neighbor)
    78                                                             
    79    109.1 MiB      0.0 MiB         279           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.1 MiB      0.0 MiB         279           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.4 MiB    111.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.4 MiB   -126.8 MiB         257       for row in grid:
    30    111.4 MiB -32506.9 MiB       65792           for spot in row:
    31    111.4 MiB -32380.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.8 MiB     -0.5 MiB           1       count = 0
    34    110.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.8 MiB      0.0 MiB           1       came_from = {}
    37    111.0 MiB      0.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.9 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.0 MiB   -975.3 MiB         820       while not open_set.empty():
    47    113.0 MiB   -975.3 MiB         820           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.0 MiB   -975.3 MiB         820           current = open_set.get()[2]
    53    113.0 MiB   -975.3 MiB         820           open_set_hash.remove(current)
    54                                         
    55    113.0 MiB   -975.3 MiB         820           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.0 MiB   -975.3 MiB         820           if current == end:
    60    111.6 MiB     -1.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.0 MiB  -8775.8 MiB        7371           for neighbor in current.neighbors:
    65    113.0 MiB  -7800.7 MiB        6552               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.0 MiB  -3901.6 MiB        3276                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.0 MiB  -3899.7 MiB        3276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.0 MiB  -7801.2 MiB        6552               if temp_g_score < g_score[neighbor]:
    71    113.0 MiB  -1179.0 MiB        1022                   came_from[neighbor] = current
    72    113.0 MiB  -1179.1 MiB        1022                   g_score[neighbor] = temp_g_score
    73    113.0 MiB  -1179.1 MiB        1022                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.0 MiB  -1179.1 MiB        1022                   if neighbor not in open_set_hash:
    75    113.0 MiB  -1179.1 MiB        1022                       count += 1
    76    113.0 MiB  -1179.1 MiB        1022                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.0 MiB  -1179.1 MiB        1022                       open_set_hash.add(neighbor)
    78                                                             
    79    113.0 MiB   -975.3 MiB         819           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.0 MiB   -975.3 MiB         819           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.6 MiB    111.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.6 MiB   -102.2 MiB         257       for row in grid:
    30    111.6 MiB -26197.8 MiB       65792           for spot in row:
    31    111.6 MiB -26095.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.1 MiB     -0.5 MiB           1       count = 0
    34    111.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.1 MiB      0.0 MiB           1       came_from = {}
    37    111.2 MiB -146380.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.5 MiB     -0.7 MiB           1       g_score[start] = 0
    39    110.5 MiB -82859.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.1 MiB     -0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.1 MiB      0.0 MiB         100       while not open_set.empty():
    47    110.1 MiB      0.0 MiB         100           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.1 MiB      0.0 MiB         100           current = open_set.get()[2]
    53    110.1 MiB      0.0 MiB         100           open_set_hash.remove(current)
    54                                         
    55    110.1 MiB      0.0 MiB         100           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.1 MiB      0.0 MiB         100           if current == end:
    60    110.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.1 MiB      0.0 MiB         891           for neighbor in current.neighbors:
    65    110.1 MiB      0.0 MiB         792               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.1 MiB      0.0 MiB         396                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.1 MiB      0.0 MiB         396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.1 MiB      0.0 MiB         792               if temp_g_score < g_score[neighbor]:
    71    110.1 MiB      0.0 MiB         164                   came_from[neighbor] = current
    72    110.1 MiB      0.0 MiB         164                   g_score[neighbor] = temp_g_score
    73    110.1 MiB      0.0 MiB         164                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.1 MiB      0.0 MiB         164                   if neighbor not in open_set_hash:
    75    110.1 MiB      0.0 MiB         164                       count += 1
    76    110.1 MiB      0.0 MiB         164                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.1 MiB      0.0 MiB         164                       open_set_hash.add(neighbor)
    78                                                             
    79    110.1 MiB      0.0 MiB          99           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.1 MiB      0.0 MiB          99           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.9 MiB    104.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.9 MiB      0.0 MiB         257       for row in grid:
    30    104.9 MiB      0.0 MiB       65792           for spot in row:
    31    104.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.9 MiB      0.0 MiB           1       count = 0
    34    104.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.9 MiB      0.0 MiB           1       came_from = {}
    37    107.6 MiB  -4995.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.4 MiB     -0.2 MiB           1       g_score[start] = 0
    39    110.5 MiB   -449.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.5 MiB      0.0 MiB         987       while not open_set.empty():
    47    110.5 MiB      0.0 MiB         987           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.5 MiB      0.0 MiB         987           current = open_set.get()[2]
    53    110.5 MiB      0.0 MiB         987           open_set_hash.remove(current)
    54                                         
    55    110.5 MiB      0.0 MiB         987           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.5 MiB      0.0 MiB         987           if current == end:
    60    110.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.5 MiB      0.0 MiB        8874           for neighbor in current.neighbors:
    65    110.5 MiB      0.0 MiB        7888               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.5 MiB      0.0 MiB        3944                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.5 MiB      0.0 MiB        3944                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.5 MiB      0.0 MiB        7888               if temp_g_score < g_score[neighbor]:
    71    110.5 MiB      0.0 MiB        1215                   came_from[neighbor] = current
    72    110.5 MiB      0.0 MiB        1215                   g_score[neighbor] = temp_g_score
    73    110.5 MiB      0.0 MiB        1215                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.5 MiB      0.0 MiB        1215                   if neighbor not in open_set_hash:
    75    110.5 MiB      0.0 MiB        1215                       count += 1
    76    110.5 MiB      0.0 MiB        1215                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.5 MiB      0.0 MiB        1215                       open_set_hash.add(neighbor)
    78                                                             
    79    110.5 MiB      0.0 MiB         986           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.5 MiB      0.0 MiB         986           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.2 MiB    110.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.2 MiB      0.0 MiB         257       for row in grid:
    30    110.2 MiB      0.0 MiB       65792           for spot in row:
    31    110.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.2 MiB      0.0 MiB           1       count = 0
    34    110.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.2 MiB      0.0 MiB           1       came_from = {}
    37    111.4 MiB  -6034.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.8 MiB     -0.6 MiB           1       g_score[start] = 0
    39    112.2 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.3 MiB  -3517.9 MiB        2496       while not open_set.empty():
    47    112.3 MiB  -3517.9 MiB        2496           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.3 MiB  -3517.9 MiB        2496           current = open_set.get()[2]
    53    112.3 MiB  -3517.9 MiB        2496           open_set_hash.remove(current)
    54                                         
    55    112.3 MiB  -3517.9 MiB        2496           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.3 MiB  -3517.9 MiB        2496           if current == end:
    60    110.4 MiB     -1.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.3 MiB -31652.0 MiB       22455           for neighbor in current.neighbors:
    65    112.3 MiB -28134.6 MiB       19960               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.3 MiB -14069.3 MiB        9980                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.3 MiB -14065.7 MiB        9980                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.3 MiB -28135.7 MiB       19960               if temp_g_score < g_score[neighbor]:
    71    112.3 MiB  -3771.2 MiB        2778                   came_from[neighbor] = current
    72    112.3 MiB  -3771.3 MiB        2778                   g_score[neighbor] = temp_g_score
    73    112.3 MiB  -3771.3 MiB        2778                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.3 MiB  -3771.3 MiB        2778                   if neighbor not in open_set_hash:
    75    112.3 MiB  -3771.3 MiB        2778                       count += 1
    76    112.3 MiB  -3771.3 MiB        2778                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.3 MiB  -3771.3 MiB        2778                       open_set_hash.add(neighbor)
    78                                                             
    79    112.3 MiB  -3517.9 MiB        2495           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.3 MiB  -3517.9 MiB        2495           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.0 MiB    113.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.0 MiB      0.0 MiB         257       for row in grid:
    30    113.0 MiB      0.0 MiB       65792           for spot in row:
    31    113.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.0 MiB      0.0 MiB           1       count = 0
    34    113.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.0 MiB      0.0 MiB           1       came_from = {}
    37    114.2 MiB    -42.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.2 MiB     -0.0 MiB           1       g_score[start] = 0
    39    115.4 MiB -18779.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.4 MiB      0.0 MiB        2856       while not open_set.empty():
    47    115.4 MiB      0.0 MiB        2856           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.4 MiB      0.0 MiB        2856           current = open_set.get()[2]
    53    115.4 MiB      0.0 MiB        2856           open_set_hash.remove(current)
    54                                         
    55    115.4 MiB      0.0 MiB        2856           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.4 MiB      0.0 MiB        2856           if current == end:
    60    115.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.4 MiB      0.0 MiB       25695           for neighbor in current.neighbors:
    65    115.4 MiB      0.0 MiB       22840               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.4 MiB      0.0 MiB       11420                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.4 MiB      0.0 MiB       11420                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.4 MiB      0.0 MiB       22840               if temp_g_score < g_score[neighbor]:
    71    115.4 MiB      0.0 MiB        3180                   came_from[neighbor] = current
    72    115.4 MiB      0.0 MiB        3180                   g_score[neighbor] = temp_g_score
    73    115.4 MiB      0.0 MiB        3180                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.4 MiB      0.0 MiB        3180                   if neighbor not in open_set_hash:
    75    115.4 MiB      0.0 MiB        3180                       count += 1
    76    115.4 MiB      0.0 MiB        3180                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.4 MiB      0.0 MiB        3180                       open_set_hash.add(neighbor)
    78                                                             
    79    115.4 MiB      0.0 MiB        2855           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.4 MiB      0.0 MiB        2855           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.5 MiB    113.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.5 MiB      0.0 MiB         257       for row in grid:
    30    113.5 MiB      0.0 MiB       65792           for spot in row:
    31    113.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.5 MiB      0.0 MiB           1       count = 0
    34    113.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.5 MiB      0.0 MiB           1       came_from = {}
    37    115.0 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.6 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.6 MiB      0.0 MiB         510       while not open_set.empty():
    47    117.6 MiB      0.0 MiB         510           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.6 MiB      0.0 MiB         510           current = open_set.get()[2]
    53    117.6 MiB      0.0 MiB         510           open_set_hash.remove(current)
    54                                         
    55    117.6 MiB      0.0 MiB         510           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.6 MiB      0.0 MiB         510           if current == end:
    60    117.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    117.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.6 MiB      0.0 MiB        4581           for neighbor in current.neighbors:
    65    117.6 MiB      0.0 MiB        4072               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.6 MiB      0.0 MiB        2036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.6 MiB      0.0 MiB        2036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.6 MiB      0.0 MiB        4072               if temp_g_score < g_score[neighbor]:
    71    117.6 MiB      0.0 MiB         636                   came_from[neighbor] = current
    72    117.6 MiB      0.0 MiB         636                   g_score[neighbor] = temp_g_score
    73    117.6 MiB      0.0 MiB         636                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.6 MiB      0.0 MiB         636                   if neighbor not in open_set_hash:
    75    117.6 MiB      0.0 MiB         636                       count += 1
    76    117.6 MiB      0.0 MiB         636                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.6 MiB      0.0 MiB         636                       open_set_hash.add(neighbor)
    78                                                             
    79    117.6 MiB      0.0 MiB         509           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.6 MiB      0.0 MiB         509           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    117.7 MiB    117.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    117.7 MiB   -341.9 MiB         257       for row in grid:
    30    117.7 MiB -87119.2 MiB       65792           for spot in row:
    31    117.7 MiB -86780.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.5 MiB     -5.1 MiB           1       count = 0
    34    112.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.5 MiB      0.0 MiB           1       came_from = {}
    37    113.6 MiB -10255.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.5 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.5 MiB   -560.2 MiB        3959       while not open_set.empty():
    47    114.5 MiB   -560.2 MiB        3959           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.5 MiB   -560.2 MiB        3959           current = open_set.get()[2]
    53    114.5 MiB   -560.3 MiB        3959           open_set_hash.remove(current)
    54                                         
    55    114.5 MiB   -560.3 MiB        3959           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.5 MiB   -560.3 MiB        3959           if current == end:
    60    113.0 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.5 MiB  -5039.3 MiB       35622           for neighbor in current.neighbors:
    65    114.5 MiB  -4479.1 MiB       31664               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.5 MiB  -2240.9 MiB       15832                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.5 MiB  -2238.2 MiB       15832                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.5 MiB  -4479.1 MiB       31664               if temp_g_score < g_score[neighbor]:
    71    114.5 MiB   -634.2 MiB        4459                   came_from[neighbor] = current
    72    114.5 MiB   -634.2 MiB        4459                   g_score[neighbor] = temp_g_score
    73    114.5 MiB   -634.2 MiB        4459                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.5 MiB   -634.2 MiB        4459                   if neighbor not in open_set_hash:
    75    114.5 MiB   -634.2 MiB        4459                       count += 1
    76    114.5 MiB   -634.2 MiB        4459                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.5 MiB   -634.2 MiB        4459                       open_set_hash.add(neighbor)
    78                                                             
    79    114.5 MiB   -560.2 MiB        3958           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.5 MiB   -560.2 MiB        3958           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.3 MiB    113.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.3 MiB   -630.9 MiB         257       for row in grid:
    30    113.3 MiB -161145.0 MiB       65792           for spot in row:
    31    113.3 MiB -160518.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.6 MiB     -4.7 MiB           1       count = 0
    34    108.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.6 MiB      0.0 MiB           1       came_from = {}
    37    110.2 MiB -91624.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.8 MiB     -2.3 MiB           1       g_score[start] = 0
    39    109.4 MiB -1350860.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     55.2 MiB    -54.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     55.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     55.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     55.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.3 MiB   -585.6 MiB         312       while not open_set.empty():
    47     55.3 MiB   -586.8 MiB         312           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.3 MiB   -586.8 MiB         312           current = open_set.get()[2]
    53     55.3 MiB   -586.8 MiB         312           open_set_hash.remove(current)
    54                                         
    55     55.3 MiB   -586.8 MiB         312           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.3 MiB   -586.8 MiB         312           if current == end:
    60     53.3 MiB     -2.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     53.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.3 MiB  -5263.3 MiB        2799           for neighbor in current.neighbors:
    65     55.3 MiB  -4677.8 MiB        2488               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.3 MiB  -2339.2 MiB        1244                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.3 MiB  -2338.6 MiB        1244                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.3 MiB  -4677.4 MiB        2488               if temp_g_score < g_score[neighbor]:
    71     55.3 MiB   -782.5 MiB         438                   came_from[neighbor] = current
    72     55.3 MiB   -782.8 MiB         438                   g_score[neighbor] = temp_g_score
    73     55.3 MiB   -782.9 MiB         438                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.3 MiB   -782.9 MiB         438                   if neighbor not in open_set_hash:
    75     55.3 MiB   -782.9 MiB         438                       count += 1
    76     55.3 MiB   -782.8 MiB         438                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.3 MiB   -782.8 MiB         438                       open_set_hash.add(neighbor)
    78                                                             
    79     55.3 MiB   -585.4 MiB         311           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.3 MiB   -585.6 MiB         311           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


