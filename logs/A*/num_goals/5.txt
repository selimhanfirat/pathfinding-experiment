Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.2 MiB     67.2 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.9 MiB  -3104.0 MiB         257       for row in grid:
    30     67.9 MiB -796459.0 MiB       65792           for spot in row:
    31     67.9 MiB -793362.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.7 MiB    -10.1 MiB           1       count = 0
    34     57.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.8 MiB      0.0 MiB           1       came_from = {}
    37     64.9 MiB  -1486.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.3 MiB   -395.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.8 MiB      0.0 MiB        2268       while not open_set.empty():
    47     71.8 MiB      0.0 MiB        2268           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.8 MiB      0.0 MiB        2268           current = open_set.get()[2]
    53     71.8 MiB      0.0 MiB        2268           open_set_hash.remove(current)
    54                                         
    55     71.8 MiB      0.0 MiB        2268           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.8 MiB      0.0 MiB        2268           if current == end:
    60     71.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.8 MiB      0.3 MiB       20403           for neighbor in current.neighbors:
    65     71.8 MiB      0.0 MiB       18136               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.8 MiB      0.0 MiB        9068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.8 MiB      0.0 MiB        9068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.8 MiB      0.0 MiB       18136               if temp_g_score < g_score[neighbor]:
    71     71.8 MiB      0.1 MiB        2646                   came_from[neighbor] = current
    72     71.8 MiB      0.0 MiB        2646                   g_score[neighbor] = temp_g_score
    73     71.8 MiB      0.0 MiB        2646                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.8 MiB      0.0 MiB        2646                   if neighbor not in open_set_hash:
    75     71.8 MiB      0.0 MiB        2646                       count += 1
    76     71.8 MiB      0.0 MiB        2646                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.8 MiB      0.1 MiB        2646                       open_set_hash.add(neighbor)
    78                                                             
    79     71.8 MiB      0.0 MiB        2267           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.8 MiB      0.0 MiB        2267           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.9 MiB     70.9 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     72.4 MiB      0.0 MiB         257       for row in grid:
    30     72.4 MiB      0.0 MiB       65792           for spot in row:
    31     72.4 MiB      1.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.4 MiB      0.0 MiB           1       count = 0
    34     72.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.4 MiB      0.0 MiB           1       came_from = {}
    37     76.8 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     81.8 MiB      4.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     81.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     81.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     81.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     81.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     81.8 MiB   -175.1 MiB        1596       while not open_set.empty():
    47     81.8 MiB   -175.1 MiB        1596           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     81.8 MiB   -175.1 MiB        1596           current = open_set.get()[2]
    53     81.8 MiB   -175.1 MiB        1596           open_set_hash.remove(current)
    54                                         
    55     81.8 MiB   -175.1 MiB        1596           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     81.8 MiB   -175.1 MiB        1596           if current == end:
    60     81.6 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     81.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     81.8 MiB  -1574.6 MiB       14355           for neighbor in current.neighbors:
    65     81.8 MiB  -1399.7 MiB       12760               if current.row != neighbor.row and current.col != neighbor.col:
    66     81.8 MiB   -700.2 MiB        6380                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     81.8 MiB   -699.6 MiB        6380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     81.8 MiB  -1399.7 MiB       12760               if temp_g_score < g_score[neighbor]:
    71     81.8 MiB   -208.2 MiB        1940                   came_from[neighbor] = current
    72     81.8 MiB   -208.2 MiB        1940                   g_score[neighbor] = temp_g_score
    73     81.8 MiB   -208.2 MiB        1940                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     81.8 MiB   -208.2 MiB        1940                   if neighbor not in open_set_hash:
    75     81.8 MiB   -208.2 MiB        1940                       count += 1
    76     81.8 MiB   -208.2 MiB        1940                       open_set.put((f_score[neighbor], count, neighbor))
    77     81.8 MiB   -208.2 MiB        1940                       open_set_hash.add(neighbor)
    78                                                             
    79     81.8 MiB   -175.1 MiB        1595           if draw is not None:
    80                                                     draw()
    81                                         
    82     81.8 MiB   -175.1 MiB        1595           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     81.6 MiB     81.6 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     81.6 MiB  -2176.7 MiB         257       for row in grid:
    30     81.6 MiB -557380.6 MiB       65792           for spot in row:
    31     81.6 MiB -555217.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     65.0 MiB    -16.5 MiB           1       count = 0
    34     65.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     65.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     65.0 MiB      0.0 MiB           1       came_from = {}
    37     69.8 MiB      4.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.0 MiB -1328927.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     51.2 MiB    -18.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     51.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     51.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     51.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     51.9 MiB      0.0 MiB         288       while not open_set.empty():
    47     51.9 MiB      0.0 MiB         288           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     51.9 MiB      0.0 MiB         288           current = open_set.get()[2]
    53     51.9 MiB      0.0 MiB         288           open_set_hash.remove(current)
    54                                         
    55     51.9 MiB      0.0 MiB         288           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     51.9 MiB      0.0 MiB         288           if current == end:
    60     51.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     51.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     51.9 MiB      0.0 MiB        2583           for neighbor in current.neighbors:
    65     51.9 MiB      0.2 MiB        2296               if current.row != neighbor.row and current.col != neighbor.col:
    66     51.9 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     51.9 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     51.9 MiB      0.1 MiB        2296               if temp_g_score < g_score[neighbor]:
    71     51.9 MiB      0.1 MiB         386                   came_from[neighbor] = current
    72     51.9 MiB      0.0 MiB         386                   g_score[neighbor] = temp_g_score
    73     51.9 MiB      0.0 MiB         386                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     51.9 MiB      0.0 MiB         386                   if neighbor not in open_set_hash:
    75     51.9 MiB      0.0 MiB         386                       count += 1
    76     51.9 MiB      0.0 MiB         386                       open_set.put((f_score[neighbor], count, neighbor))
    77     51.9 MiB      0.0 MiB         386                       open_set_hash.add(neighbor)
    78                                                             
    79     51.9 MiB      0.0 MiB         287           if draw is not None:
    80                                                     draw()
    81                                         
    82     51.9 MiB      0.0 MiB         287           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     54.2 MiB     54.2 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     57.5 MiB   -273.6 MiB         257       for row in grid:
    30     57.5 MiB -70023.6 MiB       65792           for spot in row:
    31     57.5 MiB -69744.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.5 MiB      0.0 MiB           1       count = 0
    34     57.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.5 MiB      0.0 MiB           1       came_from = {}
    37     60.2 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.8 MiB -95528.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.0 MiB     -1.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.1 MiB  -6367.5 MiB        1932       while not open_set.empty():
    47     60.1 MiB  -6367.7 MiB        1932           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.1 MiB  -6367.9 MiB        1932           current = open_set.get()[2]
    53     60.1 MiB  -6368.0 MiB        1932           open_set_hash.remove(current)
    54                                         
    55     60.1 MiB  -6368.0 MiB        1932           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.1 MiB  -6368.1 MiB        1932           if current == end:
    60     54.8 MiB     -5.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     54.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.1 MiB -57277.7 MiB       17379           for neighbor in current.neighbors:
    65     60.1 MiB -50911.7 MiB       15448               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.1 MiB -25459.2 MiB        7724                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.1 MiB -25453.5 MiB        7724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.1 MiB -50913.6 MiB       15448               if temp_g_score < g_score[neighbor]:
    71     60.1 MiB  -6961.4 MiB        2190                   came_from[neighbor] = current
    72     60.1 MiB  -6961.7 MiB        2190                   g_score[neighbor] = temp_g_score
    73     60.1 MiB  -6961.8 MiB        2190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.1 MiB  -6961.8 MiB        2190                   if neighbor not in open_set_hash:
    75     60.1 MiB  -6961.9 MiB        2190                       count += 1
    76     60.1 MiB  -6962.0 MiB        2190                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.1 MiB  -6962.1 MiB        2190                       open_set_hash.add(neighbor)
    78                                                             
    79     60.1 MiB  -6366.9 MiB        1931           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.1 MiB  -6367.2 MiB        1931           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     56.9 MiB     56.9 MiB           1   @profile(stream=open('logs/A*/num_goals/5.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     57.7 MiB   -309.2 MiB         257       for row in grid:
    30     57.7 MiB -79031.1 MiB       65792           for spot in row:
    31     57.7 MiB -78721.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     55.6 MiB     -2.1 MiB           1       count = 0
    34     55.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     55.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     55.6 MiB      0.0 MiB           1       came_from = {}
    37     59.3 MiB  -6492.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.1 MiB     -1.2 MiB           1       g_score[start] = 0
    39     59.7 MiB -479722.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     46.8 MiB    -12.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     46.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     46.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     46.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     49.9 MiB   -136.7 MiB        1620       while not open_set.empty():
    47     49.9 MiB   -136.8 MiB        1620           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     49.9 MiB   -136.6 MiB        1620           current = open_set.get()[2]
    53     49.9 MiB   -136.8 MiB        1620           open_set_hash.remove(current)
    54                                         
    55     49.9 MiB   -136.8 MiB        1620           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     49.9 MiB   -136.8 MiB        1620           if current == end:
    60     49.7 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     49.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     49.9 MiB  -1227.5 MiB       14571           for neighbor in current.neighbors:
    65     49.9 MiB  -1088.4 MiB       12952               if current.row != neighbor.row and current.col != neighbor.col:
    66     49.9 MiB   -545.7 MiB        6476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     49.9 MiB   -544.9 MiB        6476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     49.9 MiB  -1090.7 MiB       12952               if temp_g_score < g_score[neighbor]:
    71     49.9 MiB   -168.1 MiB        2014                   came_from[neighbor] = current
    72     49.9 MiB   -168.4 MiB        2014                   g_score[neighbor] = temp_g_score
    73     49.9 MiB   -168.4 MiB        2014                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     49.9 MiB   -168.4 MiB        2014                   if neighbor not in open_set_hash:
    75     49.9 MiB   -168.4 MiB        2014                       count += 1
    76     49.9 MiB   -168.2 MiB        2014                       open_set.put((f_score[neighbor], count, neighbor))
    77     49.9 MiB   -168.3 MiB        2014                       open_set_hash.add(neighbor)
    78                                                             
    79     49.9 MiB   -136.6 MiB        1619           if draw is not None:
    80                                                     draw()
    81                                         
    82     49.9 MiB   -136.7 MiB        1619           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.1 MiB     94.1 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.8 MiB     -3.6 MiB         257       for row in grid:
    30     97.8 MiB   -875.8 MiB       65792           for spot in row:
    31     97.8 MiB   -868.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.8 MiB      0.0 MiB           1       count = 0
    34     97.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.8 MiB      0.0 MiB           1       came_from = {}
    37     99.5 MiB -522611.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     85.7 MiB    -13.8 MiB           1       g_score[start] = 0
    39     87.7 MiB -108643.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     84.2 MiB     -3.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     84.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     84.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     84.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     85.2 MiB -87355.9 MiB        6475       while not open_set.empty():
    47     85.2 MiB -87356.1 MiB        6475           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     85.2 MiB -87356.0 MiB        6475           current = open_set.get()[2]
    53     85.2 MiB -87356.4 MiB        6475           open_set_hash.remove(current)
    54                                         
    55     85.2 MiB -87356.5 MiB        6475           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     85.2 MiB -87356.6 MiB        6475           if current == end:
    60     57.2 MiB    -28.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     85.2 MiB -786074.6 MiB       58266           for neighbor in current.neighbors:
    65     85.2 MiB -698722.8 MiB       51792               if current.row != neighbor.row and current.col != neighbor.col:
    66     85.2 MiB -349397.7 MiB       25896                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     85.2 MiB -349332.9 MiB       25896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     85.2 MiB -698735.5 MiB       51792               if temp_g_score < g_score[neighbor]:
    71     85.2 MiB -93264.4 MiB        6983                   came_from[neighbor] = current
    72     85.2 MiB -93265.2 MiB        6983                   g_score[neighbor] = temp_g_score
    73     85.2 MiB -93266.1 MiB        6983                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     85.2 MiB -93267.0 MiB        6983                   if neighbor not in open_set_hash:
    75     85.2 MiB -93267.3 MiB        6983                       count += 1
    76     85.2 MiB -93267.3 MiB        6983                       open_set.put((f_score[neighbor], count, neighbor))
    77     85.2 MiB -93267.7 MiB        6983                       open_set_hash.add(neighbor)
    78                                                             
    79     85.2 MiB -87355.4 MiB        6474           if draw is not None:
    80                                                     draw()
    81                                         
    82     85.2 MiB -87355.7 MiB        6474           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.1 MiB     59.1 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.2 MiB   -443.3 MiB         257       for row in grid:
    30     63.2 MiB -113590.6 MiB       65792           for spot in row:
    31     63.2 MiB -113146.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.6 MiB     -5.5 MiB           1       count = 0
    34     57.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.7 MiB      0.0 MiB           1       came_from = {}
    37     62.4 MiB  -5142.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.9 MiB     -0.5 MiB           1       g_score[start] = 0
    39     62.6 MiB -58071.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.2 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.3 MiB    -21.3 MiB        6644       while not open_set.empty():
    47     64.3 MiB    -21.3 MiB        6644           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.3 MiB    -21.3 MiB        6644           current = open_set.get()[2]
    53     64.3 MiB    -21.3 MiB        6644           open_set_hash.remove(current)
    54                                         
    55     64.3 MiB    -21.3 MiB        6644           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.3 MiB    -21.3 MiB        6644           if current == end:
    60     64.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.3 MiB   -191.5 MiB       59787           for neighbor in current.neighbors:
    65     64.3 MiB   -169.5 MiB       53144               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.3 MiB    -85.1 MiB       26572                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.3 MiB    -85.1 MiB       26572                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.3 MiB   -170.2 MiB       53144               if temp_g_score < g_score[neighbor]:
    71     64.3 MiB    -22.7 MiB        7334                   came_from[neighbor] = current
    72     64.3 MiB    -23.2 MiB        7334                   g_score[neighbor] = temp_g_score
    73     64.3 MiB    -23.2 MiB        7334                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.3 MiB    -23.2 MiB        7334                   if neighbor not in open_set_hash:
    75     64.3 MiB    -23.2 MiB        7334                       count += 1
    76     64.3 MiB    -22.5 MiB        7334                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.3 MiB    -23.1 MiB        7334                       open_set_hash.add(neighbor)
    78                                                             
    79     64.3 MiB    -21.3 MiB        6643           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.3 MiB    -21.3 MiB        6643           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.3 MiB     64.3 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.7 MiB   -213.9 MiB         257       for row in grid:
    30     64.7 MiB -54688.6 MiB       65792           for spot in row:
    31     64.7 MiB -54476.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.1 MiB     -2.6 MiB           1       count = 0
    34     62.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.1 MiB      0.0 MiB           1       came_from = {}
    37     63.1 MiB -60645.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.9 MiB     -1.2 MiB           1       g_score[start] = 0
    39     65.0 MiB -22250.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.5 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.5 MiB -177746.7 MiB        9898       while not open_set.empty():
    47     64.5 MiB -177746.7 MiB        9898           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.5 MiB -177746.8 MiB        9898           current = open_set.get()[2]
    53     64.5 MiB -177746.9 MiB        9898           open_set_hash.remove(current)
    54                                         
    55     64.5 MiB -177747.0 MiB        9898           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.5 MiB -177747.0 MiB        9898           if current == end:
    60     37.2 MiB    -27.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     37.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.5 MiB -1599580.1 MiB       89073           for neighbor in current.neighbors:
    65     64.5 MiB -1421838.3 MiB       79176               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.5 MiB -710955.1 MiB       39588                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.5 MiB -710886.0 MiB       39588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.5 MiB -1421845.1 MiB       79176               if temp_g_score < g_score[neighbor]:
    71     64.5 MiB -185505.4 MiB       10496                   came_from[neighbor] = current
    72     64.5 MiB -185505.9 MiB       10496                   g_score[neighbor] = temp_g_score
    73     64.5 MiB -185506.0 MiB       10496                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.5 MiB -185509.2 MiB       10496                   if neighbor not in open_set_hash:
    75     64.5 MiB -185510.1 MiB       10496                       count += 1
    76     64.5 MiB -185513.3 MiB       10496                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.5 MiB -185516.7 MiB       10496                       open_set_hash.add(neighbor)
    78                                                             
    79     64.5 MiB -177746.5 MiB        9897           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.5 MiB -177746.5 MiB        9897           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     44.7 MiB     44.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     53.1 MiB   -401.5 MiB         257       for row in grid:
    30     53.1 MiB -103232.2 MiB       65792           for spot in row:
    31     53.1 MiB -102822.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.0 MiB     -1.2 MiB           1       count = 0
    34     52.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.0 MiB      0.0 MiB           1       came_from = {}
    37     57.7 MiB   -818.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.8 MiB     -0.8 MiB           1       g_score[start] = 0
    39     62.1 MiB   -489.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.3 MiB -54316.5 MiB        5346       while not open_set.empty():
    47     62.3 MiB -54317.0 MiB        5346           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.3 MiB -54317.5 MiB        5346           current = open_set.get()[2]
    53     62.3 MiB -54318.0 MiB        5346           open_set_hash.remove(current)
    54                                         
    55     62.3 MiB -54318.3 MiB        5346           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.3 MiB -54319.2 MiB        5346           if current == end:
    60     41.4 MiB    -20.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     41.4 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.3 MiB -488757.6 MiB       48105           for neighbor in current.neighbors:
    65     62.3 MiB -434444.5 MiB       42760               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.3 MiB -217241.7 MiB       21380                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.3 MiB -217205.6 MiB       21380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.3 MiB -434451.3 MiB       42760               if temp_g_score < g_score[neighbor]:
    71     62.3 MiB -58310.7 MiB        5848                   came_from[neighbor] = current
    72     62.3 MiB -58312.5 MiB        5848                   g_score[neighbor] = temp_g_score
    73     62.3 MiB -58313.0 MiB        5848                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.3 MiB -58313.5 MiB        5848                   if neighbor not in open_set_hash:
    75     62.3 MiB -58315.2 MiB        5848                       count += 1
    76     62.3 MiB -58315.9 MiB        5848                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.3 MiB -58316.1 MiB        5848                       open_set_hash.add(neighbor)
    78                                                             
    79     62.3 MiB -54315.8 MiB        5345           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.3 MiB -54316.2 MiB        5345           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     47.4 MiB     47.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     56.9 MiB   -205.7 MiB         257       for row in grid:
    30     56.9 MiB -52549.1 MiB       65792           for spot in row:
    31     56.9 MiB -52336.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.9 MiB      0.0 MiB           1       count = 0
    34     57.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.0 MiB      0.0 MiB           1       came_from = {}
    37     59.3 MiB -10904.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.9 MiB     -0.5 MiB           1       g_score[start] = 0
    39     62.1 MiB -13363.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.3 MiB      0.0 MiB         390       while not open_set.empty():
    47     62.3 MiB      0.0 MiB         390           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.3 MiB      0.0 MiB         390           current = open_set.get()[2]
    53     62.3 MiB      0.0 MiB         390           open_set_hash.remove(current)
    54                                         
    55     62.3 MiB      0.0 MiB         390           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.3 MiB      0.0 MiB         390           if current == end:
    60     62.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.3 MiB      0.0 MiB        3501           for neighbor in current.neighbors:
    65     62.3 MiB      0.0 MiB        3112               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.3 MiB      0.0 MiB        1556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.3 MiB      0.0 MiB        1556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.3 MiB      0.0 MiB        3112               if temp_g_score < g_score[neighbor]:
    71     62.3 MiB      0.1 MiB         500                   came_from[neighbor] = current
    72     62.3 MiB      0.0 MiB         500                   g_score[neighbor] = temp_g_score
    73     62.3 MiB      0.0 MiB         500                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.3 MiB      0.0 MiB         500                   if neighbor not in open_set_hash:
    75     62.3 MiB      0.0 MiB         500                       count += 1
    76     62.3 MiB      0.0 MiB         500                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.3 MiB      0.0 MiB         500                       open_set_hash.add(neighbor)
    78                                                             
    79     62.3 MiB      0.0 MiB         389           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.3 MiB      0.0 MiB         389           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.0 MiB    102.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.0 MiB   -240.2 MiB         257       for row in grid:
    30    102.0 MiB -61709.9 MiB       65792           for spot in row:
    31    102.0 MiB -61470.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.0 MiB     -1.0 MiB           1       count = 0
    34    101.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.0 MiB      0.0 MiB           1       came_from = {}
    37    104.7 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.0 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.0 MiB   -589.3 MiB        2508       while not open_set.empty():
    47    108.0 MiB   -589.3 MiB        2508           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.0 MiB   -589.3 MiB        2508           current = open_set.get()[2]
    53    108.0 MiB   -589.3 MiB        2508           open_set_hash.remove(current)
    54                                         
    55    108.0 MiB   -589.3 MiB        2508           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.0 MiB   -589.3 MiB        2508           if current == end:
    60    106.9 MiB     -1.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.0 MiB  -5294.0 MiB       22563           for neighbor in current.neighbors:
    65    108.0 MiB  -4705.7 MiB       20056               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.0 MiB  -2353.1 MiB       10028                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.0 MiB  -2352.6 MiB       10028                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.0 MiB  -4705.7 MiB       20056               if temp_g_score < g_score[neighbor]:
    71    108.0 MiB   -657.8 MiB        2876                   came_from[neighbor] = current
    72    108.0 MiB   -657.8 MiB        2876                   g_score[neighbor] = temp_g_score
    73    108.0 MiB   -657.8 MiB        2876                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.0 MiB   -657.8 MiB        2876                   if neighbor not in open_set_hash:
    75    108.0 MiB   -657.8 MiB        2876                       count += 1
    76    108.0 MiB   -657.8 MiB        2876                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.0 MiB   -657.7 MiB        2876                       open_set_hash.add(neighbor)
    78                                                             
    79    108.0 MiB   -588.3 MiB        2507           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.0 MiB   -588.3 MiB        2507           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.9 MiB    106.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.9 MiB    -27.0 MiB         257       for row in grid:
    30    106.9 MiB  -6623.1 MiB       65792           for spot in row:
    31    106.9 MiB  -6597.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.1 MiB     -1.8 MiB           1       count = 0
    34    105.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.1 MiB      0.0 MiB           1       came_from = {}
    37    108.4 MiB  -1116.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.3 MiB     -0.1 MiB           1       g_score[start] = 0
    39    109.6 MiB -67351.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.2 MiB     -4.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.2 MiB   -549.4 MiB        3162       while not open_set.empty():
    47    105.2 MiB   -549.4 MiB        3162           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.2 MiB   -549.4 MiB        3162           current = open_set.get()[2]
    53    105.2 MiB   -549.5 MiB        3162           open_set_hash.remove(current)
    54                                         
    55    105.2 MiB   -549.5 MiB        3162           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.2 MiB   -549.5 MiB        3162           if current == end:
    60    104.6 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.2 MiB  -4941.5 MiB       28449           for neighbor in current.neighbors:
    65    105.2 MiB  -4392.4 MiB       25288               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.2 MiB  -2197.0 MiB       12644                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.2 MiB  -2195.5 MiB       12644                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.2 MiB  -4392.5 MiB       25288               if temp_g_score < g_score[neighbor]:
    71    105.2 MiB   -599.1 MiB        3510                   came_from[neighbor] = current
    72    105.2 MiB   -599.2 MiB        3510                   g_score[neighbor] = temp_g_score
    73    105.2 MiB   -599.3 MiB        3510                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.2 MiB   -599.3 MiB        3510                   if neighbor not in open_set_hash:
    75    105.2 MiB   -599.3 MiB        3510                       count += 1
    76    105.2 MiB   -599.3 MiB        3510                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.2 MiB   -599.3 MiB        3510                       open_set_hash.add(neighbor)
    78                                                             
    79    105.2 MiB   -549.4 MiB        3161           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.2 MiB   -549.4 MiB        3161           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.6 MiB    104.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.6 MiB -10898.0 MiB         257       for row in grid:
    30    104.6 MiB -2793265.6 MiB       65792           for spot in row:
    31    104.6 MiB -2782413.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     36.6 MiB    -68.0 MiB           1       count = 0
    34     37.0 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     37.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     37.2 MiB      0.0 MiB           1       came_from = {}
    37     45.4 MiB  -6146.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     45.2 MiB     -0.2 MiB           1       g_score[start] = 0
    39     46.7 MiB -70617.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     45.6 MiB     -1.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     45.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     45.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     45.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     46.4 MiB  -1101.9 MiB         672       while not open_set.empty():
    47     46.4 MiB  -1102.0 MiB         672           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     46.4 MiB  -1102.0 MiB         672           current = open_set.get()[2]
    53     46.4 MiB  -1102.0 MiB         672           open_set_hash.remove(current)
    54                                         
    55     46.4 MiB  -1102.1 MiB         672           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     46.4 MiB  -1102.1 MiB         672           if current == end:
    60     44.2 MiB     -2.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     44.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     46.4 MiB  -9908.0 MiB        6039           for neighbor in current.neighbors:
    65     46.4 MiB  -8806.4 MiB        5368               if current.row != neighbor.row and current.col != neighbor.col:
    66     46.4 MiB  -4407.4 MiB        2684                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     46.4 MiB  -4400.0 MiB        2684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     46.4 MiB  -8807.7 MiB        5368               if temp_g_score < g_score[neighbor]:
    71     46.4 MiB  -1272.0 MiB         822                   came_from[neighbor] = current
    72     46.4 MiB  -1272.0 MiB         822                   g_score[neighbor] = temp_g_score
    73     46.4 MiB  -1272.1 MiB         822                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     46.4 MiB  -1272.1 MiB         822                   if neighbor not in open_set_hash:
    75     46.4 MiB  -1272.1 MiB         822                       count += 1
    76     46.4 MiB  -1272.1 MiB         822                       open_set.put((f_score[neighbor], count, neighbor))
    77     46.4 MiB  -1272.0 MiB         822                       open_set_hash.add(neighbor)
    78                                                             
    79     46.4 MiB  -1101.9 MiB         671           if draw is not None:
    80                                                     draw()
    81                                         
    82     46.4 MiB  -1101.9 MiB         671           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     47.6 MiB     47.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     54.7 MiB   -329.5 MiB         257       for row in grid:
    30     54.7 MiB -84514.4 MiB       65792           for spot in row:
    31     54.7 MiB -84183.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.4 MiB     -2.3 MiB           1       count = 0
    34     52.7 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     52.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     53.0 MiB      0.0 MiB           1       came_from = {}
    37     54.4 MiB -587012.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     43.1 MiB    -11.3 MiB           1       g_score[start] = 0
    39     48.3 MiB -16455.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     48.5 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     48.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     48.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     48.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     49.9 MiB  -2239.7 MiB        4650       while not open_set.empty():
    47     49.9 MiB  -2239.7 MiB        4650           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     49.9 MiB  -2239.7 MiB        4650           current = open_set.get()[2]
    53     49.9 MiB  -2239.7 MiB        4650           open_set_hash.remove(current)
    54                                         
    55     49.9 MiB  -2240.5 MiB        4650           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     49.9 MiB  -2240.5 MiB        4650           if current == end:
    60     49.4 MiB     -0.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     49.6 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     49.9 MiB -20159.4 MiB       41841           for neighbor in current.neighbors:
    65     49.9 MiB -17919.7 MiB       37192               if current.row != neighbor.row and current.col != neighbor.col:
    66     49.9 MiB  -8959.9 MiB       18596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     49.9 MiB  -8960.2 MiB       18596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     49.9 MiB -17920.2 MiB       37192               if temp_g_score < g_score[neighbor]:
    71     49.9 MiB  -2428.9 MiB        5120                   came_from[neighbor] = current
    72     49.9 MiB  -2429.1 MiB        5120                   g_score[neighbor] = temp_g_score
    73     49.9 MiB  -2429.1 MiB        5120                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     49.9 MiB  -2429.1 MiB        5120                   if neighbor not in open_set_hash:
    75     49.9 MiB  -2429.1 MiB        5120                       count += 1
    76     49.9 MiB  -2428.8 MiB        5120                       open_set.put((f_score[neighbor], count, neighbor))
    77     49.9 MiB  -2428.8 MiB        5120                       open_set_hash.add(neighbor)
    78                                                             
    79     49.9 MiB  -2239.7 MiB        4649           if draw is not None:
    80                                                     draw()
    81                                         
    82     49.9 MiB  -2239.7 MiB        4649           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     52.3 MiB     52.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     57.9 MiB  -1108.0 MiB         257       for row in grid:
    30     58.0 MiB -284336.8 MiB       65792           for spot in row:
    31     58.0 MiB -283229.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.3 MiB     -1.6 MiB           1       count = 0
    34     56.4 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     56.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.4 MiB      0.0 MiB           1       came_from = {}
    37     61.4 MiB  -1313.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.2 MiB     -0.2 MiB           1       g_score[start] = 0
    39     64.6 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.6 MiB  -9134.6 MiB        2501       while not open_set.empty():
    47     64.6 MiB  -9134.7 MiB        2501           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.6 MiB  -9134.9 MiB        2501           current = open_set.get()[2]
    53     64.6 MiB  -9135.4 MiB        2501           open_set_hash.remove(current)
    54                                         
    55     64.6 MiB  -9135.8 MiB        2501           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.6 MiB  -9135.8 MiB        2501           if current == end:
    60     55.3 MiB     -9.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.8 MiB      0.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.6 MiB -82158.6 MiB       22500           for neighbor in current.neighbors:
    65     64.6 MiB -73027.1 MiB       20000               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.6 MiB -36521.4 MiB       10000                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.6 MiB -36507.6 MiB       10000                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.6 MiB -73029.6 MiB       20000               if temp_g_score < g_score[neighbor]:
    71     64.6 MiB -10023.1 MiB        2825                   came_from[neighbor] = current
    72     64.6 MiB -10023.2 MiB        2825                   g_score[neighbor] = temp_g_score
    73     64.6 MiB -10023.1 MiB        2825                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.6 MiB -10023.2 MiB        2825                   if neighbor not in open_set_hash:
    75     64.6 MiB -10023.3 MiB        2825                       count += 1
    76     64.6 MiB -10023.4 MiB        2825                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.6 MiB -10023.5 MiB        2825                       open_set_hash.add(neighbor)
    78                                                             
    79     64.6 MiB  -9132.7 MiB        2500           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.6 MiB  -9132.9 MiB        2500           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.9 MiB    102.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.9 MiB     -3.8 MiB         257       for row in grid:
    30    102.9 MiB   -970.1 MiB       65792           for spot in row:
    31    102.9 MiB   -966.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.9 MiB     -0.0 MiB           1       count = 0
    34    102.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.9 MiB      0.0 MiB           1       came_from = {}
    37    106.5 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.5 MiB -201021.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.5 MiB    -16.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.2 MiB  -5581.6 MiB        2133       while not open_set.empty():
    47     95.2 MiB  -5581.6 MiB        2133           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.2 MiB  -5581.6 MiB        2133           current = open_set.get()[2]
    53     95.2 MiB  -5581.6 MiB        2133           open_set_hash.remove(current)
    54                                         
    55     95.2 MiB  -5581.6 MiB        2133           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.2 MiB  -5581.7 MiB        2133           if current == end:
    60     90.2 MiB     -5.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.2 MiB -50204.9 MiB       19188           for neighbor in current.neighbors:
    65     95.2 MiB -44624.6 MiB       17056               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.2 MiB -22316.5 MiB        8528                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.2 MiB -22309.3 MiB        8528                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.2 MiB -44627.0 MiB       17056               if temp_g_score < g_score[neighbor]:
    71     95.2 MiB  -6110.4 MiB        2397                   came_from[neighbor] = current
    72     95.2 MiB  -6110.5 MiB        2397                   g_score[neighbor] = temp_g_score
    73     95.2 MiB  -6111.0 MiB        2397                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.2 MiB  -6111.0 MiB        2397                   if neighbor not in open_set_hash:
    75     95.2 MiB  -6111.0 MiB        2397                       count += 1
    76     95.2 MiB  -6111.2 MiB        2397                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.2 MiB  -6111.2 MiB        2397                       open_set_hash.add(neighbor)
    78                                                             
    79     95.2 MiB  -5581.5 MiB        2132           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.2 MiB  -5581.6 MiB        2132           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.7 MiB     91.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.0 MiB  -1756.6 MiB         257       for row in grid:
    30     93.0 MiB -444288.3 MiB       65792           for spot in row:
    31     93.0 MiB -442561.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     50.3 MiB    -42.7 MiB           1       count = 0
    34     50.4 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     50.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     50.4 MiB      0.0 MiB           1       came_from = {}
    37     50.8 MiB -516908.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     46.7 MiB     -4.2 MiB           1       g_score[start] = 0
    39     52.3 MiB -64327.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     47.6 MiB     -4.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     47.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     47.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     47.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     56.7 MiB   -936.3 MiB        5312       while not open_set.empty():
    47     56.7 MiB   -936.3 MiB        5312           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     56.7 MiB   -936.4 MiB        5312           current = open_set.get()[2]
    53     56.7 MiB   -936.7 MiB        5312           open_set_hash.remove(current)
    54                                         
    55     56.7 MiB   -936.7 MiB        5312           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     56.7 MiB   -936.7 MiB        5312           if current == end:
    60     56.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     56.7 MiB  -8420.9 MiB       47799           for neighbor in current.neighbors:
    65     56.7 MiB  -7482.8 MiB       42488               if current.row != neighbor.row and current.col != neighbor.col:
    66     56.7 MiB  -3743.5 MiB       21244                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     56.7 MiB  -3740.6 MiB       21244                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     56.7 MiB  -7484.1 MiB       42488               if temp_g_score < g_score[neighbor]:
    71     56.7 MiB  -1067.5 MiB        5732                   came_from[neighbor] = current
    72     56.7 MiB  -1068.1 MiB        5732                   g_score[neighbor] = temp_g_score
    73     56.7 MiB  -1068.1 MiB        5732                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     56.7 MiB  -1068.2 MiB        5732                   if neighbor not in open_set_hash:
    75     56.7 MiB  -1068.4 MiB        5732                       count += 1
    76     56.7 MiB  -1061.5 MiB        5732                       open_set.put((f_score[neighbor], count, neighbor))
    77     56.7 MiB  -1068.9 MiB        5732                       open_set_hash.add(neighbor)
    78                                                             
    79     56.7 MiB   -936.3 MiB        5311           if draw is not None:
    80                                                     draw()
    81                                         
    82     56.7 MiB   -936.3 MiB        5311           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.1 MiB     59.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.9 MiB     -2.7 MiB         257       for row in grid:
    30     60.9 MiB   -684.1 MiB       65792           for spot in row:
    31     60.9 MiB   -679.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.9 MiB     -0.0 MiB           1       count = 0
    34     60.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.9 MiB      0.0 MiB           1       came_from = {}
    37     65.1 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.5 MiB   -113.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.6 MiB      0.0 MiB         328       while not open_set.empty():
    47     69.6 MiB      0.0 MiB         328           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.6 MiB      0.0 MiB         328           current = open_set.get()[2]
    53     69.6 MiB      0.0 MiB         328           open_set_hash.remove(current)
    54                                         
    55     69.6 MiB      0.0 MiB         328           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.6 MiB      0.0 MiB         328           if current == end:
    60     69.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.6 MiB      0.0 MiB        2943           for neighbor in current.neighbors:
    65     69.6 MiB      0.0 MiB        2616               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.6 MiB      0.0 MiB        1308                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.6 MiB      0.0 MiB        1308                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.6 MiB      0.0 MiB        2616               if temp_g_score < g_score[neighbor]:
    71     69.6 MiB      0.0 MiB         506                   came_from[neighbor] = current
    72     69.6 MiB      0.0 MiB         506                   g_score[neighbor] = temp_g_score
    73     69.6 MiB      0.0 MiB         506                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.6 MiB      0.0 MiB         506                   if neighbor not in open_set_hash:
    75     69.6 MiB      0.0 MiB         506                       count += 1
    76     69.6 MiB      0.1 MiB         506                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.6 MiB      0.0 MiB         506                       open_set_hash.add(neighbor)
    78                                                             
    79     69.6 MiB      0.0 MiB         327           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.6 MiB      0.0 MiB         327           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.6 MiB     69.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.6 MiB      0.0 MiB         257       for row in grid:
    30     69.6 MiB      0.0 MiB       65792           for spot in row:
    31     69.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     69.6 MiB      0.0 MiB           1       count = 0
    34     69.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     69.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     69.6 MiB      0.0 MiB           1       came_from = {}
    37     74.1 MiB  -4106.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     73.8 MiB     -0.3 MiB           1       g_score[start] = 0
    39     74.5 MiB      0.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.5 MiB      0.0 MiB        1674       while not open_set.empty():
    47     74.5 MiB      0.0 MiB        1674           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.5 MiB      0.0 MiB        1674           current = open_set.get()[2]
    53     74.5 MiB      0.0 MiB        1674           open_set_hash.remove(current)
    54                                         
    55     74.5 MiB      0.0 MiB        1674           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.5 MiB      0.0 MiB        1674           if current == end:
    60     74.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.5 MiB      0.0 MiB       15057           for neighbor in current.neighbors:
    65     74.5 MiB      0.0 MiB       13384               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.5 MiB      0.0 MiB        6692                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.5 MiB      0.0 MiB        6692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.5 MiB      0.0 MiB       13384               if temp_g_score < g_score[neighbor]:
    71     74.5 MiB      0.0 MiB        1974                   came_from[neighbor] = current
    72     74.5 MiB      0.0 MiB        1974                   g_score[neighbor] = temp_g_score
    73     74.5 MiB      0.0 MiB        1974                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.5 MiB      0.0 MiB        1974                   if neighbor not in open_set_hash:
    75     74.5 MiB      0.0 MiB        1974                       count += 1
    76     74.5 MiB      0.0 MiB        1974                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.5 MiB      0.0 MiB        1974                       open_set_hash.add(neighbor)
    78                                                             
    79     74.5 MiB      0.0 MiB        1673           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.5 MiB      0.0 MiB        1673           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.5 MiB     74.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.5 MiB     -5.0 MiB         257       for row in grid:
    30     74.5 MiB  -1290.8 MiB       65792           for spot in row:
    31     74.5 MiB  -1285.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     74.5 MiB     -0.0 MiB           1       count = 0
    34     74.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.5 MiB      0.0 MiB           1       came_from = {}
    37     77.6 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     77.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     79.2 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     79.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     79.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     79.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     79.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     79.3 MiB  -5872.9 MiB        2900       while not open_set.empty():
    47     79.3 MiB  -5872.9 MiB        2900           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     79.3 MiB  -5872.9 MiB        2900           current = open_set.get()[2]
    53     79.3 MiB  -5872.9 MiB        2900           open_set_hash.remove(current)
    54                                         
    55     79.3 MiB  -5872.9 MiB        2900           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     79.3 MiB  -5872.9 MiB        2900           if current == end:
    60     75.6 MiB     -3.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     79.3 MiB -52828.6 MiB       26091           for neighbor in current.neighbors:
    65     79.3 MiB -46956.4 MiB       23192               if current.row != neighbor.row and current.col != neighbor.col:
    66     79.3 MiB -23480.3 MiB       11596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     79.3 MiB -23476.5 MiB       11596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     79.3 MiB -46957.2 MiB       23192               if temp_g_score < g_score[neighbor]:
    71     79.3 MiB  -7038.9 MiB        3518                   came_from[neighbor] = current
    72     79.3 MiB  -7039.3 MiB        3518                   g_score[neighbor] = temp_g_score
    73     79.3 MiB  -7039.7 MiB        3518                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     79.3 MiB  -7040.0 MiB        3518                   if neighbor not in open_set_hash:
    75     79.3 MiB  -7040.3 MiB        3518                       count += 1
    76     79.3 MiB  -7040.7 MiB        3518                       open_set.put((f_score[neighbor], count, neighbor))
    77     79.3 MiB  -7040.7 MiB        3518                       open_set_hash.add(neighbor)
    78                                                             
    79     79.3 MiB  -5872.9 MiB        2899           if draw is not None:
    80                                                     draw()
    81                                         
    82     79.3 MiB  -5872.9 MiB        2899           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.9 MiB    112.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.9 MiB   -424.3 MiB         257       for row in grid:
    30    112.9 MiB -108620.4 MiB       65792           for spot in row:
    31    112.9 MiB -108198.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.7 MiB     -2.3 MiB           1       count = 0
    34    110.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.7 MiB      0.0 MiB           1       came_from = {}
    37    113.9 MiB  -8459.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.8 MiB  -5769.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.8 MiB -11595.3 MiB        7802       while not open_set.empty():
    47    117.8 MiB -11595.6 MiB        7802           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.8 MiB -11595.8 MiB        7802           current = open_set.get()[2]
    53    117.8 MiB -11595.8 MiB        7802           open_set_hash.remove(current)
    54                                         
    55    117.8 MiB -11595.8 MiB        7802           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.8 MiB -11595.8 MiB        7802           if current == end:
    60    115.0 MiB     -2.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.8 MiB -104339.9 MiB       70209           for neighbor in current.neighbors:
    65    117.8 MiB -92745.5 MiB       62408               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.8 MiB -46373.4 MiB       31204                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.8 MiB -46372.2 MiB       31204                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.8 MiB -92745.9 MiB       62408               if temp_g_score < g_score[neighbor]:
    71    117.8 MiB -12217.8 MiB        8320                   came_from[neighbor] = current
    72    117.8 MiB -12217.8 MiB        8320                   g_score[neighbor] = temp_g_score
    73    117.8 MiB -12217.8 MiB        8320                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.8 MiB -12218.6 MiB        8320                   if neighbor not in open_set_hash:
    75    117.8 MiB -12218.6 MiB        8320                       count += 1
    76    117.8 MiB -12218.6 MiB        8320                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.8 MiB -12218.6 MiB        8320                       open_set_hash.add(neighbor)
    78                                                             
    79    117.8 MiB -11594.6 MiB        7801           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.8 MiB -11595.0 MiB        7801           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.0 MiB    115.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.0 MiB   -388.4 MiB         257       for row in grid:
    30    115.0 MiB -99394.5 MiB       65792           for spot in row:
    31    115.0 MiB -99007.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.8 MiB     -2.3 MiB           1       count = 0
    34    112.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.8 MiB      0.0 MiB           1       came_from = {}
    37    114.1 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.8 MiB      2.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.8 MiB -63612.9 MiB        5285       while not open_set.empty():
    47    116.8 MiB -63612.9 MiB        5285           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.8 MiB -63613.4 MiB        5285           current = open_set.get()[2]
    53    116.8 MiB -63613.8 MiB        5285           open_set_hash.remove(current)
    54                                         
    55    116.8 MiB -63613.8 MiB        5285           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.8 MiB -63613.8 MiB        5285           if current == end:
    60     99.4 MiB    -17.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.8 MiB -572434.3 MiB       47556           for neighbor in current.neighbors:
    65    116.8 MiB -508823.4 MiB       42272               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.8 MiB -254430.9 MiB       21136                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.8 MiB -254396.4 MiB       21136                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.8 MiB -508836.0 MiB       42272               if temp_g_score < g_score[neighbor]:
    71    116.8 MiB -67814.3 MiB        5725                   came_from[neighbor] = current
    72    116.8 MiB -67814.3 MiB        5725                   g_score[neighbor] = temp_g_score
    73    116.8 MiB -67814.5 MiB        5725                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.8 MiB -67814.5 MiB        5725                   if neighbor not in open_set_hash:
    75    116.8 MiB -67814.8 MiB        5725                       count += 1
    76    116.8 MiB -67814.8 MiB        5725                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.8 MiB -67815.2 MiB        5725                       open_set_hash.add(neighbor)
    78                                                             
    79    116.8 MiB -63612.7 MiB        5284           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.8 MiB -63612.9 MiB        5284           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.7 MiB    101.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.7 MiB    -47.2 MiB         257       for row in grid:
    30    101.7 MiB -12087.8 MiB       65792           for spot in row:
    31    101.7 MiB -12040.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.4 MiB     -0.3 MiB           1       count = 0
    34    101.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.4 MiB      0.0 MiB           1       came_from = {}
    37    104.7 MiB  -7122.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.7 MiB    -46.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.7 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.7 MiB      0.0 MiB        1045       while not open_set.empty():
    47    107.7 MiB      0.0 MiB        1045           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.7 MiB      0.0 MiB        1045           current = open_set.get()[2]
    53    107.7 MiB      0.0 MiB        1045           open_set_hash.remove(current)
    54                                         
    55    107.7 MiB      0.0 MiB        1045           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.7 MiB      0.0 MiB        1045           if current == end:
    60    107.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.7 MiB      0.0 MiB        9396           for neighbor in current.neighbors:
    65    107.7 MiB      0.0 MiB        8352               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.7 MiB      0.0 MiB        4176                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.7 MiB      0.0 MiB        4176                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.7 MiB      0.0 MiB        8352               if temp_g_score < g_score[neighbor]:
    71    107.7 MiB      0.0 MiB        1229                   came_from[neighbor] = current
    72    107.7 MiB      0.0 MiB        1229                   g_score[neighbor] = temp_g_score
    73    107.7 MiB      0.0 MiB        1229                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.7 MiB      0.0 MiB        1229                   if neighbor not in open_set_hash:
    75    107.7 MiB      0.0 MiB        1229                       count += 1
    76    107.7 MiB      0.0 MiB        1229                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.7 MiB      0.0 MiB        1229                       open_set_hash.add(neighbor)
    78                                                             
    79    107.7 MiB      0.0 MiB        1044           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.7 MiB      0.0 MiB        1044           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.7 MiB    107.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.7 MiB  -1241.4 MiB         257       for row in grid:
    30    107.7 MiB -317981.7 MiB       65792           for spot in row:
    31    107.7 MiB -316746.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.9 MiB     -5.8 MiB           1       count = 0
    34    101.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.9 MiB      0.0 MiB           1       came_from = {}
    37    102.6 MiB -44923.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.2 MiB     -1.4 MiB           1       g_score[start] = 0
    39    101.8 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.8 MiB    -10.0 MiB         444       while not open_set.empty():
    47    101.8 MiB    -10.0 MiB         444           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.8 MiB    -10.0 MiB         444           current = open_set.get()[2]
    53    101.8 MiB    -10.0 MiB         444           open_set_hash.remove(current)
    54                                         
    55    101.8 MiB    -10.0 MiB         444           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.8 MiB    -10.0 MiB         444           if current == end:
    60    101.8 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.8 MiB    -90.2 MiB        3987           for neighbor in current.neighbors:
    65    101.8 MiB    -80.2 MiB        3544               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.8 MiB    -40.1 MiB        1772                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.8 MiB    -40.1 MiB        1772                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.8 MiB    -80.2 MiB        3544               if temp_g_score < g_score[neighbor]:
    71    101.8 MiB    -12.0 MiB         564                   came_from[neighbor] = current
    72    101.8 MiB    -12.0 MiB         564                   g_score[neighbor] = temp_g_score
    73    101.8 MiB    -12.0 MiB         564                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.8 MiB    -12.0 MiB         564                   if neighbor not in open_set_hash:
    75    101.8 MiB    -12.0 MiB         564                       count += 1
    76    101.8 MiB    -12.0 MiB         564                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.8 MiB    -12.0 MiB         564                       open_set_hash.add(neighbor)
    78                                                             
    79    101.8 MiB    -10.0 MiB         443           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.8 MiB    -10.0 MiB         443           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.8 MiB    101.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.8 MiB    -55.5 MiB         257       for row in grid:
    30    101.8 MiB -14162.5 MiB       65792           for spot in row:
    31    101.8 MiB -14107.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.2 MiB     -0.6 MiB           1       count = 0
    34    101.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.2 MiB      0.0 MiB           1       came_from = {}
    37    101.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.0 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.0 MiB      0.0 MiB         990       while not open_set.empty():
    47    104.0 MiB      0.0 MiB         990           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.0 MiB      0.0 MiB         990           current = open_set.get()[2]
    53    104.0 MiB      0.0 MiB         990           open_set_hash.remove(current)
    54                                         
    55    104.0 MiB      0.0 MiB         990           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.0 MiB      0.0 MiB         990           if current == end:
    60    104.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.0 MiB      0.0 MiB        8901           for neighbor in current.neighbors:
    65    104.0 MiB      0.0 MiB        7912               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.0 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.0 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.0 MiB      0.0 MiB        7912               if temp_g_score < g_score[neighbor]:
    71    104.0 MiB      0.0 MiB        1404                   came_from[neighbor] = current
    72    104.0 MiB      0.0 MiB        1404                   g_score[neighbor] = temp_g_score
    73    104.0 MiB      0.0 MiB        1404                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.0 MiB      0.0 MiB        1404                   if neighbor not in open_set_hash:
    75    104.0 MiB      0.0 MiB        1404                       count += 1
    76    104.0 MiB      0.0 MiB        1404                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.0 MiB      0.0 MiB        1404                       open_set_hash.add(neighbor)
    78                                                             
    79    104.0 MiB      0.0 MiB         989           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.0 MiB      0.0 MiB         989           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    117.2 MiB    117.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    117.2 MiB    -45.6 MiB         257       for row in grid:
    30    117.2 MiB -11652.1 MiB       65792           for spot in row:
    31    117.2 MiB -11607.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    116.6 MiB     -0.6 MiB           1       count = 0
    34    116.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    116.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    116.6 MiB      0.0 MiB           1       came_from = {}
    37    117.4 MiB -107612.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.6 MiB     -3.7 MiB           1       g_score[start] = 0
    39    116.0 MiB   -273.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.0 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.0 MiB      0.0 MiB        1620       while not open_set.empty():
    47    116.0 MiB      0.0 MiB        1620           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.0 MiB      0.0 MiB        1620           current = open_set.get()[2]
    53    116.0 MiB      0.0 MiB        1620           open_set_hash.remove(current)
    54                                         
    55    116.0 MiB      0.0 MiB        1620           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.0 MiB      0.0 MiB        1620           if current == end:
    60    116.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.0 MiB      0.0 MiB       14571           for neighbor in current.neighbors:
    65    116.0 MiB      0.0 MiB       12952               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.0 MiB      0.0 MiB        6476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.0 MiB      0.0 MiB        6476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.0 MiB      0.0 MiB       12952               if temp_g_score < g_score[neighbor]:
    71    116.0 MiB      0.0 MiB        2182                   came_from[neighbor] = current
    72    116.0 MiB      0.0 MiB        2182                   g_score[neighbor] = temp_g_score
    73    116.0 MiB      0.0 MiB        2182                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.0 MiB      0.0 MiB        2182                   if neighbor not in open_set_hash:
    75    116.0 MiB      0.0 MiB        2182                       count += 1
    76    116.0 MiB      0.0 MiB        2182                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.0 MiB      0.0 MiB        2182                       open_set_hash.add(neighbor)
    78                                                             
    79    116.0 MiB      0.0 MiB        1619           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.0 MiB      0.0 MiB        1619           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.0 MiB    116.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.0 MiB   -800.5 MiB         257       for row in grid:
    30    116.0 MiB -204955.8 MiB       65792           for spot in row:
    31    116.0 MiB -204157.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.2 MiB     -3.9 MiB           1       count = 0
    34    112.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.2 MiB      0.0 MiB           1       came_from = {}
    37    113.9 MiB   -310.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.8 MiB     -0.0 MiB           1       g_score[start] = 0
    39    117.1 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.1 MiB -351399.6 MiB       13786       while not open_set.empty():
    47    117.1 MiB -351400.3 MiB       13786           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.1 MiB -351401.8 MiB       13786           current = open_set.get()[2]
    53    117.1 MiB -351402.8 MiB       13786           open_set_hash.remove(current)
    54                                         
    55    117.1 MiB -351403.6 MiB       13786           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.1 MiB -351404.3 MiB       13786           if current == end:
    60     79.4 MiB    -37.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     79.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.1 MiB -3162449.5 MiB      124065           for neighbor in current.neighbors:
    65    117.1 MiB -2811060.4 MiB      110280               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.1 MiB -1405558.6 MiB       55140                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.1 MiB -1405505.3 MiB       55140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.1 MiB -2811069.8 MiB      110280               if temp_g_score < g_score[neighbor]:
    71    117.1 MiB -363894.8 MiB       14480                   came_from[neighbor] = current
    72    117.1 MiB -363895.0 MiB       14480                   g_score[neighbor] = temp_g_score
    73    117.1 MiB -363895.5 MiB       14480                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.1 MiB -363895.8 MiB       14480                   if neighbor not in open_set_hash:
    75    117.1 MiB -363896.0 MiB       14480                       count += 1
    76    117.1 MiB -363896.5 MiB       14480                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.1 MiB -363896.7 MiB       14480                       open_set_hash.add(neighbor)
    78                                                             
    79    117.1 MiB -351396.7 MiB       13785           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.1 MiB -351398.8 MiB       13785           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     80.9 MiB     80.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     81.0 MiB     -0.1 MiB         257       for row in grid:
    30     81.0 MiB    -18.1 MiB       65792           for spot in row:
    31     81.0 MiB    -17.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     81.0 MiB     -0.0 MiB           1       count = 0
    34     81.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     81.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     81.0 MiB      0.0 MiB           1       came_from = {}
    37     81.6 MiB -51782.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     80.4 MiB     -1.2 MiB           1       g_score[start] = 0
    39     80.9 MiB   -728.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     80.2 MiB     -0.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     80.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     80.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     80.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     80.2 MiB -53244.0 MiB        4656       while not open_set.empty():
    47     80.2 MiB -53244.7 MiB        4656           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     80.2 MiB -53245.4 MiB        4656           current = open_set.get()[2]
    53     80.2 MiB -53245.7 MiB        4656           open_set_hash.remove(current)
    54                                         
    55     80.2 MiB -53246.2 MiB        4656           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     80.2 MiB -53246.5 MiB        4656           if current == end:
    60     57.3 MiB    -22.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     80.2 MiB -479076.8 MiB       41895           for neighbor in current.neighbors:
    65     80.2 MiB -425835.9 MiB       37240               if current.row != neighbor.row and current.col != neighbor.col:
    66     80.2 MiB -212937.8 MiB       18620                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     80.2 MiB -212899.3 MiB       18620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     80.2 MiB -425838.9 MiB       37240               if temp_g_score < g_score[neighbor]:
    71     80.2 MiB -57649.3 MiB        5138                   came_from[neighbor] = current
    72     80.2 MiB -57649.4 MiB        5138                   g_score[neighbor] = temp_g_score
    73     80.2 MiB -57649.8 MiB        5138                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     80.2 MiB -57650.2 MiB        5138                   if neighbor not in open_set_hash:
    75     80.2 MiB -57650.2 MiB        5138                       count += 1
    76     80.2 MiB -57650.3 MiB        5138                       open_set.put((f_score[neighbor], count, neighbor))
    77     80.2 MiB -57650.8 MiB        5138                       open_set_hash.add(neighbor)
    78                                                             
    79     80.2 MiB -53243.2 MiB        4655           if draw is not None:
    80                                                     draw()
    81                                         
    82     80.2 MiB -53243.6 MiB        4655           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.4 MiB     62.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     66.0 MiB   -873.5 MiB         257       for row in grid:
    30     66.0 MiB -224265.3 MiB       65792           for spot in row:
    31     66.0 MiB -223386.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.0 MiB      0.0 MiB           1       count = 0
    34     66.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.1 MiB      0.0 MiB           1       came_from = {}
    37     68.2 MiB -48299.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.9 MiB     -1.3 MiB           1       g_score[start] = 0
    39     69.9 MiB -22834.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.6 MiB    -87.8 MiB        5040       while not open_set.empty():
    47     70.6 MiB    -87.8 MiB        5040           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.6 MiB    -87.8 MiB        5040           current = open_set.get()[2]
    53     70.6 MiB    -87.8 MiB        5040           open_set_hash.remove(current)
    54                                         
    55     70.6 MiB    -87.8 MiB        5040           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.6 MiB    -87.8 MiB        5040           if current == end:
    60     70.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.6 MiB   -789.9 MiB       45351           for neighbor in current.neighbors:
    65     70.6 MiB   -702.2 MiB       40312               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.6 MiB   -351.1 MiB       20156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.6 MiB   -351.0 MiB       20156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.6 MiB   -702.2 MiB       40312               if temp_g_score < g_score[neighbor]:
    71     70.6 MiB    -92.6 MiB        5494                   came_from[neighbor] = current
    72     70.6 MiB    -93.2 MiB        5494                   g_score[neighbor] = temp_g_score
    73     70.6 MiB    -93.2 MiB        5494                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.6 MiB    -93.2 MiB        5494                   if neighbor not in open_set_hash:
    75     70.6 MiB    -93.2 MiB        5494                       count += 1
    76     70.6 MiB    -93.2 MiB        5494                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.6 MiB    -93.2 MiB        5494                       open_set_hash.add(neighbor)
    78                                                             
    79     70.6 MiB    -87.8 MiB        5039           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.6 MiB    -87.8 MiB        5039           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.7 MiB     70.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     71.7 MiB   -770.6 MiB         257       for row in grid:
    30     71.7 MiB -197155.7 MiB       65792           for spot in row:
    31     71.7 MiB -196386.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     67.2 MiB     -4.5 MiB           1       count = 0
    34     67.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.3 MiB      0.0 MiB           1       came_from = {}
    37     69.7 MiB -11513.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.0 MiB -120797.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.7 MiB     -1.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.7 MiB      0.0 MiB          71       while not open_set.empty():
    47     68.7 MiB      0.0 MiB          71           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.7 MiB      0.0 MiB          71           current = open_set.get()[2]
    53     68.7 MiB      0.0 MiB          71           open_set_hash.remove(current)
    54                                         
    55     68.7 MiB      0.0 MiB          71           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.7 MiB      0.0 MiB          71           if current == end:
    60     68.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.7 MiB      0.0 MiB         630           for neighbor in current.neighbors:
    65     68.7 MiB      0.0 MiB         560               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.7 MiB      0.0 MiB         280                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.7 MiB      0.0 MiB         280                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.7 MiB      0.0 MiB         560               if temp_g_score < g_score[neighbor]:
    71     68.7 MiB      0.0 MiB         215                   came_from[neighbor] = current
    72     68.7 MiB      0.0 MiB         215                   g_score[neighbor] = temp_g_score
    73     68.7 MiB      0.0 MiB         215                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.7 MiB      0.0 MiB         215                   if neighbor not in open_set_hash:
    75     68.7 MiB      0.0 MiB         215                       count += 1
    76     68.7 MiB      0.0 MiB         215                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.7 MiB      0.0 MiB         215                       open_set_hash.add(neighbor)
    78                                                             
    79     68.7 MiB      0.0 MiB          70           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.7 MiB      0.0 MiB          70           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.8 MiB    105.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.8 MiB   -696.9 MiB         257       for row in grid:
    30    105.8 MiB -178685.2 MiB       65792           for spot in row:
    31    105.8 MiB -177990.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.1 MiB     -3.7 MiB           1       count = 0
    34    102.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.1 MiB      0.0 MiB           1       came_from = {}
    37    103.4 MiB -46272.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.5 MiB     -0.8 MiB           1       g_score[start] = 0
    39    106.0 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.3 MiB    -81.2 MiB        6540       while not open_set.empty():
    47    106.3 MiB    -81.2 MiB        6540           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.3 MiB    -81.2 MiB        6540           current = open_set.get()[2]
    53    106.3 MiB    -81.2 MiB        6540           open_set_hash.remove(current)
    54                                         
    55    106.3 MiB    -81.2 MiB        6540           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.3 MiB    -81.2 MiB        6540           if current == end:
    60    105.7 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.3 MiB   -727.6 MiB       58848           for neighbor in current.neighbors:
    65    106.3 MiB   -647.0 MiB       52309               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.3 MiB   -324.6 MiB       26154                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.3 MiB   -322.4 MiB       26155                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.3 MiB   -647.0 MiB       52309               if temp_g_score < g_score[neighbor]:
    71    106.3 MiB    -95.6 MiB        7091                   came_from[neighbor] = current
    72    106.3 MiB    -95.9 MiB        7091                   g_score[neighbor] = temp_g_score
    73    106.3 MiB    -95.9 MiB        7091                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.3 MiB    -95.9 MiB        7091                   if neighbor not in open_set_hash:
    75    106.3 MiB    -95.9 MiB        7091                       count += 1
    76    106.3 MiB    -95.9 MiB        7091                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.3 MiB    -95.9 MiB        7091                       open_set_hash.add(neighbor)
    78                                                             
    79    106.3 MiB    -81.2 MiB        6539           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.3 MiB    -81.2 MiB        6539           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.8 MiB    105.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.8 MiB   -758.7 MiB         257       for row in grid:
    30    105.8 MiB -194395.5 MiB       65792           for spot in row:
    31    105.8 MiB -193642.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.9 MiB     -6.9 MiB           1       count = 0
    34     98.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.9 MiB      0.0 MiB           1       came_from = {}
    37    102.0 MiB   -694.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.2 MiB -14749.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.2 MiB  -1473.9 MiB        4840       while not open_set.empty():
    47    103.2 MiB  -1473.9 MiB        4840           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.2 MiB  -1473.9 MiB        4840           current = open_set.get()[2]
    53    103.2 MiB  -1473.9 MiB        4840           open_set_hash.remove(current)
    54                                         
    55    103.2 MiB  -1473.9 MiB        4840           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.2 MiB  -1473.9 MiB        4840           if current == end:
    60    102.6 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.2 MiB -13263.0 MiB       43548           for neighbor in current.neighbors:
    65    103.2 MiB -11789.1 MiB       38709               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.2 MiB  -5895.5 MiB       19354                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.2 MiB  -5893.8 MiB       19355                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.2 MiB -11789.5 MiB       38709               if temp_g_score < g_score[neighbor]:
    71    103.2 MiB  -1560.6 MiB        5231                   came_from[neighbor] = current
    72    103.2 MiB  -1560.7 MiB        5231                   g_score[neighbor] = temp_g_score
    73    103.2 MiB  -1560.7 MiB        5231                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.2 MiB  -1560.7 MiB        5231                   if neighbor not in open_set_hash:
    75    103.2 MiB  -1560.7 MiB        5231                       count += 1
    76    103.2 MiB  -1560.7 MiB        5231                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.2 MiB  -1560.7 MiB        5231                       open_set_hash.add(neighbor)
    78                                                             
    79    103.2 MiB  -1473.9 MiB        4839           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.2 MiB  -1473.9 MiB        4839           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.6 MiB    102.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.9 MiB  -1167.2 MiB         257       for row in grid:
    30    102.9 MiB -298414.8 MiB       65792           for spot in row:
    31    102.9 MiB -297258.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.7 MiB    -15.1 MiB           1       count = 0
    34     87.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     87.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     87.7 MiB      0.0 MiB           1       came_from = {}
    37     91.6 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.1 MiB      4.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.1 MiB  -3440.3 MiB        2772       while not open_set.empty():
    47     96.1 MiB  -3440.3 MiB        2772           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.1 MiB  -3440.3 MiB        2772           current = open_set.get()[2]
    53     96.1 MiB  -3440.3 MiB        2772           open_set_hash.remove(current)
    54                                         
    55     96.1 MiB  -3440.3 MiB        2772           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.1 MiB  -3440.3 MiB        2772           if current == end:
    60     94.5 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.1 MiB -30958.0 MiB       24936           for neighbor in current.neighbors:
    65     96.1 MiB -27518.0 MiB       22165               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.1 MiB -13760.2 MiB       11082                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.1 MiB -13758.3 MiB       11083                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.1 MiB -27518.7 MiB       22165               if temp_g_score < g_score[neighbor]:
    71     96.1 MiB  -3721.5 MiB        3067                   came_from[neighbor] = current
    72     96.1 MiB  -3721.7 MiB        3067                   g_score[neighbor] = temp_g_score
    73     96.1 MiB  -3721.7 MiB        3067                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.1 MiB  -3721.7 MiB        3067                   if neighbor not in open_set_hash:
    75     96.1 MiB  -3721.7 MiB        3067                       count += 1
    76     96.1 MiB  -3721.7 MiB        3067                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.1 MiB  -3721.7 MiB        3067                       open_set_hash.add(neighbor)
    78                                                             
    79     96.1 MiB  -3440.3 MiB        2771           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.1 MiB  -3440.3 MiB        2771           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.5 MiB     94.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.7 MiB    -86.7 MiB         257       for row in grid:
    30     94.7 MiB -22174.1 MiB       65792           for spot in row:
    31     94.7 MiB -22087.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.4 MiB     -0.4 MiB           1       count = 0
    34     94.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.4 MiB      0.0 MiB           1       came_from = {}
    37     96.4 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.5 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.5 MiB   -161.7 MiB        1144       while not open_set.empty():
    47    100.5 MiB   -161.7 MiB        1144           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.5 MiB   -161.7 MiB        1144           current = open_set.get()[2]
    53    100.5 MiB   -161.7 MiB        1144           open_set_hash.remove(current)
    54                                         
    55    100.5 MiB   -161.7 MiB        1144           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.5 MiB   -161.7 MiB        1144           if current == end:
    60    100.2 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.5 MiB  -1453.5 MiB       10284           for neighbor in current.neighbors:
    65    100.5 MiB  -1292.1 MiB        9141               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.5 MiB   -646.5 MiB        4570                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.5 MiB   -645.6 MiB        4571                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.5 MiB  -1292.1 MiB        9141               if temp_g_score < g_score[neighbor]:
    71    100.5 MiB   -181.6 MiB        1331                   came_from[neighbor] = current
    72    100.5 MiB   -181.6 MiB        1331                   g_score[neighbor] = temp_g_score
    73    100.5 MiB   -181.6 MiB        1331                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.5 MiB   -181.6 MiB        1331                   if neighbor not in open_set_hash:
    75    100.5 MiB   -181.6 MiB        1331                       count += 1
    76    100.5 MiB   -181.6 MiB        1331                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.5 MiB   -181.6 MiB        1331                       open_set_hash.add(neighbor)
    78                                                             
    79    100.5 MiB   -161.7 MiB        1143           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.5 MiB   -161.7 MiB        1143           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.2 MiB    100.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.2 MiB   -471.2 MiB         257       for row in grid:
    30    100.2 MiB -119144.2 MiB       65792           for spot in row:
    31    100.2 MiB -118689.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     76.6 MiB    -23.6 MiB           1       count = 0
    34     76.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.6 MiB      0.0 MiB           1       came_from = {}
    37     77.3 MiB      0.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     77.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     80.4 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     80.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     80.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     80.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     80.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     80.5 MiB      0.0 MiB        1710       while not open_set.empty():
    47     80.5 MiB      0.0 MiB        1710           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     80.5 MiB      0.0 MiB        1710           current = open_set.get()[2]
    53     80.5 MiB      0.0 MiB        1710           open_set_hash.remove(current)
    54                                         
    55     80.5 MiB      0.0 MiB        1710           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     80.5 MiB      0.0 MiB        1710           if current == end:
    60     80.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     80.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     80.5 MiB      0.0 MiB       15039           for neighbor in current.neighbors:
    65     80.5 MiB      0.0 MiB       13330               if current.row != neighbor.row and current.col != neighbor.col:
    66     80.5 MiB      0.0 MiB        6608                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     80.5 MiB      0.0 MiB        6722                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     80.5 MiB      0.0 MiB       13330               if temp_g_score < g_score[neighbor]:
    71     80.5 MiB      0.0 MiB        1880                   came_from[neighbor] = current
    72     80.5 MiB      0.0 MiB        1880                   g_score[neighbor] = temp_g_score
    73     80.5 MiB      0.0 MiB        1880                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     80.5 MiB      0.0 MiB        1880                   if neighbor not in open_set_hash:
    75     80.5 MiB      0.0 MiB        1880                       count += 1
    76     80.5 MiB      0.0 MiB        1880                       open_set.put((f_score[neighbor], count, neighbor))
    77     80.5 MiB      0.0 MiB        1880                       open_set_hash.add(neighbor)
    78                                                             
    79     80.5 MiB      0.0 MiB        1709           if draw is not None:
    80                                                     draw()
    81                                         
    82     80.5 MiB      0.0 MiB        1709           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    117.4 MiB    117.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    117.4 MiB  -2629.7 MiB         257       for row in grid:
    30    117.4 MiB -673523.6 MiB       65792           for spot in row:
    31    117.4 MiB -670897.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.9 MiB    -12.5 MiB           1       count = 0
    34    104.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.9 MiB      0.0 MiB           1       came_from = {}
    37    108.9 MiB -26799.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.7 MiB     -1.2 MiB           1       g_score[start] = 0
    39    109.8 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.9 MiB -49909.1 MiB        7050       while not open_set.empty():
    47    109.9 MiB -49909.1 MiB        7050           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.9 MiB -49909.3 MiB        7050           current = open_set.get()[2]
    53    109.9 MiB -49909.4 MiB        7050           open_set_hash.remove(current)
    54                                         
    55    109.9 MiB -49909.4 MiB        7050           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.9 MiB -49909.7 MiB        7050           if current == end:
    60     95.5 MiB    -14.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.9 MiB -449094.6 MiB       63441           for neighbor in current.neighbors:
    65    109.9 MiB -399191.3 MiB       56392               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.9 MiB -199606.9 MiB       28196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.9 MiB -199592.7 MiB       28196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.9 MiB -399201.4 MiB       56392               if temp_g_score < g_score[neighbor]:
    71    109.9 MiB -52553.0 MiB        7530                   came_from[neighbor] = current
    72    109.9 MiB -52553.1 MiB        7530                   g_score[neighbor] = temp_g_score
    73    109.9 MiB -52553.3 MiB        7530                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.9 MiB -52553.7 MiB        7530                   if neighbor not in open_set_hash:
    75    109.9 MiB -52554.6 MiB        7530                       count += 1
    76    109.9 MiB -52548.2 MiB        7530                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.9 MiB -52548.5 MiB        7530                       open_set_hash.add(neighbor)
    78                                                             
    79    109.9 MiB -49907.3 MiB        7049           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.9 MiB -49908.8 MiB        7049           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.0 MiB     98.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.1 MiB    -57.4 MiB         257       for row in grid:
    30     98.1 MiB -14698.6 MiB       65792           for spot in row:
    31     98.1 MiB -14640.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.1 MiB      0.0 MiB           1       count = 0
    34     98.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.1 MiB      0.0 MiB           1       came_from = {}
    37    102.9 MiB -62592.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     78.2 MiB    -24.7 MiB           1       g_score[start] = 0
    39     79.7 MiB -293449.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     73.0 MiB     -6.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     73.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     73.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     73.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     73.0 MiB      0.0 MiB         209       while not open_set.empty():
    47     73.0 MiB      0.0 MiB         209           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     73.0 MiB      0.0 MiB         209           current = open_set.get()[2]
    53     73.0 MiB      0.0 MiB         209           open_set_hash.remove(current)
    54                                         
    55     73.0 MiB      0.0 MiB         209           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     73.0 MiB      0.0 MiB         209           if current == end:
    60     73.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     73.0 MiB      0.0 MiB        1872           for neighbor in current.neighbors:
    65     73.0 MiB      0.0 MiB        1664               if current.row != neighbor.row and current.col != neighbor.col:
    66     73.0 MiB      0.0 MiB         832                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     73.0 MiB      0.0 MiB         832                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     73.0 MiB      0.0 MiB        1664               if temp_g_score < g_score[neighbor]:
    71     73.0 MiB      0.0 MiB         305                   came_from[neighbor] = current
    72     73.0 MiB      0.0 MiB         305                   g_score[neighbor] = temp_g_score
    73     73.0 MiB      0.0 MiB         305                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     73.0 MiB      0.0 MiB         305                   if neighbor not in open_set_hash:
    75     73.0 MiB      0.0 MiB         305                       count += 1
    76     73.0 MiB      0.0 MiB         305                       open_set.put((f_score[neighbor], count, neighbor))
    77     73.0 MiB      0.0 MiB         305                       open_set_hash.add(neighbor)
    78                                                             
    79     73.0 MiB      0.0 MiB         208           if draw is not None:
    80                                                     draw()
    81                                         
    82     73.0 MiB      0.0 MiB         208           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     73.2 MiB     73.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     73.2 MiB    -21.0 MiB         257       for row in grid:
    30     73.2 MiB  -5096.7 MiB       65792           for spot in row:
    31     73.2 MiB  -5077.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     70.9 MiB     -2.3 MiB           1       count = 0
    34     70.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     70.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     70.9 MiB      0.0 MiB           1       came_from = {}
    37     74.8 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     77.9 MiB -10003.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     77.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     77.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     77.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     77.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     78.3 MiB   -656.0 MiB        4161       while not open_set.empty():
    47     78.3 MiB   -656.3 MiB        4161           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     78.3 MiB   -656.7 MiB        4161           current = open_set.get()[2]
    53     78.3 MiB   -656.7 MiB        4161           open_set_hash.remove(current)
    54                                         
    55     78.3 MiB   -656.7 MiB        4161           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     78.3 MiB   -656.7 MiB        4161           if current == end:
    60     75.9 MiB     -2.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     78.3 MiB  -5894.6 MiB       37440           for neighbor in current.neighbors:
    65     78.3 MiB  -5239.4 MiB       33280               if current.row != neighbor.row and current.col != neighbor.col:
    66     78.3 MiB  -2620.2 MiB       16640                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     78.3 MiB  -2619.4 MiB       16640                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     78.3 MiB  -5239.9 MiB       33280               if temp_g_score < g_score[neighbor]:
    71     78.3 MiB   -755.2 MiB        4565                   came_from[neighbor] = current
    72     78.3 MiB   -755.5 MiB        4565                   g_score[neighbor] = temp_g_score
    73     78.3 MiB   -755.5 MiB        4565                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     78.3 MiB   -755.5 MiB        4565                   if neighbor not in open_set_hash:
    75     78.3 MiB   -755.5 MiB        4565                       count += 1
    76     78.3 MiB   -755.4 MiB        4565                       open_set.put((f_score[neighbor], count, neighbor))
    77     78.3 MiB   -755.5 MiB        4565                       open_set_hash.add(neighbor)
    78                                                             
    79     78.3 MiB   -655.5 MiB        4160           if draw is not None:
    80                                                     draw()
    81                                         
    82     78.3 MiB   -655.7 MiB        4160           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB   -658.1 MiB         257       for row in grid:
    30     76.0 MiB -168612.8 MiB       65792           for spot in row:
    31     76.0 MiB -167956.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.0 MiB     -3.9 MiB           1       count = 0
    34     72.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.0 MiB      0.0 MiB           1       came_from = {}
    37     74.9 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     79.2 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     79.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     79.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     79.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     79.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     79.2 MiB   -903.4 MiB        1330       while not open_set.empty():
    47     79.2 MiB   -903.4 MiB        1330           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     79.2 MiB   -903.4 MiB        1330           current = open_set.get()[2]
    53     79.2 MiB   -903.4 MiB        1330           open_set_hash.remove(current)
    54                                         
    55     79.2 MiB   -903.4 MiB        1330           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     79.2 MiB   -903.4 MiB        1330           if current == end:
    60     76.1 MiB     -3.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     79.2 MiB  -8107.3 MiB       11961           for neighbor in current.neighbors:
    65     79.2 MiB  -7205.9 MiB       10632               if current.row != neighbor.row and current.col != neighbor.col:
    66     79.2 MiB  -3604.9 MiB        5316                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     79.2 MiB  -3601.4 MiB        5316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     79.2 MiB  -7206.7 MiB       10632               if temp_g_score < g_score[neighbor]:
    71     79.2 MiB  -1089.0 MiB        1646                   came_from[neighbor] = current
    72     79.2 MiB  -1089.0 MiB        1646                   g_score[neighbor] = temp_g_score
    73     79.2 MiB  -1089.0 MiB        1646                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     79.2 MiB  -1089.0 MiB        1646                   if neighbor not in open_set_hash:
    75     79.2 MiB  -1089.0 MiB        1646                       count += 1
    76     79.2 MiB  -1089.0 MiB        1646                       open_set.put((f_score[neighbor], count, neighbor))
    77     79.2 MiB  -1089.0 MiB        1646                       open_set_hash.add(neighbor)
    78                                                             
    79     79.2 MiB   -903.4 MiB        1329           if draw is not None:
    80                                                     draw()
    81                                         
    82     79.2 MiB   -903.4 MiB        1329           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.1 MiB     76.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.1 MiB   -190.1 MiB         257       for row in grid:
    30     76.1 MiB -47836.3 MiB       65792           for spot in row:
    31     76.1 MiB -47649.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.1 MiB     -5.0 MiB           1       count = 0
    34     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.1 MiB      0.0 MiB           1       came_from = {}
    37     73.0 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     73.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.8 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.8 MiB    -99.2 MiB        2548       while not open_set.empty():
    47     74.8 MiB    -99.2 MiB        2548           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.8 MiB    -99.2 MiB        2548           current = open_set.get()[2]
    53     74.8 MiB    -99.2 MiB        2548           open_set_hash.remove(current)
    54                                         
    55     74.8 MiB    -99.2 MiB        2548           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.8 MiB    -99.2 MiB        2548           if current == end:
    60     74.5 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.8 MiB   -890.7 MiB       22923           for neighbor in current.neighbors:
    65     74.8 MiB   -791.5 MiB       20376               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.8 MiB   -395.8 MiB       10188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.8 MiB   -395.8 MiB       10188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.8 MiB   -791.5 MiB       20376               if temp_g_score < g_score[neighbor]:
    71     74.8 MiB   -112.1 MiB        2852                   came_from[neighbor] = current
    72     74.8 MiB   -112.1 MiB        2852                   g_score[neighbor] = temp_g_score
    73     74.8 MiB   -112.1 MiB        2852                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.8 MiB   -112.1 MiB        2852                   if neighbor not in open_set_hash:
    75     74.8 MiB   -112.1 MiB        2852                       count += 1
    76     74.8 MiB   -112.1 MiB        2852                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.8 MiB   -112.4 MiB        2852                       open_set_hash.add(neighbor)
    78                                                             
    79     74.8 MiB    -99.2 MiB        2547           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.8 MiB    -99.2 MiB        2547           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.2 MiB    110.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.2 MiB   -289.6 MiB         257       for row in grid:
    30    110.2 MiB -74033.8 MiB       65792           for spot in row:
    31    110.2 MiB -73745.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.5 MiB     -3.7 MiB           1       count = 0
    34    106.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.5 MiB      0.0 MiB           1       came_from = {}
    37    110.7 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.1 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.3 MiB  -3654.1 MiB        6960       while not open_set.empty():
    47    115.3 MiB  -3654.1 MiB        6960           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.3 MiB  -3654.1 MiB        6960           current = open_set.get()[2]
    53    115.3 MiB  -3654.1 MiB        6960           open_set_hash.remove(current)
    54                                         
    55    115.3 MiB  -3654.1 MiB        6960           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.3 MiB  -3654.1 MiB        6960           if current == end:
    60    113.9 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.3 MiB -32874.7 MiB       62631           for neighbor in current.neighbors:
    65    115.3 MiB -29222.3 MiB       55672               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.3 MiB -14611.6 MiB       27836                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.3 MiB -14610.8 MiB       27836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.3 MiB -29222.3 MiB       55672               if temp_g_score < g_score[neighbor]:
    71    115.3 MiB  -3901.9 MiB        7554                   came_from[neighbor] = current
    72    115.3 MiB  -3902.1 MiB        7554                   g_score[neighbor] = temp_g_score
    73    115.3 MiB  -3902.1 MiB        7554                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.3 MiB  -3902.1 MiB        7554                   if neighbor not in open_set_hash:
    75    115.3 MiB  -3902.1 MiB        7554                       count += 1
    76    115.3 MiB  -3902.1 MiB        7554                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.3 MiB  -3902.1 MiB        7554                       open_set_hash.add(neighbor)
    78                                                             
    79    115.3 MiB  -3654.1 MiB        6959           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.3 MiB  -3654.1 MiB        6959           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.9 MiB    113.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.9 MiB  -2291.1 MiB         257       for row in grid:
    30    113.9 MiB -586993.3 MiB       65792           for spot in row:
    31    113.9 MiB -584712.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.2 MiB    -12.7 MiB           1       count = 0
    34    101.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.2 MiB      0.0 MiB           1       came_from = {}
    37    105.2 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.2 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.2 MiB    -31.1 MiB        1183       while not open_set.empty():
    47    108.2 MiB    -31.1 MiB        1183           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.2 MiB    -31.1 MiB        1183           current = open_set.get()[2]
    53    108.2 MiB    -31.1 MiB        1183           open_set_hash.remove(current)
    54                                         
    55    108.2 MiB    -31.1 MiB        1183           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.2 MiB    -31.1 MiB        1183           if current == end:
    60    106.8 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.2 MiB   -268.9 MiB       10638           for neighbor in current.neighbors:
    65    108.2 MiB   -238.4 MiB        9456               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.2 MiB   -120.2 MiB        4728                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.2 MiB   -118.6 MiB        4728                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.2 MiB   -238.9 MiB        9456               if temp_g_score < g_score[neighbor]:
    71    108.2 MiB    -44.0 MiB        1415                   came_from[neighbor] = current
    72    108.2 MiB    -44.0 MiB        1415                   g_score[neighbor] = temp_g_score
    73    108.2 MiB    -44.0 MiB        1415                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.2 MiB    -44.0 MiB        1415                   if neighbor not in open_set_hash:
    75    108.2 MiB    -44.0 MiB        1415                       count += 1
    76    108.2 MiB    -44.0 MiB        1415                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.2 MiB    -44.0 MiB        1415                       open_set_hash.add(neighbor)
    78                                                             
    79    108.2 MiB    -30.9 MiB        1182           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.2 MiB    -31.1 MiB        1182           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.8 MiB    106.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.8 MiB  -1933.2 MiB         257       for row in grid:
    30    106.8 MiB -495068.0 MiB       65792           for spot in row:
    31    106.8 MiB -493150.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.1 MiB    -19.7 MiB           1       count = 0
    34     87.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     87.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     87.1 MiB      0.0 MiB           1       came_from = {}
    37     91.1 MiB  -1025.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     90.8 MiB     -0.3 MiB           1       g_score[start] = 0
    39     93.2 MiB  -9444.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     92.6 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     92.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     92.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     92.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     92.7 MiB -436838.7 MiB        7521       while not open_set.empty():
    47     92.7 MiB -436840.0 MiB        7521           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     92.7 MiB -436840.8 MiB        7521           current = open_set.get()[2]
    53     92.7 MiB -436842.5 MiB        7521           open_set_hash.remove(current)
    54                                         
    55     92.7 MiB -436843.5 MiB        7521           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     92.7 MiB -436844.1 MiB        7521           if current == end:
    60     27.9 MiB    -64.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     28.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     92.7 MiB -3931153.8 MiB       67680           for neighbor in current.neighbors:
    65     92.7 MiB -3494321.2 MiB       60160               if current.row != neighbor.row and current.col != neighbor.col:
    66     92.7 MiB -1747210.3 MiB       30080                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     92.7 MiB -1747124.5 MiB       30080                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     92.7 MiB -3494338.4 MiB       60160               if temp_g_score < g_score[neighbor]:
    71     92.7 MiB -459049.9 MiB        8013                   came_from[neighbor] = current
    72     92.7 MiB -459050.2 MiB        8013                   g_score[neighbor] = temp_g_score
    73     92.7 MiB -459051.2 MiB        8013                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     92.7 MiB -459051.5 MiB        8013                   if neighbor not in open_set_hash:
    75     92.7 MiB -459052.2 MiB        8013                       count += 1
    76     92.7 MiB -459053.1 MiB        8013                       open_set.put((f_score[neighbor], count, neighbor))
    77     92.7 MiB -459053.6 MiB        8013                       open_set_hash.add(neighbor)
    78                                                             
    79     92.7 MiB -436838.1 MiB        7520           if draw is not None:
    80                                                     draw()
    81                                         
    82     92.7 MiB -436838.5 MiB        7520           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     36.7 MiB     36.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     56.0 MiB      0.0 MiB         257       for row in grid:
    30     56.0 MiB      0.0 MiB       65792           for spot in row:
    31     56.0 MiB     19.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.0 MiB      0.0 MiB           1       count = 0
    34     56.0 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     56.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.0 MiB      0.0 MiB           1       came_from = {}
    37     59.8 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     62.3 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.6 MiB      0.0 MiB        2967       while not open_set.empty():
    47     62.6 MiB      0.0 MiB        2967           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.6 MiB      0.0 MiB        2967           current = open_set.get()[2]
    53     62.6 MiB      0.0 MiB        2967           open_set_hash.remove(current)
    54                                         
    55     62.6 MiB      0.0 MiB        2967           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.6 MiB      0.0 MiB        2967           if current == end:
    60     62.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.6 MiB      0.0 MiB       26694           for neighbor in current.neighbors:
    65     62.6 MiB      0.0 MiB       23728               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.6 MiB      0.0 MiB       11864                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.6 MiB      0.0 MiB       11864                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.6 MiB      0.0 MiB       23728               if temp_g_score < g_score[neighbor]:
    71     62.6 MiB      0.3 MiB        3275                   came_from[neighbor] = current
    72     62.6 MiB      0.0 MiB        3275                   g_score[neighbor] = temp_g_score
    73     62.6 MiB      0.0 MiB        3275                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.6 MiB      0.0 MiB        3275                   if neighbor not in open_set_hash:
    75     62.6 MiB      0.0 MiB        3275                       count += 1
    76     62.6 MiB      0.0 MiB        3275                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.6 MiB      0.0 MiB        3275                       open_set_hash.add(neighbor)
    78                                                             
    79     62.6 MiB      0.0 MiB        2966           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.6 MiB      0.0 MiB        2966           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.6 MiB     62.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.6 MiB   -169.3 MiB         257       for row in grid:
    30     62.6 MiB -43409.8 MiB       65792           for spot in row:
    31     62.6 MiB -43241.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.7 MiB     -1.0 MiB           1       count = 0
    34     61.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.7 MiB      0.0 MiB           1       came_from = {}
    37     65.8 MiB      4.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.7 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.9 MiB      0.0 MiB        2499       while not open_set.empty():
    47     66.9 MiB      0.0 MiB        2499           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.9 MiB      0.0 MiB        2499           current = open_set.get()[2]
    53     66.9 MiB      0.0 MiB        2499           open_set_hash.remove(current)
    54                                         
    55     66.9 MiB      0.0 MiB        2499           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.9 MiB      0.0 MiB        2499           if current == end:
    60     66.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.9 MiB      0.0 MiB       22482           for neighbor in current.neighbors:
    65     66.9 MiB      0.0 MiB       19984               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.9 MiB      0.0 MiB        9992                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.9 MiB      0.0 MiB        9992                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.9 MiB      0.0 MiB       19984               if temp_g_score < g_score[neighbor]:
    71     66.9 MiB      0.2 MiB        2795                   came_from[neighbor] = current
    72     66.9 MiB      0.0 MiB        2795                   g_score[neighbor] = temp_g_score
    73     66.9 MiB      0.0 MiB        2795                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.9 MiB      0.0 MiB        2795                   if neighbor not in open_set_hash:
    75     66.9 MiB      0.0 MiB        2795                       count += 1
    76     66.9 MiB      0.0 MiB        2795                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.9 MiB      0.0 MiB        2795                       open_set_hash.add(neighbor)
    78                                                             
    79     66.9 MiB      0.0 MiB        2498           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.9 MiB      0.0 MiB        2498           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.3 MiB    103.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.3 MiB      0.0 MiB         257       for row in grid:
    30    103.3 MiB      0.0 MiB       65792           for spot in row:
    31    103.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.3 MiB      0.0 MiB           1       count = 0
    34    103.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.3 MiB      0.0 MiB           1       came_from = {}
    37    106.2 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.6 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.6 MiB      0.0 MiB         840       while not open_set.empty():
    47    109.6 MiB      0.0 MiB         840           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.6 MiB      0.0 MiB         840           current = open_set.get()[2]
    53    109.6 MiB      0.0 MiB         840           open_set_hash.remove(current)
    54                                         
    55    109.6 MiB      0.0 MiB         840           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.6 MiB      0.0 MiB         840           if current == end:
    60    109.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.6 MiB      0.0 MiB        7551           for neighbor in current.neighbors:
    65    109.6 MiB      0.0 MiB        6712               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.6 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.6 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.6 MiB      0.0 MiB        6712               if temp_g_score < g_score[neighbor]:
    71    109.6 MiB      0.0 MiB        1092                   came_from[neighbor] = current
    72    109.6 MiB      0.0 MiB        1092                   g_score[neighbor] = temp_g_score
    73    109.6 MiB      0.0 MiB        1092                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.6 MiB      0.0 MiB        1092                   if neighbor not in open_set_hash:
    75    109.6 MiB      0.0 MiB        1092                       count += 1
    76    109.6 MiB      0.0 MiB        1092                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.6 MiB      0.0 MiB        1092                       open_set_hash.add(neighbor)
    78                                                             
    79    109.6 MiB      0.0 MiB         839           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.6 MiB      0.0 MiB         839           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.6 MiB    109.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.6 MiB   -148.5 MiB         257       for row in grid:
    30    109.6 MiB -37979.4 MiB       65792           for spot in row:
    31    109.6 MiB -37831.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.9 MiB     -0.8 MiB           1       count = 0
    34    108.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.9 MiB      0.0 MiB           1       came_from = {}
    37    110.7 MiB -100885.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.2 MiB     -2.5 MiB           1       g_score[start] = 0
    39    108.5 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.5 MiB      0.0 MiB        2030       while not open_set.empty():
    47    108.5 MiB      0.0 MiB        2030           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.5 MiB      0.0 MiB        2030           current = open_set.get()[2]
    53    108.5 MiB      0.0 MiB        2030           open_set_hash.remove(current)
    54                                         
    55    108.5 MiB      0.0 MiB        2030           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.5 MiB      0.0 MiB        2030           if current == end:
    60    108.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.5 MiB      0.0 MiB       18261           for neighbor in current.neighbors:
    65    108.5 MiB      0.0 MiB       16232               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.5 MiB      0.0 MiB        8116                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.5 MiB      0.0 MiB        8116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.5 MiB      0.0 MiB       16232               if temp_g_score < g_score[neighbor]:
    71    108.5 MiB      0.0 MiB        2374                   came_from[neighbor] = current
    72    108.5 MiB      0.0 MiB        2374                   g_score[neighbor] = temp_g_score
    73    108.5 MiB      0.0 MiB        2374                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.5 MiB      0.0 MiB        2374                   if neighbor not in open_set_hash:
    75    108.5 MiB      0.0 MiB        2374                       count += 1
    76    108.5 MiB      0.0 MiB        2374                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.5 MiB      0.0 MiB        2374                       open_set_hash.add(neighbor)
    78                                                             
    79    108.5 MiB      0.0 MiB        2029           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.5 MiB      0.0 MiB        2029           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.5 MiB    108.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.5 MiB   -192.1 MiB         257       for row in grid:
    30    108.5 MiB -49181.5 MiB       65792           for spot in row:
    31    108.5 MiB -48991.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.2 MiB     -3.3 MiB           1       count = 0
    34    105.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.2 MiB      0.0 MiB           1       came_from = {}
    37    105.5 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.9 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.9 MiB -96580.2 MiB        5994       while not open_set.empty():
    47    106.9 MiB -96580.9 MiB        5994           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.9 MiB -96581.8 MiB        5994           current = open_set.get()[2]
    53    106.9 MiB -96582.2 MiB        5994           open_set_hash.remove(current)
    54                                         
    55    106.9 MiB -96582.8 MiB        5994           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.9 MiB -96583.1 MiB        5994           if current == end:
    60     73.1 MiB    -33.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.9 MiB -869053.6 MiB       53937           for neighbor in current.neighbors:
    65    106.9 MiB -772484.6 MiB       47944               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.9 MiB -386266.7 MiB       23972                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.9 MiB -386222.7 MiB       23972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.9 MiB -772493.7 MiB       47944               if temp_g_score < g_score[neighbor]:
    71    106.9 MiB -102890.4 MiB        6464                   came_from[neighbor] = current
    72    106.9 MiB -102890.7 MiB        6464                   g_score[neighbor] = temp_g_score
    73    106.9 MiB -102892.9 MiB        6464                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.9 MiB -102893.8 MiB        6464                   if neighbor not in open_set_hash:
    75    106.9 MiB -102894.4 MiB        6464                       count += 1
    76    106.9 MiB -102895.4 MiB        6464                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.9 MiB -102896.0 MiB        6464                       open_set_hash.add(neighbor)
    78                                                             
    79    106.9 MiB -96578.8 MiB        5993           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.9 MiB -96579.2 MiB        5993           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.3 MiB     76.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     86.7 MiB   -580.5 MiB         257       for row in grid:
    30     86.7 MiB -144405.8 MiB       65792           for spot in row:
    31     86.7 MiB -143825.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.2 MiB    -26.4 MiB           1       count = 0
    34     60.3 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     60.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.3 MiB      0.0 MiB           1       came_from = {}
    37     63.4 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.2 MiB   -300.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.2 MiB     -2.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.3 MiB   -438.5 MiB        2772       while not open_set.empty():
    47     64.3 MiB   -438.5 MiB        2772           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.3 MiB   -438.5 MiB        2772           current = open_set.get()[2]
    53     64.3 MiB   -438.5 MiB        2772           open_set_hash.remove(current)
    54                                         
    55     64.3 MiB   -438.5 MiB        2772           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.3 MiB   -438.5 MiB        2772           if current == end:
    60     64.1 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.3 MiB  -3945.1 MiB       24939           for neighbor in current.neighbors:
    65     64.3 MiB  -3506.7 MiB       22168               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.3 MiB  -1753.5 MiB       11084                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.3 MiB  -1753.2 MiB       11084                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.3 MiB  -3506.8 MiB       22168               if temp_g_score < g_score[neighbor]:
    71     64.3 MiB   -486.8 MiB        3150                   came_from[neighbor] = current
    72     64.3 MiB   -486.9 MiB        3150                   g_score[neighbor] = temp_g_score
    73     64.3 MiB   -486.9 MiB        3150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.3 MiB   -486.9 MiB        3150                   if neighbor not in open_set_hash:
    75     64.3 MiB   -487.0 MiB        3150                       count += 1
    76     64.3 MiB   -487.0 MiB        3150                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.3 MiB   -486.9 MiB        3150                       open_set_hash.add(neighbor)
    78                                                             
    79     64.3 MiB   -438.5 MiB        2771           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.3 MiB   -438.5 MiB        2771           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.1 MiB     64.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.6 MiB  -1531.7 MiB         257       for row in grid:
    30     64.6 MiB -392343.1 MiB       65792           for spot in row:
    31     64.6 MiB -390818.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     54.1 MiB    -10.5 MiB           1       count = 0
    34     54.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     54.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     54.1 MiB      0.0 MiB           1       came_from = {}
    37     59.1 MiB      4.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     63.6 MiB  -3133.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.2 MiB -75564.2 MiB       12900       while not open_set.empty():
    47     64.2 MiB -75565.0 MiB       12900           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.2 MiB -75565.3 MiB       12900           current = open_set.get()[2]
    53     64.2 MiB -75565.7 MiB       12900           open_set_hash.remove(current)
    54                                         
    55     64.2 MiB -75566.3 MiB       12900           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.2 MiB -75566.7 MiB       12900           if current == end:
    60     59.2 MiB     -5.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.2 MiB -680078.6 MiB      116091           for neighbor in current.neighbors:
    65     64.2 MiB -604517.6 MiB      103192               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.2 MiB -302261.5 MiB       51596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.2 MiB -302257.7 MiB       51596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.2 MiB -604520.5 MiB      103192               if temp_g_score < g_score[neighbor]:
    71     64.2 MiB -77763.6 MiB       13556                   came_from[neighbor] = current
    72     64.2 MiB -77764.3 MiB       13556                   g_score[neighbor] = temp_g_score
    73     64.2 MiB -77764.5 MiB       13556                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.2 MiB -77764.7 MiB       13556                   if neighbor not in open_set_hash:
    75     64.2 MiB -77764.8 MiB       13556                       count += 1
    76     64.2 MiB -77759.1 MiB       13556                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.2 MiB -77759.4 MiB       13556                       open_set_hash.add(neighbor)
    78                                                             
    79     64.2 MiB -75564.0 MiB       12899           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.2 MiB -75564.2 MiB       12899           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.1 MiB     98.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.1 MiB   -430.6 MiB         257       for row in grid:
    30     98.1 MiB -110121.6 MiB       65792           for spot in row:
    31     98.1 MiB -109691.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.7 MiB     -2.4 MiB           1       count = 0
    34     95.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.7 MiB      0.0 MiB           1       came_from = {}
    37     97.8 MiB -10596.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.9 MiB     -0.9 MiB           1       g_score[start] = 0
    39     99.5 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.5 MiB      0.0 MiB         627       while not open_set.empty():
    47     99.5 MiB      0.0 MiB         627           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.5 MiB      0.0 MiB         627           current = open_set.get()[2]
    53     99.5 MiB      0.0 MiB         627           open_set_hash.remove(current)
    54                                         
    55     99.5 MiB      0.0 MiB         627           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.5 MiB      0.0 MiB         627           if current == end:
    60     99.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.5 MiB      0.0 MiB        5634           for neighbor in current.neighbors:
    65     99.5 MiB      0.0 MiB        5008               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.5 MiB      0.0 MiB        2504                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.5 MiB      0.0 MiB        2504                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.5 MiB      0.0 MiB        5008               if temp_g_score < g_score[neighbor]:
    71     99.5 MiB      0.0 MiB        1467                   came_from[neighbor] = current
    72     99.5 MiB      0.0 MiB        1467                   g_score[neighbor] = temp_g_score
    73     99.5 MiB      0.0 MiB        1467                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.5 MiB      0.0 MiB        1467                   if neighbor not in open_set_hash:
    75     99.5 MiB      0.0 MiB        1467                       count += 1
    76     99.5 MiB      0.0 MiB        1467                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.5 MiB      0.0 MiB        1467                       open_set_hash.add(neighbor)
    78                                                             
    79     99.5 MiB      0.0 MiB         626           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.5 MiB      0.0 MiB         626           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.5 MiB     99.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.5 MiB    -18.4 MiB         257       for row in grid:
    30     99.5 MiB  -4693.3 MiB       65792           for spot in row:
    31     99.5 MiB  -4675.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.2 MiB     -0.3 MiB           1       count = 0
    34     99.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.2 MiB      0.0 MiB           1       came_from = {}
    37    102.2 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.2 MiB      3.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.3 MiB -12848.2 MiB        7616       while not open_set.empty():
    47    106.3 MiB -12848.8 MiB        7616           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.3 MiB -12849.5 MiB        7616           current = open_set.get()[2]
    53    106.3 MiB -12849.5 MiB        7616           open_set_hash.remove(current)
    54                                         
    55    106.3 MiB -12849.5 MiB        7616           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.3 MiB -12849.7 MiB        7616           if current == end:
    60    103.0 MiB     -3.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.3 MiB -115622.7 MiB       68535           for neighbor in current.neighbors:
    65    106.3 MiB -102774.8 MiB       60920               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.3 MiB -51389.2 MiB       30460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.3 MiB -51385.7 MiB       30460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.3 MiB -102775.2 MiB       60920               if temp_g_score < g_score[neighbor]:
    71    106.3 MiB -13458.6 MiB        8108                   came_from[neighbor] = current
    72    106.3 MiB -13458.7 MiB        8108                   g_score[neighbor] = temp_g_score
    73    106.3 MiB -13458.7 MiB        8108                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.3 MiB -13458.7 MiB        8108                   if neighbor not in open_set_hash:
    75    106.3 MiB -13458.7 MiB        8108                       count += 1
    76    106.3 MiB -13459.1 MiB        8108                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.3 MiB -13459.3 MiB        8108                       open_set_hash.add(neighbor)
    78                                                             
    79    106.3 MiB -12848.1 MiB        7615           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.3 MiB -12848.1 MiB        7615           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.0 MiB    103.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.0 MiB   -436.6 MiB         257       for row in grid:
    30    103.0 MiB -111126.7 MiB       65792           for spot in row:
    31    103.0 MiB -110694.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.1 MiB     -5.9 MiB           1       count = 0
    34     97.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.1 MiB      0.0 MiB           1       came_from = {}
    37    100.4 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.5 MiB -46335.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.6 MiB    -97.9 MiB       11340       while not open_set.empty():
    47    101.6 MiB    -97.9 MiB       11340           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.6 MiB    -97.9 MiB       11340           current = open_set.get()[2]
    53    101.6 MiB    -97.9 MiB       11340           open_set_hash.remove(current)
    54                                         
    55    101.6 MiB    -97.9 MiB       11340           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.6 MiB    -97.9 MiB       11340           if current == end:
    60    101.6 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.6 MiB   -880.5 MiB      102051           for neighbor in current.neighbors:
    65    101.6 MiB   -782.7 MiB       90712               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.6 MiB   -391.4 MiB       45356                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.6 MiB   -391.3 MiB       45356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.6 MiB   -782.7 MiB       90712               if temp_g_score < g_score[neighbor]:
    71    101.6 MiB   -102.6 MiB       12046                   came_from[neighbor] = current
    72    101.6 MiB   -102.6 MiB       12046                   g_score[neighbor] = temp_g_score
    73    101.6 MiB   -102.6 MiB       12046                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.6 MiB   -102.6 MiB       12046                   if neighbor not in open_set_hash:
    75    101.6 MiB   -102.7 MiB       12046                       count += 1
    76    101.6 MiB   -102.7 MiB       12046                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.6 MiB   -102.6 MiB       12046                       open_set_hash.add(neighbor)
    78                                                             
    79    101.6 MiB    -97.9 MiB       11339           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.6 MiB    -97.9 MiB       11339           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.6 MiB    101.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.6 MiB      0.0 MiB         257       for row in grid:
    30    101.6 MiB      0.0 MiB       65792           for spot in row:
    31    101.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.6 MiB      0.0 MiB           1       count = 0
    34    101.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.6 MiB      0.0 MiB           1       came_from = {}
    37    103.4 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.0 MiB  -2102.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.0 MiB    -23.6 MiB        1840       while not open_set.empty():
    47    107.0 MiB    -23.6 MiB        1840           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.0 MiB    -23.6 MiB        1840           current = open_set.get()[2]
    53    107.0 MiB    -23.6 MiB        1840           open_set_hash.remove(current)
    54                                         
    55    107.0 MiB    -23.6 MiB        1840           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.0 MiB    -23.6 MiB        1840           if current == end:
    60    105.1 MiB     -2.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.0 MiB   -206.7 MiB       16551           for neighbor in current.neighbors:
    65    107.0 MiB   -183.1 MiB       14712               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.0 MiB    -94.5 MiB        7356                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.0 MiB    -88.6 MiB        7356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.0 MiB   -185.1 MiB       14712               if temp_g_score < g_score[neighbor]:
    71    107.0 MiB    -35.4 MiB        2102                   came_from[neighbor] = current
    72    107.0 MiB    -35.4 MiB        2102                   g_score[neighbor] = temp_g_score
    73    107.0 MiB    -35.4 MiB        2102                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.0 MiB    -35.4 MiB        2102                   if neighbor not in open_set_hash:
    75    107.0 MiB    -35.4 MiB        2102                       count += 1
    76    107.0 MiB    -35.4 MiB        2102                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.0 MiB    -35.4 MiB        2102                       open_set_hash.add(neighbor)
    78                                                             
    79    107.0 MiB    -23.6 MiB        1839           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.0 MiB    -23.6 MiB        1839           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.1 MiB    105.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.1 MiB   -211.5 MiB         257       for row in grid:
    30    105.1 MiB -54057.3 MiB       65792           for spot in row:
    31    105.1 MiB -53847.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.8 MiB     -2.2 MiB           1       count = 0
    34    102.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.8 MiB      0.0 MiB           1       came_from = {}
    37    105.9 MiB -15877.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.9 MiB     -1.0 MiB           1       g_score[start] = 0
    39    105.4 MiB  -2990.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.2 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.3 MiB     -1.5 MiB        6248       while not open_set.empty():
    47    105.3 MiB     -1.5 MiB        6248           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.3 MiB     -1.5 MiB        6248           current = open_set.get()[2]
    53    105.3 MiB     -1.5 MiB        6248           open_set_hash.remove(current)
    54                                         
    55    105.3 MiB     -1.5 MiB        6248           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.3 MiB     -1.5 MiB        6248           if current == end:
    60    105.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.3 MiB    -13.1 MiB       56223           for neighbor in current.neighbors:
    65    105.3 MiB    -11.7 MiB       49976               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.3 MiB     -5.8 MiB       24988                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.3 MiB     -5.8 MiB       24988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.3 MiB    -11.7 MiB       49976               if temp_g_score < g_score[neighbor]:
    71    105.3 MiB     -1.5 MiB        6706                   came_from[neighbor] = current
    72    105.3 MiB     -1.6 MiB        6706                   g_score[neighbor] = temp_g_score
    73    105.3 MiB     -1.6 MiB        6706                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.3 MiB     -1.6 MiB        6706                   if neighbor not in open_set_hash:
    75    105.3 MiB     -1.6 MiB        6706                       count += 1
    76    105.3 MiB     -1.6 MiB        6706                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.3 MiB     -1.6 MiB        6706                       open_set_hash.add(neighbor)
    78                                                             
    79    105.3 MiB     -1.5 MiB        6247           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.3 MiB     -1.5 MiB        6247           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.5 MiB    111.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.5 MiB   -457.9 MiB         257       for row in grid:
    30    111.5 MiB -117116.2 MiB       65792           for spot in row:
    31    111.5 MiB -116660.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.4 MiB     -3.1 MiB           1       count = 0
    34    108.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.4 MiB      0.0 MiB           1       came_from = {}
    37    110.4 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.6 MiB -64516.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.6 MiB     -3.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.6 MiB -274997.7 MiB       12432       while not open_set.empty():
    47    108.6 MiB -274998.9 MiB       12432           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.6 MiB -275000.7 MiB       12432           current = open_set.get()[2]
    53    108.6 MiB -275001.8 MiB       12432           open_set_hash.remove(current)
    54                                         
    55    108.6 MiB -275003.0 MiB       12432           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.6 MiB -275004.0 MiB       12432           if current == end:
    60     61.6 MiB    -47.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.6 MiB -2474779.7 MiB      111879           for neighbor in current.neighbors:
    65    108.6 MiB -2199799.5 MiB       99448               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.6 MiB -1099936.5 MiB       49724                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.6 MiB -1099870.5 MiB       49724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.6 MiB -2199814.3 MiB       99448               if temp_g_score < g_score[neighbor]:
    71    108.6 MiB -285370.2 MiB       13098                   came_from[neighbor] = current
    72    108.6 MiB -285370.8 MiB       13098                   g_score[neighbor] = temp_g_score
    73    108.6 MiB -285372.0 MiB       13098                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.6 MiB -285372.5 MiB       13098                   if neighbor not in open_set_hash:
    75    108.6 MiB -285373.0 MiB       13098                       count += 1
    76    108.6 MiB -285369.3 MiB       13098                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.6 MiB -285370.1 MiB       13098                       open_set_hash.add(neighbor)
    78                                                             
    79    108.6 MiB -274994.6 MiB       12431           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.6 MiB -274996.2 MiB       12431           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.0 MiB     64.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.4 MiB   -208.0 MiB         257       for row in grid:
    30     64.4 MiB -53342.1 MiB       65792           for spot in row:
    31     64.4 MiB -53134.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.4 MiB     -1.0 MiB           1       count = 0
    34     63.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.4 MiB      0.0 MiB           1       came_from = {}
    37     67.3 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.3 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.5 MiB  -1403.4 MiB        7052       while not open_set.empty():
    47     70.5 MiB  -1403.4 MiB        7052           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.5 MiB  -1403.4 MiB        7052           current = open_set.get()[2]
    53     70.5 MiB  -1403.4 MiB        7052           open_set_hash.remove(current)
    54                                         
    55     70.5 MiB  -1403.4 MiB        7052           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.5 MiB  -1403.4 MiB        7052           if current == end:
    60     70.1 MiB     -0.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.5 MiB -12627.1 MiB       63459           for neighbor in current.neighbors:
    65     70.5 MiB -11223.8 MiB       56408               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.5 MiB  -5612.5 MiB       28204                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.5 MiB  -5611.7 MiB       28204                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.5 MiB -11224.2 MiB       56408               if temp_g_score < g_score[neighbor]:
    71     70.5 MiB  -1473.6 MiB        7558                   came_from[neighbor] = current
    72     70.5 MiB  -1473.8 MiB        7558                   g_score[neighbor] = temp_g_score
    73     70.5 MiB  -1473.8 MiB        7558                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.5 MiB  -1473.8 MiB        7558                   if neighbor not in open_set_hash:
    75     70.5 MiB  -1473.8 MiB        7558                       count += 1
    76     70.5 MiB  -1473.8 MiB        7558                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.5 MiB  -1473.8 MiB        7558                       open_set_hash.add(neighbor)
    78                                                             
    79     70.5 MiB  -1403.3 MiB        7051           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.5 MiB  -1403.4 MiB        7051           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.1 MiB     70.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     70.1 MiB   -286.2 MiB         257       for row in grid:
    30     70.1 MiB -73376.3 MiB       65792           for spot in row:
    31     70.1 MiB -73090.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     68.9 MiB     -1.2 MiB           1       count = 0
    34     68.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     68.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     68.9 MiB      0.0 MiB           1       came_from = {}
    37     69.4 MiB      0.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.0 MiB      4.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.1 MiB      0.0 MiB         680       while not open_set.empty():
    47     74.1 MiB      0.0 MiB         680           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.1 MiB      0.0 MiB         680           current = open_set.get()[2]
    53     74.1 MiB      0.0 MiB         680           open_set_hash.remove(current)
    54                                         
    55     74.1 MiB      0.0 MiB         680           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.1 MiB      0.0 MiB         680           if current == end:
    60     74.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.1 MiB      0.0 MiB        6111           for neighbor in current.neighbors:
    65     74.1 MiB      0.0 MiB        5432               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.1 MiB      0.0 MiB        2716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.1 MiB      0.0 MiB        2716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.1 MiB      0.0 MiB        5432               if temp_g_score < g_score[neighbor]:
    71     74.1 MiB      0.0 MiB        1034                   came_from[neighbor] = current
    72     74.1 MiB      0.0 MiB        1034                   g_score[neighbor] = temp_g_score
    73     74.1 MiB      0.0 MiB        1034                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.1 MiB      0.0 MiB        1034                   if neighbor not in open_set_hash:
    75     74.1 MiB      0.0 MiB        1034                       count += 1
    76     74.1 MiB      0.0 MiB        1034                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.1 MiB      0.0 MiB        1034                       open_set_hash.add(neighbor)
    78                                                             
    79     74.1 MiB      0.0 MiB         679           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.1 MiB      0.0 MiB         679           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.2 MiB     74.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.2 MiB  -1331.4 MiB         257       for row in grid:
    30     74.2 MiB -341152.5 MiB       65792           for spot in row:
    31     74.2 MiB -339825.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     67.9 MiB     -6.3 MiB           1       count = 0
    34     67.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.9 MiB      0.0 MiB           1       came_from = {}
    37     70.9 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.4 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.5 MiB      0.0 MiB         416       while not open_set.empty():
    47     71.5 MiB      0.0 MiB         416           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.5 MiB      0.0 MiB         416           current = open_set.get()[2]
    53     71.5 MiB      0.0 MiB         416           open_set_hash.remove(current)
    54                                         
    55     71.5 MiB      0.0 MiB         416           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.5 MiB      0.0 MiB         416           if current == end:
    60     71.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.5 MiB      0.0 MiB        3735           for neighbor in current.neighbors:
    65     71.5 MiB      0.0 MiB        3320               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.5 MiB      0.0 MiB        1660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.5 MiB      0.0 MiB        1660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.5 MiB      0.0 MiB        3320               if temp_g_score < g_score[neighbor]:
    71     71.5 MiB      0.0 MiB         530                   came_from[neighbor] = current
    72     71.5 MiB      0.0 MiB         530                   g_score[neighbor] = temp_g_score
    73     71.5 MiB      0.0 MiB         530                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.5 MiB      0.0 MiB         530                   if neighbor not in open_set_hash:
    75     71.5 MiB      0.0 MiB         530                       count += 1
    76     71.5 MiB      0.0 MiB         530                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.5 MiB      0.0 MiB         530                       open_set_hash.add(neighbor)
    78                                                             
    79     71.5 MiB      0.0 MiB         415           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.5 MiB      0.0 MiB         415           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     71.5 MiB      0.0 MiB         257       for row in grid:
    30     71.5 MiB      0.0 MiB       65792           for spot in row:
    31     71.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.5 MiB      0.0 MiB           1       count = 0
    34     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.5 MiB      0.0 MiB           1       came_from = {}
    37     73.6 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     73.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     78.1 MiB      4.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     78.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     78.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     78.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     78.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     78.1 MiB      0.0 MiB         406       while not open_set.empty():
    47     78.1 MiB      0.0 MiB         406           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     78.1 MiB      0.0 MiB         406           current = open_set.get()[2]
    53     78.1 MiB      0.0 MiB         406           open_set_hash.remove(current)
    54                                         
    55     78.1 MiB      0.0 MiB         406           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     78.1 MiB      0.0 MiB         406           if current == end:
    60     78.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     78.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     78.1 MiB      0.0 MiB        3645           for neighbor in current.neighbors:
    65     78.1 MiB      0.0 MiB        3240               if current.row != neighbor.row and current.col != neighbor.col:
    66     78.1 MiB      0.0 MiB        1620                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     78.1 MiB      0.0 MiB        1620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     78.1 MiB      0.0 MiB        3240               if temp_g_score < g_score[neighbor]:
    71     78.1 MiB      0.0 MiB         518                   came_from[neighbor] = current
    72     78.1 MiB      0.0 MiB         518                   g_score[neighbor] = temp_g_score
    73     78.1 MiB      0.0 MiB         518                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     78.1 MiB      0.0 MiB         518                   if neighbor not in open_set_hash:
    75     78.1 MiB      0.0 MiB         518                       count += 1
    76     78.1 MiB      0.0 MiB         518                       open_set.put((f_score[neighbor], count, neighbor))
    77     78.1 MiB      0.0 MiB         518                       open_set_hash.add(neighbor)
    78                                                             
    79     78.1 MiB      0.0 MiB         405           if draw is not None:
    80                                                     draw()
    81                                         
    82     78.1 MiB      0.0 MiB         405           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.2 MiB    115.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.2 MiB    -15.1 MiB         257       for row in grid:
    30    115.2 MiB  -3843.1 MiB       65792           for spot in row:
    31    115.2 MiB  -3828.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.0 MiB     -0.2 MiB           1       count = 0
    34    115.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.0 MiB      0.0 MiB           1       came_from = {}
    37    117.5 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    117.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.2 MiB      0.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.2 MiB      0.0 MiB        5472       while not open_set.empty():
    47    118.2 MiB      0.0 MiB        5472           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.2 MiB      0.0 MiB        5472           current = open_set.get()[2]
    53    118.2 MiB      0.0 MiB        5472           open_set_hash.remove(current)
    54                                         
    55    118.2 MiB      0.0 MiB        5472           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.2 MiB      0.0 MiB        5472           if current == end:
    60    118.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    118.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.2 MiB      0.0 MiB       49239           for neighbor in current.neighbors:
    65    118.2 MiB      0.0 MiB       43768               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.2 MiB      0.0 MiB       21884                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.2 MiB      0.0 MiB       21884                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.2 MiB      0.0 MiB       43768               if temp_g_score < g_score[neighbor]:
    71    118.2 MiB      0.0 MiB        5968                   came_from[neighbor] = current
    72    118.2 MiB      0.0 MiB        5968                   g_score[neighbor] = temp_g_score
    73    118.2 MiB      0.0 MiB        5968                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.2 MiB      0.0 MiB        5968                   if neighbor not in open_set_hash:
    75    118.2 MiB      0.0 MiB        5968                       count += 1
    76    118.2 MiB      0.0 MiB        5968                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.2 MiB      0.0 MiB        5968                       open_set_hash.add(neighbor)
    78                                                             
    79    118.2 MiB      0.0 MiB        5471           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.2 MiB      0.0 MiB        5471           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.2 MiB    118.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.2 MiB  -1128.6 MiB         257       for row in grid:
    30    118.2 MiB -287127.5 MiB       65792           for spot in row:
    31    118.2 MiB -286014.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.4 MiB    -23.8 MiB           1       count = 0
    34     94.5 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     94.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.5 MiB      0.0 MiB           1       came_from = {}
    37     97.6 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.1 MiB -13523.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.5 MiB -50143.9 MiB        5474       while not open_set.empty():
    47    100.5 MiB -50144.0 MiB        5474           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.5 MiB -50144.0 MiB        5474           current = open_set.get()[2]
    53    100.5 MiB -50144.1 MiB        5474           open_set_hash.remove(current)
    54                                         
    55    100.5 MiB -50144.2 MiB        5474           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.5 MiB -50144.3 MiB        5474           if current == end:
    60     78.6 MiB    -22.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     78.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.5 MiB -451192.2 MiB       49257           for neighbor in current.neighbors:
    65    100.5 MiB -401052.3 MiB       43784               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.5 MiB -200548.9 MiB       21892                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.5 MiB -200507.0 MiB       21892                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.5 MiB -401064.8 MiB       43784               if temp_g_score < g_score[neighbor]:
    71    100.5 MiB -54469.4 MiB        6040                   came_from[neighbor] = current
    72    100.5 MiB -54469.7 MiB        6040                   g_score[neighbor] = temp_g_score
    73    100.5 MiB -54470.0 MiB        6040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.5 MiB -54470.3 MiB        6040                   if neighbor not in open_set_hash:
    75    100.5 MiB -54470.5 MiB        6040                       count += 1
    76    100.5 MiB -54471.2 MiB        6040                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.5 MiB -54471.7 MiB        6040                       open_set_hash.add(neighbor)
    78                                                             
    79    100.5 MiB -50143.6 MiB        5473           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.5 MiB -50143.8 MiB        5473           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     81.1 MiB     81.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.8 MiB    -83.2 MiB         257       for row in grid:
    30     88.8 MiB -21702.8 MiB       65792           for spot in row:
    31     88.8 MiB -21612.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.8 MiB      0.0 MiB           1       count = 0
    34     88.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.8 MiB      0.0 MiB           1       came_from = {}
    37     92.5 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     93.1 MiB  -3496.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.2 MiB      0.0 MiB         902       while not open_set.empty():
    47     93.2 MiB      0.0 MiB         902           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.2 MiB      0.0 MiB         902           current = open_set.get()[2]
    53     93.2 MiB      0.0 MiB         902           open_set_hash.remove(current)
    54                                         
    55     93.2 MiB      0.0 MiB         902           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.2 MiB      0.0 MiB         902           if current == end:
    60     93.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.2 MiB      0.0 MiB        8109           for neighbor in current.neighbors:
    65     93.2 MiB      0.0 MiB        7208               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.2 MiB      0.0 MiB        3604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.2 MiB      0.0 MiB        3604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.2 MiB      0.0 MiB        7208               if temp_g_score < g_score[neighbor]:
    71     93.2 MiB      0.0 MiB        1108                   came_from[neighbor] = current
    72     93.2 MiB      0.0 MiB        1108                   g_score[neighbor] = temp_g_score
    73     93.2 MiB      0.0 MiB        1108                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.2 MiB      0.0 MiB        1108                   if neighbor not in open_set_hash:
    75     93.2 MiB      0.0 MiB        1108                       count += 1
    76     93.2 MiB      0.0 MiB        1108                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.2 MiB      0.0 MiB        1108                       open_set_hash.add(neighbor)
    78                                                             
    79     93.2 MiB      0.0 MiB         901           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.2 MiB      0.0 MiB         901           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.2 MiB     93.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.2 MiB   -515.6 MiB         257       for row in grid:
    30     93.2 MiB -132329.3 MiB       65792           for spot in row:
    31     93.2 MiB -131815.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.9 MiB     -3.4 MiB           1       count = 0
    34     89.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     89.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     89.9 MiB      0.0 MiB           1       came_from = {}
    37     92.4 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     95.2 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     95.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     95.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     95.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     95.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.2 MiB      0.0 MiB        1963       while not open_set.empty():
    47     95.2 MiB      0.0 MiB        1963           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.2 MiB      0.0 MiB        1963           current = open_set.get()[2]
    53     95.2 MiB      0.0 MiB        1963           open_set_hash.remove(current)
    54                                         
    55     95.2 MiB      0.0 MiB        1963           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.2 MiB      0.0 MiB        1963           if current == end:
    60     95.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.2 MiB      0.0 MiB       17658           for neighbor in current.neighbors:
    65     95.2 MiB      0.0 MiB       15696               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.2 MiB      0.0 MiB        7848                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.2 MiB      0.0 MiB        7848                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.2 MiB      0.0 MiB       15696               if temp_g_score < g_score[neighbor]:
    71     95.2 MiB      0.0 MiB        2315                   came_from[neighbor] = current
    72     95.2 MiB      0.0 MiB        2315                   g_score[neighbor] = temp_g_score
    73     95.2 MiB      0.0 MiB        2315                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.2 MiB      0.0 MiB        2315                   if neighbor not in open_set_hash:
    75     95.2 MiB      0.0 MiB        2315                       count += 1
    76     95.2 MiB      0.0 MiB        2315                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.2 MiB      0.0 MiB        2315                       open_set_hash.add(neighbor)
    78                                                             
    79     95.2 MiB      0.0 MiB        1962           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.2 MiB      0.0 MiB        1962           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.2 MiB     95.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.2 MiB     -4.0 MiB         257       for row in grid:
    30     95.2 MiB  -1028.1 MiB       65792           for spot in row:
    31     95.2 MiB  -1024.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.2 MiB     -0.0 MiB           1       count = 0
    34     95.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.2 MiB      0.0 MiB           1       came_from = {}
    37     95.6 MiB -62277.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     95.6 MiB -1268458.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.9 MiB    -18.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     77.0 MiB      0.0 MiB        1862       while not open_set.empty():
    47     77.0 MiB      0.0 MiB        1862           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     77.0 MiB      0.0 MiB        1862           current = open_set.get()[2]
    53     77.0 MiB      0.0 MiB        1862           open_set_hash.remove(current)
    54                                         
    55     77.0 MiB      0.0 MiB        1862           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     77.0 MiB      0.0 MiB        1862           if current == end:
    60     77.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     77.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     77.0 MiB      0.0 MiB       16749           for neighbor in current.neighbors:
    65     77.0 MiB      0.0 MiB       14888               if current.row != neighbor.row and current.col != neighbor.col:
    66     77.0 MiB      0.0 MiB        7444                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     77.0 MiB      0.0 MiB        7444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     77.0 MiB      0.0 MiB       14888               if temp_g_score < g_score[neighbor]:
    71     77.0 MiB      0.0 MiB        2182                   came_from[neighbor] = current
    72     77.0 MiB      0.0 MiB        2182                   g_score[neighbor] = temp_g_score
    73     77.0 MiB      0.0 MiB        2182                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     77.0 MiB      0.0 MiB        2182                   if neighbor not in open_set_hash:
    75     77.0 MiB      0.0 MiB        2182                       count += 1
    76     77.0 MiB      0.0 MiB        2182                       open_set.put((f_score[neighbor], count, neighbor))
    77     77.0 MiB      0.0 MiB        2182                       open_set_hash.add(neighbor)
    78                                                             
    79     77.0 MiB      0.0 MiB        1861           if draw is not None:
    80                                                     draw()
    81                                         
    82     77.0 MiB      0.0 MiB        1861           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.5 MiB    109.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.5 MiB   -338.9 MiB         257       for row in grid:
    30    109.5 MiB -86788.0 MiB       65792           for spot in row:
    31    109.5 MiB -86450.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.1 MiB     -1.4 MiB           1       count = 0
    34    108.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.1 MiB      0.0 MiB           1       came_from = {}
    37    110.6 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.1 MiB -68202.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.3 MiB     -3.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.3 MiB      0.0 MiB          51       while not open_set.empty():
    47    109.3 MiB      0.0 MiB          51           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.3 MiB      0.0 MiB          51           current = open_set.get()[2]
    53    109.3 MiB      0.0 MiB          51           open_set_hash.remove(current)
    54                                         
    55    109.3 MiB      0.0 MiB          51           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.3 MiB      0.0 MiB          51           if current == end:
    60    109.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.3 MiB      0.0 MiB         450           for neighbor in current.neighbors:
    65    109.3 MiB      0.0 MiB         400               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.3 MiB      0.0 MiB         200                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.3 MiB      0.0 MiB         200                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.3 MiB      0.0 MiB         400               if temp_g_score < g_score[neighbor]:
    71    109.3 MiB      0.0 MiB         253                   came_from[neighbor] = current
    72    109.3 MiB      0.0 MiB         253                   g_score[neighbor] = temp_g_score
    73    109.3 MiB      0.0 MiB         253                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.3 MiB      0.0 MiB         253                   if neighbor not in open_set_hash:
    75    109.3 MiB      0.0 MiB         253                       count += 1
    76    109.3 MiB      0.0 MiB         253                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.3 MiB      0.0 MiB         253                       open_set_hash.add(neighbor)
    78                                                             
    79    109.3 MiB      0.0 MiB          50           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.3 MiB      0.0 MiB          50           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.3 MiB    109.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.3 MiB      0.0 MiB         257       for row in grid:
    30    109.3 MiB      0.0 MiB       65792           for spot in row:
    31    109.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.3 MiB      0.0 MiB           1       count = 0
    34    109.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.3 MiB      0.0 MiB           1       came_from = {}
    37    112.1 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.9 MiB  -1018.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.8 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.8 MiB      0.0 MiB         960       while not open_set.empty():
    47    113.8 MiB      0.0 MiB         960           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.8 MiB      0.0 MiB         960           current = open_set.get()[2]
    53    113.8 MiB      0.0 MiB         960           open_set_hash.remove(current)
    54                                         
    55    113.8 MiB      0.0 MiB         960           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.8 MiB      0.0 MiB         960           if current == end:
    60    113.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.8 MiB      0.0 MiB        8631           for neighbor in current.neighbors:
    65    113.8 MiB      0.0 MiB        7672               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.8 MiB      0.0 MiB        3836                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.8 MiB      0.0 MiB        3836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.8 MiB      0.0 MiB        7672               if temp_g_score < g_score[neighbor]:
    71    113.8 MiB      0.0 MiB        1142                   came_from[neighbor] = current
    72    113.8 MiB      0.0 MiB        1142                   g_score[neighbor] = temp_g_score
    73    113.8 MiB      0.0 MiB        1142                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.8 MiB      0.0 MiB        1142                   if neighbor not in open_set_hash:
    75    113.8 MiB      0.0 MiB        1142                       count += 1
    76    113.8 MiB      0.0 MiB        1142                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.8 MiB      0.0 MiB        1142                       open_set_hash.add(neighbor)
    78                                                             
    79    113.8 MiB      0.0 MiB         959           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.8 MiB      0.0 MiB         959           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.8 MiB    113.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.8 MiB    -13.6 MiB         257       for row in grid:
    30    113.8 MiB  -3469.9 MiB       65792           for spot in row:
    31    113.8 MiB  -3456.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.7 MiB     -0.1 MiB           1       count = 0
    34    113.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.7 MiB      0.0 MiB           1       came_from = {}
    37    113.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.2 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.2 MiB      0.0 MiB         774       while not open_set.empty():
    47    114.2 MiB      0.0 MiB         774           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.2 MiB      0.0 MiB         774           current = open_set.get()[2]
    53    114.2 MiB      0.0 MiB         774           open_set_hash.remove(current)
    54                                         
    55    114.2 MiB      0.0 MiB         774           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.2 MiB      0.0 MiB         774           if current == end:
    60    114.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.2 MiB      0.0 MiB        6957           for neighbor in current.neighbors:
    65    114.2 MiB      0.0 MiB        6184               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.2 MiB      0.0 MiB        3092                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.2 MiB      0.0 MiB        3092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.2 MiB      0.0 MiB        6184               if temp_g_score < g_score[neighbor]:
    71    114.2 MiB      0.0 MiB         980                   came_from[neighbor] = current
    72    114.2 MiB      0.0 MiB         980                   g_score[neighbor] = temp_g_score
    73    114.2 MiB      0.0 MiB         980                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.2 MiB      0.0 MiB         980                   if neighbor not in open_set_hash:
    75    114.2 MiB      0.0 MiB         980                       count += 1
    76    114.2 MiB      0.0 MiB         980                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.2 MiB      0.0 MiB         980                       open_set_hash.add(neighbor)
    78                                                             
    79    114.2 MiB      0.0 MiB         773           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.2 MiB      0.0 MiB         773           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.2 MiB    114.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.2 MiB      0.0 MiB         257       for row in grid:
    30    114.2 MiB      0.0 MiB       65792           for spot in row:
    31    114.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.2 MiB      0.0 MiB           1       count = 0
    34    114.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.2 MiB      0.0 MiB           1       came_from = {}
    37    116.3 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.9 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.9 MiB      0.0 MiB        3572       while not open_set.empty():
    47    118.9 MiB      0.0 MiB        3572           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.9 MiB      0.0 MiB        3572           current = open_set.get()[2]
    53    118.9 MiB      0.0 MiB        3572           open_set_hash.remove(current)
    54                                         
    55    118.9 MiB      0.0 MiB        3572           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.9 MiB      0.0 MiB        3572           if current == end:
    60    118.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    118.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.9 MiB      0.0 MiB       32139           for neighbor in current.neighbors:
    65    118.9 MiB      0.0 MiB       28568               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.9 MiB      0.0 MiB       14284                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.9 MiB      0.0 MiB       14284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.9 MiB      0.0 MiB       28568               if temp_g_score < g_score[neighbor]:
    71    118.9 MiB      0.0 MiB        3910                   came_from[neighbor] = current
    72    118.9 MiB      0.0 MiB        3910                   g_score[neighbor] = temp_g_score
    73    118.9 MiB      0.0 MiB        3910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.9 MiB      0.0 MiB        3910                   if neighbor not in open_set_hash:
    75    118.9 MiB      0.0 MiB        3910                       count += 1
    76    118.9 MiB      0.0 MiB        3910                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.9 MiB      0.0 MiB        3910                       open_set_hash.add(neighbor)
    78                                                             
    79    118.9 MiB      0.0 MiB        3571           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.9 MiB      0.0 MiB        3571           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.9 MiB    118.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.9 MiB   -801.5 MiB         257       for row in grid:
    30    118.9 MiB -204023.5 MiB       65792           for spot in row:
    31    118.9 MiB -203227.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.6 MiB     -8.3 MiB           1       count = 0
    34    110.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.6 MiB      0.0 MiB           1       came_from = {}
    37    113.1 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.6 MiB -131516.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.7 MiB     -3.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.7 MiB  -4799.8 MiB        3024       while not open_set.empty():
    47    109.7 MiB  -4799.8 MiB        3024           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.7 MiB  -4799.8 MiB        3024           current = open_set.get()[2]
    53    109.7 MiB  -4799.8 MiB        3024           open_set_hash.remove(current)
    54                                         
    55    109.7 MiB  -4799.8 MiB        3024           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.7 MiB  -4799.8 MiB        3024           if current == end:
    60    107.8 MiB     -1.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.7 MiB -43186.5 MiB       27207           for neighbor in current.neighbors:
    65    109.7 MiB -38387.1 MiB       24184               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.7 MiB -19195.8 MiB       12092                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.7 MiB -19191.6 MiB       12092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.7 MiB -38387.7 MiB       24184               if temp_g_score < g_score[neighbor]:
    71    109.7 MiB  -5200.5 MiB        3354                   came_from[neighbor] = current
    72    109.7 MiB  -5200.5 MiB        3354                   g_score[neighbor] = temp_g_score
    73    109.7 MiB  -5200.9 MiB        3354                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.7 MiB  -5201.0 MiB        3354                   if neighbor not in open_set_hash:
    75    109.7 MiB  -5201.2 MiB        3354                       count += 1
    76    109.7 MiB  -5201.2 MiB        3354                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.7 MiB  -5201.2 MiB        3354                       open_set_hash.add(neighbor)
    78                                                             
    79    109.7 MiB  -4799.8 MiB        3023           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.7 MiB  -4799.8 MiB        3023           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.9 MiB    108.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.9 MiB   -117.4 MiB         257       for row in grid:
    30    108.9 MiB -29525.8 MiB       65792           for spot in row:
    31    108.9 MiB -29412.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.0 MiB     -4.9 MiB           1       count = 0
    34    104.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.0 MiB      0.0 MiB           1       came_from = {}
    37    105.1 MiB -22036.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.0 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.1 MiB      0.0 MiB         867       while not open_set.empty():
    47    108.1 MiB      0.0 MiB         867           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.1 MiB      0.0 MiB         867           current = open_set.get()[2]
    53    108.1 MiB      0.0 MiB         867           open_set_hash.remove(current)
    54                                         
    55    108.1 MiB      0.0 MiB         867           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.1 MiB      0.0 MiB         867           if current == end:
    60    108.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.1 MiB      0.0 MiB        7794           for neighbor in current.neighbors:
    65    108.1 MiB      0.0 MiB        6928               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.1 MiB      0.0 MiB        3464                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.1 MiB      0.0 MiB        3464                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.1 MiB      0.0 MiB        6928               if temp_g_score < g_score[neighbor]:
    71    108.1 MiB      0.0 MiB        1035                   came_from[neighbor] = current
    72    108.1 MiB      0.0 MiB        1035                   g_score[neighbor] = temp_g_score
    73    108.1 MiB      0.0 MiB        1035                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.1 MiB      0.0 MiB        1035                   if neighbor not in open_set_hash:
    75    108.1 MiB      0.0 MiB        1035                       count += 1
    76    108.1 MiB      0.0 MiB        1035                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.1 MiB      0.0 MiB        1035                       open_set_hash.add(neighbor)
    78                                                             
    79    108.1 MiB      0.0 MiB         866           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.1 MiB      0.0 MiB         866           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.1 MiB    108.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.1 MiB      0.0 MiB         257       for row in grid:
    30    108.1 MiB      0.0 MiB       65792           for spot in row:
    31    108.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.1 MiB      0.0 MiB           1       count = 0
    34    108.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.1 MiB      0.0 MiB           1       came_from = {}
    37    109.4 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.5 MiB  -8108.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.9 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.9 MiB  -1707.0 MiB         650       while not open_set.empty():
    47    109.9 MiB  -1707.0 MiB         650           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.9 MiB  -1707.0 MiB         650           current = open_set.get()[2]
    53    109.9 MiB  -1707.0 MiB         650           open_set_hash.remove(current)
    54                                         
    55    109.9 MiB  -1707.0 MiB         650           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.9 MiB  -1707.0 MiB         650           if current == end:
    60    104.6 MiB     -5.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.9 MiB -15338.0 MiB        5841           for neighbor in current.neighbors:
    65    109.9 MiB -13631.7 MiB        5192               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.9 MiB  -6822.2 MiB        2596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.9 MiB  -6809.6 MiB        2596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.9 MiB -13633.4 MiB        5192               if temp_g_score < g_score[neighbor]:
    71    109.9 MiB  -1948.3 MiB         800                   came_from[neighbor] = current
    72    109.9 MiB  -1948.3 MiB         800                   g_score[neighbor] = temp_g_score
    73    109.9 MiB  -1948.8 MiB         800                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.9 MiB  -1949.6 MiB         800                   if neighbor not in open_set_hash:
    75    109.9 MiB  -1950.0 MiB         800                       count += 1
    76    109.9 MiB  -1950.6 MiB         800                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.9 MiB  -1950.9 MiB         800                       open_set_hash.add(neighbor)
    78                                                             
    79    109.9 MiB  -1706.6 MiB         649           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.9 MiB  -1706.6 MiB         649           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.6 MiB    104.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.8 MiB     -3.0 MiB         257       for row in grid:
    30    104.8 MiB   -747.7 MiB       65792           for spot in row:
    31    104.8 MiB   -744.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.6 MiB     -0.2 MiB           1       count = 0
    34    104.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.6 MiB      0.0 MiB           1       came_from = {}
    37    108.3 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.7 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.7 MiB      0.0 MiB        1264       while not open_set.empty():
    47    111.7 MiB      0.0 MiB        1264           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.7 MiB      0.0 MiB        1264           current = open_set.get()[2]
    53    111.7 MiB      0.0 MiB        1264           open_set_hash.remove(current)
    54                                         
    55    111.7 MiB      0.0 MiB        1264           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.7 MiB      0.0 MiB        1264           if current == end:
    60    111.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.7 MiB      0.0 MiB       11367           for neighbor in current.neighbors:
    65    111.7 MiB      0.0 MiB       10104               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.7 MiB      0.0 MiB        5052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.7 MiB      0.0 MiB        5052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.7 MiB      0.0 MiB       10104               if temp_g_score < g_score[neighbor]:
    71    111.7 MiB      0.0 MiB        1610                   came_from[neighbor] = current
    72    111.7 MiB      0.0 MiB        1610                   g_score[neighbor] = temp_g_score
    73    111.7 MiB      0.0 MiB        1610                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.7 MiB      0.0 MiB        1610                   if neighbor not in open_set_hash:
    75    111.7 MiB      0.0 MiB        1610                       count += 1
    76    111.7 MiB      0.0 MiB        1610                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.7 MiB      0.0 MiB        1610                       open_set_hash.add(neighbor)
    78                                                             
    79    111.7 MiB      0.0 MiB        1263           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.7 MiB      0.0 MiB        1263           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.7 MiB    111.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.7 MiB    -86.7 MiB         257       for row in grid:
    30    111.7 MiB -22236.1 MiB       65792           for spot in row:
    31    111.7 MiB -22150.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.7 MiB     -1.0 MiB           1       count = 0
    34    110.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.7 MiB      0.0 MiB           1       came_from = {}
    37    111.3 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.2 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.2 MiB      0.0 MiB        1045       while not open_set.empty():
    47    113.2 MiB      0.0 MiB        1045           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.2 MiB      0.0 MiB        1045           current = open_set.get()[2]
    53    113.2 MiB      0.0 MiB        1045           open_set_hash.remove(current)
    54                                         
    55    113.2 MiB      0.0 MiB        1045           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.2 MiB      0.0 MiB        1045           if current == end:
    60    113.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.2 MiB      0.0 MiB        9396           for neighbor in current.neighbors:
    65    113.2 MiB      0.0 MiB        8352               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.2 MiB      0.0 MiB        4176                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.2 MiB      0.0 MiB        4176                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.2 MiB      0.0 MiB        8352               if temp_g_score < g_score[neighbor]:
    71    113.2 MiB      0.0 MiB        1445                   came_from[neighbor] = current
    72    113.2 MiB      0.0 MiB        1445                   g_score[neighbor] = temp_g_score
    73    113.2 MiB      0.0 MiB        1445                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.2 MiB      0.0 MiB        1445                   if neighbor not in open_set_hash:
    75    113.2 MiB      0.0 MiB        1445                       count += 1
    76    113.2 MiB      0.0 MiB        1445                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.2 MiB      0.0 MiB        1445                       open_set_hash.add(neighbor)
    78                                                             
    79    113.2 MiB      0.0 MiB        1044           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.2 MiB      0.0 MiB        1044           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.2 MiB    113.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.2 MiB   -603.8 MiB         257       for row in grid:
    30    113.2 MiB -154792.8 MiB       65792           for spot in row:
    31    113.2 MiB -154191.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.5 MiB     -4.7 MiB           1       count = 0
    34    108.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.5 MiB      0.0 MiB           1       came_from = {}
    37    110.5 MiB   -212.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.5 MiB     -0.0 MiB           1       g_score[start] = 0
    39    113.5 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.5 MiB      0.0 MiB         680       while not open_set.empty():
    47    113.5 MiB      0.0 MiB         680           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.5 MiB      0.0 MiB         680           current = open_set.get()[2]
    53    113.5 MiB      0.0 MiB         680           open_set_hash.remove(current)
    54                                         
    55    113.5 MiB      0.0 MiB         680           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.5 MiB      0.0 MiB         680           if current == end:
    60    113.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.5 MiB      0.0 MiB        6111           for neighbor in current.neighbors:
    65    113.5 MiB      0.0 MiB        5432               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.5 MiB      0.0 MiB        2716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.5 MiB      0.0 MiB        2716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.5 MiB      0.0 MiB        5432               if temp_g_score < g_score[neighbor]:
    71    113.5 MiB      0.0 MiB         970                   came_from[neighbor] = current
    72    113.5 MiB      0.0 MiB         970                   g_score[neighbor] = temp_g_score
    73    113.5 MiB      0.0 MiB         970                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.5 MiB      0.0 MiB         970                   if neighbor not in open_set_hash:
    75    113.5 MiB      0.0 MiB         970                       count += 1
    76    113.5 MiB      0.0 MiB         970                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.5 MiB      0.0 MiB         970                       open_set_hash.add(neighbor)
    78                                                             
    79    113.5 MiB      0.0 MiB         679           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.5 MiB      0.0 MiB         679           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.6 MiB    115.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.6 MiB      0.0 MiB         257       for row in grid:
    30    115.6 MiB      0.0 MiB       65792           for spot in row:
    31    115.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.6 MiB      0.0 MiB           1       count = 0
    34    115.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.6 MiB      0.0 MiB           1       came_from = {}
    37    115.8 MiB -39952.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.9 MiB     -2.9 MiB           1       g_score[start] = 0
    39    114.0 MiB      1.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.0 MiB -34826.5 MiB        7380       while not open_set.empty():
    47    114.0 MiB -34827.2 MiB        7380           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.0 MiB -34829.1 MiB        7380           current = open_set.get()[2]
    53    114.0 MiB -34829.6 MiB        7380           open_set_hash.remove(current)
    54                                         
    55    114.0 MiB -34830.3 MiB        7380           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.0 MiB -34831.0 MiB        7380           if current == end:
    60     74.6 MiB    -39.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.0 MiB -313293.8 MiB       66411           for neighbor in current.neighbors:
    65    114.0 MiB -278474.1 MiB       59032               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.0 MiB -139273.8 MiB       29516                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.0 MiB -139205.9 MiB       29516                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.0 MiB -278492.8 MiB       59032               if temp_g_score < g_score[neighbor]:
    71    114.0 MiB -38025.2 MiB        7902                   came_from[neighbor] = current
    72    114.0 MiB -38025.7 MiB        7902                   g_score[neighbor] = temp_g_score
    73    114.0 MiB -38026.8 MiB        7902                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.0 MiB -38027.4 MiB        7902                   if neighbor not in open_set_hash:
    75    114.0 MiB -38027.9 MiB        7902                       count += 1
    76    114.0 MiB -38026.1 MiB        7902                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.0 MiB -38026.8 MiB        7902                       open_set_hash.add(neighbor)
    78                                                             
    79    114.0 MiB -34825.0 MiB        7379           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.0 MiB -34825.6 MiB        7379           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.7 MiB     74.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.3 MiB   -113.9 MiB         257       for row in grid:
    30     75.3 MiB -29148.0 MiB       65792           for spot in row:
    31     75.3 MiB -29033.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     74.5 MiB     -0.8 MiB           1       count = 0
    34     74.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.5 MiB      0.0 MiB           1       came_from = {}
    37     75.7 MiB      1.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.7 MiB -158745.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.7 MiB     -1.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.8 MiB      0.0 MiB        4440       while not open_set.empty():
    47     74.8 MiB      0.0 MiB        4440           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.8 MiB      0.0 MiB        4440           current = open_set.get()[2]
    53     74.8 MiB      0.0 MiB        4440           open_set_hash.remove(current)
    54                                         
    55     74.8 MiB      0.0 MiB        4440           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.8 MiB      0.0 MiB        4440           if current == end:
    60     74.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.8 MiB      0.0 MiB       39951           for neighbor in current.neighbors:
    65     74.8 MiB      0.0 MiB       35512               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.8 MiB      0.0 MiB       17756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.8 MiB      0.0 MiB       17756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.8 MiB      0.0 MiB       35512               if temp_g_score < g_score[neighbor]:
    71     74.8 MiB      0.2 MiB        4904                   came_from[neighbor] = current
    72     74.8 MiB      0.0 MiB        4904                   g_score[neighbor] = temp_g_score
    73     74.8 MiB      0.0 MiB        4904                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.8 MiB      0.0 MiB        4904                   if neighbor not in open_set_hash:
    75     74.8 MiB      0.0 MiB        4904                       count += 1
    76     74.8 MiB      0.0 MiB        4904                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.8 MiB      0.0 MiB        4904                       open_set_hash.add(neighbor)
    78                                                             
    79     74.8 MiB      0.0 MiB        4439           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.8 MiB      0.0 MiB        4439           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.8 MiB     74.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.8 MiB      0.0 MiB         257       for row in grid:
    30     74.8 MiB      0.0 MiB       65792           for spot in row:
    31     74.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     74.8 MiB      0.0 MiB           1       count = 0
    34     74.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.8 MiB      0.0 MiB           1       came_from = {}
    37     75.5 MiB  -8840.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.9 MiB     -0.6 MiB           1       g_score[start] = 0
    39     76.2 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.3 MiB      0.0 MiB        3444       while not open_set.empty():
    47     76.3 MiB      0.0 MiB        3444           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.3 MiB      0.0 MiB        3444           current = open_set.get()[2]
    53     76.3 MiB      0.0 MiB        3444           open_set_hash.remove(current)
    54                                         
    55     76.3 MiB      0.0 MiB        3444           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.3 MiB      0.0 MiB        3444           if current == end:
    60     76.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.3 MiB      0.0 MiB       30987           for neighbor in current.neighbors:
    65     76.3 MiB      0.0 MiB       27544               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.3 MiB      0.0 MiB       13772                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.3 MiB      0.0 MiB       13772                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.3 MiB      0.0 MiB       27544               if temp_g_score < g_score[neighbor]:
    71     76.3 MiB      0.0 MiB        4140                   came_from[neighbor] = current
    72     76.3 MiB      0.0 MiB        4140                   g_score[neighbor] = temp_g_score
    73     76.3 MiB      0.0 MiB        4140                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.3 MiB      0.0 MiB        4140                   if neighbor not in open_set_hash:
    75     76.3 MiB      0.0 MiB        4140                       count += 1
    76     76.3 MiB      0.0 MiB        4140                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.3 MiB      0.0 MiB        4140                       open_set_hash.add(neighbor)
    78                                                             
    79     76.3 MiB      0.0 MiB        3443           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.3 MiB      0.0 MiB        3443           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.3 MiB     76.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.3 MiB      0.0 MiB         257       for row in grid:
    30     76.3 MiB      0.0 MiB       65792           for spot in row:
    31     76.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     76.3 MiB      0.0 MiB           1       count = 0
    34     76.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.3 MiB      0.0 MiB           1       came_from = {}
    37     77.8 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     77.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     80.0 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     80.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     80.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     80.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     80.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     80.2 MiB  -5689.2 MiB        5520       while not open_set.empty():
    47     80.2 MiB  -5689.2 MiB        5520           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     80.2 MiB  -5689.4 MiB        5520           current = open_set.get()[2]
    53     80.2 MiB  -5689.7 MiB        5520           open_set_hash.remove(current)
    54                                         
    55     80.2 MiB  -5689.8 MiB        5520           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     80.2 MiB  -5689.8 MiB        5520           if current == end:
    60     77.2 MiB     -2.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     77.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     80.2 MiB -51186.4 MiB       49671           for neighbor in current.neighbors:
    65     80.2 MiB -45497.7 MiB       44152               if current.row != neighbor.row and current.col != neighbor.col:
    66     80.2 MiB -22750.5 MiB       22076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     80.2 MiB -22747.7 MiB       22076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     80.2 MiB -45498.7 MiB       44152               if temp_g_score < g_score[neighbor]:
    71     80.2 MiB  -6051.5 MiB        5940                   came_from[neighbor] = current
    72     80.2 MiB  -6051.6 MiB        5940                   g_score[neighbor] = temp_g_score
    73     80.2 MiB  -6051.7 MiB        5940                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     80.2 MiB  -6051.7 MiB        5940                   if neighbor not in open_set_hash:
    75     80.2 MiB  -6051.7 MiB        5940                       count += 1
    76     80.2 MiB  -6051.7 MiB        5940                       open_set.put((f_score[neighbor], count, neighbor))
    77     80.2 MiB  -6051.6 MiB        5940                       open_set_hash.add(neighbor)
    78                                                             
    79     80.2 MiB  -5689.1 MiB        5519           if draw is not None:
    80                                                     draw()
    81                                         
    82     80.2 MiB  -5689.2 MiB        5519           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     77.3 MiB     77.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     77.3 MiB   -261.2 MiB         257       for row in grid:
    30     77.3 MiB -67104.0 MiB       65792           for spot in row:
    31     77.3 MiB -66843.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     76.1 MiB     -1.2 MiB           1       count = 0
    34     76.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.1 MiB      0.0 MiB           1       came_from = {}
    37     77.6 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     77.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     79.3 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     79.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     79.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     79.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     79.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     79.3 MiB      0.0 MiB          57       while not open_set.empty():
    47     79.3 MiB      0.0 MiB          57           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     79.3 MiB      0.0 MiB          57           current = open_set.get()[2]
    53     79.3 MiB      0.0 MiB          57           open_set_hash.remove(current)
    54                                         
    55     79.3 MiB      0.0 MiB          57           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     79.3 MiB      0.0 MiB          57           if current == end:
    60     79.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     79.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     79.3 MiB      0.0 MiB         504           for neighbor in current.neighbors:
    65     79.3 MiB      0.0 MiB         448               if current.row != neighbor.row and current.col != neighbor.col:
    66     79.3 MiB      0.0 MiB         224                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     79.3 MiB      0.0 MiB         224                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     79.3 MiB      0.0 MiB         448               if temp_g_score < g_score[neighbor]:
    71     79.3 MiB      0.0 MiB         137                   came_from[neighbor] = current
    72     79.3 MiB      0.0 MiB         137                   g_score[neighbor] = temp_g_score
    73     79.3 MiB      0.0 MiB         137                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     79.3 MiB      0.0 MiB         137                   if neighbor not in open_set_hash:
    75     79.3 MiB      0.0 MiB         137                       count += 1
    76     79.3 MiB      0.0 MiB         137                       open_set.put((f_score[neighbor], count, neighbor))
    77     79.3 MiB      0.0 MiB         137                       open_set_hash.add(neighbor)
    78                                                             
    79     79.3 MiB      0.0 MiB          56           if draw is not None:
    80                                                     draw()
    81                                         
    82     79.3 MiB      0.0 MiB          56           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.4 MiB    109.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.4 MiB   -945.5 MiB         257       for row in grid:
    30    109.4 MiB -242910.9 MiB       65792           for spot in row:
    31    109.4 MiB -241968.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.5 MiB     -3.9 MiB           1       count = 0
    34    105.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.5 MiB      0.0 MiB           1       came_from = {}
    37    107.3 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.2 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.2 MiB -57185.6 MiB        9000       while not open_set.empty():
    47    109.2 MiB -57185.6 MiB        9000           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.2 MiB -57186.7 MiB        9000           current = open_set.get()[2]
    53    109.2 MiB -57187.0 MiB        9000           open_set_hash.remove(current)
    54                                         
    55    109.2 MiB -57187.3 MiB        9000           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.2 MiB -57187.3 MiB        9000           if current == end:
    60     99.8 MiB     -9.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.2 MiB -514640.8 MiB       80991           for neighbor in current.neighbors:
    65    109.2 MiB -457456.4 MiB       71992               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.2 MiB -228733.8 MiB       35996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.2 MiB -228725.3 MiB       35996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.2 MiB -457461.3 MiB       71992               if temp_g_score < g_score[neighbor]:
    71    109.2 MiB -59541.3 MiB        9538                   came_from[neighbor] = current
    72    109.2 MiB -59541.3 MiB        9538                   g_score[neighbor] = temp_g_score
    73    109.2 MiB -59541.3 MiB        9538                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.2 MiB -59541.3 MiB        9538                   if neighbor not in open_set_hash:
    75    109.2 MiB -59541.4 MiB        9538                       count += 1
    76    109.2 MiB -59541.4 MiB        9538                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.2 MiB -59541.7 MiB        9538                       open_set_hash.add(neighbor)
    78                                                             
    79    109.2 MiB -57185.2 MiB        8999           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.2 MiB -57185.2 MiB        8999           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.4 MiB    100.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.4 MiB   -190.9 MiB         257       for row in grid:
    30    100.4 MiB -48742.4 MiB       65792           for spot in row:
    31    100.4 MiB -48552.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.8 MiB     -1.7 MiB           1       count = 0
    34     98.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.8 MiB      0.0 MiB           1       came_from = {}
    37    100.9 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.7 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.7 MiB    -16.2 MiB         860       while not open_set.empty():
    47    103.7 MiB    -16.2 MiB         860           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.7 MiB    -16.2 MiB         860           current = open_set.get()[2]
    53    103.7 MiB    -16.2 MiB         860           open_set_hash.remove(current)
    54                                         
    55    103.7 MiB    -16.2 MiB         860           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.7 MiB    -16.2 MiB         860           if current == end:
    60    103.7 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.7 MiB   -145.4 MiB        7731           for neighbor in current.neighbors:
    65    103.7 MiB   -129.2 MiB        6872               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.7 MiB    -64.6 MiB        3436                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.7 MiB    -64.6 MiB        3436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.7 MiB   -129.2 MiB        6872               if temp_g_score < g_score[neighbor]:
    71    103.7 MiB    -19.6 MiB        1070                   came_from[neighbor] = current
    72    103.7 MiB    -19.6 MiB        1070                   g_score[neighbor] = temp_g_score
    73    103.7 MiB    -19.6 MiB        1070                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.7 MiB    -19.6 MiB        1070                   if neighbor not in open_set_hash:
    75    103.7 MiB    -19.6 MiB        1070                       count += 1
    76    103.7 MiB    -19.6 MiB        1070                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.7 MiB    -19.6 MiB        1070                       open_set_hash.add(neighbor)
    78                                                             
    79    103.7 MiB    -16.2 MiB         859           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.7 MiB    -16.2 MiB         859           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.7 MiB    103.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.7 MiB   -464.0 MiB         257       for row in grid:
    30    103.7 MiB -119101.8 MiB       65792           for spot in row:
    31    103.7 MiB -118639.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.4 MiB     -2.3 MiB           1       count = 0
    34    101.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.4 MiB      0.0 MiB           1       came_from = {}
    37    103.0 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.1 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.3 MiB      0.0 MiB        4095       while not open_set.empty():
    47    106.3 MiB      0.0 MiB        4095           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.3 MiB      0.0 MiB        4095           current = open_set.get()[2]
    53    106.3 MiB      0.0 MiB        4095           open_set_hash.remove(current)
    54                                         
    55    106.3 MiB      0.0 MiB        4095           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.3 MiB      0.0 MiB        4095           if current == end:
    60    106.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.3 MiB      0.0 MiB       36846           for neighbor in current.neighbors:
    65    106.3 MiB      0.0 MiB       32752               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.3 MiB      0.0 MiB       16376                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.3 MiB      0.0 MiB       16376                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.3 MiB      0.0 MiB       32752               if temp_g_score < g_score[neighbor]:
    71    106.3 MiB      0.1 MiB        4479                   came_from[neighbor] = current
    72    106.3 MiB      0.0 MiB        4479                   g_score[neighbor] = temp_g_score
    73    106.3 MiB      0.0 MiB        4479                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.3 MiB      0.0 MiB        4479                   if neighbor not in open_set_hash:
    75    106.3 MiB      0.0 MiB        4479                       count += 1
    76    106.3 MiB      0.0 MiB        4479                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.3 MiB      0.0 MiB        4479                       open_set_hash.add(neighbor)
    78                                                             
    79    106.3 MiB      0.0 MiB        4094           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.3 MiB      0.0 MiB        4094           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.3 MiB    106.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.3 MiB      0.0 MiB         257       for row in grid:
    30    106.3 MiB      0.0 MiB       65792           for spot in row:
    31    106.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.3 MiB      0.0 MiB           1       count = 0
    34    106.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.3 MiB      0.0 MiB           1       came_from = {}
    37    107.9 MiB -48027.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.7 MiB     -1.1 MiB           1       g_score[start] = 0
    39    108.9 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.1 MiB  -8996.0 MiB        7755       while not open_set.empty():
    47    109.1 MiB  -8996.0 MiB        7755           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.1 MiB  -8996.0 MiB        7755           current = open_set.get()[2]
    53    109.1 MiB  -8996.0 MiB        7755           open_set_hash.remove(current)
    54                                         
    55    109.1 MiB  -8996.0 MiB        7755           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.1 MiB  -8996.0 MiB        7755           if current == end:
    60    106.4 MiB     -2.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.1 MiB -80945.8 MiB       69786           for neighbor in current.neighbors:
    65    109.1 MiB -71950.5 MiB       62032               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.1 MiB -35977.6 MiB       31016                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.1 MiB -35973.2 MiB       31016                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.1 MiB -71951.4 MiB       62032               if temp_g_score < g_score[neighbor]:
    71    109.1 MiB  -9461.5 MiB        8255                   came_from[neighbor] = current
    72    109.1 MiB  -9461.7 MiB        8255                   g_score[neighbor] = temp_g_score
    73    109.1 MiB  -9461.7 MiB        8255                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.1 MiB  -9461.7 MiB        8255                   if neighbor not in open_set_hash:
    75    109.1 MiB  -9461.7 MiB        8255                       count += 1
    76    109.1 MiB  -9461.7 MiB        8255                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.1 MiB  -9461.7 MiB        8255                       open_set_hash.add(neighbor)
    78                                                             
    79    109.1 MiB  -8996.0 MiB        7754           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.1 MiB  -8996.0 MiB        7754           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.4 MiB    106.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.4 MiB      0.0 MiB         257       for row in grid:
    30    106.4 MiB      0.0 MiB       65792           for spot in row:
    31    106.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.4 MiB      0.0 MiB           1       count = 0
    34    106.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.4 MiB      0.0 MiB           1       came_from = {}
    37    106.8 MiB      0.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.4 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.4 MiB -515335.5 MiB       12198       while not open_set.empty():
    47    110.4 MiB -515337.4 MiB       12198           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.4 MiB -515339.9 MiB       12198           current = open_set.get()[2]
    53    110.4 MiB -515340.8 MiB       12198           open_set_hash.remove(current)
    54                                         
    55    110.4 MiB -515341.8 MiB       12198           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.4 MiB -515343.1 MiB       12198           if current == end:
    60     55.6 MiB    -54.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.4 MiB -4637825.2 MiB      109773           for neighbor in current.neighbors:
    65    110.4 MiB -4122508.1 MiB       97576               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.4 MiB -2061307.9 MiB       48788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.4 MiB -2061212.8 MiB       48788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.4 MiB -4122531.7 MiB       97576               if temp_g_score < g_score[neighbor]:
    71    110.4 MiB -534226.4 MiB       12852                   came_from[neighbor] = current
    72    110.4 MiB -534226.9 MiB       12852                   g_score[neighbor] = temp_g_score
    73    110.4 MiB -534226.9 MiB       12852                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.4 MiB -534227.5 MiB       12852                   if neighbor not in open_set_hash:
    75    110.4 MiB -534228.9 MiB       12852                       count += 1
    76    110.4 MiB -534215.6 MiB       12852                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.4 MiB -534218.0 MiB       12852                       open_set_hash.add(neighbor)
    78                                                             
    79    110.4 MiB -515331.9 MiB       12197           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.4 MiB -515333.6 MiB       12197           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.9 MiB     93.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.9 MiB   -242.0 MiB         257       for row in grid:
    30     93.9 MiB -61956.3 MiB       65792           for spot in row:
    31     93.9 MiB -61715.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.8 MiB     -1.2 MiB           1       count = 0
    34     92.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.8 MiB      0.0 MiB           1       came_from = {}
    37     97.6 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.2 MiB      2.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.3 MiB      0.0 MiB        1125       while not open_set.empty():
    47    100.3 MiB      0.0 MiB        1125           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.3 MiB      0.0 MiB        1125           current = open_set.get()[2]
    53    100.3 MiB      0.0 MiB        1125           open_set_hash.remove(current)
    54                                         
    55    100.3 MiB      0.0 MiB        1125           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.3 MiB      0.0 MiB        1125           if current == end:
    60    100.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.3 MiB      0.0 MiB       10116           for neighbor in current.neighbors:
    65    100.3 MiB      0.0 MiB        8992               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.3 MiB      0.0 MiB        4496                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.3 MiB      0.0 MiB        4496                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.3 MiB      0.0 MiB        8992               if temp_g_score < g_score[neighbor]:
    71    100.3 MiB      0.0 MiB        2033                   came_from[neighbor] = current
    72    100.3 MiB      0.0 MiB        2033                   g_score[neighbor] = temp_g_score
    73    100.3 MiB      0.0 MiB        2033                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.3 MiB      0.0 MiB        2033                   if neighbor not in open_set_hash:
    75    100.3 MiB      0.0 MiB        2033                       count += 1
    76    100.3 MiB      0.0 MiB        2033                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.3 MiB      0.0 MiB        2033                       open_set_hash.add(neighbor)
    78                                                             
    79    100.3 MiB      0.0 MiB        1124           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.3 MiB      0.0 MiB        1124           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.3 MiB  -5236.5 MiB         257       for row in grid:
    30    100.3 MiB -1339323.9 MiB       65792           for spot in row:
    31    100.3 MiB -1334128.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     28.7 MiB    -71.6 MiB           1       count = 0
    34     29.1 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     29.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     29.3 MiB      0.0 MiB           1       came_from = {}
    37     39.9 MiB     10.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     39.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     45.0 MiB      5.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     45.1 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     45.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     45.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     45.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     48.7 MiB   -931.8 MiB        6435       while not open_set.empty():
    47     48.7 MiB   -931.9 MiB        6435           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     48.7 MiB   -931.9 MiB        6435           current = open_set.get()[2]
    53     48.7 MiB   -931.9 MiB        6435           open_set_hash.remove(current)
    54                                         
    55     48.7 MiB   -931.9 MiB        6435           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     48.7 MiB   -931.9 MiB        6435           if current == end:
    60     48.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     48.7 MiB  -8385.0 MiB       57906           for neighbor in current.neighbors:
    65     48.7 MiB  -7451.4 MiB       51472               if current.row != neighbor.row and current.col != neighbor.col:
    66     48.7 MiB  -3726.9 MiB       25736                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     48.7 MiB  -3726.9 MiB       25736                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     48.7 MiB  -7454.1 MiB       51472               if temp_g_score < g_score[neighbor]:
    71     48.7 MiB   -972.1 MiB        6899                   came_from[neighbor] = current
    72     48.7 MiB   -972.4 MiB        6899                   g_score[neighbor] = temp_g_score
    73     48.7 MiB   -972.5 MiB        6899                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     48.7 MiB   -972.5 MiB        6899                   if neighbor not in open_set_hash:
    75     48.7 MiB   -972.5 MiB        6899                       count += 1
    76     48.7 MiB   -972.4 MiB        6899                       open_set.put((f_score[neighbor], count, neighbor))
    77     48.7 MiB   -972.3 MiB        6899                       open_set_hash.add(neighbor)
    78                                                             
    79     48.7 MiB   -931.9 MiB        6434           if draw is not None:
    80                                                     draw()
    81                                         
    82     48.7 MiB   -931.9 MiB        6434           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     51.2 MiB     51.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.5 MiB      0.0 MiB         257       for row in grid:
    30     60.5 MiB      0.0 MiB       65792           for spot in row:
    31     60.5 MiB      9.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.5 MiB      0.0 MiB           1       count = 0
    34     60.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.5 MiB      0.0 MiB           1       came_from = {}
    37     64.8 MiB   -287.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.5 MiB      4.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.1 MiB  -7862.6 MiB       11312       while not open_set.empty():
    47     70.1 MiB  -7862.6 MiB       11312           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.1 MiB  -7862.6 MiB       11312           current = open_set.get()[2]
    53     70.1 MiB  -7862.6 MiB       11312           open_set_hash.remove(current)
    54                                         
    55     70.1 MiB  -7862.7 MiB       11312           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.1 MiB  -7862.7 MiB       11312           if current == end:
    60     66.1 MiB     -3.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.1 MiB -70745.3 MiB      101799           for neighbor in current.neighbors:
    65     70.1 MiB -62883.8 MiB       90488               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.1 MiB -31445.5 MiB       45244                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.1 MiB -31439.1 MiB       45244                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.1 MiB -62885.2 MiB       90488               if temp_g_score < g_score[neighbor]:
    71     70.1 MiB  -8344.6 MiB       11938                   came_from[neighbor] = current
    72     70.1 MiB  -8345.0 MiB       11938                   g_score[neighbor] = temp_g_score
    73     70.1 MiB  -8345.0 MiB       11938                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.1 MiB  -8345.0 MiB       11938                   if neighbor not in open_set_hash:
    75     70.1 MiB  -8345.0 MiB       11938                       count += 1
    76     70.1 MiB  -8345.0 MiB       11938                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.1 MiB  -8344.9 MiB       11938                       open_set_hash.add(neighbor)
    78                                                             
    79     70.1 MiB  -7862.6 MiB       11311           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.1 MiB  -7862.6 MiB       11311           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     66.2 MiB     66.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     66.2 MiB      0.0 MiB         257       for row in grid:
    30     66.2 MiB      0.0 MiB       65792           for spot in row:
    31     66.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.2 MiB      0.0 MiB           1       count = 0
    34     66.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.2 MiB      0.0 MiB           1       came_from = {}
    37     67.4 MiB -31272.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.1 MiB     -0.3 MiB           1       g_score[start] = 0
    39     71.0 MiB -33937.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.1 MiB     -6.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.2 MiB -128960.8 MiB       12512       while not open_set.empty():
    47     64.2 MiB -128961.1 MiB       12512           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.2 MiB -128961.6 MiB       12512           current = open_set.get()[2]
    53     64.2 MiB -128961.8 MiB       12512           open_set_hash.remove(current)
    54                                         
    55     64.2 MiB -128962.1 MiB       12512           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.2 MiB -128962.3 MiB       12512           if current == end:
    60     36.6 MiB    -27.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     36.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.2 MiB -1160492.6 MiB      112599           for neighbor in current.neighbors:
    65     64.2 MiB -1031542.0 MiB      100088               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.2 MiB -515795.6 MiB       50044                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.2 MiB -515750.0 MiB       50044                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.2 MiB -1031549.7 MiB      100088               if temp_g_score < g_score[neighbor]:
    71     64.2 MiB -134247.5 MiB       13150                   came_from[neighbor] = current
    72     64.2 MiB -134248.0 MiB       13150                   g_score[neighbor] = temp_g_score
    73     64.2 MiB -134248.8 MiB       13150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.2 MiB -134249.1 MiB       13150                   if neighbor not in open_set_hash:
    75     64.2 MiB -134249.8 MiB       13150                       count += 1
    76     64.2 MiB -134251.3 MiB       13150                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.2 MiB -134252.0 MiB       13150                       open_set_hash.add(neighbor)
    78                                                             
    79     64.2 MiB -128958.9 MiB       12511           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.2 MiB -128959.8 MiB       12511           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     41.4 MiB     41.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     56.8 MiB     -0.4 MiB         257       for row in grid:
    30     56.8 MiB   -119.4 MiB       65792           for spot in row:
    31     56.8 MiB   -103.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.8 MiB      0.0 MiB           1       count = 0
    34     56.9 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     56.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.9 MiB      0.0 MiB           1       came_from = {}
    37     61.5 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.6 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.8 MiB      0.0 MiB        4494       while not open_set.empty():
    47     65.8 MiB      0.0 MiB        4494           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.8 MiB      0.0 MiB        4494           current = open_set.get()[2]
    53     65.8 MiB      0.0 MiB        4494           open_set_hash.remove(current)
    54                                         
    55     65.8 MiB      0.0 MiB        4494           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.8 MiB      0.0 MiB        4494           if current == end:
    60     65.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.8 MiB      0.0 MiB       40437           for neighbor in current.neighbors:
    65     65.8 MiB      0.0 MiB       35944               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.8 MiB      0.0 MiB       17972                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.8 MiB      0.0 MiB       17972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.8 MiB      0.0 MiB       35944               if temp_g_score < g_score[neighbor]:
    71     65.8 MiB      0.1 MiB        4874                   came_from[neighbor] = current
    72     65.8 MiB      0.0 MiB        4874                   g_score[neighbor] = temp_g_score
    73     65.8 MiB      0.0 MiB        4874                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.8 MiB      0.0 MiB        4874                   if neighbor not in open_set_hash:
    75     65.8 MiB      0.0 MiB        4874                       count += 1
    76     65.8 MiB      0.0 MiB        4874                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.8 MiB      0.1 MiB        4874                       open_set_hash.add(neighbor)
    78                                                             
    79     65.8 MiB      0.0 MiB        4493           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.8 MiB      0.0 MiB        4493           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.5 MiB     98.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.5 MiB   -886.9 MiB         257       for row in grid:
    30     98.5 MiB -226735.4 MiB       65792           for spot in row:
    31     98.5 MiB -225853.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.4 MiB     -7.1 MiB           1       count = 0
    34     91.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.4 MiB      0.0 MiB           1       came_from = {}
    37     91.5 MiB -608346.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     82.1 MiB     -9.4 MiB           1       g_score[start] = 0
    39     85.3 MiB      3.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     85.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     85.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     85.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     85.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     85.9 MiB  -3676.5 MiB        3256       while not open_set.empty():
    47     85.9 MiB  -3676.6 MiB        3256           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     85.9 MiB  -3676.7 MiB        3256           current = open_set.get()[2]
    53     85.9 MiB  -3676.8 MiB        3256           open_set_hash.remove(current)
    54                                         
    55     85.9 MiB  -3676.8 MiB        3256           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     85.9 MiB  -3676.9 MiB        3256           if current == end:
    60     79.5 MiB     -6.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     79.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     85.9 MiB -33054.6 MiB       29295           for neighbor in current.neighbors:
    65     85.9 MiB -29379.5 MiB       26040               if current.row != neighbor.row and current.col != neighbor.col:
    66     85.9 MiB -14694.3 MiB       13020                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     85.9 MiB -14686.7 MiB       13020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     85.9 MiB -29381.7 MiB       26040               if temp_g_score < g_score[neighbor]:
    71     85.9 MiB  -4058.7 MiB        3578                   came_from[neighbor] = current
    72     85.9 MiB  -4059.0 MiB        3578                   g_score[neighbor] = temp_g_score
    73     85.9 MiB  -4059.3 MiB        3578                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     85.9 MiB  -4060.7 MiB        3578                   if neighbor not in open_set_hash:
    75     85.9 MiB  -4060.8 MiB        3578                       count += 1
    76     85.9 MiB  -4060.8 MiB        3578                       open_set.put((f_score[neighbor], count, neighbor))
    77     85.9 MiB  -4060.8 MiB        3578                       open_set_hash.add(neighbor)
    78                                                             
    79     85.9 MiB  -3676.0 MiB        3255           if draw is not None:
    80                                                     draw()
    81                                         
    82     85.9 MiB  -3676.1 MiB        3255           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     81.5 MiB     81.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     84.0 MiB  -2063.5 MiB         257       for row in grid:
    30     84.0 MiB -529895.2 MiB       65792           for spot in row:
    31     84.0 MiB -527828.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     80.1 MiB     -3.9 MiB           1       count = 0
    34     80.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     80.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     80.1 MiB      0.0 MiB           1       came_from = {}
    37     82.4 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     82.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     84.7 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     84.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     84.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     84.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     84.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     84.8 MiB      0.0 MiB          66       while not open_set.empty():
    47     84.8 MiB      0.0 MiB          66           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     84.8 MiB      0.0 MiB          66           current = open_set.get()[2]
    53     84.8 MiB      0.0 MiB          66           open_set_hash.remove(current)
    54                                         
    55     84.8 MiB      0.0 MiB          66           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     84.8 MiB      0.0 MiB          66           if current == end:
    60     84.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     84.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     84.8 MiB      0.0 MiB         585           for neighbor in current.neighbors:
    65     84.8 MiB      0.0 MiB         520               if current.row != neighbor.row and current.col != neighbor.col:
    66     84.8 MiB      0.0 MiB         260                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     84.8 MiB      0.0 MiB         260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     84.8 MiB      0.0 MiB         520               if temp_g_score < g_score[neighbor]:
    71     84.8 MiB      0.0 MiB         138                   came_from[neighbor] = current
    72     84.8 MiB      0.0 MiB         138                   g_score[neighbor] = temp_g_score
    73     84.8 MiB      0.0 MiB         138                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     84.8 MiB      0.0 MiB         138                   if neighbor not in open_set_hash:
    75     84.8 MiB      0.0 MiB         138                       count += 1
    76     84.8 MiB      0.0 MiB         138                       open_set.put((f_score[neighbor], count, neighbor))
    77     84.8 MiB      0.0 MiB         138                       open_set_hash.add(neighbor)
    78                                                             
    79     84.8 MiB      0.0 MiB          65           if draw is not None:
    80                                                     draw()
    81                                         
    82     84.8 MiB      0.0 MiB          65           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     84.8 MiB     84.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     84.8 MiB      0.0 MiB         257       for row in grid:
    30     84.8 MiB      0.0 MiB       65792           for spot in row:
    31     84.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     84.8 MiB      0.0 MiB           1       count = 0
    34     84.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     84.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     84.8 MiB      0.0 MiB           1       came_from = {}
    37     86.6 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     86.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     90.1 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     90.4 MiB      0.0 MiB        7200       while not open_set.empty():
    47     90.4 MiB      0.0 MiB        7200           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     90.4 MiB      0.0 MiB        7200           current = open_set.get()[2]
    53     90.4 MiB      0.0 MiB        7200           open_set_hash.remove(current)
    54                                         
    55     90.4 MiB      0.0 MiB        7200           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     90.4 MiB      0.0 MiB        7200           if current == end:
    60     90.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     90.4 MiB      0.0 MiB       64791           for neighbor in current.neighbors:
    65     90.4 MiB      0.0 MiB       57592               if current.row != neighbor.row and current.col != neighbor.col:
    66     90.4 MiB      0.0 MiB       28796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     90.4 MiB      0.0 MiB       28796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     90.4 MiB      0.0 MiB       57592               if temp_g_score < g_score[neighbor]:
    71     90.4 MiB      0.2 MiB        7686                   came_from[neighbor] = current
    72     90.4 MiB      0.0 MiB        7686                   g_score[neighbor] = temp_g_score
    73     90.4 MiB      0.0 MiB        7686                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     90.4 MiB      0.0 MiB        7686                   if neighbor not in open_set_hash:
    75     90.4 MiB      0.0 MiB        7686                       count += 1
    76     90.4 MiB      0.0 MiB        7686                       open_set.put((f_score[neighbor], count, neighbor))
    77     90.4 MiB      0.0 MiB        7686                       open_set_hash.add(neighbor)
    78                                                             
    79     90.4 MiB      0.0 MiB        7199           if draw is not None:
    80                                                     draw()
    81                                         
    82     90.4 MiB      0.0 MiB        7199           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.4 MiB     90.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.4 MiB      0.0 MiB         257       for row in grid:
    30     90.4 MiB      0.0 MiB       65792           for spot in row:
    31     90.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.4 MiB      0.0 MiB           1       count = 0
    34     90.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     90.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     90.4 MiB      0.0 MiB           1       came_from = {}
    37     94.0 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.1 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.1 MiB -57252.6 MiB        2709       while not open_set.empty():
    47     97.1 MiB -57252.8 MiB        2709           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.1 MiB -57253.1 MiB        2709           current = open_set.get()[2]
    53     97.1 MiB -57253.3 MiB        2709           open_set_hash.remove(current)
    54                                         
    55     97.1 MiB -57253.4 MiB        2709           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.1 MiB -57253.6 MiB        2709           if current == end:
    60     73.8 MiB    -23.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     73.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.1 MiB -515163.8 MiB       24372           for neighbor in current.neighbors:
    65     97.1 MiB -457914.9 MiB       21664               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.1 MiB -228979.6 MiB       10832                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.1 MiB -228938.9 MiB       10832                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.1 MiB -457921.3 MiB       21664               if temp_g_score < g_score[neighbor]:
    71     97.1 MiB -63006.7 MiB        3045                   came_from[neighbor] = current
    72     97.1 MiB -63008.6 MiB        3045                   g_score[neighbor] = temp_g_score
    73     97.1 MiB -63010.8 MiB        3045                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.1 MiB -63011.5 MiB        3045                   if neighbor not in open_set_hash:
    75     97.1 MiB -63012.3 MiB        3045                       count += 1
    76     97.1 MiB -63013.7 MiB        3045                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.1 MiB -63014.5 MiB        3045                       open_set_hash.add(neighbor)
    78                                                             
    79     97.1 MiB -57252.5 MiB        2708           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.1 MiB -57252.6 MiB        2708           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     73.9 MiB     73.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     73.9 MiB    -53.5 MiB         257       for row in grid:
    30     73.9 MiB -13527.7 MiB       65792           for spot in row:
    31     73.9 MiB -13475.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.6 MiB     -1.3 MiB           1       count = 0
    34     72.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.6 MiB      0.0 MiB           1       came_from = {}
    37     74.9 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.9 MiB      0.0 MiB         420       while not open_set.empty():
    47     74.9 MiB      0.0 MiB         420           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.9 MiB      0.0 MiB         420           current = open_set.get()[2]
    53     74.9 MiB      0.0 MiB         420           open_set_hash.remove(current)
    54                                         
    55     74.9 MiB      0.0 MiB         420           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.9 MiB      0.0 MiB         420           if current == end:
    60     74.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.9 MiB      0.0 MiB        3771           for neighbor in current.neighbors:
    65     74.9 MiB      0.0 MiB        3352               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.9 MiB      0.0 MiB        1676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.9 MiB      0.0 MiB        1676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.9 MiB      0.0 MiB        3352               if temp_g_score < g_score[neighbor]:
    71     74.9 MiB      0.0 MiB         644                   came_from[neighbor] = current
    72     74.9 MiB      0.0 MiB         644                   g_score[neighbor] = temp_g_score
    73     74.9 MiB      0.0 MiB         644                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.9 MiB      0.0 MiB         644                   if neighbor not in open_set_hash:
    75     74.9 MiB      0.0 MiB         644                       count += 1
    76     74.9 MiB      0.0 MiB         644                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.9 MiB      0.0 MiB         644                       open_set_hash.add(neighbor)
    78                                                             
    79     74.9 MiB      0.0 MiB         419           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.9 MiB      0.0 MiB         419           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.2 MiB    108.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.2 MiB    -45.5 MiB         257       for row in grid:
    30    108.2 MiB -11412.2 MiB       65792           for spot in row:
    31    108.2 MiB -11367.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.5 MiB     -1.8 MiB           1       count = 0
    34    106.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.5 MiB      0.0 MiB           1       came_from = {}
    37    109.5 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.8 MiB      3.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.8 MiB -25943.1 MiB        5292       while not open_set.empty():
    47    112.8 MiB -25943.1 MiB        5292           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.8 MiB -25943.1 MiB        5292           current = open_set.get()[2]
    53    112.8 MiB -25943.1 MiB        5292           open_set_hash.remove(current)
    54                                         
    55    112.8 MiB -25943.1 MiB        5292           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.8 MiB -25943.1 MiB        5292           if current == end:
    60    107.5 MiB     -5.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.8 MiB -233466.9 MiB       47619           for neighbor in current.neighbors:
    65    112.8 MiB -207524.6 MiB       42328               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.8 MiB -103768.9 MiB       21164                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.8 MiB -103756.7 MiB       21164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.8 MiB -207526.3 MiB       42328               if temp_g_score < g_score[neighbor]:
    71    112.8 MiB -28048.5 MiB        5790                   came_from[neighbor] = current
    72    112.8 MiB -28048.5 MiB        5790                   g_score[neighbor] = temp_g_score
    73    112.8 MiB -28048.5 MiB        5790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.8 MiB -28048.5 MiB        5790                   if neighbor not in open_set_hash:
    75    112.8 MiB -28048.5 MiB        5790                       count += 1
    76    112.8 MiB -28048.5 MiB        5790                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.8 MiB -28048.4 MiB        5790                       open_set_hash.add(neighbor)
    78                                                             
    79    112.8 MiB -25943.1 MiB        5291           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.8 MiB -25943.1 MiB        5291           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.5 MiB    107.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.5 MiB    -23.3 MiB         257       for row in grid:
    30    107.5 MiB  -5770.8 MiB       65792           for spot in row:
    31    107.5 MiB  -5749.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.9 MiB     -2.6 MiB           1       count = 0
    34    104.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.9 MiB      0.0 MiB           1       came_from = {}
    37    107.2 MiB -26081.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.3 MiB -34998.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.3 MiB     -3.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.3 MiB  -3440.3 MiB        1488       while not open_set.empty():
    47    106.3 MiB  -3440.6 MiB        1488           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.3 MiB  -3440.6 MiB        1488           current = open_set.get()[2]
    53    106.3 MiB  -3441.0 MiB        1488           open_set_hash.remove(current)
    54                                         
    55    106.3 MiB  -3441.1 MiB        1488           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.3 MiB  -3441.1 MiB        1488           if current == end:
    60     93.6 MiB    -12.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.3 MiB -30894.7 MiB       13383           for neighbor in current.neighbors:
    65    106.3 MiB -27456.5 MiB       11896               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.3 MiB -13739.4 MiB        5948                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.3 MiB -13718.2 MiB        5948                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.3 MiB -27459.5 MiB       11896               if temp_g_score < g_score[neighbor]:
    71    106.3 MiB  -3975.7 MiB        1740                   came_from[neighbor] = current
    72    106.3 MiB  -3975.7 MiB        1740                   g_score[neighbor] = temp_g_score
    73    106.3 MiB  -3975.9 MiB        1740                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.3 MiB  -3976.3 MiB        1740                   if neighbor not in open_set_hash:
    75    106.3 MiB  -3976.5 MiB        1740                       count += 1
    76    106.3 MiB  -3976.7 MiB        1740                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.3 MiB  -3977.7 MiB        1740                       open_set_hash.add(neighbor)
    78                                                             
    79    106.3 MiB  -3439.8 MiB        1487           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.3 MiB  -3440.0 MiB        1487           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.6 MiB     93.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.6 MiB  -1498.3 MiB         257       for row in grid:
    30     93.6 MiB -384344.0 MiB       65792           for spot in row:
    31     93.6 MiB -382849.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.6 MiB     -6.0 MiB           1       count = 0
    34     87.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     87.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     87.7 MiB      0.0 MiB           1       came_from = {}
    37     91.4 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.8 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.9 MiB      0.0 MiB         972       while not open_set.empty():
    47     94.9 MiB      0.0 MiB         972           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.9 MiB      0.0 MiB         972           current = open_set.get()[2]
    53     94.9 MiB      0.0 MiB         972           open_set_hash.remove(current)
    54                                         
    55     94.9 MiB      0.0 MiB         972           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.9 MiB      0.0 MiB         972           if current == end:
    60     94.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.9 MiB      0.0 MiB        8739           for neighbor in current.neighbors:
    65     94.9 MiB      0.0 MiB        7768               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.9 MiB      0.0 MiB        3884                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.9 MiB      0.0 MiB        3884                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.9 MiB      0.0 MiB        7768               if temp_g_score < g_score[neighbor]:
    71     94.9 MiB      0.1 MiB        1150                   came_from[neighbor] = current
    72     94.9 MiB      0.0 MiB        1150                   g_score[neighbor] = temp_g_score
    73     94.9 MiB      0.0 MiB        1150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.9 MiB      0.0 MiB        1150                   if neighbor not in open_set_hash:
    75     94.9 MiB      0.0 MiB        1150                       count += 1
    76     94.9 MiB      0.0 MiB        1150                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.9 MiB      0.0 MiB        1150                       open_set_hash.add(neighbor)
    78                                                             
    79     94.9 MiB      0.0 MiB         971           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.9 MiB      0.0 MiB         971           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.9 MiB     94.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.9 MiB      0.0 MiB         257       for row in grid:
    30     94.9 MiB      0.0 MiB       65792           for spot in row:
    31     94.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.9 MiB      0.0 MiB           1       count = 0
    34     94.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.9 MiB      0.0 MiB           1       came_from = {}
    37     98.6 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.3 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.4 MiB      0.0 MiB        4608       while not open_set.empty():
    47    100.4 MiB      0.0 MiB        4608           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.4 MiB      0.0 MiB        4608           current = open_set.get()[2]
    53    100.4 MiB      0.0 MiB        4608           open_set_hash.remove(current)
    54                                         
    55    100.4 MiB      0.0 MiB        4608           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.4 MiB      0.0 MiB        4608           if current == end:
    60    100.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.4 MiB      0.0 MiB       41463           for neighbor in current.neighbors:
    65    100.4 MiB      0.0 MiB       36856               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.4 MiB      0.0 MiB       18428                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.4 MiB      0.0 MiB       18428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.4 MiB      0.0 MiB       36856               if temp_g_score < g_score[neighbor]:
    71    100.4 MiB      0.1 MiB        5006                   came_from[neighbor] = current
    72    100.4 MiB      0.0 MiB        5006                   g_score[neighbor] = temp_g_score
    73    100.4 MiB      0.0 MiB        5006                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.4 MiB      0.0 MiB        5006                   if neighbor not in open_set_hash:
    75    100.4 MiB      0.0 MiB        5006                       count += 1
    76    100.4 MiB      0.0 MiB        5006                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.4 MiB      0.0 MiB        5006                       open_set_hash.add(neighbor)
    78                                                             
    79    100.4 MiB      0.0 MiB        4607           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.4 MiB      0.0 MiB        4607           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.4 MiB    100.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.4 MiB   -121.2 MiB         257       for row in grid:
    30    100.4 MiB -30528.0 MiB       65792           for spot in row:
    31    100.4 MiB -30409.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.3 MiB     -4.0 MiB           1       count = 0
    34     96.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.3 MiB      0.0 MiB           1       came_from = {}
    37     96.8 MiB -296021.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     82.2 MiB    -14.6 MiB           1       g_score[start] = 0
    39     87.1 MiB -232576.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.6 MiB    -23.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.6 MiB      0.0 MiB         368       while not open_set.empty():
    47     63.6 MiB      0.0 MiB         368           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.6 MiB      0.0 MiB         368           current = open_set.get()[2]
    53     63.6 MiB      0.0 MiB         368           open_set_hash.remove(current)
    54                                         
    55     63.6 MiB      0.0 MiB         368           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.6 MiB      0.0 MiB         368           if current == end:
    60     63.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.6 MiB      0.0 MiB        3303           for neighbor in current.neighbors:
    65     63.6 MiB      0.0 MiB        2936               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.6 MiB      0.0 MiB        1468                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.6 MiB      0.0 MiB        1468                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.6 MiB      0.0 MiB        2936               if temp_g_score < g_score[neighbor]:
    71     63.6 MiB      0.0 MiB         490                   came_from[neighbor] = current
    72     63.6 MiB      0.0 MiB         490                   g_score[neighbor] = temp_g_score
    73     63.6 MiB      0.0 MiB         490                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.6 MiB      0.0 MiB         490                   if neighbor not in open_set_hash:
    75     63.6 MiB      0.0 MiB         490                       count += 1
    76     63.6 MiB      0.0 MiB         490                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.6 MiB      0.0 MiB         490                       open_set_hash.add(neighbor)
    78                                                             
    79     63.6 MiB      0.0 MiB         367           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.6 MiB      0.0 MiB         367           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.6 MiB    100.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.6 MiB    -25.7 MiB         257       for row in grid:
    30    100.6 MiB  -6589.6 MiB       65792           for spot in row:
    31    100.6 MiB  -6564.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.5 MiB     -0.2 MiB           1       count = 0
    34    100.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.5 MiB      0.0 MiB           1       came_from = {}
    37    101.2 MiB      0.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.8 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.8 MiB      0.0 MiB        2025       while not open_set.empty():
    47    101.8 MiB      0.0 MiB        2025           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.8 MiB      0.0 MiB        2025           current = open_set.get()[2]
    53    101.8 MiB      0.0 MiB        2025           open_set_hash.remove(current)
    54                                         
    55    101.8 MiB      0.0 MiB        2025           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.8 MiB      0.0 MiB        2025           if current == end:
    60    101.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.8 MiB      0.0 MiB       18216           for neighbor in current.neighbors:
    65    101.8 MiB      0.0 MiB       16192               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.8 MiB      0.0 MiB        8096                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.8 MiB      0.0 MiB        8096                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.8 MiB      0.0 MiB       16192               if temp_g_score < g_score[neighbor]:
    71    101.8 MiB      0.0 MiB        2293                   came_from[neighbor] = current
    72    101.8 MiB      0.0 MiB        2293                   g_score[neighbor] = temp_g_score
    73    101.8 MiB      0.0 MiB        2293                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.8 MiB      0.0 MiB        2293                   if neighbor not in open_set_hash:
    75    101.8 MiB      0.0 MiB        2293                       count += 1
    76    101.8 MiB      0.0 MiB        2293                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.8 MiB      0.0 MiB        2293                       open_set_hash.add(neighbor)
    78                                                             
    79    101.8 MiB      0.0 MiB        2024           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.8 MiB      0.0 MiB        2024           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.8 MiB    101.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.8 MiB    -35.0 MiB         257       for row in grid:
    30    101.8 MiB  -8984.8 MiB       65792           for spot in row:
    31    101.8 MiB  -8949.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.7 MiB     -0.2 MiB           1       count = 0
    34    101.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.7 MiB      0.0 MiB           1       came_from = {}
    37    103.1 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.8 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.9 MiB      0.0 MiB         144       while not open_set.empty():
    47    105.9 MiB      0.0 MiB         144           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.9 MiB      0.0 MiB         144           current = open_set.get()[2]
    53    105.9 MiB      0.0 MiB         144           open_set_hash.remove(current)
    54                                         
    55    105.9 MiB      0.0 MiB         144           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.9 MiB      0.0 MiB         144           if current == end:
    60    105.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.9 MiB      0.0 MiB        1287           for neighbor in current.neighbors:
    65    105.9 MiB      0.0 MiB        1144               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.9 MiB      0.0 MiB         572                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.9 MiB      0.0 MiB         572                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.9 MiB      0.0 MiB        1144               if temp_g_score < g_score[neighbor]:
    71    105.9 MiB      0.0 MiB         294                   came_from[neighbor] = current
    72    105.9 MiB      0.0 MiB         294                   g_score[neighbor] = temp_g_score
    73    105.9 MiB      0.0 MiB         294                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.9 MiB      0.0 MiB         294                   if neighbor not in open_set_hash:
    75    105.9 MiB      0.0 MiB         294                       count += 1
    76    105.9 MiB      0.0 MiB         294                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.9 MiB      0.0 MiB         294                       open_set_hash.add(neighbor)
    78                                                             
    79    105.9 MiB      0.0 MiB         143           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.9 MiB      0.0 MiB         143           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.9 MiB    105.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.9 MiB  -4611.4 MiB         257       for row in grid:
    30    105.9 MiB -1181841.7 MiB       65792           for spot in row:
    31    105.9 MiB -1177242.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     84.2 MiB    -21.6 MiB           1       count = 0
    34     84.3 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     84.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     84.3 MiB      0.0 MiB           1       came_from = {}
    37     89.2 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     89.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     93.0 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.0 MiB      0.0 MiB         195       while not open_set.empty():
    47     93.0 MiB      0.0 MiB         195           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.0 MiB      0.0 MiB         195           current = open_set.get()[2]
    53     93.0 MiB      0.0 MiB         195           open_set_hash.remove(current)
    54                                         
    55     93.0 MiB      0.0 MiB         195           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.0 MiB      0.0 MiB         195           if current == end:
    60     93.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.0 MiB      0.0 MiB        1746           for neighbor in current.neighbors:
    65     93.0 MiB      0.0 MiB        1552               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.0 MiB      0.0 MiB         776                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.0 MiB      0.0 MiB         776                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.0 MiB      0.0 MiB        1552               if temp_g_score < g_score[neighbor]:
    71     93.0 MiB      0.0 MiB         291                   came_from[neighbor] = current
    72     93.0 MiB      0.0 MiB         291                   g_score[neighbor] = temp_g_score
    73     93.0 MiB      0.0 MiB         291                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.0 MiB      0.0 MiB         291                   if neighbor not in open_set_hash:
    75     93.0 MiB      0.0 MiB         291                       count += 1
    76     93.0 MiB      0.0 MiB         291                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.0 MiB      0.0 MiB         291                       open_set_hash.add(neighbor)
    78                                                             
    79     93.0 MiB      0.0 MiB         194           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.0 MiB      0.0 MiB         194           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.0 MiB     93.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.8 MiB    -15.8 MiB         257       for row in grid:
    30     93.8 MiB  -4041.4 MiB       65792           for spot in row:
    31     93.8 MiB  -4025.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.5 MiB     -0.3 MiB           1       count = 0
    34     93.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.5 MiB      0.0 MiB           1       came_from = {}
    37     97.1 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.2 MiB -25533.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.2 MiB      0.0 MiB         104       while not open_set.empty():
    47     99.2 MiB      0.0 MiB         104           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.2 MiB      0.0 MiB         104           current = open_set.get()[2]
    53     99.2 MiB      0.0 MiB         104           open_set_hash.remove(current)
    54                                         
    55     99.2 MiB      0.0 MiB         104           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.2 MiB      0.0 MiB         104           if current == end:
    60     99.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.2 MiB      0.0 MiB         927           for neighbor in current.neighbors:
    65     99.2 MiB      0.0 MiB         824               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.2 MiB      0.0 MiB         412                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.2 MiB      0.0 MiB         412                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.2 MiB      0.0 MiB         824               if temp_g_score < g_score[neighbor]:
    71     99.2 MiB      0.0 MiB         170                   came_from[neighbor] = current
    72     99.2 MiB      0.0 MiB         170                   g_score[neighbor] = temp_g_score
    73     99.2 MiB      0.0 MiB         170                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.2 MiB      0.0 MiB         170                   if neighbor not in open_set_hash:
    75     99.2 MiB      0.0 MiB         170                       count += 1
    76     99.2 MiB      0.0 MiB         170                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.2 MiB      0.0 MiB         170                       open_set_hash.add(neighbor)
    78                                                             
    79     99.2 MiB      0.0 MiB         103           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.2 MiB      0.0 MiB         103           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.2 MiB     99.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.2 MiB    -25.8 MiB         257       for row in grid:
    30     99.2 MiB  -6579.3 MiB       65792           for spot in row:
    31     99.2 MiB  -6553.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.9 MiB     -0.3 MiB           1       count = 0
    34     98.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.9 MiB      0.0 MiB           1       came_from = {}
    37    100.5 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.8 MiB -1833584.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.7 MiB    -38.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.9 MiB   -330.9 MiB        1512       while not open_set.empty():
    47     62.9 MiB   -330.9 MiB        1512           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.9 MiB   -330.9 MiB        1512           current = open_set.get()[2]
    53     62.9 MiB   -330.9 MiB        1512           open_set_hash.remove(current)
    54                                         
    55     62.9 MiB   -331.1 MiB        1512           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.9 MiB   -331.3 MiB        1512           if current == end:
    60     60.0 MiB     -2.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.9 MiB  -2977.2 MiB       13599           for neighbor in current.neighbors:
    65     62.9 MiB  -2646.5 MiB       12088               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.9 MiB  -1323.6 MiB        6044                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.9 MiB  -1323.0 MiB        6044                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.9 MiB  -2646.9 MiB       12088               if temp_g_score < g_score[neighbor]:
    71     62.9 MiB   -404.4 MiB        1782                   came_from[neighbor] = current
    72     62.9 MiB   -404.4 MiB        1782                   g_score[neighbor] = temp_g_score
    73     62.9 MiB   -404.4 MiB        1782                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.9 MiB   -404.4 MiB        1782                   if neighbor not in open_set_hash:
    75     62.9 MiB   -404.4 MiB        1782                       count += 1
    76     62.9 MiB   -404.4 MiB        1782                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.9 MiB   -404.4 MiB        1782                       open_set_hash.add(neighbor)
    78                                                             
    79     62.9 MiB   -330.9 MiB        1511           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.9 MiB   -330.9 MiB        1511           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.9 MiB     99.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.9 MiB      0.0 MiB         257       for row in grid:
    30     99.9 MiB      0.0 MiB       65792           for spot in row:
    31     99.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.9 MiB      0.0 MiB           1       count = 0
    34     99.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.9 MiB      0.0 MiB           1       came_from = {}
    37    102.5 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.2 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.2 MiB      0.0 MiB         120       while not open_set.empty():
    47    106.2 MiB      0.0 MiB         120           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.2 MiB      0.0 MiB         120           current = open_set.get()[2]
    53    106.2 MiB      0.0 MiB         120           open_set_hash.remove(current)
    54                                         
    55    106.2 MiB      0.0 MiB         120           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.2 MiB      0.0 MiB         120           if current == end:
    60    106.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.2 MiB      0.0 MiB        1071           for neighbor in current.neighbors:
    65    106.2 MiB      0.0 MiB         952               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.2 MiB      0.0 MiB         476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.2 MiB      0.0 MiB         476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.2 MiB      0.0 MiB         952               if temp_g_score < g_score[neighbor]:
    71    106.2 MiB      0.0 MiB         194                   came_from[neighbor] = current
    72    106.2 MiB      0.0 MiB         194                   g_score[neighbor] = temp_g_score
    73    106.2 MiB      0.0 MiB         194                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.2 MiB      0.0 MiB         194                   if neighbor not in open_set_hash:
    75    106.2 MiB      0.0 MiB         194                       count += 1
    76    106.2 MiB      0.0 MiB         194                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.2 MiB      0.0 MiB         194                       open_set_hash.add(neighbor)
    78                                                             
    79    106.2 MiB      0.0 MiB         119           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.2 MiB      0.0 MiB         119           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB      0.0 MiB         257       for row in grid:
    30    106.2 MiB      0.0 MiB       65792           for spot in row:
    31    106.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.2 MiB      0.0 MiB           1       count = 0
    34    106.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.2 MiB      0.0 MiB           1       came_from = {}
    37    108.8 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.8 MiB      0.0 MiB         392       while not open_set.empty():
    47    108.8 MiB      0.0 MiB         392           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.8 MiB      0.0 MiB         392           current = open_set.get()[2]
    53    108.8 MiB      0.0 MiB         392           open_set_hash.remove(current)
    54                                         
    55    108.8 MiB      0.0 MiB         392           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.8 MiB      0.0 MiB         392           if current == end:
    60    108.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.8 MiB      0.0 MiB        3519           for neighbor in current.neighbors:
    65    108.8 MiB      0.0 MiB        3128               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.8 MiB      0.0 MiB        1564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.8 MiB      0.0 MiB        1564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.8 MiB      0.0 MiB        3128               if temp_g_score < g_score[neighbor]:
    71    108.8 MiB      0.0 MiB         628                   came_from[neighbor] = current
    72    108.8 MiB      0.0 MiB         628                   g_score[neighbor] = temp_g_score
    73    108.8 MiB      0.0 MiB         628                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.8 MiB      0.0 MiB         628                   if neighbor not in open_set_hash:
    75    108.8 MiB      0.0 MiB         628                       count += 1
    76    108.8 MiB      0.0 MiB         628                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.8 MiB      0.0 MiB         628                       open_set_hash.add(neighbor)
    78                                                             
    79    108.8 MiB      0.0 MiB         391           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.8 MiB      0.0 MiB         391           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.8 MiB    108.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.8 MiB   -263.6 MiB         257       for row in grid:
    30    108.8 MiB -67349.5 MiB       65792           for spot in row:
    31    108.8 MiB -67088.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.8 MiB     -4.0 MiB           1       count = 0
    34    104.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.8 MiB      0.0 MiB           1       came_from = {}
    37    107.8 MiB  -2182.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.6 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.6 MiB      0.0 MiB        6032       while not open_set.empty():
    47    110.6 MiB      0.0 MiB        6032           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.6 MiB      0.0 MiB        6032           current = open_set.get()[2]
    53    110.6 MiB      0.0 MiB        6032           open_set_hash.remove(current)
    54                                         
    55    110.6 MiB      0.0 MiB        6032           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.6 MiB      0.0 MiB        6032           if current == end:
    60    110.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.6 MiB      0.0 MiB       54279           for neighbor in current.neighbors:
    65    110.6 MiB      0.0 MiB       48248               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.6 MiB      0.0 MiB       24124                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.6 MiB      0.0 MiB       24124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.6 MiB      0.0 MiB       48248               if temp_g_score < g_score[neighbor]:
    71    110.6 MiB      0.0 MiB        6598                   came_from[neighbor] = current
    72    110.6 MiB      0.0 MiB        6598                   g_score[neighbor] = temp_g_score
    73    110.6 MiB      0.0 MiB        6598                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.6 MiB      0.0 MiB        6598                   if neighbor not in open_set_hash:
    75    110.6 MiB      0.0 MiB        6598                       count += 1
    76    110.6 MiB      0.0 MiB        6598                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.6 MiB      0.0 MiB        6598                       open_set_hash.add(neighbor)
    78                                                             
    79    110.6 MiB      0.0 MiB        6031           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.6 MiB      0.0 MiB        6031           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.6 MiB    110.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.6 MiB   -833.7 MiB         257       for row in grid:
    30    110.6 MiB -213656.9 MiB       65792           for spot in row:
    31    110.6 MiB -212827.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.5 MiB     -6.1 MiB           1       count = 0
    34    104.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.5 MiB      0.0 MiB           1       came_from = {}
    37    105.7 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.5 MiB   -332.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.5 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.6 MiB -13608.7 MiB        9135       while not open_set.empty():
    47    107.6 MiB -13608.8 MiB        9135           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.6 MiB -13609.3 MiB        9135           current = open_set.get()[2]
    53    107.6 MiB -13609.5 MiB        9135           open_set_hash.remove(current)
    54                                         
    55    107.6 MiB -13609.8 MiB        9135           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.6 MiB -13609.8 MiB        9135           if current == end:
    60    101.2 MiB     -6.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.6 MiB -122442.9 MiB       82206           for neighbor in current.neighbors:
    65    107.6 MiB -108835.7 MiB       73072               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.6 MiB -54421.8 MiB       36536                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.6 MiB -54415.1 MiB       36536                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.6 MiB -108837.7 MiB       73072               if temp_g_score < g_score[neighbor]:
    71    107.6 MiB -14412.4 MiB        9691                   came_from[neighbor] = current
    72    107.6 MiB -14412.5 MiB        9691                   g_score[neighbor] = temp_g_score
    73    107.6 MiB -14412.5 MiB        9691                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.6 MiB -14412.6 MiB        9691                   if neighbor not in open_set_hash:
    75    107.6 MiB -14412.9 MiB        9691                       count += 1
    76    107.6 MiB -14413.3 MiB        9691                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.6 MiB -14413.2 MiB        9691                       open_set_hash.add(neighbor)
    78                                                             
    79    107.6 MiB -13608.0 MiB        9134           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.6 MiB -13608.4 MiB        9134           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.2 MiB    101.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.2 MiB   -159.7 MiB         257       for row in grid:
    30    101.2 MiB -41007.0 MiB       65792           for spot in row:
    31    101.2 MiB -40849.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.8 MiB     -2.4 MiB           1       count = 0
    34     98.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.8 MiB      0.0 MiB           1       came_from = {}
    37    102.2 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.4 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.4 MiB -802264.4 MiB       13328       while not open_set.empty():
    47    104.4 MiB -802265.2 MiB       13328           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.4 MiB -802267.3 MiB       13328           current = open_set.get()[2]
    53    104.4 MiB -802268.6 MiB       13328           open_set_hash.remove(current)
    54                                         
    55    104.4 MiB -802269.3 MiB       13328           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.4 MiB -802269.7 MiB       13328           if current == end:
    60     46.4 MiB    -58.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     46.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.4 MiB -7220178.3 MiB      119943           for neighbor in current.neighbors:
    65    104.4 MiB -6417921.6 MiB      106616               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.4 MiB -3209043.2 MiB       53308                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.4 MiB -3208889.7 MiB       53308                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.4 MiB -6417943.4 MiB      106616               if temp_g_score < g_score[neighbor]:
    71    104.4 MiB -828242.3 MiB       13990                   came_from[neighbor] = current
    72    104.4 MiB -828242.8 MiB       13990                   g_score[neighbor] = temp_g_score
    73    104.4 MiB -828241.9 MiB       13990                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.4 MiB -828242.6 MiB       13990                   if neighbor not in open_set_hash:
    75    104.4 MiB -828243.5 MiB       13990                       count += 1
    76    104.4 MiB -828228.4 MiB       13990                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.4 MiB -828229.4 MiB       13990                       open_set_hash.add(neighbor)
    78                                                             
    79    104.4 MiB -802260.2 MiB       13327           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.4 MiB -802262.2 MiB       13327           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.8 MiB     91.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.8 MiB   -212.8 MiB         257       for row in grid:
    30     91.8 MiB -54456.6 MiB       65792           for spot in row:
    31     91.8 MiB -54245.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.0 MiB     -1.8 MiB           1       count = 0
    34     90.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     90.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     90.0 MiB      0.0 MiB           1       came_from = {}
    37     94.0 MiB -22886.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.5 MiB     -0.5 MiB           1       g_score[start] = 0
    39     97.0 MiB -22961.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.7 MiB     -2.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.7 MiB -421496.8 MiB       12376       while not open_set.empty():
    47     94.7 MiB -421498.4 MiB       12376           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.7 MiB -421501.4 MiB       12376           current = open_set.get()[2]
    53     94.7 MiB -421503.1 MiB       12376           open_set_hash.remove(current)
    54                                         
    55     94.7 MiB -421507.2 MiB       12376           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.7 MiB -421511.3 MiB       12376           if current == end:
    60     45.0 MiB    -49.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     45.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.7 MiB -3793311.4 MiB      111375           for neighbor in current.neighbors:
    65     94.7 MiB -3371829.5 MiB       99000               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.7 MiB -1685953.1 MiB       49500                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.7 MiB -1685888.9 MiB       49500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.7 MiB -3371854.2 MiB       99000               if temp_g_score < g_score[neighbor]:
    71     94.7 MiB -436686.0 MiB       13010                   came_from[neighbor] = current
    72     94.7 MiB -436687.9 MiB       13010                   g_score[neighbor] = temp_g_score
    73     94.7 MiB -436689.1 MiB       13010                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.7 MiB -436690.8 MiB       13010                   if neighbor not in open_set_hash:
    75     94.7 MiB -436692.6 MiB       13010                       count += 1
    76     94.7 MiB -436671.4 MiB       13010                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.7 MiB -436672.4 MiB       13010                       open_set_hash.add(neighbor)
    78                                                             
    79     94.7 MiB -421489.9 MiB       12375           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.7 MiB -421491.4 MiB       12375           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     47.8 MiB     47.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     52.1 MiB     -1.1 MiB         257       for row in grid:
    30     52.1 MiB   -301.3 MiB       65792           for spot in row:
    31     52.1 MiB   -295.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.1 MiB      0.0 MiB           1       count = 0
    34     52.2 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     52.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.2 MiB      0.0 MiB           1       came_from = {}
    37     57.4 MiB      5.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     58.6 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     58.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     58.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     58.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     58.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.2 MiB   -167.2 MiB        7857       while not open_set.empty():
    47     59.2 MiB   -167.2 MiB        7857           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.2 MiB   -167.2 MiB        7857           current = open_set.get()[2]
    53     59.2 MiB   -167.2 MiB        7857           open_set_hash.remove(current)
    54                                         
    55     59.2 MiB   -167.2 MiB        7857           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.2 MiB   -167.2 MiB        7857           if current == end:
    60     59.1 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.3 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.2 MiB  -1503.3 MiB       70704           for neighbor in current.neighbors:
    65     59.2 MiB  -1336.1 MiB       62848               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.2 MiB   -668.2 MiB       31424                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.2 MiB   -668.0 MiB       31424                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.2 MiB  -1336.2 MiB       62848               if temp_g_score < g_score[neighbor]:
    71     59.2 MiB   -177.1 MiB        8405                   came_from[neighbor] = current
    72     59.2 MiB   -177.6 MiB        8405                   g_score[neighbor] = temp_g_score
    73     59.2 MiB   -177.6 MiB        8405                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.2 MiB   -177.6 MiB        8405                   if neighbor not in open_set_hash:
    75     59.2 MiB   -177.6 MiB        8405                       count += 1
    76     59.2 MiB   -177.5 MiB        8405                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.2 MiB   -177.5 MiB        8405                       open_set_hash.add(neighbor)
    78                                                             
    79     59.2 MiB   -167.2 MiB        7856           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.2 MiB   -167.2 MiB        7856           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.3 MiB     59.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     59.3 MiB  -1254.9 MiB         257       for row in grid:
    30     59.3 MiB -320425.4 MiB       65792           for spot in row:
    31     59.3 MiB -319182.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     42.1 MiB    -17.2 MiB           1       count = 0
    34     42.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     42.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     42.5 MiB      0.0 MiB           1       came_from = {}
    37     48.9 MiB -139339.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     41.5 MiB     -7.4 MiB           1       g_score[start] = 0
    39     46.4 MiB  -2286.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     46.5 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     46.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     46.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     46.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     47.3 MiB     -3.8 MiB         654       while not open_set.empty():
    47     47.3 MiB     -3.9 MiB         654           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     47.3 MiB     -3.9 MiB         654           current = open_set.get()[2]
    53     47.3 MiB     -3.9 MiB         654           open_set_hash.remove(current)
    54                                         
    55     47.3 MiB     -3.9 MiB         654           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     47.3 MiB     -3.9 MiB         654           if current == end:
    60     47.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     47.3 MiB    -34.3 MiB        5877           for neighbor in current.neighbors:
    65     47.3 MiB    -30.2 MiB        5224               if current.row != neighbor.row and current.col != neighbor.col:
    66     47.3 MiB    -15.3 MiB        2612                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     47.3 MiB    -15.2 MiB        2612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     47.3 MiB    -30.6 MiB        5224               if temp_g_score < g_score[neighbor]:
    71     47.3 MiB     -6.2 MiB        1100                   came_from[neighbor] = current
    72     47.3 MiB     -6.3 MiB        1100                   g_score[neighbor] = temp_g_score
    73     47.3 MiB     -6.3 MiB        1100                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     47.3 MiB     -6.3 MiB        1100                   if neighbor not in open_set_hash:
    75     47.3 MiB     -6.3 MiB        1100                       count += 1
    76     47.3 MiB     -6.1 MiB        1100                       open_set.put((f_score[neighbor], count, neighbor))
    77     47.3 MiB     -6.2 MiB        1100                       open_set_hash.add(neighbor)
    78                                                             
    79     47.3 MiB     -3.9 MiB         653           if draw is not None:
    80                                                     draw()
    81                                         
    82     47.3 MiB     -3.9 MiB         653           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     49.9 MiB     49.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     54.0 MiB   -863.2 MiB         257       for row in grid:
    30     54.0 MiB -220656.1 MiB       65792           for spot in row:
    31     54.0 MiB -219800.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     50.1 MiB     -3.9 MiB           1       count = 0
    34     50.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     50.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     50.2 MiB      0.0 MiB           1       came_from = {}
    37     55.7 MiB      5.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     59.1 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     59.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     59.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     59.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     59.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.5 MiB      0.0 MiB        2418       while not open_set.empty():
    47     59.5 MiB      0.0 MiB        2418           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.5 MiB      0.0 MiB        2418           current = open_set.get()[2]
    53     59.5 MiB      0.0 MiB        2418           open_set_hash.remove(current)
    54                                         
    55     59.5 MiB      0.0 MiB        2418           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.5 MiB      0.0 MiB        2418           if current == end:
    60     59.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.5 MiB      0.0 MiB       21753           for neighbor in current.neighbors:
    65     59.5 MiB      0.0 MiB       19336               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.5 MiB      0.0 MiB        9668                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.5 MiB      0.0 MiB        9668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.5 MiB      0.0 MiB       19336               if temp_g_score < g_score[neighbor]:
    71     59.5 MiB      0.2 MiB        2840                   came_from[neighbor] = current
    72     59.5 MiB      0.0 MiB        2840                   g_score[neighbor] = temp_g_score
    73     59.5 MiB      0.0 MiB        2840                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.5 MiB      0.0 MiB        2840                   if neighbor not in open_set_hash:
    75     59.5 MiB      0.0 MiB        2840                       count += 1
    76     59.5 MiB      0.0 MiB        2840                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.5 MiB      0.1 MiB        2840                       open_set_hash.add(neighbor)
    78                                                             
    79     59.5 MiB      0.0 MiB        2417           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.5 MiB      0.0 MiB        2417           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.6 MiB     59.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     59.6 MiB      0.0 MiB         257       for row in grid:
    30     59.6 MiB      0.0 MiB       65792           for spot in row:
    31     59.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.6 MiB      0.0 MiB           1       count = 0
    34     59.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.6 MiB      0.0 MiB           1       came_from = {}
    37     63.1 MiB      3.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.7 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.8 MiB      0.0 MiB        1869       while not open_set.empty():
    47     65.8 MiB      0.0 MiB        1869           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.8 MiB      0.0 MiB        1869           current = open_set.get()[2]
    53     65.8 MiB      0.0 MiB        1869           open_set_hash.remove(current)
    54                                         
    55     65.8 MiB      0.0 MiB        1869           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.8 MiB      0.0 MiB        1869           if current == end:
    60     65.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.8 MiB      0.0 MiB       16812           for neighbor in current.neighbors:
    65     65.8 MiB      0.0 MiB       14944               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.8 MiB      0.0 MiB        7472                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.8 MiB      0.0 MiB        7472                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.8 MiB      0.0 MiB       14944               if temp_g_score < g_score[neighbor]:
    71     65.8 MiB      0.0 MiB        2129                   came_from[neighbor] = current
    72     65.8 MiB      0.0 MiB        2129                   g_score[neighbor] = temp_g_score
    73     65.8 MiB      0.0 MiB        2129                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.8 MiB      0.0 MiB        2129                   if neighbor not in open_set_hash:
    75     65.8 MiB      0.0 MiB        2129                       count += 1
    76     65.8 MiB      0.0 MiB        2129                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.8 MiB      0.0 MiB        2129                       open_set_hash.add(neighbor)
    78                                                             
    79     65.8 MiB      0.0 MiB        1868           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.8 MiB      0.0 MiB        1868           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.0 MiB    103.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.0 MiB      0.0 MiB         257       for row in grid:
    30    103.0 MiB      0.0 MiB       65792           for spot in row:
    31    103.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.0 MiB      0.0 MiB           1       count = 0
    34    103.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.0 MiB      0.0 MiB           1       came_from = {}
    37    105.1 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.5 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.5 MiB -22625.7 MiB        4876       while not open_set.empty():
    47    108.5 MiB -22625.8 MiB        4876           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.5 MiB -22626.0 MiB        4876           current = open_set.get()[2]
    53    108.5 MiB -22626.1 MiB        4876           open_set_hash.remove(current)
    54                                         
    55    108.5 MiB -22629.5 MiB        4876           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.5 MiB -22629.5 MiB        4876           if current == end:
    60    101.4 MiB     -7.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.5 MiB -203621.8 MiB       43875           for neighbor in current.neighbors:
    65    108.5 MiB -180998.5 MiB       39000               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.5 MiB -90500.8 MiB       19500                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.5 MiB -90497.7 MiB       19500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.5 MiB -180999.0 MiB       39000               if temp_g_score < g_score[neighbor]:
    71    108.5 MiB -23907.6 MiB        5270                   came_from[neighbor] = current
    72    108.5 MiB -23907.6 MiB        5270                   g_score[neighbor] = temp_g_score
    73    108.5 MiB -23907.6 MiB        5270                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.5 MiB -23907.6 MiB        5270                   if neighbor not in open_set_hash:
    75    108.5 MiB -23907.6 MiB        5270                       count += 1
    76    108.5 MiB -23907.6 MiB        5270                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.5 MiB -23907.6 MiB        5270                       open_set_hash.add(neighbor)
    78                                                             
    79    108.5 MiB -22625.5 MiB        4875           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.5 MiB -22625.7 MiB        4875           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.4 MiB    101.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.4 MiB      0.0 MiB         257       for row in grid:
    30    101.4 MiB      0.0 MiB       65792           for spot in row:
    31    101.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.4 MiB      0.0 MiB           1       count = 0
    34    101.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.4 MiB      0.0 MiB           1       came_from = {}
    37    104.3 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.5 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.5 MiB      0.0 MiB         378       while not open_set.empty():
    47    105.5 MiB      0.0 MiB         378           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.5 MiB      0.0 MiB         378           current = open_set.get()[2]
    53    105.5 MiB      0.0 MiB         378           open_set_hash.remove(current)
    54                                         
    55    105.5 MiB      0.0 MiB         378           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.5 MiB      0.0 MiB         378           if current == end:
    60    105.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.5 MiB      0.0 MiB        3393           for neighbor in current.neighbors:
    65    105.5 MiB      0.0 MiB        3016               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.5 MiB      0.0 MiB        1508                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.5 MiB      0.0 MiB        1508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.5 MiB      0.0 MiB        3016               if temp_g_score < g_score[neighbor]:
    71    105.5 MiB      0.0 MiB         486                   came_from[neighbor] = current
    72    105.5 MiB      0.0 MiB         486                   g_score[neighbor] = temp_g_score
    73    105.5 MiB      0.0 MiB         486                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.5 MiB      0.0 MiB         486                   if neighbor not in open_set_hash:
    75    105.5 MiB      0.0 MiB         486                       count += 1
    76    105.5 MiB      0.0 MiB         486                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.5 MiB      0.0 MiB         486                       open_set_hash.add(neighbor)
    78                                                             
    79    105.5 MiB      0.0 MiB         377           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.5 MiB      0.0 MiB         377           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.5 MiB    105.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.5 MiB  -2204.7 MiB         257       for row in grid:
    30    105.5 MiB -563771.7 MiB       65792           for spot in row:
    31    105.5 MiB -561586.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     81.5 MiB    -24.1 MiB           1       count = 0
    34     81.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     81.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     81.5 MiB      0.0 MiB           1       came_from = {}
    37     81.5 MiB -1799338.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     44.9 MiB    -36.6 MiB           1       g_score[start] = 0
    39     51.3 MiB   -398.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     51.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     51.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     51.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     51.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     52.7 MiB -91008.4 MiB        7497       while not open_set.empty():
    47     52.7 MiB -91008.8 MiB        7497           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     52.7 MiB -91009.2 MiB        7497           current = open_set.get()[2]
    53     52.7 MiB -91009.3 MiB        7497           open_set_hash.remove(current)
    54                                         
    55     52.7 MiB -91009.7 MiB        7497           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     52.7 MiB -91009.8 MiB        7497           if current == end:
    60     37.3 MiB    -15.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     37.4 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     52.7 MiB -819034.8 MiB       67464           for neighbor in current.neighbors:
    65     52.7 MiB -728026.5 MiB       59968               if current.row != neighbor.row and current.col != neighbor.col:
    66     52.7 MiB -364024.1 MiB       29984                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     52.7 MiB -364009.3 MiB       29984                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     52.7 MiB -728037.3 MiB       59968               if temp_g_score < g_score[neighbor]:
    71     52.7 MiB -95299.0 MiB        7993                   came_from[neighbor] = current
    72     52.7 MiB -95299.1 MiB        7993                   g_score[neighbor] = temp_g_score
    73     52.7 MiB -95299.3 MiB        7993                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     52.7 MiB -95299.5 MiB        7993                   if neighbor not in open_set_hash:
    75     52.7 MiB -95299.6 MiB        7993                       count += 1
    76     52.7 MiB -95299.8 MiB        7993                       open_set.put((f_score[neighbor], count, neighbor))
    77     52.7 MiB -95299.9 MiB        7993                       open_set_hash.add(neighbor)
    78                                                             
    79     52.7 MiB -91008.1 MiB        7496           if draw is not None:
    80                                                     draw()
    81                                         
    82     52.7 MiB -91008.3 MiB        7496           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     40.3 MiB     40.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.5 MiB      0.0 MiB         257       for row in grid:
    30     58.5 MiB     -4.0 MiB       65792           for spot in row:
    31     58.5 MiB     14.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.5 MiB      0.0 MiB           1       count = 0
    34     58.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.6 MiB      0.0 MiB           1       came_from = {}
    37     61.2 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     63.3 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.5 MiB      0.0 MiB         615       while not open_set.empty():
    47     63.5 MiB      0.0 MiB         615           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.5 MiB      0.0 MiB         615           current = open_set.get()[2]
    53     63.5 MiB      0.0 MiB         615           open_set_hash.remove(current)
    54                                         
    55     63.5 MiB      0.0 MiB         615           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.5 MiB      0.0 MiB         615           if current == end:
    60     63.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.5 MiB      0.0 MiB        5526           for neighbor in current.neighbors:
    65     63.5 MiB      0.0 MiB        4912               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.5 MiB      0.0 MiB        2456                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.5 MiB      0.0 MiB        2456                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.5 MiB      0.0 MiB        4912               if temp_g_score < g_score[neighbor]:
    71     63.5 MiB      0.1 MiB         807                   came_from[neighbor] = current
    72     63.5 MiB      0.0 MiB         807                   g_score[neighbor] = temp_g_score
    73     63.5 MiB      0.0 MiB         807                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.5 MiB      0.0 MiB         807                   if neighbor not in open_set_hash:
    75     63.5 MiB      0.0 MiB         807                       count += 1
    76     63.5 MiB      0.0 MiB         807                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.5 MiB      0.0 MiB         807                       open_set_hash.add(neighbor)
    78                                                             
    79     63.5 MiB      0.0 MiB         614           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.5 MiB      0.0 MiB         614           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.5 MiB     63.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.5 MiB    -76.9 MiB         257       for row in grid:
    30     63.5 MiB -19702.8 MiB       65792           for spot in row:
    31     63.5 MiB -19626.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.9 MiB     -0.6 MiB           1       count = 0
    34     62.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.9 MiB      0.0 MiB           1       came_from = {}
    37     64.7 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.7 MiB  -3589.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.1 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.2 MiB      0.0 MiB        3132       while not open_set.empty():
    47     65.2 MiB      0.0 MiB        3132           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.2 MiB      0.0 MiB        3132           current = open_set.get()[2]
    53     65.2 MiB      0.0 MiB        3132           open_set_hash.remove(current)
    54                                         
    55     65.2 MiB      0.0 MiB        3132           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.2 MiB      0.0 MiB        3132           if current == end:
    60     65.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.2 MiB      0.0 MiB       28179           for neighbor in current.neighbors:
    65     65.2 MiB      0.0 MiB       25048               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.2 MiB      0.0 MiB       12524                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.2 MiB      0.0 MiB       12524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.2 MiB      0.0 MiB       25048               if temp_g_score < g_score[neighbor]:
    71     65.2 MiB      0.1 MiB        3648                   came_from[neighbor] = current
    72     65.2 MiB      0.0 MiB        3648                   g_score[neighbor] = temp_g_score
    73     65.2 MiB      0.0 MiB        3648                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.2 MiB      0.0 MiB        3648                   if neighbor not in open_set_hash:
    75     65.2 MiB      0.0 MiB        3648                       count += 1
    76     65.2 MiB      0.0 MiB        3648                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.2 MiB      0.0 MiB        3648                       open_set_hash.add(neighbor)
    78                                                             
    79     65.2 MiB      0.0 MiB        3131           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.2 MiB      0.0 MiB        3131           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.5 MiB     99.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.5 MiB   -463.1 MiB         257       for row in grid:
    30     99.5 MiB -118593.5 MiB       65792           for spot in row:
    31     99.5 MiB -118133.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.7 MiB     -5.9 MiB           1       count = 0
    34     93.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.7 MiB      0.0 MiB           1       came_from = {}
    37     97.8 MiB  -4837.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.2 MiB -25921.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.3 MiB  -4636.6 MiB        4800       while not open_set.empty():
    47    100.3 MiB  -4636.6 MiB        4800           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.3 MiB  -4636.7 MiB        4800           current = open_set.get()[2]
    53    100.3 MiB  -4636.7 MiB        4800           open_set_hash.remove(current)
    54                                         
    55    100.3 MiB  -4636.7 MiB        4800           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.3 MiB  -4636.8 MiB        4800           if current == end:
    60     98.8 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.3 MiB -41722.2 MiB       43191           for neighbor in current.neighbors:
    65    100.3 MiB -37086.0 MiB       38392               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.3 MiB -18544.4 MiB       19196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.3 MiB -18541.8 MiB       19196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.3 MiB -37086.5 MiB       38392               if temp_g_score < g_score[neighbor]:
    71    100.3 MiB  -4913.4 MiB        5190                   came_from[neighbor] = current
    72    100.3 MiB  -4913.4 MiB        5190                   g_score[neighbor] = temp_g_score
    73    100.3 MiB  -4913.4 MiB        5190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.3 MiB  -4913.4 MiB        5190                   if neighbor not in open_set_hash:
    75    100.3 MiB  -4913.4 MiB        5190                       count += 1
    76    100.3 MiB  -4913.4 MiB        5190                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.3 MiB  -4913.4 MiB        5190                       open_set_hash.add(neighbor)
    78                                                             
    79    100.3 MiB  -4636.6 MiB        4799           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.3 MiB  -4636.6 MiB        4799           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.8 MiB     98.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.8 MiB   -139.0 MiB         257       for row in grid:
    30     98.8 MiB -35502.9 MiB       65792           for spot in row:
    31     98.8 MiB -35364.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.3 MiB     -1.5 MiB           1       count = 0
    34     97.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.3 MiB      0.0 MiB           1       came_from = {}
    37    100.2 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.5 MiB -109128.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.4 MiB     -2.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.4 MiB  -3070.2 MiB        2438       while not open_set.empty():
    47     99.4 MiB  -3070.2 MiB        2438           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.4 MiB  -3070.2 MiB        2438           current = open_set.get()[2]
    53     99.4 MiB  -3070.2 MiB        2438           open_set_hash.remove(current)
    54                                         
    55     99.4 MiB  -3070.4 MiB        2438           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.4 MiB  -3070.6 MiB        2438           if current == end:
    60     93.5 MiB     -5.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.4 MiB -27601.0 MiB       21933           for neighbor in current.neighbors:
    65     99.4 MiB -24531.3 MiB       19496               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.4 MiB -12269.6 MiB        9748                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.4 MiB -12264.0 MiB        9748                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.4 MiB -24534.3 MiB       19496               if temp_g_score < g_score[neighbor]:
    71     99.4 MiB  -3430.1 MiB        2740                   came_from[neighbor] = current
    72     99.4 MiB  -3430.2 MiB        2740                   g_score[neighbor] = temp_g_score
    73     99.4 MiB  -3430.3 MiB        2740                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.4 MiB  -3430.3 MiB        2740                   if neighbor not in open_set_hash:
    75     99.4 MiB  -3430.3 MiB        2740                       count += 1
    76     99.4 MiB  -3430.6 MiB        2740                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.4 MiB  -3430.8 MiB        2740                       open_set_hash.add(neighbor)
    78                                                             
    79     99.4 MiB  -3070.2 MiB        2437           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.4 MiB  -3070.2 MiB        2437           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.5 MiB     93.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.5 MiB   -218.0 MiB         257       for row in grid:
    30     93.5 MiB -55913.5 MiB       65792           for spot in row:
    31     93.5 MiB -55697.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.2 MiB     -3.4 MiB           1       count = 0
    34     90.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     90.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     90.2 MiB      0.0 MiB           1       came_from = {}
    37     93.0 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.5 MiB  -1228.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.5 MiB   -904.0 MiB        2059       while not open_set.empty():
    47     96.5 MiB   -904.0 MiB        2059           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.5 MiB   -904.0 MiB        2059           current = open_set.get()[2]
    53     96.5 MiB   -904.1 MiB        2059           open_set_hash.remove(current)
    54                                         
    55     96.5 MiB   -904.1 MiB        2059           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.5 MiB   -904.1 MiB        2059           if current == end:
    60     93.8 MiB     -2.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.5 MiB  -8119.8 MiB       18522           for neighbor in current.neighbors:
    65     96.5 MiB  -7216.4 MiB       16464               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.5 MiB  -3610.5 MiB        8232                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.5 MiB  -3606.3 MiB        8232                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.5 MiB  -7217.3 MiB       16464               if temp_g_score < g_score[neighbor]:
    71     96.5 MiB  -1031.6 MiB        2399                   came_from[neighbor] = current
    72     96.5 MiB  -1031.6 MiB        2399                   g_score[neighbor] = temp_g_score
    73     96.5 MiB  -1031.7 MiB        2399                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.5 MiB  -1031.8 MiB        2399                   if neighbor not in open_set_hash:
    75     96.5 MiB  -1031.8 MiB        2399                       count += 1
    76     96.5 MiB  -1031.9 MiB        2399                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.5 MiB  -1031.9 MiB        2399                       open_set_hash.add(neighbor)
    78                                                             
    79     96.5 MiB   -903.9 MiB        2058           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.5 MiB   -903.9 MiB        2058           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.8 MiB     93.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.8 MiB   -337.7 MiB         257       for row in grid:
    30     93.8 MiB -86419.5 MiB       65792           for spot in row:
    31     93.8 MiB -86082.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.8 MiB     -2.1 MiB           1       count = 0
    34     91.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.8 MiB      0.0 MiB           1       came_from = {}
    37     91.8 MiB -234548.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.6 MiB     -3.2 MiB           1       g_score[start] = 0
    39     88.6 MiB  -1224.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     88.5 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     88.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     88.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     88.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     88.7 MiB      0.0 MiB        3074       while not open_set.empty():
    47     88.7 MiB      0.0 MiB        3074           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     88.7 MiB      0.0 MiB        3074           current = open_set.get()[2]
    53     88.7 MiB      0.0 MiB        3074           open_set_hash.remove(current)
    54                                         
    55     88.7 MiB      0.0 MiB        3074           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     88.7 MiB      0.0 MiB        3074           if current == end:
    60     88.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     88.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     88.7 MiB      0.0 MiB       27657           for neighbor in current.neighbors:
    65     88.7 MiB      0.0 MiB       24584               if current.row != neighbor.row and current.col != neighbor.col:
    66     88.7 MiB      0.0 MiB       12292                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     88.7 MiB      0.0 MiB       12292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     88.7 MiB      0.0 MiB       24584               if temp_g_score < g_score[neighbor]:
    71     88.7 MiB      0.1 MiB        3410                   came_from[neighbor] = current
    72     88.7 MiB      0.0 MiB        3410                   g_score[neighbor] = temp_g_score
    73     88.7 MiB      0.0 MiB        3410                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     88.7 MiB      0.0 MiB        3410                   if neighbor not in open_set_hash:
    75     88.7 MiB      0.0 MiB        3410                       count += 1
    76     88.7 MiB      0.0 MiB        3410                       open_set.put((f_score[neighbor], count, neighbor))
    77     88.7 MiB      0.0 MiB        3410                       open_set_hash.add(neighbor)
    78                                                             
    79     88.7 MiB      0.0 MiB        3073           if draw is not None:
    80                                                     draw()
    81                                         
    82     88.7 MiB      0.0 MiB        3073           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.7 MiB     88.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.7 MiB    -92.0 MiB         257       for row in grid:
    30     88.7 MiB -23567.4 MiB       65792           for spot in row:
    31     88.7 MiB -23475.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.2 MiB     -0.5 MiB           1       count = 0
    34     88.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.2 MiB      0.0 MiB           1       came_from = {}
    37     88.8 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     92.7 MiB   -312.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     92.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     92.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     92.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     92.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     92.8 MiB -100709.5 MiB        6348       while not open_set.empty():
    47     92.8 MiB -100709.8 MiB        6348           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     92.8 MiB -100710.2 MiB        6348           current = open_set.get()[2]
    53     92.8 MiB -100710.4 MiB        6348           open_set_hash.remove(current)
    54                                         
    55     92.8 MiB -100710.6 MiB        6348           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     92.8 MiB -100710.7 MiB        6348           if current == end:
    60     68.0 MiB    -24.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     92.8 MiB -906228.6 MiB       57123           for neighbor in current.neighbors:
    65     92.8 MiB -805522.7 MiB       50776               if current.row != neighbor.row and current.col != neighbor.col:
    66     92.8 MiB -402774.6 MiB       25388                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     92.8 MiB -402750.1 MiB       25388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     92.8 MiB -805526.9 MiB       50776               if temp_g_score < g_score[neighbor]:
    71     92.8 MiB -106609.6 MiB        6852                   came_from[neighbor] = current
    72     92.8 MiB -106610.5 MiB        6852                   g_score[neighbor] = temp_g_score
    73     92.8 MiB -106612.4 MiB        6852                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     92.8 MiB -106613.7 MiB        6852                   if neighbor not in open_set_hash:
    75     92.8 MiB -106615.6 MiB        6852                       count += 1
    76     92.8 MiB -106616.9 MiB        6852                       open_set.put((f_score[neighbor], count, neighbor))
    77     92.8 MiB -106617.3 MiB        6852                       open_set_hash.add(neighbor)
    78                                                             
    79     92.8 MiB -100708.6 MiB        6347           if draw is not None:
    80                                                     draw()
    81                                         
    82     92.8 MiB -100709.0 MiB        6347           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.2 MiB    100.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.2 MiB   -348.5 MiB         257       for row in grid:
    30    100.2 MiB -89418.8 MiB       65792           for spot in row:
    31    100.2 MiB -89071.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.0 MiB     -2.3 MiB           1       count = 0
    34     98.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.0 MiB      0.0 MiB           1       came_from = {}
    37     98.2 MiB -30700.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.6 MiB     -0.6 MiB           1       g_score[start] = 0
    39     99.6 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.7 MiB      0.0 MiB        1836       while not open_set.empty():
    47     99.7 MiB      0.0 MiB        1836           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.7 MiB      0.0 MiB        1836           current = open_set.get()[2]
    53     99.7 MiB      0.0 MiB        1836           open_set_hash.remove(current)
    54                                         
    55     99.7 MiB      0.0 MiB        1836           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.7 MiB      0.0 MiB        1836           if current == end:
    60     99.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.7 MiB      0.0 MiB       16515           for neighbor in current.neighbors:
    65     99.7 MiB      0.0 MiB       14680               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.7 MiB      0.0 MiB        7340                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.7 MiB      0.0 MiB        7340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.7 MiB      0.0 MiB       14680               if temp_g_score < g_score[neighbor]:
    71     99.7 MiB      0.1 MiB        2188                   came_from[neighbor] = current
    72     99.7 MiB      0.0 MiB        2188                   g_score[neighbor] = temp_g_score
    73     99.7 MiB      0.0 MiB        2188                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.7 MiB      0.0 MiB        2188                   if neighbor not in open_set_hash:
    75     99.7 MiB      0.0 MiB        2188                       count += 1
    76     99.7 MiB      0.0 MiB        2188                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.7 MiB      0.0 MiB        2188                       open_set_hash.add(neighbor)
    78                                                             
    79     99.7 MiB      0.0 MiB        1835           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.7 MiB      0.0 MiB        1835           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.7 MiB     99.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.7 MiB   -835.6 MiB         257       for row in grid:
    30     99.7 MiB -214521.0 MiB       65792           for spot in row:
    31     99.7 MiB -213688.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.8 MiB     -4.0 MiB           1       count = 0
    34     95.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.8 MiB      0.0 MiB           1       came_from = {}
    37     98.2 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.3 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.3 MiB   -560.2 MiB        4224       while not open_set.empty():
    47    101.3 MiB   -560.2 MiB        4224           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.3 MiB   -560.2 MiB        4224           current = open_set.get()[2]
    53    101.3 MiB   -560.2 MiB        4224           open_set_hash.remove(current)
    54                                         
    55    101.3 MiB   -560.2 MiB        4224           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.3 MiB   -560.2 MiB        4224           if current == end:
    60    101.2 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.3 MiB  -5041.0 MiB       38007           for neighbor in current.neighbors:
    65    101.3 MiB  -4480.8 MiB       33784               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.3 MiB  -2240.7 MiB       16892                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.3 MiB  -2240.2 MiB       16892                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.3 MiB  -4480.9 MiB       33784               if temp_g_score < g_score[neighbor]:
    71    101.3 MiB   -602.2 MiB        4614                   came_from[neighbor] = current
    72    101.3 MiB   -602.2 MiB        4614                   g_score[neighbor] = temp_g_score
    73    101.3 MiB   -602.2 MiB        4614                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.3 MiB   -602.3 MiB        4614                   if neighbor not in open_set_hash:
    75    101.3 MiB   -602.3 MiB        4614                       count += 1
    76    101.3 MiB   -602.2 MiB        4614                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.3 MiB   -602.3 MiB        4614                       open_set_hash.add(neighbor)
    78                                                             
    79    101.3 MiB   -560.2 MiB        4223           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.3 MiB   -560.2 MiB        4223           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.2 MiB    101.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.2 MiB   -615.4 MiB         257       for row in grid:
    30    101.2 MiB -157662.3 MiB       65792           for spot in row:
    31    101.2 MiB -157048.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.0 MiB     -3.1 MiB           1       count = 0
    34     98.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.0 MiB      0.0 MiB           1       came_from = {}
    37    101.2 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.2 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.2 MiB     -2.1 MiB        8892       while not open_set.empty():
    47    102.2 MiB     -2.1 MiB        8892           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.2 MiB     -2.1 MiB        8892           current = open_set.get()[2]
    53    102.2 MiB     -2.1 MiB        8892           open_set_hash.remove(current)
    54                                         
    55    102.2 MiB     -2.1 MiB        8892           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.2 MiB     -2.1 MiB        8892           if current == end:
    60    102.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.2 MiB    -18.8 MiB       80019           for neighbor in current.neighbors:
    65    102.2 MiB    -16.7 MiB       71128               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.2 MiB     -8.3 MiB       35564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.2 MiB     -8.3 MiB       35564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.2 MiB    -16.7 MiB       71128               if temp_g_score < g_score[neighbor]:
    71    102.2 MiB     -2.5 MiB        9440                   came_from[neighbor] = current
    72    102.2 MiB     -2.5 MiB        9440                   g_score[neighbor] = temp_g_score
    73    102.2 MiB     -2.5 MiB        9440                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.2 MiB     -2.5 MiB        9440                   if neighbor not in open_set_hash:
    75    102.2 MiB     -2.5 MiB        9440                       count += 1
    76    102.2 MiB     -2.5 MiB        9440                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.2 MiB     -2.5 MiB        9440                       open_set_hash.add(neighbor)
    78                                                             
    79    102.2 MiB     -2.1 MiB        8891           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.2 MiB     -2.1 MiB        8891           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.2 MiB    102.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.2 MiB    -16.1 MiB         257       for row in grid:
    30    102.2 MiB  -4118.0 MiB       65792           for spot in row:
    31    102.2 MiB  -4102.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.2 MiB     -0.1 MiB           1       count = 0
    34    102.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.2 MiB      0.0 MiB           1       came_from = {}
    37    102.2 MiB -126827.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.4 MiB     -3.8 MiB           1       g_score[start] = 0
    39     99.6 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.6 MiB   -231.3 MiB        1010       while not open_set.empty():
    47     99.6 MiB   -231.3 MiB        1010           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.6 MiB   -231.3 MiB        1010           current = open_set.get()[2]
    53     99.6 MiB   -231.3 MiB        1010           open_set_hash.remove(current)
    54                                         
    55     99.6 MiB   -231.3 MiB        1010           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.6 MiB   -231.3 MiB        1010           if current == end:
    60     99.3 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.6 MiB  -2080.7 MiB        9081           for neighbor in current.neighbors:
    65     99.6 MiB  -1849.7 MiB        8072               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.6 MiB   -925.1 MiB        4036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.6 MiB   -924.6 MiB        4036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.6 MiB  -1849.7 MiB        8072               if temp_g_score < g_score[neighbor]:
    71     99.6 MiB   -279.1 MiB        1250                   came_from[neighbor] = current
    72     99.6 MiB   -279.1 MiB        1250                   g_score[neighbor] = temp_g_score
    73     99.6 MiB   -279.1 MiB        1250                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.6 MiB   -279.1 MiB        1250                   if neighbor not in open_set_hash:
    75     99.6 MiB   -279.1 MiB        1250                       count += 1
    76     99.6 MiB   -279.1 MiB        1250                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.6 MiB   -279.1 MiB        1250                       open_set_hash.add(neighbor)
    78                                                             
    79     99.6 MiB   -231.3 MiB        1009           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.6 MiB   -231.3 MiB        1009           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.3 MiB     99.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.3 MiB   -512.1 MiB         257       for row in grid:
    30     99.3 MiB -131208.5 MiB       65792           for spot in row:
    31     99.3 MiB -130697.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.3 MiB     -4.0 MiB           1       count = 0
    34     95.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.4 MiB      0.0 MiB           1       came_from = {}
    37     95.7 MiB -446756.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     84.8 MiB    -10.9 MiB           1       g_score[start] = 0
    39     85.2 MiB -937245.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     59.3 MiB    -25.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     59.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     59.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     59.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.4 MiB  -2315.0 MiB        1952       while not open_set.empty():
    47     59.4 MiB  -2315.0 MiB        1952           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.4 MiB  -2315.1 MiB        1952           current = open_set.get()[2]
    53     59.4 MiB  -2315.2 MiB        1952           open_set_hash.remove(current)
    54                                         
    55     59.4 MiB  -2315.2 MiB        1952           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.4 MiB  -2315.3 MiB        1952           if current == end:
    60     57.3 MiB     -2.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.4 MiB -20824.7 MiB       17559           for neighbor in current.neighbors:
    65     59.4 MiB -18510.3 MiB       15608               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.4 MiB  -9256.8 MiB        7804                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.4 MiB  -9254.1 MiB        7804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.4 MiB -18511.3 MiB       15608               if temp_g_score < g_score[neighbor]:
    71     59.4 MiB  -2634.1 MiB        2258                   came_from[neighbor] = current
    72     59.4 MiB  -2634.1 MiB        2258                   g_score[neighbor] = temp_g_score
    73     59.4 MiB  -2634.1 MiB        2258                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.4 MiB  -2634.1 MiB        2258                   if neighbor not in open_set_hash:
    75     59.4 MiB  -2634.1 MiB        2258                       count += 1
    76     59.4 MiB  -2634.1 MiB        2258                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.4 MiB  -2634.1 MiB        2258                       open_set_hash.add(neighbor)
    78                                                             
    79     59.4 MiB  -2315.0 MiB        1951           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.4 MiB  -2315.0 MiB        1951           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.2 MiB     96.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.2 MiB   -642.2 MiB         257       for row in grid:
    30     96.2 MiB -164523.5 MiB       65792           for spot in row:
    31     96.2 MiB -163882.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.5 MiB     -3.8 MiB           1       count = 0
    34     92.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.5 MiB      0.0 MiB           1       came_from = {}
    37     95.6 MiB  -9548.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.5 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.6 MiB      0.0 MiB        3234       while not open_set.empty():
    47     99.6 MiB      0.0 MiB        3234           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.6 MiB      0.0 MiB        3234           current = open_set.get()[2]
    53     99.6 MiB      0.0 MiB        3234           open_set_hash.remove(current)
    54                                         
    55     99.6 MiB      0.0 MiB        3234           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.6 MiB      0.0 MiB        3234           if current == end:
    60     99.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.6 MiB      0.0 MiB       28953           for neighbor in current.neighbors:
    65     99.6 MiB      0.0 MiB       25720               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.6 MiB      0.0 MiB       12836                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.6 MiB      0.0 MiB       12884                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.6 MiB      0.0 MiB       25720               if temp_g_score < g_score[neighbor]:
    71     99.6 MiB      0.0 MiB        3544                   came_from[neighbor] = current
    72     99.6 MiB      0.0 MiB        3544                   g_score[neighbor] = temp_g_score
    73     99.6 MiB      0.0 MiB        3544                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.6 MiB      0.0 MiB        3544                   if neighbor not in open_set_hash:
    75     99.6 MiB      0.0 MiB        3544                       count += 1
    76     99.6 MiB      0.0 MiB        3544                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.6 MiB      0.0 MiB        3544                       open_set_hash.add(neighbor)
    78                                                             
    79     99.6 MiB      0.0 MiB        3233           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.6 MiB      0.0 MiB        3233           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.6 MiB     99.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.6 MiB      0.0 MiB         257       for row in grid:
    30     99.6 MiB      0.0 MiB       65792           for spot in row:
    31     99.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.6 MiB      0.0 MiB           1       count = 0
    34     99.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.6 MiB      0.0 MiB           1       came_from = {}
    37    100.7 MiB -38315.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.6 MiB     -1.1 MiB           1       g_score[start] = 0
    39    103.3 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.3 MiB     -3.6 MiB         288       while not open_set.empty():
    47    103.3 MiB     -3.6 MiB         288           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.3 MiB     -3.6 MiB         288           current = open_set.get()[2]
    53    103.3 MiB     -3.6 MiB         288           open_set_hash.remove(current)
    54                                         
    55    103.3 MiB     -3.6 MiB         288           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.3 MiB     -3.6 MiB         288           if current == end:
    60    103.3 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.3 MiB    -32.3 MiB        2583           for neighbor in current.neighbors:
    65    103.3 MiB    -28.7 MiB        2296               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.3 MiB    -14.4 MiB        1148                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.3 MiB    -14.3 MiB        1148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.3 MiB    -28.7 MiB        2296               if temp_g_score < g_score[neighbor]:
    71    103.3 MiB     -4.6 MiB         390                   came_from[neighbor] = current
    72    103.3 MiB     -4.6 MiB         390                   g_score[neighbor] = temp_g_score
    73    103.3 MiB     -4.6 MiB         390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.3 MiB     -4.6 MiB         390                   if neighbor not in open_set_hash:
    75    103.3 MiB     -4.6 MiB         390                       count += 1
    76    103.3 MiB     -4.6 MiB         390                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.3 MiB     -4.6 MiB         390                       open_set_hash.add(neighbor)
    78                                                             
    79    103.3 MiB     -3.6 MiB         287           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.3 MiB     -3.6 MiB         287           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.3 MiB    103.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.3 MiB      0.0 MiB         257       for row in grid:
    30    103.3 MiB      0.0 MiB       65792           for spot in row:
    31    103.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.3 MiB      0.0 MiB           1       count = 0
    34    103.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.3 MiB      0.0 MiB           1       came_from = {}
    37    106.9 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.8 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.8 MiB  -3047.1 MiB        5781       while not open_set.empty():
    47    109.8 MiB  -3047.1 MiB        5781           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.8 MiB  -3047.1 MiB        5781           current = open_set.get()[2]
    53    109.8 MiB  -3047.1 MiB        5781           open_set_hash.remove(current)
    54                                         
    55    109.8 MiB  -3047.1 MiB        5781           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.8 MiB  -3047.1 MiB        5781           if current == end:
    60    107.4 MiB     -2.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.8 MiB -27411.1 MiB       52020           for neighbor in current.neighbors:
    65    109.8 MiB -24364.3 MiB       46240               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.8 MiB -12185.9 MiB       23120                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.8 MiB -12179.0 MiB       23120                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.8 MiB -24365.7 MiB       46240               if temp_g_score < g_score[neighbor]:
    71    109.8 MiB  -3279.9 MiB        6213                   came_from[neighbor] = current
    72    109.8 MiB  -3279.9 MiB        6213                   g_score[neighbor] = temp_g_score
    73    109.8 MiB  -3279.9 MiB        6213                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.8 MiB  -3279.9 MiB        6213                   if neighbor not in open_set_hash:
    75    109.8 MiB  -3279.9 MiB        6213                       count += 1
    76    109.8 MiB  -3279.9 MiB        6213                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.8 MiB  -3279.9 MiB        6213                       open_set_hash.add(neighbor)
    78                                                             
    79    109.8 MiB  -3047.1 MiB        5780           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.8 MiB  -3047.1 MiB        5780           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.4 MiB    107.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.4 MiB    -55.5 MiB         257       for row in grid:
    30    107.4 MiB -13978.2 MiB       65792           for spot in row:
    31    107.4 MiB -13924.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.2 MiB     -2.2 MiB           1       count = 0
    34    105.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.2 MiB      0.0 MiB           1       came_from = {}
    37    105.8 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.2 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.2 MiB      0.0 MiB         531       while not open_set.empty():
    47    108.2 MiB      0.0 MiB         531           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.2 MiB      0.0 MiB         531           current = open_set.get()[2]
    53    108.2 MiB      0.0 MiB         531           open_set_hash.remove(current)
    54                                         
    55    108.2 MiB      0.0 MiB         531           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.2 MiB      0.0 MiB         531           if current == end:
    60    108.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.2 MiB      0.0 MiB        4770           for neighbor in current.neighbors:
    65    108.2 MiB      0.0 MiB        4240               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.2 MiB      0.0 MiB        2120                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.2 MiB      0.0 MiB        2120                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.2 MiB      0.0 MiB        4240               if temp_g_score < g_score[neighbor]:
    71    108.2 MiB      0.0 MiB         783                   came_from[neighbor] = current
    72    108.2 MiB      0.0 MiB         783                   g_score[neighbor] = temp_g_score
    73    108.2 MiB      0.0 MiB         783                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.2 MiB      0.0 MiB         783                   if neighbor not in open_set_hash:
    75    108.2 MiB      0.0 MiB         783                       count += 1
    76    108.2 MiB      0.0 MiB         783                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.2 MiB      0.0 MiB         783                       open_set_hash.add(neighbor)
    78                                                             
    79    108.2 MiB      0.0 MiB         530           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.2 MiB      0.0 MiB         530           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.2 MiB    108.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.2 MiB     -3.6 MiB         257       for row in grid:
    30    108.2 MiB   -922.9 MiB       65792           for spot in row:
    31    108.2 MiB   -919.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.2 MiB     -0.0 MiB           1       count = 0
    34    108.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.2 MiB      0.0 MiB           1       came_from = {}
    37    110.5 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.0 MiB   -495.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.0 MiB      0.0 MiB         366       while not open_set.empty():
    47    113.0 MiB      0.0 MiB         366           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.0 MiB      0.0 MiB         366           current = open_set.get()[2]
    53    113.0 MiB      0.0 MiB         366           open_set_hash.remove(current)
    54                                         
    55    113.0 MiB      0.0 MiB         366           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.0 MiB      0.0 MiB         366           if current == end:
    60    113.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.0 MiB      0.0 MiB        3285           for neighbor in current.neighbors:
    65    113.0 MiB      0.0 MiB        2920               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.0 MiB      0.0 MiB        1460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.0 MiB      0.0 MiB        1460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.0 MiB      0.0 MiB        2920               if temp_g_score < g_score[neighbor]:
    71    113.0 MiB      0.0 MiB         620                   came_from[neighbor] = current
    72    113.0 MiB      0.0 MiB         620                   g_score[neighbor] = temp_g_score
    73    113.0 MiB      0.0 MiB         620                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.0 MiB      0.0 MiB         620                   if neighbor not in open_set_hash:
    75    113.0 MiB      0.0 MiB         620                       count += 1
    76    113.0 MiB      0.0 MiB         620                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.0 MiB      0.0 MiB         620                       open_set_hash.add(neighbor)
    78                                                             
    79    113.0 MiB      0.0 MiB         365           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.0 MiB      0.0 MiB         365           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.4 MiB    113.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.4 MiB      0.0 MiB         257       for row in grid:
    30    113.4 MiB      0.0 MiB       65792           for spot in row:
    31    113.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.4 MiB      0.0 MiB           1       count = 0
    34    113.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.4 MiB      0.0 MiB           1       came_from = {}
    37    113.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.5 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.5 MiB    -20.1 MiB        2849       while not open_set.empty():
    47    113.5 MiB    -20.1 MiB        2849           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.5 MiB    -20.1 MiB        2849           current = open_set.get()[2]
    53    113.5 MiB    -20.1 MiB        2849           open_set_hash.remove(current)
    54                                         
    55    113.5 MiB    -20.1 MiB        2849           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.5 MiB    -20.1 MiB        2849           if current == end:
    60    113.5 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.5 MiB   -180.5 MiB       25632           for neighbor in current.neighbors:
    65    113.5 MiB   -160.4 MiB       22784               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.5 MiB    -80.2 MiB       11392                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.5 MiB    -80.2 MiB       11392                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.5 MiB   -160.4 MiB       22784               if temp_g_score < g_score[neighbor]:
    71    113.5 MiB    -21.7 MiB        3149                   came_from[neighbor] = current
    72    113.5 MiB    -21.7 MiB        3149                   g_score[neighbor] = temp_g_score
    73    113.5 MiB    -21.7 MiB        3149                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.5 MiB    -21.7 MiB        3149                   if neighbor not in open_set_hash:
    75    113.5 MiB    -21.7 MiB        3149                       count += 1
    76    113.5 MiB    -21.7 MiB        3149                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.5 MiB    -21.7 MiB        3149                       open_set_hash.add(neighbor)
    78                                                             
    79    113.5 MiB    -20.1 MiB        2848           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.5 MiB    -20.1 MiB        2848           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.5 MiB    113.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.5 MiB   -441.9 MiB         257       for row in grid:
    30    113.5 MiB -113349.3 MiB       65792           for spot in row:
    31    113.5 MiB -112909.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.3 MiB     -3.2 MiB           1       count = 0
    34    110.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.3 MiB      0.0 MiB           1       came_from = {}
    37    111.5 MiB -187147.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.9 MiB     -9.6 MiB           1       g_score[start] = 0
    39    103.3 MiB -846095.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.5 MiB    -35.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.5 MiB   -465.7 MiB         781       while not open_set.empty():
    47     67.5 MiB   -465.7 MiB         781           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.5 MiB   -465.7 MiB         781           current = open_set.get()[2]
    53     67.5 MiB   -465.7 MiB         781           open_set_hash.remove(current)
    54                                         
    55     67.5 MiB   -465.7 MiB         781           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.5 MiB   -465.7 MiB         781           if current == end:
    60     66.8 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.5 MiB  -4187.6 MiB        7020           for neighbor in current.neighbors:
    65     67.5 MiB  -3721.9 MiB        6240               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.5 MiB  -1861.9 MiB        3120                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.5 MiB  -1860.2 MiB        3120                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.5 MiB  -3722.2 MiB        6240               if temp_g_score < g_score[neighbor]:
    71     67.5 MiB   -633.4 MiB        1085                   came_from[neighbor] = current
    72     67.5 MiB   -633.5 MiB        1085                   g_score[neighbor] = temp_g_score
    73     67.5 MiB   -633.7 MiB        1085                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.5 MiB   -633.9 MiB        1085                   if neighbor not in open_set_hash:
    75     67.5 MiB   -633.9 MiB        1085                       count += 1
    76     67.5 MiB   -633.8 MiB        1085                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.5 MiB   -633.8 MiB        1085                       open_set_hash.add(neighbor)
    78                                                             
    79     67.5 MiB   -465.7 MiB         780           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.5 MiB   -465.7 MiB         780           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     66.8 MiB     66.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.5 MiB   -657.5 MiB         257       for row in grid:
    30     67.5 MiB -168627.4 MiB       65792           for spot in row:
    31     67.5 MiB -167970.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.8 MiB     -2.7 MiB           1       count = 0
    34     64.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     64.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     64.8 MiB      0.0 MiB           1       came_from = {}
    37     67.1 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.9 MiB  -7805.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.5 MiB     -0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.6 MiB      0.0 MiB         748       while not open_set.empty():
    47     68.6 MiB      0.0 MiB         748           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.6 MiB      0.0 MiB         748           current = open_set.get()[2]
    53     68.6 MiB      0.0 MiB         748           open_set_hash.remove(current)
    54                                         
    55     68.6 MiB      0.0 MiB         748           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.6 MiB      0.0 MiB         748           if current == end:
    60     68.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.6 MiB      0.0 MiB        6723           for neighbor in current.neighbors:
    65     68.6 MiB      0.0 MiB        5976               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.6 MiB      0.0 MiB        2988                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.6 MiB      0.0 MiB        2988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.6 MiB      0.0 MiB        5976               if temp_g_score < g_score[neighbor]:
    71     68.6 MiB      0.1 MiB        1040                   came_from[neighbor] = current
    72     68.6 MiB      0.0 MiB        1040                   g_score[neighbor] = temp_g_score
    73     68.6 MiB      0.0 MiB        1040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.6 MiB      0.0 MiB        1040                   if neighbor not in open_set_hash:
    75     68.6 MiB      0.0 MiB        1040                       count += 1
    76     68.6 MiB      0.0 MiB        1040                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.6 MiB      0.0 MiB        1040                       open_set_hash.add(neighbor)
    78                                                             
    79     68.6 MiB      0.0 MiB         747           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.6 MiB      0.0 MiB         747           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     68.6 MiB     68.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.6 MiB  -6305.0 MiB         257       for row in grid:
    30     68.6 MiB -1614364.2 MiB       65792           for spot in row:
    31     68.6 MiB -1608077.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     33.9 MiB    -34.7 MiB           1       count = 0
    34     34.2 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     34.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     34.5 MiB      0.0 MiB           1       came_from = {}
    37     42.5 MiB  -3174.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     42.3 MiB     -0.2 MiB           1       g_score[start] = 0
    39     49.1 MiB  -1761.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     49.2 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     49.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     49.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     49.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     49.8 MiB  -3432.7 MiB        3304       while not open_set.empty():
    47     49.8 MiB  -3432.8 MiB        3304           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     49.8 MiB  -3432.8 MiB        3304           current = open_set.get()[2]
    53     49.8 MiB  -3432.8 MiB        3304           open_set_hash.remove(current)
    54                                         
    55     49.8 MiB  -3432.9 MiB        3304           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     49.8 MiB  -3433.0 MiB        3304           if current == end:
    60     47.5 MiB     -2.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     49.8 MiB -30880.2 MiB       29727           for neighbor in current.neighbors:
    65     49.8 MiB -27448.0 MiB       26424               if current.row != neighbor.row and current.col != neighbor.col:
    66     49.8 MiB -13725.4 MiB       13212                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     49.8 MiB -13723.1 MiB       13212                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     49.8 MiB -27448.9 MiB       26424               if temp_g_score < g_score[neighbor]:
    71     49.8 MiB  -3678.0 MiB        3650                   came_from[neighbor] = current
    72     49.8 MiB  -3678.2 MiB        3650                   g_score[neighbor] = temp_g_score
    73     49.8 MiB  -3678.2 MiB        3650                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     49.8 MiB  -3678.2 MiB        3650                   if neighbor not in open_set_hash:
    75     49.8 MiB  -3678.3 MiB        3650                       count += 1
    76     49.8 MiB  -3678.5 MiB        3650                       open_set.put((f_score[neighbor], count, neighbor))
    77     49.8 MiB  -3678.7 MiB        3650                       open_set_hash.add(neighbor)
    78                                                             
    79     49.8 MiB  -3432.7 MiB        3303           if draw is not None:
    80                                                     draw()
    81                                         
    82     49.8 MiB  -3432.8 MiB        3303           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     50.2 MiB     50.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.6 MiB     -0.0 MiB         257       for row in grid:
    30     58.6 MiB     -1.1 MiB       65792           for spot in row:
    31     58.6 MiB      7.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.6 MiB      0.0 MiB           1       count = 0
    34     58.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.6 MiB      0.0 MiB           1       came_from = {}
    37     63.5 MiB      4.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.2 MiB      4.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.2 MiB      0.0 MiB         891       while not open_set.empty():
    47     68.2 MiB      0.0 MiB         891           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.2 MiB      0.0 MiB         891           current = open_set.get()[2]
    53     68.2 MiB      0.0 MiB         891           open_set_hash.remove(current)
    54                                         
    55     68.2 MiB      0.0 MiB         891           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.2 MiB      0.0 MiB         891           if current == end:
    60     68.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.2 MiB      0.0 MiB        8010           for neighbor in current.neighbors:
    65     68.2 MiB      0.0 MiB        7120               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.2 MiB      0.0 MiB        3560                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.2 MiB      0.0 MiB        3560                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.2 MiB      0.0 MiB        7120               if temp_g_score < g_score[neighbor]:
    71     68.2 MiB      0.0 MiB        1095                   came_from[neighbor] = current
    72     68.2 MiB      0.0 MiB        1095                   g_score[neighbor] = temp_g_score
    73     68.2 MiB      0.0 MiB        1095                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.2 MiB      0.0 MiB        1095                   if neighbor not in open_set_hash:
    75     68.2 MiB      0.0 MiB        1095                       count += 1
    76     68.2 MiB      0.0 MiB        1095                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.2 MiB      0.0 MiB        1095                       open_set_hash.add(neighbor)
    78                                                             
    79     68.2 MiB      0.0 MiB         890           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.2 MiB      0.0 MiB         890           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.4 MiB    103.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.4 MiB      0.0 MiB         257       for row in grid:
    30    103.4 MiB      0.0 MiB       65792           for spot in row:
    31    103.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.4 MiB      0.0 MiB           1       count = 0
    34    103.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.4 MiB      0.0 MiB           1       came_from = {}
    37    106.1 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.2 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.3 MiB      0.0 MiB         988       while not open_set.empty():
    47    109.3 MiB      0.0 MiB         988           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.3 MiB      0.0 MiB         988           current = open_set.get()[2]
    53    109.3 MiB      0.0 MiB         988           open_set_hash.remove(current)
    54                                         
    55    109.3 MiB      0.0 MiB         988           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.3 MiB      0.0 MiB         988           if current == end:
    60    109.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.3 MiB      0.0 MiB        8883           for neighbor in current.neighbors:
    65    109.3 MiB      0.0 MiB        7896               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.3 MiB      0.0 MiB        3948                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.3 MiB      0.0 MiB        3948                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.3 MiB      0.0 MiB        7896               if temp_g_score < g_score[neighbor]:
    71    109.3 MiB      0.0 MiB        1316                   came_from[neighbor] = current
    72    109.3 MiB      0.0 MiB        1316                   g_score[neighbor] = temp_g_score
    73    109.3 MiB      0.0 MiB        1316                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.3 MiB      0.0 MiB        1316                   if neighbor not in open_set_hash:
    75    109.3 MiB      0.0 MiB        1316                       count += 1
    76    109.3 MiB      0.0 MiB        1316                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.3 MiB      0.0 MiB        1316                       open_set_hash.add(neighbor)
    78                                                             
    79    109.3 MiB      0.0 MiB         987           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.3 MiB      0.0 MiB         987           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.3 MiB    109.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.3 MiB      0.0 MiB         257       for row in grid:
    30    109.3 MiB      0.0 MiB       65792           for spot in row:
    31    109.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.3 MiB      0.0 MiB           1       count = 0
    34    109.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.3 MiB      0.0 MiB           1       came_from = {}
    37    109.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.8 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.3 MiB      0.0 MiB        7250       while not open_set.empty():
    47    112.3 MiB      0.0 MiB        7250           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.3 MiB      0.0 MiB        7250           current = open_set.get()[2]
    53    112.3 MiB      0.0 MiB        7250           open_set_hash.remove(current)
    54                                         
    55    112.3 MiB      0.0 MiB        7250           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.3 MiB      0.0 MiB        7250           if current == end:
    60    112.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.3 MiB      0.0 MiB       65241           for neighbor in current.neighbors:
    65    112.3 MiB      0.0 MiB       57992               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.3 MiB      0.0 MiB       28996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.3 MiB      0.0 MiB       28996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.3 MiB      0.0 MiB       57992               if temp_g_score < g_score[neighbor]:
    71    112.3 MiB      0.5 MiB        7730                   came_from[neighbor] = current
    72    112.3 MiB      0.0 MiB        7730                   g_score[neighbor] = temp_g_score
    73    112.3 MiB      0.0 MiB        7730                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.3 MiB      0.0 MiB        7730                   if neighbor not in open_set_hash:
    75    112.3 MiB      0.0 MiB        7730                       count += 1
    76    112.3 MiB      0.0 MiB        7730                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.3 MiB      0.0 MiB        7730                       open_set_hash.add(neighbor)
    78                                                             
    79    112.3 MiB      0.0 MiB        7249           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.3 MiB      0.0 MiB        7249           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.3 MiB    112.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.3 MiB      0.0 MiB         257       for row in grid:
    30    112.3 MiB      0.0 MiB       65792           for spot in row:
    31    112.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.3 MiB      0.0 MiB           1       count = 0
    34    112.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.3 MiB      0.0 MiB           1       came_from = {}
    37    112.4 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.1 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.2 MiB -51991.8 MiB       11176       while not open_set.empty():
    47    114.2 MiB -51991.8 MiB       11176           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.2 MiB -51991.8 MiB       11176           current = open_set.get()[2]
    53    114.2 MiB -51991.8 MiB       11176           open_set_hash.remove(current)
    54                                         
    55    114.2 MiB -51991.8 MiB       11176           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.2 MiB -51991.8 MiB       11176           if current == end:
    60    107.3 MiB     -6.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.2 MiB -467880.0 MiB      100575           for neighbor in current.neighbors:
    65    114.2 MiB -415889.0 MiB       89400               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.2 MiB -207950.1 MiB       44700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.2 MiB -207939.7 MiB       44700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.2 MiB -415890.4 MiB       89400               if temp_g_score < g_score[neighbor]:
    71    114.2 MiB -53917.5 MiB       11780                   came_from[neighbor] = current
    72    114.2 MiB -53917.7 MiB       11780                   g_score[neighbor] = temp_g_score
    73    114.2 MiB -53918.1 MiB       11780                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.2 MiB -53918.8 MiB       11780                   if neighbor not in open_set_hash:
    75    114.2 MiB -53919.5 MiB       11780                       count += 1
    76    114.2 MiB -53920.9 MiB       11780                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.2 MiB -53921.5 MiB       11780                       open_set_hash.add(neighbor)
    78                                                             
    79    114.2 MiB -51991.8 MiB       11175           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.2 MiB -51991.8 MiB       11175           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.3 MiB    107.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.3 MiB    -10.5 MiB         257       for row in grid:
    30    107.3 MiB  -2678.2 MiB       65792           for spot in row:
    31    107.3 MiB  -2667.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.2 MiB     -0.0 MiB           1       count = 0
    34    107.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.2 MiB      0.0 MiB           1       came_from = {}
    37    109.8 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.4 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.4 MiB -24939.3 MiB        5820       while not open_set.empty():
    47    112.4 MiB -24939.3 MiB        5820           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.4 MiB -24939.4 MiB        5820           current = open_set.get()[2]
    53    112.4 MiB -24939.4 MiB        5820           open_set_hash.remove(current)
    54                                         
    55    112.4 MiB -24939.4 MiB        5820           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.4 MiB -24939.4 MiB        5820           if current == end:
    60    107.7 MiB     -4.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.4 MiB -224422.3 MiB       52371           for neighbor in current.neighbors:
    65    112.4 MiB -199483.4 MiB       46552               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.4 MiB -99744.9 MiB       23276                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.4 MiB -99739.1 MiB       23276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.4 MiB -199484.3 MiB       46552               if temp_g_score < g_score[neighbor]:
    71    112.4 MiB -26721.4 MiB        6326                   came_from[neighbor] = current
    72    112.4 MiB -26722.4 MiB        6326                   g_score[neighbor] = temp_g_score
    73    112.4 MiB -26722.4 MiB        6326                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.4 MiB -26722.5 MiB        6326                   if neighbor not in open_set_hash:
    75    112.4 MiB -26722.7 MiB        6326                       count += 1
    76    112.4 MiB -26722.9 MiB        6326                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.4 MiB -26723.0 MiB        6326                       open_set_hash.add(neighbor)
    78                                                             
    79    112.4 MiB -24939.3 MiB        5819           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.4 MiB -24939.3 MiB        5819           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.7 MiB    107.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.7 MiB    -92.5 MiB         257       for row in grid:
    30    107.7 MiB -23663.5 MiB       65792           for spot in row:
    31    107.7 MiB -23571.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.2 MiB     -0.5 MiB           1       count = 0
    34    107.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.2 MiB      0.0 MiB           1       came_from = {}
    37    110.0 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.0 MiB -112198.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.8 MiB     -2.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.8 MiB -59624.4 MiB        7644       while not open_set.empty():
    47    107.8 MiB -59624.6 MiB        7644           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.8 MiB -59624.8 MiB        7644           current = open_set.get()[2]
    53    107.8 MiB -59625.0 MiB        7644           open_set_hash.remove(current)
    54                                         
    55    107.8 MiB -59625.2 MiB        7644           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.8 MiB -59625.3 MiB        7644           if current == end:
    60     92.2 MiB    -15.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.8 MiB -536542.6 MiB       68787           for neighbor in current.neighbors:
    65    107.8 MiB -476924.4 MiB       61144               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.8 MiB -238474.7 MiB       30572                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.8 MiB -238451.6 MiB       30572                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.8 MiB -476929.0 MiB       61144               if temp_g_score < g_score[neighbor]:
    71    107.8 MiB -63375.1 MiB        8190                   came_from[neighbor] = current
    72    107.8 MiB -63375.2 MiB        8190                   g_score[neighbor] = temp_g_score
    73    107.8 MiB -63375.5 MiB        8190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.8 MiB -63375.8 MiB        8190                   if neighbor not in open_set_hash:
    75    107.8 MiB -63376.0 MiB        8190                       count += 1
    76    107.8 MiB -63376.4 MiB        8190                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.8 MiB -63376.7 MiB        8190                       open_set_hash.add(neighbor)
    78                                                             
    79    107.8 MiB -59623.4 MiB        7643           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.8 MiB -59624.0 MiB        7643           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.4 MiB    104.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.4 MiB     -9.7 MiB         257       for row in grid:
    30    104.4 MiB  -1999.5 MiB       65792           for spot in row:
    31    104.4 MiB  -1989.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.5 MiB     -1.9 MiB           1       count = 0
    34    102.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.5 MiB      0.0 MiB           1       came_from = {}
    37    102.5 MiB -88478.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.0 MiB     -0.5 MiB           1       g_score[start] = 0
    39    104.0 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.0 MiB      0.0 MiB         990       while not open_set.empty():
    47    104.0 MiB      0.0 MiB         990           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.0 MiB      0.0 MiB         990           current = open_set.get()[2]
    53    104.0 MiB      0.0 MiB         990           open_set_hash.remove(current)
    54                                         
    55    104.0 MiB      0.0 MiB         990           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.0 MiB      0.0 MiB         990           if current == end:
    60    104.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.0 MiB      0.0 MiB        8901           for neighbor in current.neighbors:
    65    104.0 MiB      0.0 MiB        7912               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.0 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.0 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.0 MiB      0.0 MiB        7912               if temp_g_score < g_score[neighbor]:
    71    104.0 MiB      0.0 MiB        1282                   came_from[neighbor] = current
    72    104.0 MiB      0.0 MiB        1282                   g_score[neighbor] = temp_g_score
    73    104.0 MiB      0.0 MiB        1282                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.0 MiB      0.0 MiB        1282                   if neighbor not in open_set_hash:
    75    104.0 MiB      0.0 MiB        1282                       count += 1
    76    104.0 MiB      0.0 MiB        1282                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.0 MiB      0.0 MiB        1282                       open_set_hash.add(neighbor)
    78                                                             
    79    104.0 MiB      0.0 MiB         989           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.0 MiB      0.0 MiB         989           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.0 MiB    104.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.0 MiB   -406.0 MiB         257       for row in grid:
    30    104.0 MiB -104132.0 MiB       65792           for spot in row:
    31    104.0 MiB -103726.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.3 MiB     -1.6 MiB           1       count = 0
    34    102.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.3 MiB      0.0 MiB           1       came_from = {}
    37    103.5 MiB -68525.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.9 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.9 MiB -28875.3 MiB        3068       while not open_set.empty():
    47    107.9 MiB -28875.3 MiB        3068           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.9 MiB -28875.4 MiB        3068           current = open_set.get()[2]
    53    107.9 MiB -28875.5 MiB        3068           open_set_hash.remove(current)
    54                                         
    55    107.9 MiB -28875.5 MiB        3068           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.9 MiB -28875.8 MiB        3068           if current == end:
    60     74.5 MiB    -33.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.9 MiB -259712.3 MiB       27603           for neighbor in current.neighbors:
    65    107.9 MiB -230837.4 MiB       24536               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.9 MiB -115467.5 MiB       12268                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.9 MiB -115370.0 MiB       12268                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.9 MiB -230837.7 MiB       24536               if temp_g_score < g_score[neighbor]:
    71    107.9 MiB -31620.2 MiB        3392                   came_from[neighbor] = current
    72    107.9 MiB -31620.4 MiB        3392                   g_score[neighbor] = temp_g_score
    73    107.9 MiB -31620.5 MiB        3392                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.9 MiB -31651.3 MiB        3392                   if neighbor not in open_set_hash:
    75    107.9 MiB -31651.5 MiB        3392                       count += 1
    76    107.9 MiB -31651.8 MiB        3392                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.9 MiB -31652.0 MiB        3392                       open_set_hash.add(neighbor)
    78                                                             
    79    107.9 MiB -28875.2 MiB        3067           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.9 MiB -28875.3 MiB        3067           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.5 MiB     74.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.9 MiB  -1691.4 MiB         257       for row in grid:
    30     75.9 MiB -433499.9 MiB       65792           for spot in row:
    31     75.9 MiB -431814.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     65.3 MiB    -10.6 MiB           1       count = 0
    34     65.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     65.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     65.3 MiB      0.0 MiB           1       came_from = {}
    37     65.4 MiB -53372.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.3 MiB     -0.1 MiB           1       g_score[start] = 0
    39     69.6 MiB   -117.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.6 MiB    -62.9 MiB         726       while not open_set.empty():
    47     69.6 MiB    -62.9 MiB         726           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.6 MiB    -62.9 MiB         726           current = open_set.get()[2]
    53     69.6 MiB    -62.9 MiB         726           open_set_hash.remove(current)
    54                                         
    55     69.6 MiB    -62.9 MiB         726           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.6 MiB    -62.9 MiB         726           if current == end:
    60     69.3 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.6 MiB   -564.1 MiB        6525           for neighbor in current.neighbors:
    65     69.6 MiB   -501.3 MiB        5800               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.6 MiB   -250.9 MiB        2900                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.6 MiB   -250.4 MiB        2900                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.6 MiB   -501.3 MiB        5800               if temp_g_score < g_score[neighbor]:
    71     69.6 MiB    -74.5 MiB         878                   came_from[neighbor] = current
    72     69.6 MiB    -74.5 MiB         878                   g_score[neighbor] = temp_g_score
    73     69.6 MiB    -74.5 MiB         878                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.6 MiB    -74.5 MiB         878                   if neighbor not in open_set_hash:
    75     69.6 MiB    -74.6 MiB         878                       count += 1
    76     69.6 MiB    -74.6 MiB         878                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.6 MiB    -74.6 MiB         878                       open_set_hash.add(neighbor)
    78                                                             
    79     69.6 MiB    -62.9 MiB         725           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.6 MiB    -62.9 MiB         725           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.3 MiB     69.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.8 MiB  -4535.8 MiB         257       for row in grid:
    30     69.8 MiB -1160200.5 MiB       65792           for spot in row:
    31     69.8 MiB -1155680.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     41.9 MiB    -27.9 MiB           1       count = 0
    34     42.0 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     42.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     42.0 MiB      0.0 MiB           1       came_from = {}
    37     45.6 MiB -34566.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     45.4 MiB     -0.2 MiB           1       g_score[start] = 0
    39     51.9 MiB      6.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     52.2 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     52.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     52.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     52.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     52.7 MiB      0.0 MiB         128       while not open_set.empty():
    47     52.7 MiB      0.0 MiB         128           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     52.7 MiB      0.0 MiB         128           current = open_set.get()[2]
    53     52.7 MiB      0.0 MiB         128           open_set_hash.remove(current)
    54                                         
    55     52.7 MiB      0.0 MiB         128           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     52.7 MiB      0.0 MiB         128           if current == end:
    60     52.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     52.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     52.7 MiB      0.1 MiB        1143           for neighbor in current.neighbors:
    65     52.7 MiB      0.3 MiB        1016               if current.row != neighbor.row and current.col != neighbor.col:
    66     52.7 MiB      0.0 MiB         508                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     52.7 MiB      0.0 MiB         508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     52.7 MiB      0.0 MiB        1016               if temp_g_score < g_score[neighbor]:
    71     52.7 MiB      0.0 MiB         190                   came_from[neighbor] = current
    72     52.7 MiB      0.0 MiB         190                   g_score[neighbor] = temp_g_score
    73     52.7 MiB      0.0 MiB         190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     52.7 MiB      0.0 MiB         190                   if neighbor not in open_set_hash:
    75     52.7 MiB      0.0 MiB         190                       count += 1
    76     52.7 MiB      0.0 MiB         190                       open_set.put((f_score[neighbor], count, neighbor))
    77     52.7 MiB      0.0 MiB         190                       open_set_hash.add(neighbor)
    78                                                             
    79     52.7 MiB      0.0 MiB         127           if draw is not None:
    80                                                     draw()
    81                                         
    82     52.7 MiB      0.0 MiB         127           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     55.2 MiB     55.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.9 MiB      0.0 MiB         257       for row in grid:
    30     61.9 MiB      0.0 MiB       65792           for spot in row:
    31     61.9 MiB      6.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.9 MiB      0.0 MiB           1       count = 0
    34     61.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.9 MiB      0.0 MiB           1       came_from = {}
    37     64.4 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.2 MiB   -385.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.1 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.1 MiB   -617.8 MiB         924       while not open_set.empty():
    47     68.1 MiB   -617.8 MiB         924           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.1 MiB   -617.8 MiB         924           current = open_set.get()[2]
    53     68.1 MiB   -617.8 MiB         924           open_set_hash.remove(current)
    54                                         
    55     68.1 MiB   -617.8 MiB         924           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.1 MiB   -617.8 MiB         924           if current == end:
    60     67.3 MiB     -0.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.4 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.1 MiB  -5556.9 MiB        8307           for neighbor in current.neighbors:
    65     68.1 MiB  -4939.4 MiB        7384               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.1 MiB  -2471.2 MiB        3692                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.1 MiB  -2468.5 MiB        3692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.1 MiB  -4940.0 MiB        7384               if temp_g_score < g_score[neighbor]:
    71     68.1 MiB   -797.0 MiB        1214                   came_from[neighbor] = current
    72     68.1 MiB   -797.0 MiB        1214                   g_score[neighbor] = temp_g_score
    73     68.1 MiB   -797.0 MiB        1214                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.1 MiB   -797.0 MiB        1214                   if neighbor not in open_set_hash:
    75     68.1 MiB   -797.0 MiB        1214                       count += 1
    76     68.1 MiB   -797.0 MiB        1214                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.1 MiB   -796.9 MiB        1214                       open_set_hash.add(neighbor)
    78                                                             
    79     68.1 MiB   -617.8 MiB         923           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.1 MiB   -617.8 MiB         923           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.8 MiB     98.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.8 MiB   -531.2 MiB         257       for row in grid:
    30     98.8 MiB -135249.3 MiB       65792           for spot in row:
    31     98.8 MiB -134721.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.5 MiB     -7.2 MiB           1       count = 0
    34     91.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.5 MiB      0.0 MiB           1       came_from = {}
    37     94.4 MiB -19353.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.2 MiB -29041.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.2 MiB      0.0 MiB         615       while not open_set.empty():
    47     97.2 MiB      0.0 MiB         615           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.2 MiB      0.0 MiB         615           current = open_set.get()[2]
    53     97.2 MiB      0.0 MiB         615           open_set_hash.remove(current)
    54                                         
    55     97.2 MiB      0.0 MiB         615           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.2 MiB      0.0 MiB         615           if current == end:
    60     97.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.2 MiB      0.0 MiB        5526           for neighbor in current.neighbors:
    65     97.2 MiB      0.0 MiB        4912               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.2 MiB      0.0 MiB        2456                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.2 MiB      0.0 MiB        2456                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.2 MiB      0.0 MiB        4912               if temp_g_score < g_score[neighbor]:
    71     97.2 MiB      0.0 MiB         755                   came_from[neighbor] = current
    72     97.2 MiB      0.0 MiB         755                   g_score[neighbor] = temp_g_score
    73     97.2 MiB      0.0 MiB         755                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.2 MiB      0.0 MiB         755                   if neighbor not in open_set_hash:
    75     97.2 MiB      0.0 MiB         755                       count += 1
    76     97.2 MiB      0.0 MiB         755                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.2 MiB      0.0 MiB         755                       open_set_hash.add(neighbor)
    78                                                             
    79     97.2 MiB      0.0 MiB         614           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.2 MiB      0.0 MiB         614           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.2 MiB     97.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.0 MiB  -3735.5 MiB         257       for row in grid:
    30     98.0 MiB -955858.4 MiB       65792           for spot in row:
    31     98.0 MiB -952134.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.4 MiB    -25.5 MiB           1       count = 0
    34     72.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.4 MiB      0.0 MiB           1       came_from = {}
    37     77.5 MiB    -17.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     77.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     79.8 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     79.9 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     79.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     79.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     79.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     80.8 MiB      0.0 MiB        1060       while not open_set.empty():
    47     80.8 MiB      0.0 MiB        1060           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     80.8 MiB      0.0 MiB        1060           current = open_set.get()[2]
    53     80.8 MiB      0.0 MiB        1060           open_set_hash.remove(current)
    54                                         
    55     80.8 MiB      0.0 MiB        1060           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     80.8 MiB      0.0 MiB        1060           if current == end:
    60     80.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     80.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     80.8 MiB      0.3 MiB        9531           for neighbor in current.neighbors:
    65     80.8 MiB      0.4 MiB        8472               if current.row != neighbor.row and current.col != neighbor.col:
    66     80.8 MiB      0.0 MiB        4236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     80.8 MiB      0.0 MiB        4236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     80.8 MiB      0.0 MiB        8472               if temp_g_score < g_score[neighbor]:
    71     80.8 MiB      0.1 MiB        1310                   came_from[neighbor] = current
    72     80.8 MiB      0.0 MiB        1310                   g_score[neighbor] = temp_g_score
    73     80.8 MiB      0.0 MiB        1310                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     80.8 MiB      0.0 MiB        1310                   if neighbor not in open_set_hash:
    75     80.8 MiB      0.0 MiB        1310                       count += 1
    76     80.8 MiB      0.0 MiB        1310                       open_set.put((f_score[neighbor], count, neighbor))
    77     80.8 MiB      0.0 MiB        1310                       open_set_hash.add(neighbor)
    78                                                             
    79     80.8 MiB      0.0 MiB        1059           if draw is not None:
    80                                                     draw()
    81                                         
    82     80.8 MiB      0.0 MiB        1059           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     83.1 MiB     83.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     83.7 MiB      0.0 MiB         257       for row in grid:
    30     83.7 MiB      0.0 MiB       65792           for spot in row:
    31     83.7 MiB      0.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     83.7 MiB      0.0 MiB           1       count = 0
    34     83.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     83.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     83.7 MiB      0.0 MiB           1       came_from = {}
    37     84.5 MiB      0.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     84.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     88.8 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     88.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     88.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     88.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     88.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     88.8 MiB      0.0 MiB        2024       while not open_set.empty():
    47     88.8 MiB      0.0 MiB        2024           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     88.8 MiB      0.0 MiB        2024           current = open_set.get()[2]
    53     88.8 MiB      0.0 MiB        2024           open_set_hash.remove(current)
    54                                         
    55     88.8 MiB      0.0 MiB        2024           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     88.8 MiB      0.0 MiB        2024           if current == end:
    60     88.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     88.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     88.8 MiB      0.0 MiB       18207           for neighbor in current.neighbors:
    65     88.8 MiB      0.0 MiB       16184               if current.row != neighbor.row and current.col != neighbor.col:
    66     88.8 MiB      0.0 MiB        8092                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     88.8 MiB      0.0 MiB        8092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     88.8 MiB      0.0 MiB       16184               if temp_g_score < g_score[neighbor]:
    71     88.8 MiB      0.0 MiB        2294                   came_from[neighbor] = current
    72     88.8 MiB      0.0 MiB        2294                   g_score[neighbor] = temp_g_score
    73     88.8 MiB      0.0 MiB        2294                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     88.8 MiB      0.0 MiB        2294                   if neighbor not in open_set_hash:
    75     88.8 MiB      0.0 MiB        2294                       count += 1
    76     88.8 MiB      0.0 MiB        2294                       open_set.put((f_score[neighbor], count, neighbor))
    77     88.8 MiB      0.0 MiB        2294                       open_set_hash.add(neighbor)
    78                                                             
    79     88.8 MiB      0.0 MiB        2023           if draw is not None:
    80                                                     draw()
    81                                         
    82     88.8 MiB      0.0 MiB        2023           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.8 MiB   -111.4 MiB         257       for row in grid:
    30     88.8 MiB -28380.4 MiB       65792           for spot in row:
    31     88.8 MiB -28270.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     86.7 MiB     -2.1 MiB           1       count = 0
    34     86.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     86.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     86.7 MiB      0.0 MiB           1       came_from = {}
    37     87.0 MiB -83141.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     86.8 MiB     -0.2 MiB           1       g_score[start] = 0
    39     88.4 MiB      1.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     88.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     88.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     88.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     88.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     88.4 MiB -62929.9 MiB        2431       while not open_set.empty():
    47     88.4 MiB -62930.5 MiB        2431           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     88.4 MiB -62933.9 MiB        2431           current = open_set.get()[2]
    53     88.4 MiB -62935.2 MiB        2431           open_set_hash.remove(current)
    54                                         
    55     88.4 MiB -62936.5 MiB        2431           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     88.4 MiB -62937.3 MiB        2431           if current == end:
    60     37.3 MiB    -51.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     37.9 MiB      0.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     88.4 MiB -566156.8 MiB       21870           for neighbor in current.neighbors:
    65     88.4 MiB -503235.5 MiB       19440               if current.row != neighbor.row and current.col != neighbor.col:
    66     88.4 MiB -251659.7 MiB        9720                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     88.4 MiB -251586.4 MiB        9720                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     88.4 MiB -503254.9 MiB       19440               if temp_g_score < g_score[neighbor]:
    71     88.4 MiB -70990.3 MiB        2783                   came_from[neighbor] = current
    72     88.4 MiB -70991.2 MiB        2783                   g_score[neighbor] = temp_g_score
    73     88.4 MiB -70994.1 MiB        2783                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     88.4 MiB -70995.3 MiB        2783                   if neighbor not in open_set_hash:
    75     88.4 MiB -70996.4 MiB        2783                       count += 1
    76     88.4 MiB -70997.8 MiB        2783                       open_set.put((f_score[neighbor], count, neighbor))
    77     88.4 MiB -70998.4 MiB        2783                       open_set_hash.add(neighbor)
    78                                                             
    79     88.4 MiB -62928.4 MiB        2430           if draw is not None:
    80                                                     draw()
    81                                         
    82     88.4 MiB -62929.0 MiB        2430           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     41.4 MiB     41.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     54.4 MiB    -21.0 MiB         257       for row in grid:
    30     54.4 MiB  -5362.1 MiB       65792           for spot in row:
    31     54.4 MiB  -5329.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     54.4 MiB      0.0 MiB           1       count = 0
    34     54.4 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     54.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     54.4 MiB      0.0 MiB           1       came_from = {}
    37     55.5 MiB -208989.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     50.3 MiB     -5.2 MiB           1       g_score[start] = 0
    39     54.8 MiB  -1853.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     54.7 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     54.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     54.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     54.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.3 MiB -22304.2 MiB       11040       while not open_set.empty():
    47     55.3 MiB -22304.2 MiB       11040           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.3 MiB -22304.4 MiB       11040           current = open_set.get()[2]
    53     55.3 MiB -22304.5 MiB       11040           open_set_hash.remove(current)
    54                                         
    55     55.3 MiB -22304.5 MiB       11040           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.3 MiB -22304.5 MiB       11040           if current == end:
    60     54.3 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     54.4 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.3 MiB -200729.5 MiB       99351           for neighbor in current.neighbors:
    65     55.3 MiB -178424.6 MiB       88312               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.3 MiB -89215.9 MiB       44156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.3 MiB -89210.1 MiB       44156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.3 MiB -178426.8 MiB       88312               if temp_g_score < g_score[neighbor]:
    71     55.3 MiB -23236.5 MiB       11690                   came_from[neighbor] = current
    72     55.3 MiB -23236.8 MiB       11690                   g_score[neighbor] = temp_g_score
    73     55.3 MiB -23236.8 MiB       11690                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.3 MiB -23236.8 MiB       11690                   if neighbor not in open_set_hash:
    75     55.3 MiB -23236.8 MiB       11690                       count += 1
    76     55.3 MiB -23236.6 MiB       11690                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.3 MiB -23236.6 MiB       11690                       open_set_hash.add(neighbor)
    78                                                             
    79     55.3 MiB -22303.7 MiB       11039           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.3 MiB -22303.9 MiB       11039           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.1 MiB     92.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.1 MiB      0.0 MiB         257       for row in grid:
    30     92.1 MiB      0.0 MiB       65792           for spot in row:
    31     92.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.1 MiB      0.0 MiB           1       count = 0
    34     92.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.1 MiB      0.0 MiB           1       came_from = {}
    37     94.6 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.9 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.9 MiB      0.0 MiB        1792       while not open_set.empty():
    47     98.9 MiB      0.0 MiB        1792           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.9 MiB      0.0 MiB        1792           current = open_set.get()[2]
    53     98.9 MiB      0.0 MiB        1792           open_set_hash.remove(current)
    54                                         
    55     98.9 MiB      0.0 MiB        1792           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.9 MiB      0.0 MiB        1792           if current == end:
    60     98.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.9 MiB      0.0 MiB       16119           for neighbor in current.neighbors:
    65     98.9 MiB      0.0 MiB       14328               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.9 MiB      0.0 MiB        7164                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.9 MiB      0.0 MiB        7164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.9 MiB      0.0 MiB       14328               if temp_g_score < g_score[neighbor]:
    71     98.9 MiB      0.0 MiB        2030                   came_from[neighbor] = current
    72     98.9 MiB      0.0 MiB        2030                   g_score[neighbor] = temp_g_score
    73     98.9 MiB      0.0 MiB        2030                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.9 MiB      0.0 MiB        2030                   if neighbor not in open_set_hash:
    75     98.9 MiB      0.0 MiB        2030                       count += 1
    76     98.9 MiB      0.0 MiB        2030                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.9 MiB      0.0 MiB        2030                       open_set_hash.add(neighbor)
    78                                                             
    79     98.9 MiB      0.0 MiB        1791           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.9 MiB      0.0 MiB        1791           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.9 MiB     98.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.9 MiB      0.0 MiB         257       for row in grid:
    30     98.9 MiB      0.0 MiB       65792           for spot in row:
    31     98.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.9 MiB      0.0 MiB           1       count = 0
    34     98.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.9 MiB      0.0 MiB           1       came_from = {}
    37    100.1 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.3 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.3 MiB   -457.2 MiB        1007       while not open_set.empty():
    47    101.3 MiB   -457.2 MiB        1007           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.3 MiB   -457.2 MiB        1007           current = open_set.get()[2]
    53    101.3 MiB   -457.2 MiB        1007           open_set_hash.remove(current)
    54                                         
    55    101.3 MiB   -457.2 MiB        1007           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.3 MiB   -457.2 MiB        1007           if current == end:
    60    100.8 MiB     -0.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.3 MiB  -4113.2 MiB        9054           for neighbor in current.neighbors:
    65    101.3 MiB  -3656.0 MiB        8048               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.3 MiB  -1828.6 MiB        4024                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.3 MiB  -1827.5 MiB        4024                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.3 MiB  -3656.2 MiB        8048               if temp_g_score < g_score[neighbor]:
    71    101.3 MiB   -558.3 MiB        1255                   came_from[neighbor] = current
    72    101.3 MiB   -558.3 MiB        1255                   g_score[neighbor] = temp_g_score
    73    101.3 MiB   -558.3 MiB        1255                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.3 MiB   -558.3 MiB        1255                   if neighbor not in open_set_hash:
    75    101.3 MiB   -558.3 MiB        1255                       count += 1
    76    101.3 MiB   -558.3 MiB        1255                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.3 MiB   -558.3 MiB        1255                       open_set_hash.add(neighbor)
    78                                                             
    79    101.3 MiB   -457.2 MiB        1006           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.3 MiB   -457.2 MiB        1006           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.8 MiB    100.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.8 MiB    -92.4 MiB         257       for row in grid:
    30    100.8 MiB -23732.0 MiB       65792           for spot in row:
    31    100.8 MiB -23639.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.3 MiB     -0.5 MiB           1       count = 0
    34    100.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.3 MiB      0.0 MiB           1       came_from = {}
    37    100.3 MiB -173861.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.5 MiB     -2.8 MiB           1       g_score[start] = 0
    39     99.8 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.8 MiB  -4394.5 MiB        2320       while not open_set.empty():
    47     99.8 MiB  -4394.5 MiB        2320           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.8 MiB  -4394.6 MiB        2320           current = open_set.get()[2]
    53     99.8 MiB  -4394.6 MiB        2320           open_set_hash.remove(current)
    54                                         
    55     99.8 MiB  -4394.6 MiB        2320           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.8 MiB  -4394.6 MiB        2320           if current == end:
    60     96.2 MiB     -3.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.8 MiB -39526.5 MiB       20871           for neighbor in current.neighbors:
    65     99.8 MiB -35132.6 MiB       18552               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.8 MiB -17567.9 MiB        9276                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.8 MiB -17565.0 MiB        9276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.8 MiB -35133.3 MiB       18552               if temp_g_score < g_score[neighbor]:
    71     99.8 MiB  -4739.5 MiB        2594                   came_from[neighbor] = current
    72     99.8 MiB  -4739.5 MiB        2594                   g_score[neighbor] = temp_g_score
    73     99.8 MiB  -4739.6 MiB        2594                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.8 MiB  -4739.6 MiB        2594                   if neighbor not in open_set_hash:
    75     99.8 MiB  -4739.6 MiB        2594                       count += 1
    76     99.8 MiB  -4739.7 MiB        2594                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.8 MiB  -4740.1 MiB        2594                       open_set_hash.add(neighbor)
    78                                                             
    79     99.8 MiB  -4394.4 MiB        2319           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.8 MiB  -4394.5 MiB        2319           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.2 MiB     96.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.0 MiB   -284.9 MiB         257       for row in grid:
    30     97.0 MiB -72939.0 MiB       65792           for spot in row:
    31     97.0 MiB -72655.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.3 MiB     -2.7 MiB           1       count = 0
    34     94.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.3 MiB      0.0 MiB           1       came_from = {}
    37     94.7 MiB -54253.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.4 MiB     -1.3 MiB           1       g_score[start] = 0
    39     95.6 MiB -40080.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.3 MiB     -1.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.3 MiB -88001.3 MiB        5135       while not open_set.empty():
    47     94.3 MiB -88001.4 MiB        5135           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.3 MiB -88002.0 MiB        5135           current = open_set.get()[2]
    53     94.3 MiB -88002.0 MiB        5135           open_set_hash.remove(current)
    54                                         
    55     94.3 MiB -88002.2 MiB        5135           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.3 MiB -88005.9 MiB        5135           if current == end:
    60     58.0 MiB    -36.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.3 MiB -791904.5 MiB       46206           for neighbor in current.neighbors:
    65     94.3 MiB -703914.7 MiB       41072               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.3 MiB -351978.6 MiB       20536                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.3 MiB -351941.3 MiB       20536                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.3 MiB -703923.3 MiB       41072               if temp_g_score < g_score[neighbor]:
    71     94.3 MiB -93417.8 MiB        5551                   came_from[neighbor] = current
    72     94.3 MiB -93418.3 MiB        5551                   g_score[neighbor] = temp_g_score
    73     94.3 MiB -93418.9 MiB        5551                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.3 MiB -93419.2 MiB        5551                   if neighbor not in open_set_hash:
    75     94.3 MiB -93419.4 MiB        5551                       count += 1
    76     94.3 MiB -93420.2 MiB        5551                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.3 MiB -93420.5 MiB        5551                       open_set_hash.add(neighbor)
    78                                                             
    79     94.3 MiB -88000.5 MiB        5134           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.3 MiB -88001.0 MiB        5134           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.9 MiB     61.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.6 MiB      0.0 MiB         257       for row in grid:
    30     67.6 MiB      0.0 MiB       65792           for spot in row:
    31     67.6 MiB      5.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     67.6 MiB      0.0 MiB           1       count = 0
    34     67.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.6 MiB      0.0 MiB           1       came_from = {}
    37     70.4 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     73.1 MiB -45748.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.6 MiB     -2.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.8 MiB  -6868.8 MiB        9316       while not open_set.empty():
    47     70.8 MiB  -6868.8 MiB        9316           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.8 MiB  -6868.8 MiB        9316           current = open_set.get()[2]
    53     70.8 MiB  -6868.8 MiB        9316           open_set_hash.remove(current)
    54                                         
    55     70.8 MiB  -6868.9 MiB        9316           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.8 MiB  -6869.1 MiB        9316           if current == end:
    60     68.2 MiB     -2.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.8 MiB -61808.1 MiB       83835           for neighbor in current.neighbors:
    65     70.8 MiB -54939.8 MiB       74520               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.8 MiB -27471.5 MiB       37260                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.8 MiB -27468.7 MiB       37260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.8 MiB -54940.4 MiB       74520               if temp_g_score < g_score[neighbor]:
    71     70.8 MiB  -7233.5 MiB        9860                   came_from[neighbor] = current
    72     70.8 MiB  -7233.7 MiB        9860                   g_score[neighbor] = temp_g_score
    73     70.8 MiB  -7233.7 MiB        9860                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.8 MiB  -7233.8 MiB        9860                   if neighbor not in open_set_hash:
    75     70.8 MiB  -7233.8 MiB        9860                       count += 1
    76     70.8 MiB  -7234.3 MiB        9860                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.8 MiB  -7234.5 MiB        9860                       open_set_hash.add(neighbor)
    78                                                             
    79     70.8 MiB  -6868.8 MiB        9315           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.8 MiB  -6868.8 MiB        9315           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.8 MiB     98.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.8 MiB  -1314.4 MiB         257       for row in grid:
    30     98.8 MiB -337263.1 MiB       65792           for spot in row:
    31     98.8 MiB -335951.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.0 MiB     -6.8 MiB           1       count = 0
    34     92.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.0 MiB      0.0 MiB           1       came_from = {}
    37     93.4 MiB -40951.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.0 MiB     -0.3 MiB           1       g_score[start] = 0
    39     94.7 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.8 MiB  -1583.1 MiB        1060       while not open_set.empty():
    47     94.8 MiB  -1583.1 MiB        1060           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.8 MiB  -1583.2 MiB        1060           current = open_set.get()[2]
    53     94.8 MiB  -1583.2 MiB        1060           open_set_hash.remove(current)
    54                                         
    55     94.8 MiB  -1583.6 MiB        1060           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.8 MiB  -1583.7 MiB        1060           if current == end:
    60     93.1 MiB     -1.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.8 MiB -14242.9 MiB        9531           for neighbor in current.neighbors:
    65     94.8 MiB -12659.9 MiB        8472               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.8 MiB  -6330.8 MiB        4236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.8 MiB  -6329.4 MiB        4236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.8 MiB -12660.4 MiB        8472               if temp_g_score < g_score[neighbor]:
    71     94.8 MiB  -1909.4 MiB        1310                   came_from[neighbor] = current
    72     94.8 MiB  -1909.4 MiB        1310                   g_score[neighbor] = temp_g_score
    73     94.8 MiB  -1909.5 MiB        1310                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.8 MiB  -1909.5 MiB        1310                   if neighbor not in open_set_hash:
    75     94.8 MiB  -1909.5 MiB        1310                       count += 1
    76     94.8 MiB  -1909.7 MiB        1310                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.8 MiB  -1909.7 MiB        1310                       open_set_hash.add(neighbor)
    78                                                             
    79     94.8 MiB  -1583.1 MiB        1059           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.8 MiB  -1583.1 MiB        1059           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.2 MiB     93.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.9 MiB     -0.6 MiB         257       for row in grid:
    30     93.9 MiB   -147.4 MiB       65792           for spot in row:
    31     93.9 MiB   -146.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.9 MiB      0.0 MiB           1       count = 0
    34     93.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.9 MiB      0.0 MiB           1       came_from = {}
    37     96.6 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.9 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.9 MiB      0.0 MiB         473       while not open_set.empty():
    47     96.9 MiB      0.0 MiB         473           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.9 MiB      0.0 MiB         473           current = open_set.get()[2]
    53     96.9 MiB      0.0 MiB         473           open_set_hash.remove(current)
    54                                         
    55     96.9 MiB      0.0 MiB         473           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.9 MiB      0.0 MiB         473           if current == end:
    60     96.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.9 MiB      0.0 MiB        4248           for neighbor in current.neighbors:
    65     96.9 MiB      0.0 MiB        3776               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.9 MiB      0.0 MiB        1888                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.9 MiB      0.0 MiB        1888                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.9 MiB      0.0 MiB        3776               if temp_g_score < g_score[neighbor]:
    71     96.9 MiB      0.0 MiB         665                   came_from[neighbor] = current
    72     96.9 MiB      0.0 MiB         665                   g_score[neighbor] = temp_g_score
    73     96.9 MiB      0.0 MiB         665                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.9 MiB      0.0 MiB         665                   if neighbor not in open_set_hash:
    75     96.9 MiB      0.0 MiB         665                       count += 1
    76     96.9 MiB      0.0 MiB         665                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.9 MiB      0.0 MiB         665                       open_set_hash.add(neighbor)
    78                                                             
    79     96.9 MiB      0.0 MiB         472           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.9 MiB      0.0 MiB         472           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.9 MiB     96.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.9 MiB      0.0 MiB         257       for row in grid:
    30     96.9 MiB      0.0 MiB       65792           for spot in row:
    31     96.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.9 MiB      0.0 MiB           1       count = 0
    34     96.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.9 MiB      0.0 MiB           1       came_from = {}
    37    100.3 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.9 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.9 MiB      0.0 MiB        1008       while not open_set.empty():
    47    100.9 MiB      0.0 MiB        1008           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.9 MiB      0.0 MiB        1008           current = open_set.get()[2]
    53    100.9 MiB      0.0 MiB        1008           open_set_hash.remove(current)
    54                                         
    55    100.9 MiB      0.0 MiB        1008           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.9 MiB      0.0 MiB        1008           if current == end:
    60    100.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.9 MiB      0.0 MiB        9063           for neighbor in current.neighbors:
    65    100.9 MiB      0.0 MiB        8056               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.9 MiB      0.0 MiB        4028                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.9 MiB      0.0 MiB        4028                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.9 MiB      0.0 MiB        8056               if temp_g_score < g_score[neighbor]:
    71    100.9 MiB      0.0 MiB        1190                   came_from[neighbor] = current
    72    100.9 MiB      0.0 MiB        1190                   g_score[neighbor] = temp_g_score
    73    100.9 MiB      0.0 MiB        1190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.9 MiB      0.0 MiB        1190                   if neighbor not in open_set_hash:
    75    100.9 MiB      0.0 MiB        1190                       count += 1
    76    100.9 MiB      0.0 MiB        1190                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.9 MiB      0.0 MiB        1190                       open_set_hash.add(neighbor)
    78                                                             
    79    100.9 MiB      0.0 MiB        1007           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.9 MiB      0.0 MiB        1007           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.9 MiB    100.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.9 MiB  -2621.8 MiB         257       for row in grid:
    30    100.9 MiB -669803.9 MiB       65792           for spot in row:
    31    100.9 MiB -667201.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     73.4 MiB    -27.6 MiB           1       count = 0
    34     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     73.4 MiB      0.0 MiB           1       came_from = {}
    37     79.8 MiB      6.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     79.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     83.5 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     83.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     83.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     83.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     83.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     84.8 MiB -169263.2 MiB        6720       while not open_set.empty():
    47     84.8 MiB -169263.7 MiB        6720           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     84.8 MiB -169264.4 MiB        6720           current = open_set.get()[2]
    53     84.8 MiB -169264.7 MiB        6720           open_set_hash.remove(current)
    54                                         
    55     84.8 MiB -169265.0 MiB        6720           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     84.8 MiB -169268.5 MiB        6720           if current == end:
    60     57.2 MiB    -27.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     84.8 MiB -1523266.7 MiB       60471           for neighbor in current.neighbors:
    65     84.8 MiB -1354006.3 MiB       53752               if current.row != neighbor.row and current.col != neighbor.col:
    66     84.8 MiB -677025.2 MiB       26876                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     84.8 MiB -676986.7 MiB       26876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     84.8 MiB -1354017.3 MiB       53752               if temp_g_score < g_score[neighbor]:
    71     84.8 MiB -179057.6 MiB        7214                   came_from[neighbor] = current
    72     84.8 MiB -179058.7 MiB        7214                   g_score[neighbor] = temp_g_score
    73     84.8 MiB -179060.9 MiB        7214                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     84.8 MiB -179063.0 MiB        7214                   if neighbor not in open_set_hash:
    75     84.8 MiB -179063.3 MiB        7214                       count += 1
    76     84.8 MiB -179059.9 MiB        7214                       open_set.put((f_score[neighbor], count, neighbor))
    77     84.8 MiB -179060.2 MiB        7214                       open_set_hash.add(neighbor)
    78                                                             
    79     84.8 MiB -169262.4 MiB        6719           if draw is not None:
    80                                                     draw()
    81                                         
    82     84.8 MiB -169262.8 MiB        6719           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.6 MiB     59.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.6 MiB      0.0 MiB         257       for row in grid:
    30     60.6 MiB      0.0 MiB       65792           for spot in row:
    31     60.6 MiB      1.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.6 MiB      0.0 MiB           1       count = 0
    34     60.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.6 MiB      0.0 MiB           1       came_from = {}
    37     63.4 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.8 MiB -10928.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.8 MiB -60066.3 MiB        8928       while not open_set.empty():
    47     64.8 MiB -60066.5 MiB        8928           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.8 MiB -60066.8 MiB        8928           current = open_set.get()[2]
    53     64.8 MiB -60066.9 MiB        8928           open_set_hash.remove(current)
    54                                         
    55     64.8 MiB -60067.2 MiB        8928           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.8 MiB -60067.4 MiB        8928           if current == end:
    60     53.9 MiB    -10.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     54.1 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.8 MiB -540545.6 MiB       80343           for neighbor in current.neighbors:
    65     64.8 MiB -480480.9 MiB       71416               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.8 MiB -240247.0 MiB       35708                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.8 MiB -240235.8 MiB       35708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.8 MiB -480483.1 MiB       71416               if temp_g_score < g_score[neighbor]:
    71     64.8 MiB -63923.8 MiB        9626                   came_from[neighbor] = current
    72     64.8 MiB -63923.8 MiB        9626                   g_score[neighbor] = temp_g_score
    73     64.8 MiB -63923.8 MiB        9626                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.8 MiB -63923.8 MiB        9626                   if neighbor not in open_set_hash:
    75     64.8 MiB -63926.7 MiB        9626                       count += 1
    76     64.8 MiB -63928.1 MiB        9626                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.8 MiB -63928.0 MiB        9626                       open_set_hash.add(neighbor)
    78                                                             
    79     64.8 MiB -60066.0 MiB        8927           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.8 MiB -60066.2 MiB        8927           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.9 MiB     91.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.9 MiB      0.0 MiB         257       for row in grid:
    30     91.9 MiB      0.0 MiB       65792           for spot in row:
    31     91.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.9 MiB      0.0 MiB           1       count = 0
    34     91.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.9 MiB      0.0 MiB           1       came_from = {}
    37     96.2 MiB   -322.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.6 MiB      4.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.8 MiB   -113.5 MiB        3750       while not open_set.empty():
    47    100.8 MiB   -113.5 MiB        3750           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.8 MiB   -113.5 MiB        3750           current = open_set.get()[2]
    53    100.8 MiB   -113.5 MiB        3750           open_set_hash.remove(current)
    54                                         
    55    100.8 MiB   -113.5 MiB        3750           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.8 MiB   -113.5 MiB        3750           if current == end:
    60    100.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.8 MiB  -1022.5 MiB       33741           for neighbor in current.neighbors:
    65    100.8 MiB   -909.0 MiB       29992               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.8 MiB   -454.6 MiB       14996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.8 MiB   -454.5 MiB       14996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.8 MiB   -909.1 MiB       29992               if temp_g_score < g_score[neighbor]:
    71    100.8 MiB   -122.6 MiB        4148                   came_from[neighbor] = current
    72    100.8 MiB   -122.7 MiB        4148                   g_score[neighbor] = temp_g_score
    73    100.8 MiB   -122.7 MiB        4148                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.8 MiB   -122.7 MiB        4148                   if neighbor not in open_set_hash:
    75    100.8 MiB   -122.7 MiB        4148                       count += 1
    76    100.8 MiB   -122.7 MiB        4148                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.8 MiB   -122.7 MiB        4148                       open_set_hash.add(neighbor)
    78                                                             
    79    100.8 MiB   -113.5 MiB        3749           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.8 MiB   -113.5 MiB        3749           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.8 MiB    100.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.8 MiB     -0.3 MiB         257       for row in grid:
    30    100.8 MiB    -67.0 MiB       65792           for spot in row:
    31    100.8 MiB    -66.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.7 MiB     -0.2 MiB           1       count = 0
    34    100.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.7 MiB      0.0 MiB           1       came_from = {}
    37    104.9 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.0 MiB -17800.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.1 MiB      0.0 MiB        1176       while not open_set.empty():
    47    107.1 MiB      0.0 MiB        1176           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.1 MiB      0.0 MiB        1176           current = open_set.get()[2]
    53    107.1 MiB      0.0 MiB        1176           open_set_hash.remove(current)
    54                                         
    55    107.1 MiB      0.0 MiB        1176           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.1 MiB      0.0 MiB        1176           if current == end:
    60    107.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.1 MiB      0.0 MiB       10575           for neighbor in current.neighbors:
    65    107.1 MiB      0.0 MiB        9400               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.1 MiB      0.0 MiB        4700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.1 MiB      0.0 MiB        4700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.1 MiB      0.0 MiB        9400               if temp_g_score < g_score[neighbor]:
    71    107.1 MiB      0.1 MiB        1538                   came_from[neighbor] = current
    72    107.1 MiB      0.0 MiB        1538                   g_score[neighbor] = temp_g_score
    73    107.1 MiB      0.0 MiB        1538                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.1 MiB      0.0 MiB        1538                   if neighbor not in open_set_hash:
    75    107.1 MiB      0.0 MiB        1538                       count += 1
    76    107.1 MiB      0.0 MiB        1538                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.1 MiB      0.0 MiB        1538                       open_set_hash.add(neighbor)
    78                                                             
    79    107.1 MiB      0.0 MiB        1175           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.1 MiB      0.0 MiB        1175           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.1 MiB    107.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.1 MiB     -2.4 MiB         257       for row in grid:
    30    107.1 MiB   -624.2 MiB       65792           for spot in row:
    31    107.1 MiB   -621.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.1 MiB     -0.0 MiB           1       count = 0
    34    107.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.1 MiB      0.0 MiB           1       came_from = {}
    37    108.2 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.7 MiB -98011.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.4 MiB     -1.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.6 MiB      0.0 MiB        2548       while not open_set.empty():
    47    108.6 MiB      0.0 MiB        2548           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.6 MiB      0.0 MiB        2548           current = open_set.get()[2]
    53    108.6 MiB      0.0 MiB        2548           open_set_hash.remove(current)
    54                                         
    55    108.6 MiB      0.0 MiB        2548           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.6 MiB      0.0 MiB        2548           if current == end:
    60    108.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.6 MiB      0.0 MiB       22923           for neighbor in current.neighbors:
    65    108.6 MiB      0.0 MiB       20376               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.6 MiB      0.0 MiB       10188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.6 MiB      0.0 MiB       10188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.6 MiB      0.0 MiB       20376               if temp_g_score < g_score[neighbor]:
    71    108.6 MiB      0.1 MiB        2966                   came_from[neighbor] = current
    72    108.6 MiB      0.0 MiB        2966                   g_score[neighbor] = temp_g_score
    73    108.6 MiB      0.0 MiB        2966                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.6 MiB      0.0 MiB        2966                   if neighbor not in open_set_hash:
    75    108.6 MiB      0.0 MiB        2966                       count += 1
    76    108.6 MiB      0.0 MiB        2966                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.6 MiB      0.0 MiB        2966                       open_set_hash.add(neighbor)
    78                                                             
    79    108.6 MiB      0.0 MiB        2547           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.6 MiB      0.0 MiB        2547           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.6 MiB    108.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.6 MiB      0.0 MiB         257       for row in grid:
    30    108.6 MiB      0.0 MiB       65792           for spot in row:
    31    108.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.6 MiB      0.0 MiB           1       count = 0
    34    108.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.6 MiB      0.0 MiB           1       came_from = {}
    37    110.7 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.0 MiB -68191.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.0 MiB  -5745.5 MiB        3304       while not open_set.empty():
    47    111.0 MiB  -5745.5 MiB        3304           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.0 MiB  -5745.5 MiB        3304           current = open_set.get()[2]
    53    111.0 MiB  -5745.5 MiB        3304           open_set_hash.remove(current)
    54                                         
    55    111.0 MiB  -5745.5 MiB        3304           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.0 MiB  -5745.5 MiB        3304           if current == end:
    60    107.3 MiB     -3.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.0 MiB -51693.3 MiB       29727           for neighbor in current.neighbors:
    65    111.0 MiB -45948.7 MiB       26424               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.0 MiB -22978.3 MiB       13212                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.0 MiB -22971.5 MiB       13212                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.0 MiB -45950.4 MiB       26424               if temp_g_score < g_score[neighbor]:
    71    111.0 MiB  -6562.6 MiB        3830                   came_from[neighbor] = current
    72    111.0 MiB  -6562.7 MiB        3830                   g_score[neighbor] = temp_g_score
    73    111.0 MiB  -6562.9 MiB        3830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.0 MiB  -6562.9 MiB        3830                   if neighbor not in open_set_hash:
    75    111.0 MiB  -6563.0 MiB        3830                       count += 1
    76    111.0 MiB  -6563.1 MiB        3830                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.0 MiB  -6563.2 MiB        3830                       open_set_hash.add(neighbor)
    78                                                             
    79    111.0 MiB  -5745.4 MiB        3303           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.0 MiB  -5745.5 MiB        3303           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.3 MiB    107.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.3 MiB  -1629.5 MiB         257       for row in grid:
    30    107.3 MiB -417892.8 MiB       65792           for spot in row:
    31    107.3 MiB -416270.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.0 MiB    -10.4 MiB           1       count = 0
    34     97.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.0 MiB      0.0 MiB           1       came_from = {}
    37     98.4 MiB -186612.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.5 MiB     -4.9 MiB           1       g_score[start] = 0
    39     96.2 MiB      2.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.2 MiB  -6405.8 MiB        3612       while not open_set.empty():
    47     96.2 MiB  -6405.8 MiB        3612           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.2 MiB  -6405.8 MiB        3612           current = open_set.get()[2]
    53     96.2 MiB  -6405.8 MiB        3612           open_set_hash.remove(current)
    54                                         
    55     96.2 MiB  -6405.8 MiB        3612           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.2 MiB  -6405.8 MiB        3612           if current == end:
    60     93.7 MiB     -2.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.2 MiB -57639.0 MiB       32499           for neighbor in current.neighbors:
    65     96.2 MiB -51233.9 MiB       28888               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.2 MiB -25619.1 MiB       14444                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.2 MiB -25615.4 MiB       14444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.2 MiB -51235.0 MiB       28888               if temp_g_score < g_score[neighbor]:
    71     96.2 MiB  -6925.0 MiB        3980                   came_from[neighbor] = current
    72     96.2 MiB  -6925.0 MiB        3980                   g_score[neighbor] = temp_g_score
    73     96.2 MiB  -6925.0 MiB        3980                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.2 MiB  -6925.1 MiB        3980                   if neighbor not in open_set_hash:
    75     96.2 MiB  -6925.1 MiB        3980                       count += 1
    76     96.2 MiB  -6925.1 MiB        3980                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.2 MiB  -6925.1 MiB        3980                       open_set_hash.add(neighbor)
    78                                                             
    79     96.2 MiB  -6405.6 MiB        3611           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.2 MiB  -6405.8 MiB        3611           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.4 MiB    103.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.4 MiB   -925.3 MiB         257       for row in grid:
    30    103.4 MiB -236992.3 MiB       65792           for spot in row:
    31    103.4 MiB -236070.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.2 MiB     -4.3 MiB           1       count = 0
    34     99.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.2 MiB      0.0 MiB           1       came_from = {}
    37    101.2 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.2 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.2 MiB  -2075.1 MiB        4850       while not open_set.empty():
    47    103.2 MiB  -2075.1 MiB        4850           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.2 MiB  -2076.1 MiB        4850           current = open_set.get()[2]
    53    103.2 MiB  -2076.1 MiB        4850           open_set_hash.remove(current)
    54                                         
    55    103.2 MiB  -2076.1 MiB        4850           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.2 MiB  -2076.1 MiB        4850           if current == end:
    60     97.1 MiB     -6.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.2 MiB -18649.8 MiB       43641           for neighbor in current.neighbors:
    65    103.2 MiB -16575.2 MiB       38792               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.2 MiB  -8293.6 MiB       19396                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.2 MiB  -8282.0 MiB       19396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.2 MiB -16576.2 MiB       38792               if temp_g_score < g_score[neighbor]:
    71    103.2 MiB  -2355.5 MiB        5242                   came_from[neighbor] = current
    72    103.2 MiB  -2355.5 MiB        5242                   g_score[neighbor] = temp_g_score
    73    103.2 MiB  -2356.0 MiB        5242                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.2 MiB  -2356.0 MiB        5242                   if neighbor not in open_set_hash:
    75    103.2 MiB  -2356.2 MiB        5242                       count += 1
    76    103.2 MiB  -2358.0 MiB        5242                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.2 MiB  -2358.0 MiB        5242                       open_set_hash.add(neighbor)
    78                                                             
    79    103.2 MiB  -2075.1 MiB        4849           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.2 MiB  -2075.1 MiB        4849           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.1 MiB     97.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.1 MiB  -6389.4 MiB         257       for row in grid:
    30     97.1 MiB -1635779.1 MiB       65792           for spot in row:
    31     97.1 MiB -1629417.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.1 MiB    -37.0 MiB           1       count = 0
    34     60.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.2 MiB      0.0 MiB           1       came_from = {}
    37     64.8 MiB    -80.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.8 MiB     -0.0 MiB           1       g_score[start] = 0
    39     68.7 MiB   -284.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.8 MiB -25925.2 MiB        4970       while not open_set.empty():
    47     68.8 MiB -25926.8 MiB        4970           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.8 MiB -25927.3 MiB        4970           current = open_set.get()[2]
    53     68.8 MiB -25928.1 MiB        4970           open_set_hash.remove(current)
    54                                         
    55     68.8 MiB -25928.4 MiB        4970           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.8 MiB -25928.6 MiB        4970           if current == end:
    60     42.8 MiB    -26.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     43.3 MiB      0.6 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.8 MiB -233199.8 MiB       44721           for neighbor in current.neighbors:
    65     68.8 MiB -207278.8 MiB       39752               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.8 MiB -103661.7 MiB       19876                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.8 MiB -103623.8 MiB       19876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.8 MiB -207289.3 MiB       39752               if temp_g_score < g_score[neighbor]:
    71     68.8 MiB -27674.0 MiB        5392                   came_from[neighbor] = current
    72     68.8 MiB -27674.5 MiB        5392                   g_score[neighbor] = temp_g_score
    73     68.8 MiB -27675.7 MiB        5392                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.8 MiB -27676.1 MiB        5392                   if neighbor not in open_set_hash:
    75     68.8 MiB -27677.0 MiB        5392                       count += 1
    76     68.8 MiB -27678.0 MiB        5392                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.8 MiB -27678.0 MiB        5392                       open_set_hash.add(neighbor)
    78                                                             
    79     68.8 MiB -25924.6 MiB        4969           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.8 MiB -25924.8 MiB        4969           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     48.7 MiB     48.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     51.3 MiB  -1607.0 MiB         257       for row in grid:
    30     51.3 MiB -413418.1 MiB       65792           for spot in row:
    31     51.3 MiB -412015.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     51.3 MiB      0.0 MiB           1       count = 0
    34     51.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     51.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     51.7 MiB      0.0 MiB           1       came_from = {}
    37     53.3 MiB -164236.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     49.6 MiB     -3.6 MiB           1       g_score[start] = 0
    39     53.5 MiB -22057.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     53.7 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     53.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     53.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     53.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     54.3 MiB      0.0 MiB         324       while not open_set.empty():
    47     54.3 MiB      0.0 MiB         324           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     54.3 MiB      0.0 MiB         324           current = open_set.get()[2]
    53     54.3 MiB      0.0 MiB         324           open_set_hash.remove(current)
    54                                         
    55     54.3 MiB      0.0 MiB         324           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     54.3 MiB      0.0 MiB         324           if current == end:
    60     54.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     54.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     54.3 MiB      0.4 MiB        2907           for neighbor in current.neighbors:
    65     54.3 MiB      0.0 MiB        2584               if current.row != neighbor.row and current.col != neighbor.col:
    66     54.3 MiB      0.0 MiB        1292                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     54.3 MiB      0.0 MiB        1292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     54.3 MiB      0.0 MiB        2584               if temp_g_score < g_score[neighbor]:
    71     54.3 MiB      0.0 MiB         500                   came_from[neighbor] = current
    72     54.3 MiB      0.0 MiB         500                   g_score[neighbor] = temp_g_score
    73     54.3 MiB      0.0 MiB         500                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     54.3 MiB      0.0 MiB         500                   if neighbor not in open_set_hash:
    75     54.3 MiB      0.0 MiB         500                       count += 1
    76     54.3 MiB      0.1 MiB         500                       open_set.put((f_score[neighbor], count, neighbor))
    77     54.3 MiB      0.0 MiB         500                       open_set_hash.add(neighbor)
    78                                                             
    79     54.3 MiB      0.0 MiB         323           if draw is not None:
    80                                                     draw()
    81                                         
    82     54.3 MiB      0.0 MiB         323           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     54.5 MiB     54.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     57.3 MiB   -314.5 MiB         257       for row in grid:
    30     57.3 MiB -80179.0 MiB       65792           for spot in row:
    31     57.3 MiB -79867.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     51.6 MiB     -5.7 MiB           1       count = 0
    34     51.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     51.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     51.7 MiB      0.0 MiB           1       came_from = {}
    37     54.7 MiB -10562.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     54.1 MiB     -0.6 MiB           1       g_score[start] = 0
    39     58.3 MiB   -431.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     58.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     58.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     58.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     58.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     58.4 MiB    -17.3 MiB        1551       while not open_set.empty():
    47     58.4 MiB    -17.3 MiB        1551           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     58.4 MiB    -17.3 MiB        1551           current = open_set.get()[2]
    53     58.4 MiB    -17.3 MiB        1551           open_set_hash.remove(current)
    54                                         
    55     58.4 MiB    -17.3 MiB        1551           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     58.4 MiB    -17.3 MiB        1551           if current == end:
    60     58.4 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     58.4 MiB   -155.5 MiB       13950           for neighbor in current.neighbors:
    65     58.4 MiB   -138.2 MiB       12400               if current.row != neighbor.row and current.col != neighbor.col:
    66     58.4 MiB    -69.1 MiB        6200                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     58.4 MiB    -69.1 MiB        6200                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     58.4 MiB   -138.2 MiB       12400               if temp_g_score < g_score[neighbor]:
    71     58.4 MiB    -19.3 MiB        1803                   came_from[neighbor] = current
    72     58.4 MiB    -19.3 MiB        1803                   g_score[neighbor] = temp_g_score
    73     58.4 MiB    -19.3 MiB        1803                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     58.4 MiB    -19.3 MiB        1803                   if neighbor not in open_set_hash:
    75     58.4 MiB    -19.3 MiB        1803                       count += 1
    76     58.4 MiB    -19.2 MiB        1803                       open_set.put((f_score[neighbor], count, neighbor))
    77     58.4 MiB    -19.2 MiB        1803                       open_set_hash.add(neighbor)
    78                                                             
    79     58.4 MiB    -17.3 MiB        1550           if draw is not None:
    80                                                     draw()
    81                                         
    82     58.4 MiB    -17.3 MiB        1550           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     58.5 MiB     58.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.8 MiB      0.0 MiB         257       for row in grid:
    30     58.8 MiB      0.0 MiB       65792           for spot in row:
    31     58.8 MiB      0.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.8 MiB      0.0 MiB           1       count = 0
    34     58.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.8 MiB      0.0 MiB           1       came_from = {}
    37     59.3 MiB -148504.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.4 MiB     -1.9 MiB           1       g_score[start] = 0
    39     61.5 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.5 MiB   -657.4 MiB         721       while not open_set.empty():
    47     61.5 MiB   -657.4 MiB         721           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.5 MiB   -657.6 MiB         721           current = open_set.get()[2]
    53     61.5 MiB   -657.6 MiB         721           open_set_hash.remove(current)
    54                                         
    55     61.5 MiB   -657.6 MiB         721           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.5 MiB   -657.6 MiB         721           if current == end:
    60     60.5 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.5 MiB  -5916.7 MiB        6480           for neighbor in current.neighbors:
    65     61.5 MiB  -5259.5 MiB        5760               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.5 MiB  -2629.8 MiB        2880                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.5 MiB  -2629.9 MiB        2880                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.5 MiB  -5259.7 MiB        5760               if temp_g_score < g_score[neighbor]:
    71     61.5 MiB   -848.1 MiB         953                   came_from[neighbor] = current
    72     61.5 MiB   -848.1 MiB         953                   g_score[neighbor] = temp_g_score
    73     61.5 MiB   -848.1 MiB         953                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.5 MiB   -848.1 MiB         953                   if neighbor not in open_set_hash:
    75     61.5 MiB   -848.1 MiB         953                       count += 1
    76     61.5 MiB   -848.1 MiB         953                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.5 MiB   -848.1 MiB         953                       open_set_hash.add(neighbor)
    78                                                             
    79     61.5 MiB   -657.4 MiB         720           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.5 MiB   -657.4 MiB         720           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.6 MiB     96.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.6 MiB   -723.1 MiB         257       for row in grid:
    30     96.6 MiB -184692.8 MiB       65792           for spot in row:
    31     96.6 MiB -183973.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.2 MiB     -7.4 MiB           1       count = 0
    34     89.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     89.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     89.2 MiB      0.0 MiB           1       came_from = {}
    37     92.0 MiB -11986.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.6 MiB      4.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.6 MiB      0.0 MiB        1638       while not open_set.empty():
    47     96.6 MiB      0.0 MiB        1638           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.6 MiB      0.0 MiB        1638           current = open_set.get()[2]
    53     96.6 MiB      0.0 MiB        1638           open_set_hash.remove(current)
    54                                         
    55     96.6 MiB      0.0 MiB        1638           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.6 MiB      0.0 MiB        1638           if current == end:
    60     96.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.6 MiB      0.0 MiB       14733           for neighbor in current.neighbors:
    65     96.6 MiB      0.0 MiB       13096               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.6 MiB      0.0 MiB        6548                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.6 MiB      0.0 MiB        6548                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.6 MiB      0.0 MiB       13096               if temp_g_score < g_score[neighbor]:
    71     96.6 MiB      0.0 MiB        1866                   came_from[neighbor] = current
    72     96.6 MiB      0.0 MiB        1866                   g_score[neighbor] = temp_g_score
    73     96.6 MiB      0.0 MiB        1866                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.6 MiB      0.0 MiB        1866                   if neighbor not in open_set_hash:
    75     96.6 MiB      0.0 MiB        1866                       count += 1
    76     96.6 MiB      0.0 MiB        1866                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.6 MiB      0.0 MiB        1866                       open_set_hash.add(neighbor)
    78                                                             
    79     96.6 MiB      0.0 MiB        1637           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.6 MiB      0.0 MiB        1637           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.7 MiB     96.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.9 MiB      0.0 MiB         257       for row in grid:
    30     96.9 MiB      0.0 MiB       65792           for spot in row:
    31     96.9 MiB      0.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.9 MiB      0.0 MiB           1       count = 0
    34     96.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.9 MiB      0.0 MiB           1       came_from = {}
    37     99.8 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.1 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.1 MiB      0.0 MiB        1026       while not open_set.empty():
    47    102.1 MiB      0.0 MiB        1026           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.1 MiB      0.0 MiB        1026           current = open_set.get()[2]
    53    102.1 MiB      0.0 MiB        1026           open_set_hash.remove(current)
    54                                         
    55    102.1 MiB      0.0 MiB        1026           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.1 MiB      0.0 MiB        1026           if current == end:
    60    102.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.1 MiB      0.0 MiB        9225           for neighbor in current.neighbors:
    65    102.1 MiB      0.0 MiB        8200               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.1 MiB      0.0 MiB        4100                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.1 MiB      0.0 MiB        4100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.1 MiB      0.0 MiB        8200               if temp_g_score < g_score[neighbor]:
    71    102.1 MiB      0.0 MiB        1288                   came_from[neighbor] = current
    72    102.1 MiB      0.0 MiB        1288                   g_score[neighbor] = temp_g_score
    73    102.1 MiB      0.0 MiB        1288                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.1 MiB      0.0 MiB        1288                   if neighbor not in open_set_hash:
    75    102.1 MiB      0.0 MiB        1288                       count += 1
    76    102.1 MiB      0.0 MiB        1288                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.1 MiB      0.0 MiB        1288                       open_set_hash.add(neighbor)
    78                                                             
    79    102.1 MiB      0.0 MiB        1025           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.1 MiB      0.0 MiB        1025           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.1 MiB    102.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.1 MiB      0.0 MiB         257       for row in grid:
    30    102.1 MiB      0.0 MiB       65792           for spot in row:
    31    102.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.1 MiB      0.0 MiB           1       count = 0
    34    102.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.1 MiB      0.0 MiB           1       came_from = {}
    37    103.6 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.3 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.3 MiB   -658.4 MiB        5130       while not open_set.empty():
    47    104.3 MiB   -658.4 MiB        5130           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.3 MiB   -658.4 MiB        5130           current = open_set.get()[2]
    53    104.3 MiB   -658.4 MiB        5130           open_set_hash.remove(current)
    54                                         
    55    104.3 MiB   -658.4 MiB        5130           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.3 MiB   -658.4 MiB        5130           if current == end:
    60    104.2 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.3 MiB  -5926.6 MiB       46161           for neighbor in current.neighbors:
    65    104.3 MiB  -5268.2 MiB       41032               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.3 MiB  -2634.3 MiB       20516                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.3 MiB  -2634.1 MiB       20516                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.3 MiB  -5268.5 MiB       41032               if temp_g_score < g_score[neighbor]:
    71    104.3 MiB   -695.6 MiB        5550                   came_from[neighbor] = current
    72    104.3 MiB   -695.6 MiB        5550                   g_score[neighbor] = temp_g_score
    73    104.3 MiB   -695.6 MiB        5550                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.3 MiB   -695.6 MiB        5550                   if neighbor not in open_set_hash:
    75    104.3 MiB   -695.6 MiB        5550                       count += 1
    76    104.3 MiB   -695.6 MiB        5550                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.3 MiB   -695.6 MiB        5550                       open_set_hash.add(neighbor)
    78                                                             
    79    104.3 MiB   -658.4 MiB        5129           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.3 MiB   -658.4 MiB        5129           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.2 MiB    104.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.2 MiB    -18.3 MiB         257       for row in grid:
    30    104.2 MiB  -4663.8 MiB       65792           for spot in row:
    31    104.2 MiB  -4645.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.0 MiB     -0.2 MiB           1       count = 0
    34    104.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.0 MiB      0.0 MiB           1       came_from = {}
    37    105.0 MiB -487169.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.6 MiB    -13.4 MiB           1       g_score[start] = 0
    39     93.5 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.5 MiB      0.0 MiB        1050       while not open_set.empty():
    47     93.5 MiB      0.0 MiB        1050           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.5 MiB      0.0 MiB        1050           current = open_set.get()[2]
    53     93.5 MiB      0.0 MiB        1050           open_set_hash.remove(current)
    54                                         
    55     93.5 MiB      0.0 MiB        1050           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.5 MiB      0.0 MiB        1050           if current == end:
    60     93.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.5 MiB      0.0 MiB        9441           for neighbor in current.neighbors:
    65     93.5 MiB      0.0 MiB        8392               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.5 MiB      0.0 MiB        4196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.5 MiB      0.0 MiB        4196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.5 MiB      0.0 MiB        8392               if temp_g_score < g_score[neighbor]:
    71     93.5 MiB      0.0 MiB        1248                   came_from[neighbor] = current
    72     93.5 MiB      0.0 MiB        1248                   g_score[neighbor] = temp_g_score
    73     93.5 MiB      0.0 MiB        1248                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.5 MiB      0.0 MiB        1248                   if neighbor not in open_set_hash:
    75     93.5 MiB      0.0 MiB        1248                       count += 1
    76     93.5 MiB      0.0 MiB        1248                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.5 MiB      0.0 MiB        1248                       open_set_hash.add(neighbor)
    78                                                             
    79     93.5 MiB      0.0 MiB        1049           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.5 MiB      0.0 MiB        1049           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.5 MiB     93.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.5 MiB    -11.4 MiB         257       for row in grid:
    30     93.5 MiB  -2913.9 MiB       65792           for spot in row:
    31     93.5 MiB  -2902.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.5 MiB     -0.0 MiB           1       count = 0
    34     93.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.5 MiB      0.0 MiB           1       came_from = {}
    37     96.4 MiB  -8877.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.9 MiB   -615.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.8 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.8 MiB    -76.2 MiB        2755       while not open_set.empty():
    47     98.8 MiB    -76.2 MiB        2755           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.8 MiB    -76.2 MiB        2755           current = open_set.get()[2]
    53     98.8 MiB    -76.2 MiB        2755           open_set_hash.remove(current)
    54                                         
    55     98.8 MiB    -76.2 MiB        2755           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.8 MiB    -76.2 MiB        2755           if current == end:
    60     98.7 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.8 MiB   -685.3 MiB       24786           for neighbor in current.neighbors:
    65     98.8 MiB   -609.1 MiB       22032               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.8 MiB   -304.7 MiB       11016                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.8 MiB   -304.5 MiB       11016                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.8 MiB   -609.2 MiB       22032               if temp_g_score < g_score[neighbor]:
    71     98.8 MiB    -83.8 MiB        3059                   came_from[neighbor] = current
    72     98.8 MiB    -83.8 MiB        3059                   g_score[neighbor] = temp_g_score
    73     98.8 MiB    -83.9 MiB        3059                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.8 MiB    -83.9 MiB        3059                   if neighbor not in open_set_hash:
    75     98.8 MiB    -83.9 MiB        3059                       count += 1
    76     98.8 MiB    -83.9 MiB        3059                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.8 MiB    -83.9 MiB        3059                       open_set_hash.add(neighbor)
    78                                                             
    79     98.8 MiB    -76.2 MiB        2754           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.8 MiB    -76.2 MiB        2754           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.3 MiB    103.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.3 MiB      0.0 MiB         257       for row in grid:
    30    103.3 MiB      0.0 MiB       65792           for spot in row:
    31    103.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.3 MiB      0.0 MiB           1       count = 0
    34    103.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.3 MiB      0.0 MiB           1       came_from = {}
    37    103.3 MiB  -7182.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.8 MiB     -0.5 MiB           1       g_score[start] = 0
    39    104.5 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.5 MiB  -3368.4 MiB        1792       while not open_set.empty():
    47    104.5 MiB  -3368.4 MiB        1792           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.5 MiB  -3368.4 MiB        1792           current = open_set.get()[2]
    53    104.5 MiB  -3368.4 MiB        1792           open_set_hash.remove(current)
    54                                         
    55    104.5 MiB  -3368.4 MiB        1792           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.5 MiB  -3368.4 MiB        1792           if current == end:
    60    101.1 MiB     -3.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.5 MiB -30293.2 MiB       16119           for neighbor in current.neighbors:
    65    104.5 MiB -26925.7 MiB       14328               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.5 MiB -13466.0 MiB        7164                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.5 MiB -13460.1 MiB        7164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.5 MiB -26926.3 MiB       14328               if temp_g_score < g_score[neighbor]:
    71    104.5 MiB  -3841.8 MiB        2102                   came_from[neighbor] = current
    72    104.5 MiB  -3841.8 MiB        2102                   g_score[neighbor] = temp_g_score
    73    104.5 MiB  -3842.2 MiB        2102                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.5 MiB  -3842.4 MiB        2102                   if neighbor not in open_set_hash:
    75    104.5 MiB  -3842.5 MiB        2102                       count += 1
    76    104.5 MiB  -3842.9 MiB        2102                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.5 MiB  -3843.4 MiB        2102                       open_set_hash.add(neighbor)
    78                                                             
    79    104.5 MiB  -3368.3 MiB        1791           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.5 MiB  -3368.4 MiB        1791           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.1 MiB    101.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.1 MiB   -488.4 MiB         257       for row in grid:
    30    101.1 MiB -125016.4 MiB       65792           for spot in row:
    31    101.1 MiB -124529.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.7 MiB     -2.4 MiB           1       count = 0
    34     98.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.7 MiB      0.0 MiB           1       came_from = {}
    37    100.4 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.2 MiB  -4127.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.2 MiB      0.0 MiB        2862       while not open_set.empty():
    47    103.2 MiB      0.0 MiB        2862           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.2 MiB      0.0 MiB        2862           current = open_set.get()[2]
    53    103.2 MiB      0.0 MiB        2862           open_set_hash.remove(current)
    54                                         
    55    103.2 MiB      0.0 MiB        2862           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.2 MiB      0.0 MiB        2862           if current == end:
    60    103.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.2 MiB      0.0 MiB       25749           for neighbor in current.neighbors:
    65    103.2 MiB      0.0 MiB       22888               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.2 MiB      0.0 MiB       11444                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.2 MiB      0.0 MiB       11444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.2 MiB      0.0 MiB       22888               if temp_g_score < g_score[neighbor]:
    71    103.2 MiB      0.0 MiB        3182                   came_from[neighbor] = current
    72    103.2 MiB      0.0 MiB        3182                   g_score[neighbor] = temp_g_score
    73    103.2 MiB      0.0 MiB        3182                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.2 MiB      0.0 MiB        3182                   if neighbor not in open_set_hash:
    75    103.2 MiB      0.0 MiB        3182                       count += 1
    76    103.2 MiB      0.0 MiB        3182                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.2 MiB      0.0 MiB        3182                       open_set_hash.add(neighbor)
    78                                                             
    79    103.2 MiB      0.0 MiB        2861           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.2 MiB      0.0 MiB        2861           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.2 MiB    103.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.2 MiB   -521.5 MiB         257       for row in grid:
    30    103.2 MiB -133136.8 MiB       65792           for spot in row:
    31    103.2 MiB -132618.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.5 MiB     -4.7 MiB           1       count = 0
    34     98.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.5 MiB      0.0 MiB           1       came_from = {}
    37    101.3 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.1 MiB   -426.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.1 MiB      0.0 MiB        2080       while not open_set.empty():
    47    104.1 MiB      0.0 MiB        2080           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.1 MiB      0.0 MiB        2080           current = open_set.get()[2]
    53    104.1 MiB      0.0 MiB        2080           open_set_hash.remove(current)
    54                                         
    55    104.1 MiB      0.0 MiB        2080           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.1 MiB      0.0 MiB        2080           if current == end:
    60    104.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.1 MiB      0.0 MiB       18711           for neighbor in current.neighbors:
    65    104.1 MiB      0.0 MiB       16632               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.1 MiB      0.0 MiB        8316                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.1 MiB      0.0 MiB        8316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.1 MiB      0.0 MiB       16632               if temp_g_score < g_score[neighbor]:
    71    104.1 MiB      0.0 MiB        2342                   came_from[neighbor] = current
    72    104.1 MiB      0.0 MiB        2342                   g_score[neighbor] = temp_g_score
    73    104.1 MiB      0.0 MiB        2342                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.1 MiB      0.0 MiB        2342                   if neighbor not in open_set_hash:
    75    104.1 MiB      0.0 MiB        2342                       count += 1
    76    104.1 MiB      0.0 MiB        2342                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.1 MiB      0.0 MiB        2342                       open_set_hash.add(neighbor)
    78                                                             
    79    104.1 MiB      0.0 MiB        2079           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.1 MiB      0.0 MiB        2079           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.1 MiB    104.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.1 MiB      0.0 MiB         257       for row in grid:
    30    104.1 MiB      0.0 MiB       65792           for spot in row:
    31    104.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.1 MiB      0.0 MiB           1       count = 0
    34    104.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.1 MiB      0.0 MiB           1       came_from = {}
    37    104.7 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.2 MiB  -3099.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.2 MiB      0.0 MiB          55       while not open_set.empty():
    47    107.2 MiB      0.0 MiB          55           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.2 MiB      0.0 MiB          55           current = open_set.get()[2]
    53    107.2 MiB      0.0 MiB          55           open_set_hash.remove(current)
    54                                         
    55    107.2 MiB      0.0 MiB          55           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.2 MiB      0.0 MiB          55           if current == end:
    60    107.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.2 MiB      0.0 MiB         486           for neighbor in current.neighbors:
    65    107.2 MiB      0.0 MiB         432               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.2 MiB      0.0 MiB         216                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.2 MiB      0.0 MiB         216                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.2 MiB      0.0 MiB         432               if temp_g_score < g_score[neighbor]:
    71    107.2 MiB      0.0 MiB         167                   came_from[neighbor] = current
    72    107.2 MiB      0.0 MiB         167                   g_score[neighbor] = temp_g_score
    73    107.2 MiB      0.0 MiB         167                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.2 MiB      0.0 MiB         167                   if neighbor not in open_set_hash:
    75    107.2 MiB      0.0 MiB         167                       count += 1
    76    107.2 MiB      0.0 MiB         167                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.2 MiB      0.0 MiB         167                       open_set_hash.add(neighbor)
    78                                                             
    79    107.2 MiB      0.0 MiB          54           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.2 MiB      0.0 MiB          54           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.2 MiB    107.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.2 MiB   -374.3 MiB         257       for row in grid:
    30    107.2 MiB -95915.1 MiB       65792           for spot in row:
    31    107.2 MiB -95542.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.4 MiB     -1.8 MiB           1       count = 0
    34    105.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.4 MiB      0.0 MiB           1       came_from = {}
    37    105.4 MiB -114864.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.9 MiB     -7.5 MiB           1       g_score[start] = 0
    39     98.7 MiB -64929.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.8 MiB      0.0 MiB         234       while not open_set.empty():
    47     98.8 MiB      0.0 MiB         234           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.8 MiB      0.0 MiB         234           current = open_set.get()[2]
    53     98.8 MiB      0.0 MiB         234           open_set_hash.remove(current)
    54                                         
    55     98.8 MiB      0.0 MiB         234           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.8 MiB      0.0 MiB         234           if current == end:
    60     98.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.8 MiB      0.0 MiB        2097           for neighbor in current.neighbors:
    65     98.8 MiB      0.0 MiB        1864               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.8 MiB      0.0 MiB         932                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.8 MiB      0.0 MiB         932                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.8 MiB      0.0 MiB        1864               if temp_g_score < g_score[neighbor]:
    71     98.8 MiB      0.0 MiB         334                   came_from[neighbor] = current
    72     98.8 MiB      0.0 MiB         334                   g_score[neighbor] = temp_g_score
    73     98.8 MiB      0.0 MiB         334                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.8 MiB      0.0 MiB         334                   if neighbor not in open_set_hash:
    75     98.8 MiB      0.0 MiB         334                       count += 1
    76     98.8 MiB      0.0 MiB         334                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.8 MiB      0.0 MiB         334                       open_set_hash.add(neighbor)
    78                                                             
    79     98.8 MiB      0.0 MiB         233           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.8 MiB      0.0 MiB         233           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.5 MiB    104.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.5 MiB      0.0 MiB         257       for row in grid:
    30    104.5 MiB      0.0 MiB       65792           for spot in row:
    31    104.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.5 MiB      0.0 MiB           1       count = 0
    34    104.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.5 MiB      0.0 MiB           1       came_from = {}
    37    107.6 MiB -51225.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.1 MiB     -2.5 MiB           1       g_score[start] = 0
    39    106.9 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.9 MiB      0.0 MiB        1133       while not open_set.empty():
    47    106.9 MiB      0.0 MiB        1133           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.9 MiB      0.0 MiB        1133           current = open_set.get()[2]
    53    106.9 MiB      0.0 MiB        1133           open_set_hash.remove(current)
    54                                         
    55    106.9 MiB      0.0 MiB        1133           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.9 MiB      0.0 MiB        1133           if current == end:
    60    106.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.9 MiB      0.0 MiB       10188           for neighbor in current.neighbors:
    65    106.9 MiB      0.0 MiB        9056               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.9 MiB      0.0 MiB        4528                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.9 MiB      0.0 MiB        4528                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.9 MiB      0.0 MiB        9056               if temp_g_score < g_score[neighbor]:
    71    106.9 MiB      0.0 MiB        1381                   came_from[neighbor] = current
    72    106.9 MiB      0.0 MiB        1381                   g_score[neighbor] = temp_g_score
    73    106.9 MiB      0.0 MiB        1381                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.9 MiB      0.0 MiB        1381                   if neighbor not in open_set_hash:
    75    106.9 MiB      0.0 MiB        1381                       count += 1
    76    106.9 MiB      0.0 MiB        1381                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.9 MiB      0.0 MiB        1381                       open_set_hash.add(neighbor)
    78                                                             
    79    106.9 MiB      0.0 MiB        1132           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.9 MiB      0.0 MiB        1132           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.9 MiB    106.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.9 MiB   -282.8 MiB         257       for row in grid:
    30    106.9 MiB -72397.0 MiB       65792           for spot in row:
    31    106.9 MiB -72116.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.6 MiB     -4.3 MiB           1       count = 0
    34    102.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.6 MiB      0.0 MiB           1       came_from = {}
    37    105.7 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.9 MiB -52036.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.9 MiB   -751.2 MiB        4692       while not open_set.empty():
    47    106.9 MiB   -751.2 MiB        4692           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.9 MiB   -751.2 MiB        4692           current = open_set.get()[2]
    53    106.9 MiB   -751.2 MiB        4692           open_set_hash.remove(current)
    54                                         
    55    106.9 MiB   -751.2 MiB        4692           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.9 MiB   -751.2 MiB        4692           if current == end:
    60    106.2 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.9 MiB  -6755.5 MiB       42219           for neighbor in current.neighbors:
    65    106.9 MiB  -6004.6 MiB       37528               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.9 MiB  -3002.8 MiB       18764                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.9 MiB  -3001.9 MiB       18764                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.9 MiB  -6005.0 MiB       37528               if temp_g_score < g_score[neighbor]:
    71    106.9 MiB   -811.6 MiB        5160                   came_from[neighbor] = current
    72    106.9 MiB   -811.6 MiB        5160                   g_score[neighbor] = temp_g_score
    73    106.9 MiB   -811.6 MiB        5160                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.9 MiB   -811.6 MiB        5160                   if neighbor not in open_set_hash:
    75    106.9 MiB   -811.6 MiB        5160                       count += 1
    76    106.9 MiB   -811.6 MiB        5160                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.9 MiB   -811.6 MiB        5160                       open_set_hash.add(neighbor)
    78                                                             
    79    106.9 MiB   -751.2 MiB        4691           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.9 MiB   -751.2 MiB        4691           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB    -59.3 MiB         257       for row in grid:
    30    106.2 MiB -15007.4 MiB       65792           for spot in row:
    31    106.2 MiB -14948.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.4 MiB     -1.8 MiB           1       count = 0
    34    104.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.4 MiB      0.0 MiB           1       came_from = {}
    37    104.5 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.4 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.5 MiB   -937.6 MiB        4876       while not open_set.empty():
    47    105.5 MiB   -937.6 MiB        4876           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.5 MiB   -937.6 MiB        4876           current = open_set.get()[2]
    53    105.5 MiB   -937.6 MiB        4876           open_set_hash.remove(current)
    54                                         
    55    105.5 MiB   -937.6 MiB        4876           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.5 MiB   -937.6 MiB        4876           if current == end:
    60    104.0 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.5 MiB  -8436.1 MiB       43875           for neighbor in current.neighbors:
    65    105.5 MiB  -7498.7 MiB       39000               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.5 MiB  -3750.3 MiB       19500                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.5 MiB  -3748.5 MiB       19500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.5 MiB  -7499.0 MiB       39000               if temp_g_score < g_score[neighbor]:
    71    105.5 MiB  -1038.5 MiB        5390                   came_from[neighbor] = current
    72    105.5 MiB  -1038.6 MiB        5390                   g_score[neighbor] = temp_g_score
    73    105.5 MiB  -1038.6 MiB        5390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.5 MiB  -1038.6 MiB        5390                   if neighbor not in open_set_hash:
    75    105.5 MiB  -1038.6 MiB        5390                       count += 1
    76    105.5 MiB  -1038.6 MiB        5390                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.5 MiB  -1038.5 MiB        5390                       open_set_hash.add(neighbor)
    78                                                             
    79    105.5 MiB   -937.6 MiB        4875           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.5 MiB   -937.6 MiB        4875           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.0 MiB    104.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.0 MiB      0.0 MiB         257       for row in grid:
    30    104.0 MiB      0.0 MiB       65792           for spot in row:
    31    104.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.0 MiB      0.0 MiB           1       count = 0
    34    104.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.0 MiB      0.0 MiB           1       came_from = {}
    37    104.8 MiB -74566.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.0 MiB     -1.8 MiB           1       g_score[start] = 0
    39    104.5 MiB      1.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.5 MiB   -441.0 MiB        1552       while not open_set.empty():
    47    104.5 MiB   -441.0 MiB        1552           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.5 MiB   -441.0 MiB        1552           current = open_set.get()[2]
    53    104.5 MiB   -441.0 MiB        1552           open_set_hash.remove(current)
    54                                         
    55    104.5 MiB   -441.0 MiB        1552           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.5 MiB   -441.0 MiB        1552           if current == end:
    60    100.6 MiB     -3.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.5 MiB  -3961.4 MiB       13959           for neighbor in current.neighbors:
    65    104.5 MiB  -3521.0 MiB       12408               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.5 MiB  -1764.0 MiB        6204                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.5 MiB  -1757.4 MiB        6204                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.5 MiB  -3524.1 MiB       12408               if temp_g_score < g_score[neighbor]:
    71    104.5 MiB   -543.4 MiB        1808                   came_from[neighbor] = current
    72    104.5 MiB   -543.4 MiB        1808                   g_score[neighbor] = temp_g_score
    73    104.5 MiB   -543.4 MiB        1808                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.5 MiB   -543.4 MiB        1808                   if neighbor not in open_set_hash:
    75    104.5 MiB   -543.4 MiB        1808                       count += 1
    76    104.5 MiB   -543.4 MiB        1808                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.5 MiB   -543.4 MiB        1808                       open_set_hash.add(neighbor)
    78                                                             
    79    104.5 MiB   -441.0 MiB        1551           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.5 MiB   -441.0 MiB        1551           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.6 MiB    100.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.6 MiB      0.0 MiB         257       for row in grid:
    30    100.6 MiB      0.0 MiB       65792           for spot in row:
    31    100.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.6 MiB      0.0 MiB           1       count = 0
    34    100.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.6 MiB      0.0 MiB           1       came_from = {}
    37    102.0 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.3 MiB -305756.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.5 MiB     -5.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.6 MiB      0.0 MiB        4464       while not open_set.empty():
    47     96.6 MiB      0.0 MiB        4464           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.6 MiB      0.0 MiB        4464           current = open_set.get()[2]
    53     96.6 MiB      0.0 MiB        4464           open_set_hash.remove(current)
    54                                         
    55     96.6 MiB      0.0 MiB        4464           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.6 MiB      0.0 MiB        4464           if current == end:
    60     96.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.6 MiB      0.0 MiB       40167           for neighbor in current.neighbors:
    65     96.6 MiB      0.0 MiB       35704               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.6 MiB      0.0 MiB       17852                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.6 MiB      0.0 MiB       17852                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.6 MiB      0.0 MiB       35704               if temp_g_score < g_score[neighbor]:
    71     96.6 MiB      0.0 MiB        4874                   came_from[neighbor] = current
    72     96.6 MiB      0.0 MiB        4874                   g_score[neighbor] = temp_g_score
    73     96.6 MiB      0.0 MiB        4874                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.6 MiB      0.0 MiB        4874                   if neighbor not in open_set_hash:
    75     96.6 MiB      0.0 MiB        4874                       count += 1
    76     96.6 MiB      0.0 MiB        4874                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.6 MiB      0.0 MiB        4874                       open_set_hash.add(neighbor)
    78                                                             
    79     96.6 MiB      0.0 MiB        4463           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.6 MiB      0.0 MiB        4463           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.6 MiB    102.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.6 MiB   -431.4 MiB         257       for row in grid:
    30    102.6 MiB -110713.6 MiB       65792           for spot in row:
    31    102.6 MiB -110283.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.7 MiB     -1.9 MiB           1       count = 0
    34    100.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.7 MiB      0.0 MiB           1       came_from = {}
    37    103.0 MiB -12122.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.8 MiB     -1.3 MiB           1       g_score[start] = 0
    39    101.9 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.9 MiB      0.0 MiB        1457       while not open_set.empty():
    47    101.9 MiB      0.0 MiB        1457           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.9 MiB      0.0 MiB        1457           current = open_set.get()[2]
    53    101.9 MiB      0.0 MiB        1457           open_set_hash.remove(current)
    54                                         
    55    101.9 MiB      0.0 MiB        1457           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.9 MiB      0.0 MiB        1457           if current == end:
    60    101.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.9 MiB      0.0 MiB       13104           for neighbor in current.neighbors:
    65    101.9 MiB      0.0 MiB       11648               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.9 MiB      0.0 MiB        5824                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.9 MiB      0.0 MiB        5824                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.9 MiB      0.0 MiB       11648               if temp_g_score < g_score[neighbor]:
    71    101.9 MiB      0.0 MiB        1673                   came_from[neighbor] = current
    72    101.9 MiB      0.0 MiB        1673                   g_score[neighbor] = temp_g_score
    73    101.9 MiB      0.0 MiB        1673                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.9 MiB      0.0 MiB        1673                   if neighbor not in open_set_hash:
    75    101.9 MiB      0.0 MiB        1673                       count += 1
    76    101.9 MiB      0.0 MiB        1673                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.9 MiB      0.0 MiB        1673                       open_set_hash.add(neighbor)
    78                                                             
    79    101.9 MiB      0.0 MiB        1456           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.9 MiB      0.0 MiB        1456           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.9 MiB    101.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.9 MiB      0.0 MiB         257       for row in grid:
    30    101.9 MiB      0.0 MiB       65792           for spot in row:
    31    101.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.9 MiB      0.0 MiB           1       count = 0
    34    101.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.9 MiB      0.0 MiB           1       came_from = {}
    37    102.1 MiB -11562.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.0 MiB     -0.1 MiB           1       g_score[start] = 0
    39    102.8 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.8 MiB      0.0 MiB         480       while not open_set.empty():
    47    102.8 MiB      0.0 MiB         480           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.8 MiB      0.0 MiB         480           current = open_set.get()[2]
    53    102.8 MiB      0.0 MiB         480           open_set_hash.remove(current)
    54                                         
    55    102.8 MiB      0.0 MiB         480           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.8 MiB      0.0 MiB         480           if current == end:
    60    102.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.8 MiB      0.0 MiB        4311           for neighbor in current.neighbors:
    65    102.8 MiB      0.0 MiB        3832               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.8 MiB      0.0 MiB        1916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.8 MiB      0.0 MiB        1916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.8 MiB      0.0 MiB        3832               if temp_g_score < g_score[neighbor]:
    71    102.8 MiB      0.0 MiB         606                   came_from[neighbor] = current
    72    102.8 MiB      0.0 MiB         606                   g_score[neighbor] = temp_g_score
    73    102.8 MiB      0.0 MiB         606                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.8 MiB      0.0 MiB         606                   if neighbor not in open_set_hash:
    75    102.8 MiB      0.0 MiB         606                       count += 1
    76    102.8 MiB      0.0 MiB         606                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.8 MiB      0.0 MiB         606                       open_set_hash.add(neighbor)
    78                                                             
    79    102.8 MiB      0.0 MiB         479           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.8 MiB      0.0 MiB         479           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.8 MiB    102.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.8 MiB   -827.2 MiB         257       for row in grid:
    30    102.8 MiB -211109.0 MiB       65792           for spot in row:
    31    102.8 MiB -210292.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.7 MiB    -14.1 MiB           1       count = 0
    34     88.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.7 MiB      0.0 MiB           1       came_from = {}
    37     89.5 MiB -60909.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     89.2 MiB     -0.2 MiB           1       g_score[start] = 0
    39     92.9 MiB  -9426.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     92.7 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     92.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     92.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     92.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.3 MiB      0.0 MiB         740       while not open_set.empty():
    47     93.3 MiB      0.0 MiB         740           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.3 MiB      0.0 MiB         740           current = open_set.get()[2]
    53     93.3 MiB      0.0 MiB         740           open_set_hash.remove(current)
    54                                         
    55     93.3 MiB      0.0 MiB         740           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.3 MiB      0.0 MiB         740           if current == end:
    60     93.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.3 MiB      0.0 MiB        6651           for neighbor in current.neighbors:
    65     93.3 MiB      0.3 MiB        5912               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.3 MiB      0.0 MiB        2956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.3 MiB      0.0 MiB        2956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.3 MiB      0.0 MiB        5912               if temp_g_score < g_score[neighbor]:
    71     93.3 MiB      0.1 MiB        1054                   came_from[neighbor] = current
    72     93.3 MiB      0.0 MiB        1054                   g_score[neighbor] = temp_g_score
    73     93.3 MiB      0.0 MiB        1054                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.3 MiB      0.0 MiB        1054                   if neighbor not in open_set_hash:
    75     93.3 MiB      0.0 MiB        1054                       count += 1
    76     93.3 MiB      0.1 MiB        1054                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.3 MiB      0.0 MiB        1054                       open_set_hash.add(neighbor)
    78                                                             
    79     93.3 MiB      0.0 MiB         739           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.3 MiB      0.0 MiB         739           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.3 MiB     93.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.8 MiB  -1647.5 MiB         257       for row in grid:
    30     94.8 MiB -422118.9 MiB       65792           for spot in row:
    31     94.8 MiB -420477.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.9 MiB     -5.9 MiB           1       count = 0
    34     88.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.9 MiB      0.0 MiB           1       came_from = {}
    37     91.5 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.7 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.9 MiB      0.0 MiB        1768       while not open_set.empty():
    47     94.9 MiB      0.0 MiB        1768           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.9 MiB      0.0 MiB        1768           current = open_set.get()[2]
    53     94.9 MiB      0.0 MiB        1768           open_set_hash.remove(current)
    54                                         
    55     94.9 MiB      0.0 MiB        1768           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.9 MiB      0.0 MiB        1768           if current == end:
    60     94.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.9 MiB      0.0 MiB       15903           for neighbor in current.neighbors:
    65     94.9 MiB      0.0 MiB       14136               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.9 MiB      0.0 MiB        7068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.9 MiB      0.0 MiB        7068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.9 MiB      0.0 MiB       14136               if temp_g_score < g_score[neighbor]:
    71     94.9 MiB      0.2 MiB        2090                   came_from[neighbor] = current
    72     94.9 MiB      0.0 MiB        2090                   g_score[neighbor] = temp_g_score
    73     94.9 MiB      0.0 MiB        2090                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.9 MiB      0.0 MiB        2090                   if neighbor not in open_set_hash:
    75     94.9 MiB      0.0 MiB        2090                       count += 1
    76     94.9 MiB      0.0 MiB        2090                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.9 MiB      0.0 MiB        2090                       open_set_hash.add(neighbor)
    78                                                             
    79     94.9 MiB      0.0 MiB        1767           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.9 MiB      0.0 MiB        1767           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.9 MiB     94.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.9 MiB    -14.8 MiB         257       for row in grid:
    30     94.9 MiB  -3363.8 MiB       65792           for spot in row:
    31     94.9 MiB  -3350.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.0 MiB     -1.8 MiB           1       count = 0
    34     93.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.0 MiB      0.0 MiB           1       came_from = {}
    37     95.1 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.7 MiB -32485.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.5 MiB     -6.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     91.1 MiB      0.0 MiB         306       while not open_set.empty():
    47     91.1 MiB      0.0 MiB         306           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     91.1 MiB      0.0 MiB         306           current = open_set.get()[2]
    53     91.1 MiB      0.0 MiB         306           open_set_hash.remove(current)
    54                                         
    55     91.1 MiB      0.0 MiB         306           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     91.1 MiB      0.0 MiB         306           if current == end:
    60     91.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     91.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     91.1 MiB      0.0 MiB        2745           for neighbor in current.neighbors:
    65     91.1 MiB      0.4 MiB        2440               if current.row != neighbor.row and current.col != neighbor.col:
    66     91.1 MiB      0.0 MiB        1220                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     91.1 MiB      0.0 MiB        1220                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     91.1 MiB      0.1 MiB        2440               if temp_g_score < g_score[neighbor]:
    71     91.1 MiB      0.0 MiB         718                   came_from[neighbor] = current
    72     91.1 MiB      0.0 MiB         718                   g_score[neighbor] = temp_g_score
    73     91.1 MiB      0.0 MiB         718                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     91.1 MiB      0.0 MiB         718                   if neighbor not in open_set_hash:
    75     91.1 MiB      0.0 MiB         718                       count += 1
    76     91.1 MiB      0.0 MiB         718                       open_set.put((f_score[neighbor], count, neighbor))
    77     91.1 MiB      0.0 MiB         718                       open_set_hash.add(neighbor)
    78                                                             
    79     91.1 MiB      0.0 MiB         305           if draw is not None:
    80                                                     draw()
    81                                         
    82     91.1 MiB      0.0 MiB         305           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.3 MiB   -202.7 MiB         257       for row in grid:
    30    100.3 MiB -51954.2 MiB       65792           for spot in row:
    31    100.3 MiB -51752.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.8 MiB     -1.5 MiB           1       count = 0
    34     98.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.8 MiB      0.0 MiB           1       came_from = {}
    37    100.9 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.3 MiB      5.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.4 MiB  -2899.2 MiB        2520       while not open_set.empty():
    47    106.4 MiB  -2899.2 MiB        2520           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.4 MiB  -2899.2 MiB        2520           current = open_set.get()[2]
    53    106.4 MiB  -2899.2 MiB        2520           open_set_hash.remove(current)
    54                                         
    55    106.4 MiB  -2899.2 MiB        2520           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.4 MiB  -2899.2 MiB        2520           if current == end:
    60    103.5 MiB     -2.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.4 MiB -26081.6 MiB       22671           for neighbor in current.neighbors:
    65    106.4 MiB -23182.9 MiB       20152               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.4 MiB -11595.7 MiB       10076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.4 MiB -11587.9 MiB       10076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.4 MiB -23184.2 MiB       20152               if temp_g_score < g_score[neighbor]:
    71    106.4 MiB  -3319.6 MiB        2914                   came_from[neighbor] = current
    72    106.4 MiB  -3319.7 MiB        2914                   g_score[neighbor] = temp_g_score
    73    106.4 MiB  -3319.8 MiB        2914                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.4 MiB  -3319.8 MiB        2914                   if neighbor not in open_set_hash:
    75    106.4 MiB  -3319.8 MiB        2914                       count += 1
    76    106.4 MiB  -3319.9 MiB        2914                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.4 MiB  -3320.0 MiB        2914                       open_set_hash.add(neighbor)
    78                                                             
    79    106.4 MiB  -2899.2 MiB        2519           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.4 MiB  -2899.2 MiB        2519           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.5 MiB    103.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.7 MiB    -24.2 MiB         257       for row in grid:
    30    103.7 MiB  -5837.5 MiB       65792           for spot in row:
    31    103.7 MiB  -5814.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.4 MiB     -2.3 MiB           1       count = 0
    34    101.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.4 MiB      0.0 MiB           1       came_from = {}
    37    104.1 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.0 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.0 MiB    -35.5 MiB         770       while not open_set.empty():
    47    107.0 MiB    -35.5 MiB         770           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.0 MiB    -35.5 MiB         770           current = open_set.get()[2]
    53    107.0 MiB    -35.5 MiB         770           open_set_hash.remove(current)
    54                                         
    55    107.0 MiB    -35.5 MiB         770           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.0 MiB    -35.5 MiB         770           if current == end:
    60    106.9 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.0 MiB   -319.2 MiB        6921           for neighbor in current.neighbors:
    65    107.0 MiB   -283.7 MiB        6152               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.0 MiB   -142.0 MiB        3076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.0 MiB   -141.8 MiB        3076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.0 MiB   -283.7 MiB        6152               if temp_g_score < g_score[neighbor]:
    71    107.0 MiB    -41.9 MiB         952                   came_from[neighbor] = current
    72    107.0 MiB    -41.9 MiB         952                   g_score[neighbor] = temp_g_score
    73    107.0 MiB    -41.9 MiB         952                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.0 MiB    -41.9 MiB         952                   if neighbor not in open_set_hash:
    75    107.0 MiB    -41.9 MiB         952                       count += 1
    76    107.0 MiB    -41.9 MiB         952                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.0 MiB    -41.9 MiB         952                       open_set_hash.add(neighbor)
    78                                                             
    79    107.0 MiB    -35.5 MiB         769           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.0 MiB    -35.5 MiB         769           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.9 MiB    106.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.9 MiB   -987.2 MiB         257       for row in grid:
    30    106.9 MiB -250642.3 MiB       65792           for spot in row:
    31    106.9 MiB -249668.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.8 MiB    -17.1 MiB           1       count = 0
    34     89.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     89.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     89.9 MiB      0.0 MiB           1       came_from = {}
    37     91.2 MiB -95140.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.9 MiB     -2.4 MiB           1       g_score[start] = 0
    39     89.9 MiB -530959.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     81.3 MiB     -8.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     81.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     81.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     81.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     81.9 MiB -56226.6 MiB        3900       while not open_set.empty():
    47     81.9 MiB -56227.2 MiB        3900           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     81.9 MiB -56228.5 MiB        3900           current = open_set.get()[2]
    53     81.9 MiB -56229.4 MiB        3900           open_set_hash.remove(current)
    54                                         
    55     81.9 MiB -56230.3 MiB        3900           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     81.9 MiB -56231.3 MiB        3900           if current == end:
    60     31.1 MiB    -50.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     31.2 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     81.9 MiB -505790.7 MiB       35091           for neighbor in current.neighbors:
    65     81.9 MiB -449575.3 MiB       31192               if current.row != neighbor.row and current.col != neighbor.col:
    66     81.9 MiB -224832.2 MiB       15596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     81.9 MiB -224751.1 MiB       15596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     81.9 MiB -449592.1 MiB       31192               if temp_g_score < g_score[neighbor]:
    71     81.9 MiB -60999.5 MiB        4278                   came_from[neighbor] = current
    72     81.9 MiB -61001.1 MiB        4278                   g_score[neighbor] = temp_g_score
    73     81.9 MiB -61003.5 MiB        4278                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     81.9 MiB -61004.6 MiB        4278                   if neighbor not in open_set_hash:
    75     81.9 MiB -61005.3 MiB        4278                       count += 1
    76     81.9 MiB -61006.8 MiB        4278                       open_set.put((f_score[neighbor], count, neighbor))
    77     81.9 MiB -61007.4 MiB        4278                       open_set_hash.add(neighbor)
    78                                                             
    79     81.9 MiB -56224.6 MiB        3899           if draw is not None:
    80                                                     draw()
    81                                         
    82     81.9 MiB -56225.5 MiB        3899           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     38.0 MiB     38.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     56.6 MiB    -37.4 MiB         257       for row in grid:
    30     56.6 MiB  -9534.9 MiB       65792           for spot in row:
    31     56.6 MiB  -9479.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.6 MiB      0.0 MiB           1       count = 0
    34     56.7 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     56.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.7 MiB      0.0 MiB           1       came_from = {}
    37     61.0 MiB   -194.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.0 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.2 MiB  -7117.2 MiB        4095       while not open_set.empty():
    47     64.2 MiB  -7117.3 MiB        4095           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.2 MiB  -7117.5 MiB        4095           current = open_set.get()[2]
    53     64.2 MiB  -7117.6 MiB        4095           open_set_hash.remove(current)
    54                                         
    55     64.2 MiB  -7117.7 MiB        4095           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.2 MiB  -7117.9 MiB        4095           if current == end:
    60     62.0 MiB     -2.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.2 MiB -64047.9 MiB       36846           for neighbor in current.neighbors:
    65     64.2 MiB -56931.4 MiB       32752               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.2 MiB -28465.9 MiB       16376                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.2 MiB -28465.5 MiB       16376                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.2 MiB -56931.6 MiB       32752               if temp_g_score < g_score[neighbor]:
    71     64.2 MiB  -7928.9 MiB        4631                   came_from[neighbor] = current
    72     64.2 MiB  -7928.9 MiB        4631                   g_score[neighbor] = temp_g_score
    73     64.2 MiB  -7928.9 MiB        4631                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.2 MiB  -7928.9 MiB        4631                   if neighbor not in open_set_hash:
    75     64.2 MiB  -7928.9 MiB        4631                       count += 1
    76     64.2 MiB  -7928.9 MiB        4631                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.2 MiB  -7928.8 MiB        4631                       open_set_hash.add(neighbor)
    78                                                             
    79     64.2 MiB  -7116.9 MiB        4094           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.2 MiB  -7117.0 MiB        4094           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.0 MiB     62.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.0 MiB   -213.0 MiB         257       for row in grid:
    30     62.0 MiB -54649.2 MiB       65792           for spot in row:
    31     62.0 MiB -54437.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.2 MiB     -1.8 MiB           1       count = 0
    34     60.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.2 MiB      0.0 MiB           1       came_from = {}
    37     62.2 MiB    -48.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.1 MiB     -0.0 MiB           1       g_score[start] = 0
    39     63.7 MiB      1.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.8 MiB      0.0 MiB        1032       while not open_set.empty():
    47     63.8 MiB      0.0 MiB        1032           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.8 MiB      0.0 MiB        1032           current = open_set.get()[2]
    53     63.8 MiB      0.0 MiB        1032           open_set_hash.remove(current)
    54                                         
    55     63.8 MiB      0.0 MiB        1032           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.8 MiB      0.0 MiB        1032           if current == end:
    60     63.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.9 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.8 MiB      0.0 MiB        9279           for neighbor in current.neighbors:
    65     63.8 MiB      0.0 MiB        8248               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.8 MiB      0.0 MiB        4124                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.8 MiB      0.0 MiB        4124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.8 MiB      0.0 MiB        8248               if temp_g_score < g_score[neighbor]:
    71     63.8 MiB      0.0 MiB        1730                   came_from[neighbor] = current
    72     63.8 MiB      0.0 MiB        1730                   g_score[neighbor] = temp_g_score
    73     63.8 MiB      0.0 MiB        1730                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.8 MiB      0.0 MiB        1730                   if neighbor not in open_set_hash:
    75     63.8 MiB      0.0 MiB        1730                       count += 1
    76     63.8 MiB      0.0 MiB        1730                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.8 MiB      0.0 MiB        1730                       open_set_hash.add(neighbor)
    78                                                             
    79     63.8 MiB      0.0 MiB        1031           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.8 MiB      0.0 MiB        1031           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.7 MiB     97.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.7 MiB   -768.2 MiB         257       for row in grid:
    30     97.7 MiB -196717.6 MiB       65792           for spot in row:
    31     97.7 MiB -195952.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.5 MiB     -3.2 MiB           1       count = 0
    34     94.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.5 MiB      0.0 MiB           1       came_from = {}
    37     96.1 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.9 MiB      4.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.9 MiB   -452.8 MiB        2709       while not open_set.empty():
    47    100.9 MiB   -452.8 MiB        2709           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.9 MiB   -452.8 MiB        2709           current = open_set.get()[2]
    53    100.9 MiB   -452.8 MiB        2709           open_set_hash.remove(current)
    54                                         
    55    100.9 MiB   -452.8 MiB        2709           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.9 MiB   -452.8 MiB        2709           if current == end:
    60    100.8 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.9 MiB  -4075.1 MiB       24372           for neighbor in current.neighbors:
    65    100.9 MiB  -3622.5 MiB       21664               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.9 MiB  -1811.3 MiB       10832                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.9 MiB  -1811.2 MiB       10832                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.9 MiB  -3622.6 MiB       21664               if temp_g_score < g_score[neighbor]:
    71    100.9 MiB   -498.0 MiB        3005                   came_from[neighbor] = current
    72    100.9 MiB   -498.0 MiB        3005                   g_score[neighbor] = temp_g_score
    73    100.9 MiB   -498.0 MiB        3005                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.9 MiB   -498.0 MiB        3005                   if neighbor not in open_set_hash:
    75    100.9 MiB   -498.0 MiB        3005                       count += 1
    76    100.9 MiB   -498.0 MiB        3005                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.9 MiB   -498.0 MiB        3005                       open_set_hash.add(neighbor)
    78                                                             
    79    100.9 MiB   -452.8 MiB        2708           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.9 MiB   -452.8 MiB        2708           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.8 MiB    100.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.8 MiB   -457.2 MiB         257       for row in grid:
    30    100.8 MiB -117313.1 MiB       65792           for spot in row:
    31    100.8 MiB -116857.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.4 MiB     -2.4 MiB           1       count = 0
    34     98.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.4 MiB      0.0 MiB           1       came_from = {}
    37    100.0 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.5 MiB -215551.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.5 MiB     -4.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.6 MiB -67729.7 MiB        6204       while not open_set.empty():
    47     96.6 MiB -67730.4 MiB        6204           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.6 MiB -67731.3 MiB        6204           current = open_set.get()[2]
    53     96.6 MiB -67731.8 MiB        6204           open_set_hash.remove(current)
    54                                         
    55     96.6 MiB -67732.4 MiB        6204           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.6 MiB -67733.0 MiB        6204           if current == end:
    60     82.3 MiB    -14.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     82.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.6 MiB -609505.1 MiB       55827           for neighbor in current.neighbors:
    65     96.6 MiB -541777.7 MiB       49624               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.6 MiB -270898.9 MiB       24812                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.6 MiB -270881.6 MiB       24812                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.6 MiB -541782.5 MiB       49624               if temp_g_score < g_score[neighbor]:
    71     96.6 MiB -71599.3 MiB        6654                   came_from[neighbor] = current
    72     96.6 MiB -71599.8 MiB        6654                   g_score[neighbor] = temp_g_score
    73     96.6 MiB -71600.0 MiB        6654                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.6 MiB -71600.1 MiB        6654                   if neighbor not in open_set_hash:
    75     96.6 MiB -71600.3 MiB        6654                       count += 1
    76     96.6 MiB -71600.7 MiB        6654                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.6 MiB -71600.9 MiB        6654                       open_set_hash.add(neighbor)
    78                                                             
    79     96.6 MiB -67729.1 MiB        6203           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.6 MiB -67729.4 MiB        6203           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     85.4 MiB     85.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     87.0 MiB  -1005.2 MiB         257       for row in grid:
    30     87.0 MiB -257538.0 MiB       65792           for spot in row:
    31     87.0 MiB -256533.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     81.0 MiB     -6.1 MiB           1       count = 0
    34     81.0 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     81.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     81.0 MiB      0.0 MiB           1       came_from = {}
    37     84.8 MiB   -175.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     84.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     89.2 MiB  -3959.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     89.0 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     89.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     89.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     89.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     89.1 MiB   -251.0 MiB         572       while not open_set.empty():
    47     89.1 MiB   -251.0 MiB         572           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     89.1 MiB   -251.0 MiB         572           current = open_set.get()[2]
    53     89.1 MiB   -251.0 MiB         572           open_set_hash.remove(current)
    54                                         
    55     89.1 MiB   -251.0 MiB         572           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     89.1 MiB   -251.0 MiB         572           if current == end:
    60     87.3 MiB     -1.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     87.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     89.1 MiB  -2253.0 MiB        5139           for neighbor in current.neighbors:
    65     89.1 MiB  -2002.6 MiB        4568               if current.row != neighbor.row and current.col != neighbor.col:
    66     89.1 MiB  -1004.6 MiB        2284                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     89.1 MiB   -998.7 MiB        2284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     89.1 MiB  -2003.8 MiB        4568               if temp_g_score < g_score[neighbor]:
    71     89.1 MiB   -500.8 MiB        1150                   came_from[neighbor] = current
    72     89.1 MiB   -501.0 MiB        1150                   g_score[neighbor] = temp_g_score
    73     89.1 MiB   -501.0 MiB        1150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     89.1 MiB   -501.0 MiB        1150                   if neighbor not in open_set_hash:
    75     89.1 MiB   -501.0 MiB        1150                       count += 1
    76     89.1 MiB   -500.1 MiB        1150                       open_set.put((f_score[neighbor], count, neighbor))
    77     89.1 MiB   -500.2 MiB        1150                       open_set_hash.add(neighbor)
    78                                                             
    79     89.1 MiB   -251.0 MiB         571           if draw is not None:
    80                                                     draw()
    81                                         
    82     89.1 MiB   -251.0 MiB         571           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     87.4 MiB     87.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     87.7 MiB  -4028.8 MiB         257       for row in grid:
    30     87.7 MiB -1030956.8 MiB       65792           for spot in row:
    31     87.7 MiB -1026949.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.5 MiB    -29.2 MiB           1       count = 0
    34     58.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.5 MiB      0.0 MiB           1       came_from = {}
    37     61.9 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     63.8 MiB -51373.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.2 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.3 MiB      0.0 MiB         672       while not open_set.empty():
    47     63.3 MiB      0.0 MiB         672           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.3 MiB      0.0 MiB         672           current = open_set.get()[2]
    53     63.3 MiB      0.0 MiB         672           open_set_hash.remove(current)
    54                                         
    55     63.3 MiB      0.0 MiB         672           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.3 MiB      0.0 MiB         672           if current == end:
    60     63.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.3 MiB      0.0 MiB        6039           for neighbor in current.neighbors:
    65     63.3 MiB      0.0 MiB        5368               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.3 MiB      0.0 MiB        2684                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.3 MiB      0.0 MiB        2684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.3 MiB      0.0 MiB        5368               if temp_g_score < g_score[neighbor]:
    71     63.3 MiB      0.0 MiB        1350                   came_from[neighbor] = current
    72     63.3 MiB      0.0 MiB        1350                   g_score[neighbor] = temp_g_score
    73     63.3 MiB      0.0 MiB        1350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.3 MiB      0.0 MiB        1350                   if neighbor not in open_set_hash:
    75     63.3 MiB      0.0 MiB        1350                       count += 1
    76     63.3 MiB      0.0 MiB        1350                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.3 MiB      0.1 MiB        1350                       open_set_hash.add(neighbor)
    78                                                             
    79     63.3 MiB      0.0 MiB         671           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.3 MiB      0.0 MiB         671           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.3 MiB     63.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.3 MiB   -151.9 MiB         257       for row in grid:
    30     63.3 MiB -38889.4 MiB       65792           for spot in row:
    31     63.3 MiB -38738.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.4 MiB     -0.9 MiB           1       count = 0
    34     62.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.4 MiB      0.0 MiB           1       came_from = {}
    37     65.0 MiB -21255.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.7 MiB   -126.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.7 MiB  -7950.2 MiB        1038       while not open_set.empty():
    47     67.7 MiB  -7950.2 MiB        1038           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.7 MiB  -7950.2 MiB        1038           current = open_set.get()[2]
    53     67.7 MiB  -7950.2 MiB        1038           open_set_hash.remove(current)
    54                                         
    55     67.7 MiB  -7950.2 MiB        1038           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.7 MiB  -7950.2 MiB        1038           if current == end:
    60     58.4 MiB     -9.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.7 MiB -71498.8 MiB        9333           for neighbor in current.neighbors:
    65     67.7 MiB -63549.1 MiB        8296               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.7 MiB -31781.9 MiB        4148                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.7 MiB -31767.5 MiB        4148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.7 MiB -63551.0 MiB        8296               if temp_g_score < g_score[neighbor]:
    71     67.7 MiB -13232.5 MiB        1740                   came_from[neighbor] = current
    72     67.7 MiB -13232.5 MiB        1740                   g_score[neighbor] = temp_g_score
    73     67.7 MiB -13232.6 MiB        1740                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.7 MiB -13232.8 MiB        1740                   if neighbor not in open_set_hash:
    75     67.7 MiB -13235.8 MiB        1740                       count += 1
    76     67.7 MiB -13237.1 MiB        1740                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.7 MiB -13237.7 MiB        1740                       open_set_hash.add(neighbor)
    78                                                             
    79     67.7 MiB  -7950.2 MiB        1037           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.7 MiB  -7950.2 MiB        1037           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.6 MiB     90.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.6 MiB   -613.9 MiB         257       for row in grid:
    30     90.6 MiB -156784.9 MiB       65792           for spot in row:
    31     90.6 MiB -156181.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     76.6 MiB    -14.1 MiB           1       count = 0
    34     76.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.6 MiB      0.0 MiB           1       came_from = {}
    37     80.2 MiB -41965.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     79.0 MiB     -1.1 MiB           1       g_score[start] = 0
    39     81.8 MiB -35945.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     79.7 MiB     -2.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     79.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     79.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     79.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     79.9 MiB      0.1 MiB          24       while not open_set.empty():
    47     79.9 MiB      0.0 MiB          24           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     79.9 MiB      0.0 MiB          24           current = open_set.get()[2]
    53     79.9 MiB      0.0 MiB          24           open_set_hash.remove(current)
    54                                         
    55     79.9 MiB      0.0 MiB          24           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     79.9 MiB      0.0 MiB          24           if current == end:
    60     79.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     79.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     79.9 MiB      0.0 MiB         207           for neighbor in current.neighbors:
    65     79.9 MiB      0.0 MiB         184               if current.row != neighbor.row and current.col != neighbor.col:
    66     79.9 MiB      0.0 MiB          92                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     79.9 MiB      0.0 MiB          92                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     79.9 MiB      0.0 MiB         184               if temp_g_score < g_score[neighbor]:
    71     79.9 MiB      0.0 MiB          54                   came_from[neighbor] = current
    72     79.9 MiB      0.0 MiB          54                   g_score[neighbor] = temp_g_score
    73     79.9 MiB      0.0 MiB          54                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     79.9 MiB      0.0 MiB          54                   if neighbor not in open_set_hash:
    75     79.9 MiB      0.0 MiB          54                       count += 1
    76     79.9 MiB      0.0 MiB          54                       open_set.put((f_score[neighbor], count, neighbor))
    77     79.9 MiB      0.0 MiB          54                       open_set_hash.add(neighbor)
    78                                                             
    79     79.9 MiB      0.0 MiB          23           if draw is not None:
    80                                                     draw()
    81                                         
    82     79.9 MiB      0.0 MiB          23           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     82.4 MiB     82.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     85.8 MiB   -510.8 MiB         257       for row in grid:
    30     85.8 MiB -130845.5 MiB       65792           for spot in row:
    31     85.8 MiB -130329.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.8 MiB      0.0 MiB           1       count = 0
    34     85.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     85.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     85.8 MiB      0.0 MiB           1       came_from = {}
    37     88.5 MiB -20345.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     92.9 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     92.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     92.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     92.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     92.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     92.9 MiB  -5374.9 MiB        3290       while not open_set.empty():
    47     92.9 MiB  -5375.0 MiB        3290           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     92.9 MiB  -5375.1 MiB        3290           current = open_set.get()[2]
    53     92.9 MiB  -5375.2 MiB        3290           open_set_hash.remove(current)
    54                                         
    55     92.9 MiB  -5375.2 MiB        3290           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     92.9 MiB  -5375.2 MiB        3290           if current == end:
    60     90.7 MiB     -2.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     92.9 MiB -48367.9 MiB       29601           for neighbor in current.neighbors:
    65     92.9 MiB -42993.6 MiB       26312               if current.row != neighbor.row and current.col != neighbor.col:
    66     92.9 MiB -21500.5 MiB       13156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     92.9 MiB -21493.6 MiB       13156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     92.9 MiB -42994.6 MiB       26312               if temp_g_score < g_score[neighbor]:
    71     92.9 MiB  -5995.1 MiB        3734                   came_from[neighbor] = current
    72     92.9 MiB  -5995.1 MiB        3734                   g_score[neighbor] = temp_g_score
    73     92.9 MiB  -5995.1 MiB        3734                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     92.9 MiB  -5995.1 MiB        3734                   if neighbor not in open_set_hash:
    75     92.9 MiB  -5995.1 MiB        3734                       count += 1
    76     92.9 MiB  -5995.3 MiB        3734                       open_set.put((f_score[neighbor], count, neighbor))
    77     92.9 MiB  -5995.3 MiB        3734                       open_set_hash.add(neighbor)
    78                                                             
    79     92.9 MiB  -5374.9 MiB        3289           if draw is not None:
    80                                                     draw()
    81                                         
    82     92.9 MiB  -5374.9 MiB        3289           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.8 MiB     90.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.9 MiB   -302.4 MiB         257       for row in grid:
    30     90.9 MiB -77581.8 MiB       65792           for spot in row:
    31     90.9 MiB -77280.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.6 MiB     -1.2 MiB           1       count = 0
    34     89.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     89.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     89.6 MiB      0.0 MiB           1       came_from = {}
    37     91.1 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     93.0 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.0 MiB -17289.6 MiB        5476       while not open_set.empty():
    47     93.0 MiB -17290.1 MiB        5476           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.0 MiB -17290.8 MiB        5476           current = open_set.get()[2]
    53     93.0 MiB -17291.3 MiB        5476           open_set_hash.remove(current)
    54                                         
    55     93.0 MiB -17292.1 MiB        5476           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.0 MiB -17292.6 MiB        5476           if current == end:
    60     71.4 MiB    -21.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.0 MiB -155476.7 MiB       49275           for neighbor in current.neighbors:
    65     93.0 MiB -138191.2 MiB       43800               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.0 MiB -69105.1 MiB       21900                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.0 MiB -69088.2 MiB       21900                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.0 MiB -138196.8 MiB       43800               if temp_g_score < g_score[neighbor]:
    71     93.0 MiB -18881.8 MiB        5918                   came_from[neighbor] = current
    72     93.0 MiB -18882.7 MiB        5918                   g_score[neighbor] = temp_g_score
    73     93.0 MiB -18883.6 MiB        5918                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.0 MiB -18884.3 MiB        5918                   if neighbor not in open_set_hash:
    75     93.0 MiB -18884.9 MiB        5918                       count += 1
    76     93.0 MiB -18885.6 MiB        5918                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.0 MiB -18886.4 MiB        5918                       open_set_hash.add(neighbor)
    78                                                             
    79     93.0 MiB -17288.4 MiB        5475           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.0 MiB -17289.0 MiB        5475           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     71.4 MiB     71.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     71.4 MiB  -5408.3 MiB         257       for row in grid:
    30     71.4 MiB -1384459.9 MiB       65792           for spot in row:
    31     71.4 MiB -1379073.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     36.5 MiB    -34.9 MiB           1       count = 0
    34     36.6 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     36.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     36.6 MiB      0.0 MiB           1       came_from = {}
    37     42.4 MiB -43796.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     40.4 MiB     -2.0 MiB           1       g_score[start] = 0
    39     44.5 MiB  -5351.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     44.7 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     44.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     44.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     44.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     56.9 MiB      0.0 MiB        2394       while not open_set.empty():
    47     56.9 MiB      0.0 MiB        2394           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     56.9 MiB      0.0 MiB        2394           current = open_set.get()[2]
    53     56.9 MiB      0.0 MiB        2394           open_set_hash.remove(current)
    54                                         
    55     56.9 MiB      0.0 MiB        2394           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     56.9 MiB      0.0 MiB        2394           if current == end:
    60     56.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     56.9 MiB      1.2 MiB       21537           for neighbor in current.neighbors:
    65     56.9 MiB      1.5 MiB       19144               if current.row != neighbor.row and current.col != neighbor.col:
    66     56.9 MiB      0.0 MiB        9572                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     56.9 MiB      0.0 MiB        9572                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     56.9 MiB      0.0 MiB       19144               if temp_g_score < g_score[neighbor]:
    71     56.9 MiB      0.2 MiB        3104                   came_from[neighbor] = current
    72     56.9 MiB      0.0 MiB        3104                   g_score[neighbor] = temp_g_score
    73     56.9 MiB      0.0 MiB        3104                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     56.9 MiB      0.0 MiB        3104                   if neighbor not in open_set_hash:
    75     56.9 MiB      0.0 MiB        3104                       count += 1
    76     56.9 MiB      9.2 MiB        3104                       open_set.put((f_score[neighbor], count, neighbor))
    77     56.9 MiB      0.1 MiB        3104                       open_set_hash.add(neighbor)
    78                                                             
    79     56.9 MiB      0.0 MiB        2393           if draw is not None:
    80                                                     draw()
    81                                         
    82     56.9 MiB      0.0 MiB        2393           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.5 MiB     59.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.5 MiB   -130.2 MiB         257       for row in grid:
    30     60.5 MiB -32737.8 MiB       65792           for spot in row:
    31     60.5 MiB -32611.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     54.5 MiB     -6.0 MiB           1       count = 0
    34     54.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     54.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     54.5 MiB      0.0 MiB           1       came_from = {}
    37     58.2 MiB  -1402.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     62.5 MiB  -1356.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.4 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.0 MiB      0.0 MiB        7812       while not open_set.empty():
    47     63.0 MiB      0.0 MiB        7812           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.0 MiB      0.0 MiB        7812           current = open_set.get()[2]
    53     63.0 MiB      0.0 MiB        7812           open_set_hash.remove(current)
    54                                         
    55     63.0 MiB      0.0 MiB        7812           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.0 MiB      0.0 MiB        7812           if current == end:
    60     63.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.0 MiB      0.0 MiB       70299           for neighbor in current.neighbors:
    65     63.0 MiB      0.0 MiB       62488               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.0 MiB      0.0 MiB       31244                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.0 MiB      0.0 MiB       31244                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.0 MiB      0.0 MiB       62488               if temp_g_score < g_score[neighbor]:
    71     63.0 MiB      0.4 MiB        8310                   came_from[neighbor] = current
    72     63.0 MiB      0.0 MiB        8310                   g_score[neighbor] = temp_g_score
    73     63.0 MiB      0.0 MiB        8310                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.0 MiB      0.0 MiB        8310                   if neighbor not in open_set_hash:
    75     63.0 MiB      0.0 MiB        8310                       count += 1
    76     63.0 MiB      0.0 MiB        8310                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.0 MiB      0.1 MiB        8310                       open_set_hash.add(neighbor)
    78                                                             
    79     63.0 MiB      0.0 MiB        7811           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.0 MiB      0.0 MiB        7811           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.5 MiB     95.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.5 MiB  -3418.6 MiB         257       for row in grid:
    30     95.5 MiB -873543.5 MiB       65792           for spot in row:
    31     95.5 MiB -870149.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.3 MiB    -38.1 MiB           1       count = 0
    34     57.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     57.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     57.8 MiB      0.0 MiB           1       came_from = {}
    37     64.9 MiB  -1195.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.8 MiB     -0.1 MiB           1       g_score[start] = 0
    39     69.4 MiB  -1104.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.5 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.8 MiB -106752.8 MiB        3780       while not open_set.empty():
    47     69.8 MiB -106753.0 MiB        3780           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.8 MiB -106753.8 MiB        3780           current = open_set.get()[2]
    53     69.8 MiB -106754.3 MiB        3780           open_set_hash.remove(current)
    54                                         
    55     69.8 MiB -106754.7 MiB        3780           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.8 MiB -106755.0 MiB        3780           if current == end:
    60     48.4 MiB    -21.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.8 MiB -960708.5 MiB       34011           for neighbor in current.neighbors:
    65     69.8 MiB -853959.2 MiB       30232               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.8 MiB -427013.7 MiB       15116                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.8 MiB -426952.0 MiB       15116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.8 MiB -853970.8 MiB       30232               if temp_g_score < g_score[neighbor]:
    71     69.8 MiB -122053.9 MiB        4374                   came_from[neighbor] = current
    72     69.8 MiB -122054.9 MiB        4374                   g_score[neighbor] = temp_g_score
    73     69.8 MiB -122056.7 MiB        4374                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.8 MiB -122057.3 MiB        4374                   if neighbor not in open_set_hash:
    75     69.8 MiB -122057.9 MiB        4374                       count += 1
    76     69.8 MiB -122050.9 MiB        4374                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.8 MiB -122051.7 MiB        4374                       open_set_hash.add(neighbor)
    78                                                             
    79     69.8 MiB -106752.3 MiB        3779           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.8 MiB -106752.5 MiB        3779           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     50.9 MiB     50.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     52.1 MiB   -208.8 MiB         257       for row in grid:
    30     52.1 MiB -53217.8 MiB       65792           for spot in row:
    31     52.1 MiB -53006.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     50.9 MiB     -1.2 MiB           1       count = 0
    34     51.2 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     51.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     51.4 MiB      0.0 MiB           1       came_from = {}
    37     55.9 MiB  -4167.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.3 MiB      4.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.5 MiB -60326.6 MiB       15006       while not open_set.empty():
    47     60.5 MiB -60327.3 MiB       15006           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.5 MiB -60328.5 MiB       15006           current = open_set.get()[2]
    53     60.5 MiB -60328.8 MiB       15006           open_set_hash.remove(current)
    54                                         
    55     60.5 MiB -60328.9 MiB       15006           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.5 MiB -60329.1 MiB       15006           if current == end:
    60     38.9 MiB    -21.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     39.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.5 MiB -542834.7 MiB      135045           for neighbor in current.neighbors:
    65     60.5 MiB -482516.0 MiB      120040               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.5 MiB -241276.9 MiB       60020                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.5 MiB -241241.1 MiB       60020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.5 MiB -482519.9 MiB      120040               if temp_g_score < g_score[neighbor]:
    71     60.5 MiB -63201.1 MiB       15740                   came_from[neighbor] = current
    72     60.5 MiB -63202.8 MiB       15740                   g_score[neighbor] = temp_g_score
    73     60.5 MiB -63204.3 MiB       15740                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.5 MiB -63204.5 MiB       15740                   if neighbor not in open_set_hash:
    75     60.5 MiB -63204.8 MiB       15740                       count += 1
    76     60.5 MiB -63205.1 MiB       15740                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.5 MiB -63205.1 MiB       15740                       open_set_hash.add(neighbor)
    78                                                             
    79     60.5 MiB -60325.2 MiB       15005           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.5 MiB -60325.8 MiB       15005           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     42.9 MiB     42.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     53.3 MiB   -472.5 MiB         257       for row in grid:
    30     53.3 MiB -121469.2 MiB       65792           for spot in row:
    31     53.3 MiB -120984.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     53.3 MiB      0.0 MiB           1       count = 0
    34     53.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     53.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     53.3 MiB      0.0 MiB           1       came_from = {}
    37     58.4 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.2 MiB  -1202.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.1 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.1 MiB      0.0 MiB          40       while not open_set.empty():
    47     60.1 MiB      0.0 MiB          40           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.1 MiB      0.0 MiB          40           current = open_set.get()[2]
    53     60.1 MiB      0.0 MiB          40           open_set_hash.remove(current)
    54                                         
    55     60.1 MiB      0.0 MiB          40           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.1 MiB      0.0 MiB          40           if current == end:
    60     60.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.1 MiB      0.0 MiB         351           for neighbor in current.neighbors:
    65     60.1 MiB      0.0 MiB         312               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.1 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.1 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.1 MiB      0.0 MiB         312               if temp_g_score < g_score[neighbor]:
    71     60.1 MiB      0.0 MiB          86                   came_from[neighbor] = current
    72     60.1 MiB      0.0 MiB          86                   g_score[neighbor] = temp_g_score
    73     60.1 MiB      0.0 MiB          86                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.1 MiB      0.0 MiB          86                   if neighbor not in open_set_hash:
    75     60.1 MiB      0.0 MiB          86                       count += 1
    76     60.1 MiB      0.0 MiB          86                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.1 MiB      0.0 MiB          86                       open_set_hash.add(neighbor)
    78                                                             
    79     60.1 MiB      0.0 MiB          39           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.1 MiB      0.0 MiB          39           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     60.2 MiB     60.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.2 MiB  -1925.3 MiB         257       for row in grid:
    30     60.2 MiB -493008.0 MiB       65792           for spot in row:
    31     60.2 MiB -491092.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     47.4 MiB    -12.8 MiB           1       count = 0
    34     47.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     47.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     47.4 MiB      0.0 MiB           1       came_from = {}
    37     47.8 MiB -358130.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     43.9 MiB     -3.9 MiB           1       g_score[start] = 0
    39     47.6 MiB -33188.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     46.2 MiB     -1.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     46.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     46.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     46.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     47.6 MiB   -406.9 MiB         750       while not open_set.empty():
    47     47.6 MiB   -406.9 MiB         750           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     47.6 MiB   -407.0 MiB         750           current = open_set.get()[2]
    53     47.6 MiB   -407.1 MiB         750           open_set_hash.remove(current)
    54                                         
    55     47.6 MiB   -407.2 MiB         750           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     47.6 MiB   -407.2 MiB         750           if current == end:
    60     42.3 MiB     -5.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     42.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     47.6 MiB  -3634.2 MiB        6741           for neighbor in current.neighbors:
    65     47.6 MiB  -3228.5 MiB        5992               if current.row != neighbor.row and current.col != neighbor.col:
    66     47.6 MiB  -1619.4 MiB        2996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     47.6 MiB  -1610.8 MiB        2996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     47.6 MiB  -3230.8 MiB        5992               if temp_g_score < g_score[neighbor]:
    71     47.6 MiB   -519.4 MiB         918                   came_from[neighbor] = current
    72     47.6 MiB   -519.8 MiB         918                   g_score[neighbor] = temp_g_score
    73     47.6 MiB   -520.2 MiB         918                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     47.6 MiB   -520.2 MiB         918                   if neighbor not in open_set_hash:
    75     47.6 MiB   -520.3 MiB         918                       count += 1
    76     47.6 MiB   -520.3 MiB         918                       open_set.put((f_score[neighbor], count, neighbor))
    77     47.6 MiB   -520.6 MiB         918                       open_set_hash.add(neighbor)
    78                                                             
    79     47.6 MiB   -406.9 MiB         749           if draw is not None:
    80                                                     draw()
    81                                         
    82     47.6 MiB   -406.9 MiB         749           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     44.9 MiB     44.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.9 MiB      0.0 MiB         257       for row in grid:
    30     58.9 MiB      0.0 MiB       65792           for spot in row:
    31     58.9 MiB     14.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.9 MiB      0.0 MiB           1       count = 0
    34     59.0 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     59.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.0 MiB      0.0 MiB           1       came_from = {}
    37     59.9 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.6 MiB  -3000.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.7 MiB -24035.1 MiB        6885       while not open_set.empty():
    47     61.7 MiB -24035.2 MiB        6885           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.7 MiB -24035.3 MiB        6885           current = open_set.get()[2]
    53     61.7 MiB -24035.3 MiB        6885           open_set_hash.remove(current)
    54                                         
    55     61.7 MiB -24035.4 MiB        6885           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.7 MiB -24035.4 MiB        6885           if current == end:
    60     53.0 MiB     -8.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     53.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.7 MiB -216267.1 MiB       61956           for neighbor in current.neighbors:
    65     61.7 MiB -192234.4 MiB       55072               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.7 MiB -96124.7 MiB       27536                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.7 MiB -96111.2 MiB       27536                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.7 MiB -192237.2 MiB       55072               if temp_g_score < g_score[neighbor]:
    71     61.7 MiB -25446.8 MiB        7369                   came_from[neighbor] = current
    72     61.7 MiB -25447.0 MiB        7369                   g_score[neighbor] = temp_g_score
    73     61.7 MiB -25447.1 MiB        7369                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.7 MiB -25447.3 MiB        7369                   if neighbor not in open_set_hash:
    75     61.7 MiB -25447.3 MiB        7369                       count += 1
    76     61.7 MiB -25447.5 MiB        7369                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.7 MiB -25447.8 MiB        7369                       open_set_hash.add(neighbor)
    78                                                             
    79     61.7 MiB -24034.0 MiB        6884           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.7 MiB -24034.0 MiB        6884           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.5 MiB     93.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.5 MiB    -52.1 MiB         257       for row in grid:
    30     93.5 MiB -13368.0 MiB       65792           for spot in row:
    31     93.5 MiB -13316.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.2 MiB     -0.2 MiB           1       count = 0
    34     93.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.2 MiB      0.0 MiB           1       came_from = {}
    37     97.2 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.1 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.2 MiB      0.0 MiB        2235       while not open_set.empty():
    47    100.2 MiB      0.0 MiB        2235           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.2 MiB      0.0 MiB        2235           current = open_set.get()[2]
    53    100.2 MiB      0.0 MiB        2235           open_set_hash.remove(current)
    54                                         
    55    100.2 MiB      0.0 MiB        2235           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.2 MiB      0.0 MiB        2235           if current == end:
    60    100.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.2 MiB      0.0 MiB       20106           for neighbor in current.neighbors:
    65    100.2 MiB      0.0 MiB       17872               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.2 MiB      0.0 MiB        8936                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.2 MiB      0.0 MiB        8936                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.2 MiB      0.0 MiB       17872               if temp_g_score < g_score[neighbor]:
    71    100.2 MiB      0.0 MiB        2591                   came_from[neighbor] = current
    72    100.2 MiB      0.0 MiB        2591                   g_score[neighbor] = temp_g_score
    73    100.2 MiB      0.0 MiB        2591                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.2 MiB      0.0 MiB        2591                   if neighbor not in open_set_hash:
    75    100.2 MiB      0.0 MiB        2591                       count += 1
    76    100.2 MiB      0.0 MiB        2591                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.2 MiB      0.0 MiB        2591                       open_set_hash.add(neighbor)
    78                                                             
    79    100.2 MiB      0.0 MiB        2234           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.2 MiB      0.0 MiB        2234           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.2 MiB    100.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.2 MiB    -76.8 MiB         257       for row in grid:
    30    100.2 MiB -19671.5 MiB       65792           for spot in row:
    31    100.2 MiB -19595.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.4 MiB     -0.8 MiB           1       count = 0
    34     99.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.4 MiB      0.0 MiB           1       came_from = {}
    37    100.0 MiB -79923.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.8 MiB     -2.2 MiB           1       g_score[start] = 0
    39     97.8 MiB -470016.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     82.9 MiB    -14.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     82.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     82.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     82.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     83.7 MiB     -0.2 MiB         270       while not open_set.empty():
    47     83.7 MiB     -0.2 MiB         270           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     83.7 MiB     -0.2 MiB         270           current = open_set.get()[2]
    53     83.7 MiB     -0.2 MiB         270           open_set_hash.remove(current)
    54                                         
    55     83.7 MiB     -0.2 MiB         270           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     83.7 MiB     -0.2 MiB         270           if current == end:
    60     83.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     83.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     83.7 MiB     -1.4 MiB        2421           for neighbor in current.neighbors:
    65     83.7 MiB     -1.5 MiB        2152               if current.row != neighbor.row and current.col != neighbor.col:
    66     83.7 MiB     -0.8 MiB        1076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     83.7 MiB     -0.8 MiB        1076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     83.7 MiB     -1.5 MiB        2152               if temp_g_score < g_score[neighbor]:
    71     83.7 MiB     -0.4 MiB         364                   came_from[neighbor] = current
    72     83.7 MiB     -0.4 MiB         364                   g_score[neighbor] = temp_g_score
    73     83.7 MiB     -0.4 MiB         364                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     83.7 MiB     -0.4 MiB         364                   if neighbor not in open_set_hash:
    75     83.7 MiB     -0.4 MiB         364                       count += 1
    76     83.7 MiB     -0.4 MiB         364                       open_set.put((f_score[neighbor], count, neighbor))
    77     83.7 MiB     -0.3 MiB         364                       open_set_hash.add(neighbor)
    78                                                             
    79     83.7 MiB     -0.2 MiB         269           if draw is not None:
    80                                                     draw()
    81                                         
    82     83.7 MiB     -0.2 MiB         269           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     84.2 MiB     84.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     85.3 MiB  -6122.7 MiB         257       for row in grid:
    30     85.3 MiB -1567656.8 MiB       65792           for spot in row:
    31     85.3 MiB -1561550.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.7 MiB    -25.6 MiB           1       count = 0
    34     59.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.7 MiB      0.0 MiB           1       came_from = {}
    37     63.5 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.9 MiB -11920.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.0 MiB   -106.2 MiB        3000       while not open_set.empty():
    47     67.0 MiB   -106.2 MiB        3000           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.0 MiB   -106.2 MiB        3000           current = open_set.get()[2]
    53     67.0 MiB   -106.2 MiB        3000           open_set_hash.remove(current)
    54                                         
    55     67.0 MiB   -106.2 MiB        3000           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.0 MiB   -106.2 MiB        3000           if current == end:
    60     67.0 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.0 MiB   -956.1 MiB       26991           for neighbor in current.neighbors:
    65     67.0 MiB   -849.9 MiB       23992               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.0 MiB   -425.1 MiB       11996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.0 MiB   -425.0 MiB       11996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.0 MiB   -850.0 MiB       23992               if temp_g_score < g_score[neighbor]:
    71     67.0 MiB   -115.4 MiB        3338                   came_from[neighbor] = current
    72     67.0 MiB   -115.4 MiB        3338                   g_score[neighbor] = temp_g_score
    73     67.0 MiB   -115.4 MiB        3338                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.0 MiB   -115.4 MiB        3338                   if neighbor not in open_set_hash:
    75     67.0 MiB   -115.4 MiB        3338                       count += 1
    76     67.0 MiB   -115.4 MiB        3338                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.0 MiB   -115.4 MiB        3338                       open_set_hash.add(neighbor)
    78                                                             
    79     67.0 MiB   -106.2 MiB        2999           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.0 MiB   -106.2 MiB        2999           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.0 MiB     67.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.0 MiB      0.0 MiB         257       for row in grid:
    30     67.0 MiB      0.0 MiB       65792           for spot in row:
    31     67.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     67.0 MiB      0.0 MiB           1       count = 0
    34     67.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.0 MiB      0.0 MiB           1       came_from = {}
    37     69.5 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     72.4 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.4 MiB -11633.2 MiB        3060       while not open_set.empty():
    47     72.4 MiB -11633.2 MiB        3060           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.4 MiB -11633.6 MiB        3060           current = open_set.get()[2]
    53     72.4 MiB -11633.6 MiB        3060           open_set_hash.remove(current)
    54                                         
    55     72.4 MiB -11633.6 MiB        3060           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.4 MiB -11633.7 MiB        3060           if current == end:
    60     60.6 MiB    -11.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.4 MiB -104647.3 MiB       27531           for neighbor in current.neighbors:
    65     72.4 MiB -93016.0 MiB       24472               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.4 MiB -46521.9 MiB       12236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.4 MiB -46497.2 MiB       12236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.4 MiB -93021.3 MiB       24472               if temp_g_score < g_score[neighbor]:
    71     72.4 MiB -12581.5 MiB        3400                   came_from[neighbor] = current
    72     72.4 MiB -12581.8 MiB        3400                   g_score[neighbor] = temp_g_score
    73     72.4 MiB -12582.1 MiB        3400                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.4 MiB -12582.1 MiB        3400                   if neighbor not in open_set_hash:
    75     72.4 MiB -12582.1 MiB        3400                       count += 1
    76     72.4 MiB -12582.1 MiB        3400                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.4 MiB -12582.1 MiB        3400                       open_set_hash.add(neighbor)
    78                                                             
    79     72.4 MiB -11633.0 MiB        3059           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.4 MiB -11633.2 MiB        3059           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.3 MiB     62.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.9 MiB      0.0 MiB         257       for row in grid:
    30     62.9 MiB      0.0 MiB       65792           for spot in row:
    31     62.9 MiB      0.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.9 MiB      0.0 MiB           1       count = 0
    34     62.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.9 MiB      0.0 MiB           1       came_from = {}
    37     66.9 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.7 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.0 MiB      0.0 MiB        5616       while not open_set.empty():
    47     70.0 MiB      0.0 MiB        5616           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.0 MiB      0.0 MiB        5616           current = open_set.get()[2]
    53     70.0 MiB      0.0 MiB        5616           open_set_hash.remove(current)
    54                                         
    55     70.0 MiB      0.0 MiB        5616           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.0 MiB      0.0 MiB        5616           if current == end:
    60     70.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.0 MiB      0.0 MiB       50535           for neighbor in current.neighbors:
    65     70.0 MiB      0.0 MiB       44920               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.0 MiB      0.0 MiB       22460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.0 MiB      0.0 MiB       22460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.0 MiB      0.0 MiB       44920               if temp_g_score < g_score[neighbor]:
    71     70.0 MiB      0.2 MiB        6178                   came_from[neighbor] = current
    72     70.0 MiB      0.0 MiB        6178                   g_score[neighbor] = temp_g_score
    73     70.0 MiB      0.0 MiB        6178                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.0 MiB      0.0 MiB        6178                   if neighbor not in open_set_hash:
    75     70.0 MiB      0.0 MiB        6178                       count += 1
    76     70.0 MiB      0.0 MiB        6178                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.0 MiB      0.0 MiB        6178                       open_set_hash.add(neighbor)
    78                                                             
    79     70.0 MiB      0.0 MiB        5615           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.0 MiB      0.0 MiB        5615           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.0 MiB    102.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.0 MiB     -7.0 MiB         257       for row in grid:
    30    102.0 MiB  -1793.4 MiB       65792           for spot in row:
    31    102.0 MiB  -1786.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.9 MiB     -0.1 MiB           1       count = 0
    34    101.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.9 MiB      0.0 MiB           1       came_from = {}
    37    104.2 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.2 MiB -535297.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     78.6 MiB    -25.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     78.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     78.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     78.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     79.5 MiB -98202.9 MiB        5390       while not open_set.empty():
    47     79.5 MiB -98203.8 MiB        5390           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     79.5 MiB -98205.0 MiB        5390           current = open_set.get()[2]
    53     79.5 MiB -98205.6 MiB        5390           open_set_hash.remove(current)
    54                                         
    55     79.5 MiB -98206.1 MiB        5390           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     79.5 MiB -98206.8 MiB        5390           if current == end:
    60     49.7 MiB    -29.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     49.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     79.5 MiB -883644.2 MiB       48501           for neighbor in current.neighbors:
    65     79.5 MiB -785461.4 MiB       43112               if current.row != neighbor.row and current.col != neighbor.col:
    66     79.5 MiB -392737.0 MiB       21556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     79.5 MiB -392728.0 MiB       21556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     79.5 MiB -785470.4 MiB       43112               if temp_g_score < g_score[neighbor]:
    71     79.5 MiB -103887.3 MiB        5836                   came_from[neighbor] = current
    72     79.5 MiB -103888.0 MiB        5836                   g_score[neighbor] = temp_g_score
    73     79.5 MiB -103888.2 MiB        5836                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     79.5 MiB -103888.4 MiB        5836                   if neighbor not in open_set_hash:
    75     79.5 MiB -103888.6 MiB        5836                       count += 1
    76     79.5 MiB -103878.0 MiB        5836                       open_set.put((f_score[neighbor], count, neighbor))
    77     79.5 MiB -103879.8 MiB        5836                       open_set_hash.add(neighbor)
    78                                                             
    79     79.5 MiB -98201.2 MiB        5389           if draw is not None:
    80                                                     draw()
    81                                         
    82     79.5 MiB -98202.2 MiB        5389           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     52.4 MiB     52.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     56.7 MiB      0.0 MiB         257       for row in grid:
    30     56.7 MiB      0.0 MiB       65792           for spot in row:
    31     56.7 MiB      4.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.7 MiB      0.0 MiB           1       count = 0
    34     56.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     56.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.7 MiB      0.0 MiB           1       came_from = {}
    37     60.5 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.5 MiB -98525.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.4 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.2 MiB     -8.6 MiB        1505       while not open_set.empty():
    47     62.2 MiB     -8.6 MiB        1505           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.2 MiB     -8.6 MiB        1505           current = open_set.get()[2]
    53     62.2 MiB     -8.6 MiB        1505           open_set_hash.remove(current)
    54                                         
    55     62.2 MiB     -8.6 MiB        1505           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.2 MiB     -8.6 MiB        1505           if current == end:
    60     62.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.2 MiB    -77.2 MiB       13536           for neighbor in current.neighbors:
    65     62.2 MiB    -68.6 MiB       12032               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.2 MiB    -34.3 MiB        6016                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.2 MiB    -34.2 MiB        6016                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.2 MiB    -68.1 MiB       12032               if temp_g_score < g_score[neighbor]:
    71     62.2 MiB     -9.5 MiB        1745                   came_from[neighbor] = current
    72     62.2 MiB     -9.7 MiB        1745                   g_score[neighbor] = temp_g_score
    73     62.2 MiB     -9.7 MiB        1745                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.2 MiB     -9.7 MiB        1745                   if neighbor not in open_set_hash:
    75     62.2 MiB     -9.7 MiB        1745                       count += 1
    76     62.2 MiB     -9.5 MiB        1745                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.2 MiB     -9.6 MiB        1745                       open_set_hash.add(neighbor)
    78                                                             
    79     62.2 MiB     -8.6 MiB        1504           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.2 MiB     -8.6 MiB        1504           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.4 MiB     62.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.4 MiB  -4585.0 MiB         257       for row in grid:
    30     62.4 MiB -1172916.9 MiB       65792           for spot in row:
    31     62.4 MiB -1168354.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     24.6 MiB    -37.8 MiB           1       count = 0
    34     25.0 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     25.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     25.3 MiB      0.0 MiB           1       came_from = {}
    37     35.4 MiB  -5847.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     35.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     41.0 MiB  -2646.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     41.2 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     41.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     41.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     41.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     42.4 MiB     -1.3 MiB         176       while not open_set.empty():
    47     42.4 MiB     -1.3 MiB         176           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     42.4 MiB     -1.3 MiB         176           current = open_set.get()[2]
    53     42.4 MiB     -1.3 MiB         176           open_set_hash.remove(current)
    54                                         
    55     42.4 MiB     -1.3 MiB         176           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     42.4 MiB     -1.3 MiB         176           if current == end:
    60     42.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     42.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     42.4 MiB    -11.4 MiB        1575           for neighbor in current.neighbors:
    65     42.4 MiB     -9.8 MiB        1400               if current.row != neighbor.row and current.col != neighbor.col:
    66     42.4 MiB     -5.2 MiB         700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     42.4 MiB     -5.2 MiB         700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     42.4 MiB    -10.4 MiB        1400               if temp_g_score < g_score[neighbor]:
    71     42.4 MiB     -1.8 MiB         250                   came_from[neighbor] = current
    72     42.4 MiB     -1.9 MiB         250                   g_score[neighbor] = temp_g_score
    73     42.4 MiB     -1.9 MiB         250                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     42.4 MiB     -1.9 MiB         250                   if neighbor not in open_set_hash:
    75     42.4 MiB     -1.9 MiB         250                       count += 1
    76     42.4 MiB     -1.8 MiB         250                       open_set.put((f_score[neighbor], count, neighbor))
    77     42.4 MiB     -1.9 MiB         250                       open_set_hash.add(neighbor)
    78                                                             
    79     42.4 MiB     -1.3 MiB         175           if draw is not None:
    80                                                     draw()
    81                                         
    82     42.4 MiB     -1.3 MiB         175           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     45.1 MiB     45.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     56.2 MiB    -21.7 MiB         257       for row in grid:
    30     56.2 MiB  -5454.8 MiB       65792           for spot in row:
    31     56.2 MiB  -5422.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.2 MiB      0.0 MiB           1       count = 0
    34     56.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     56.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.2 MiB      0.0 MiB           1       came_from = {}
    37     57.1 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.7 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.7 MiB   -412.2 MiB         207       while not open_set.empty():
    47     60.7 MiB   -412.2 MiB         207           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.7 MiB   -412.2 MiB         207           current = open_set.get()[2]
    53     60.7 MiB   -412.2 MiB         207           open_set_hash.remove(current)
    54                                         
    55     60.7 MiB   -412.2 MiB         207           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.7 MiB   -412.2 MiB         207           if current == end:
    60     58.4 MiB     -2.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.7 MiB  -3692.5 MiB        1854           for neighbor in current.neighbors:
    65     60.7 MiB  -3280.5 MiB        1648               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.7 MiB  -1641.5 MiB         824                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.7 MiB  -1639.4 MiB         824                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.7 MiB  -3280.9 MiB        1648               if temp_g_score < g_score[neighbor]:
    71     60.7 MiB   -520.6 MiB         287                   came_from[neighbor] = current
    72     60.7 MiB   -520.8 MiB         287                   g_score[neighbor] = temp_g_score
    73     60.7 MiB   -521.0 MiB         287                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.7 MiB   -521.0 MiB         287                   if neighbor not in open_set_hash:
    75     60.7 MiB   -521.2 MiB         287                       count += 1
    76     60.7 MiB   -521.6 MiB         287                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.7 MiB   -522.0 MiB         287                       open_set_hash.add(neighbor)
    78                                                             
    79     60.7 MiB   -412.2 MiB         206           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.7 MiB   -412.2 MiB         206           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     58.4 MiB     58.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.4 MiB      0.0 MiB         257       for row in grid:
    30     58.4 MiB      0.0 MiB       65792           for spot in row:
    31     58.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.4 MiB      0.0 MiB           1       count = 0
    34     58.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.4 MiB      0.0 MiB           1       came_from = {}
    37     62.2 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.7 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.7 MiB      0.0 MiB         288       while not open_set.empty():
    47     65.7 MiB      0.0 MiB         288           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.7 MiB      0.0 MiB         288           current = open_set.get()[2]
    53     65.7 MiB      0.0 MiB         288           open_set_hash.remove(current)
    54                                         
    55     65.7 MiB      0.0 MiB         288           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.7 MiB      0.0 MiB         288           if current == end:
    60     65.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.7 MiB      0.0 MiB        2583           for neighbor in current.neighbors:
    65     65.7 MiB      0.0 MiB        2296               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.7 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.7 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.7 MiB      0.0 MiB        2296               if temp_g_score < g_score[neighbor]:
    71     65.7 MiB      0.0 MiB         676                   came_from[neighbor] = current
    72     65.7 MiB      0.0 MiB         676                   g_score[neighbor] = temp_g_score
    73     65.7 MiB      0.0 MiB         676                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.7 MiB      0.0 MiB         676                   if neighbor not in open_set_hash:
    75     65.7 MiB      0.0 MiB         676                       count += 1
    76     65.7 MiB      0.1 MiB         676                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.7 MiB      0.0 MiB         676                       open_set_hash.add(neighbor)
    78                                                             
    79     65.7 MiB      0.0 MiB         287           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.7 MiB      0.0 MiB         287           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.8 MiB    103.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.8 MiB   -971.9 MiB         257       for row in grid:
    30    103.8 MiB -249516.1 MiB       65792           for spot in row:
    31    103.8 MiB -248551.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.3 MiB     -9.5 MiB           1       count = 0
    34     94.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.3 MiB      0.0 MiB           1       came_from = {}
    37     97.8 MiB -19901.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.2 MiB -12916.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.3 MiB -247985.9 MiB        8428       while not open_set.empty():
    47    101.3 MiB -247987.7 MiB        8428           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.3 MiB -247989.6 MiB        8428           current = open_set.get()[2]
    53    101.3 MiB -247991.4 MiB        8428           open_set_hash.remove(current)
    54                                         
    55    101.3 MiB -247993.2 MiB        8428           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.3 MiB -247994.8 MiB        8428           if current == end:
    60     31.3 MiB    -70.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     33.2 MiB      1.9 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.3 MiB -2231573.3 MiB       75843           for neighbor in current.neighbors:
    65    101.3 MiB -1983597.7 MiB       67416               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.3 MiB -991874.7 MiB       33708                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.3 MiB -991735.2 MiB       33708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.3 MiB -1983626.6 MiB       67416               if temp_g_score < g_score[neighbor]:
    71    101.3 MiB -262237.6 MiB        8990                   came_from[neighbor] = current
    72    101.3 MiB -262238.3 MiB        8990                   g_score[neighbor] = temp_g_score
    73    101.3 MiB -262241.1 MiB        8990                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.3 MiB -262241.7 MiB        8990                   if neighbor not in open_set_hash:
    75    101.3 MiB -262245.9 MiB        8990                       count += 1
    76    101.3 MiB -262249.8 MiB        8990                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.3 MiB -262250.8 MiB        8990                       open_set_hash.add(neighbor)
    78                                                             
    79    101.3 MiB -247982.8 MiB        8427           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.3 MiB -247984.0 MiB        8427           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     38.3 MiB     38.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.6 MiB      0.0 MiB         257       for row in grid:
    30     58.6 MiB      0.0 MiB       65792           for spot in row:
    31     58.6 MiB     20.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.6 MiB      0.0 MiB           1       count = 0
    34     58.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.7 MiB      0.0 MiB           1       came_from = {}
    37     63.0 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.3 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.6 MiB      0.0 MiB        1660       while not open_set.empty():
    47     64.6 MiB      0.0 MiB        1660           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.6 MiB      0.0 MiB        1660           current = open_set.get()[2]
    53     64.6 MiB      0.0 MiB        1660           open_set_hash.remove(current)
    54                                         
    55     64.6 MiB      0.0 MiB        1660           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.6 MiB      0.0 MiB        1660           if current == end:
    60     64.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.6 MiB      0.0 MiB       14931           for neighbor in current.neighbors:
    65     64.6 MiB      0.0 MiB       13272               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.6 MiB      0.0 MiB        6636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.6 MiB      0.0 MiB        6636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.6 MiB      0.0 MiB       13272               if temp_g_score < g_score[neighbor]:
    71     64.6 MiB      0.2 MiB        2030                   came_from[neighbor] = current
    72     64.6 MiB      0.0 MiB        2030                   g_score[neighbor] = temp_g_score
    73     64.6 MiB      0.0 MiB        2030                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.6 MiB      0.0 MiB        2030                   if neighbor not in open_set_hash:
    75     64.6 MiB      0.0 MiB        2030                       count += 1
    76     64.6 MiB      0.0 MiB        2030                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.6 MiB      0.0 MiB        2030                       open_set_hash.add(neighbor)
    78                                                             
    79     64.6 MiB      0.0 MiB        1659           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.6 MiB      0.0 MiB        1659           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.6 MiB     64.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.6 MiB    -18.9 MiB         257       for row in grid:
    30     64.6 MiB  -4810.0 MiB       65792           for spot in row:
    31     64.6 MiB  -4791.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.4 MiB     -0.2 MiB           1       count = 0
    34     64.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     64.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     64.4 MiB      0.0 MiB           1       came_from = {}
    37     67.8 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.8 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.9 MiB -48681.6 MiB        3640       while not open_set.empty():
    47     70.9 MiB -48681.8 MiB        3640           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.9 MiB -48682.9 MiB        3640           current = open_set.get()[2]
    53     70.9 MiB -48683.1 MiB        3640           open_set_hash.remove(current)
    54                                         
    55     70.9 MiB -48683.3 MiB        3640           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.9 MiB -48683.6 MiB        3640           if current == end:
    60     56.5 MiB    -14.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.9 MiB -438072.7 MiB       32751           for neighbor in current.neighbors:
    65     70.9 MiB -389393.8 MiB       29112               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.9 MiB -194711.4 MiB       14556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.9 MiB -194685.9 MiB       14556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.9 MiB -389400.6 MiB       29112               if temp_g_score < g_score[neighbor]:
    71     70.9 MiB -53157.8 MiB        4022                   came_from[neighbor] = current
    72     70.9 MiB -53158.1 MiB        4022                   g_score[neighbor] = temp_g_score
    73     70.9 MiB -53158.0 MiB        4022                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.9 MiB -53158.2 MiB        4022                   if neighbor not in open_set_hash:
    75     70.9 MiB -53158.3 MiB        4022                       count += 1
    76     70.9 MiB -53159.1 MiB        4022                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.9 MiB -53159.2 MiB        4022                       open_set_hash.add(neighbor)
    78                                                             
    79     70.9 MiB -48680.9 MiB        3639           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.9 MiB -48681.1 MiB        3639           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     57.9 MiB     57.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     57.9 MiB  -2157.2 MiB         257       for row in grid:
    30     57.9 MiB -555009.2 MiB       65792           for spot in row:
    31     57.9 MiB -552846.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.8 MiB     -0.1 MiB           1       count = 0
    34     57.8 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     57.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.8 MiB      0.0 MiB           1       came_from = {}
    37     58.3 MiB -25001.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.7 MiB     -1.7 MiB           1       g_score[start] = 0
    39     61.7 MiB      5.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.9 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.3 MiB      0.0 MiB        1771       while not open_set.empty():
    47     62.3 MiB      0.0 MiB        1771           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.3 MiB      0.0 MiB        1771           current = open_set.get()[2]
    53     62.3 MiB      0.0 MiB        1771           open_set_hash.remove(current)
    54                                         
    55     62.3 MiB      0.0 MiB        1771           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.3 MiB      0.0 MiB        1771           if current == end:
    60     62.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.3 MiB      0.1 MiB       15930           for neighbor in current.neighbors:
    65     62.3 MiB      0.1 MiB       14160               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.3 MiB      0.0 MiB        7080                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.3 MiB      0.0 MiB        7080                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.3 MiB      0.0 MiB       14160               if temp_g_score < g_score[neighbor]:
    71     62.3 MiB      0.0 MiB        2123                   came_from[neighbor] = current
    72     62.3 MiB      0.0 MiB        2123                   g_score[neighbor] = temp_g_score
    73     62.3 MiB      0.0 MiB        2123                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.3 MiB      0.0 MiB        2123                   if neighbor not in open_set_hash:
    75     62.3 MiB      0.0 MiB        2123                       count += 1
    76     62.3 MiB      0.0 MiB        2123                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.3 MiB      0.1 MiB        2123                       open_set_hash.add(neighbor)
    78                                                             
    79     62.3 MiB      0.0 MiB        1770           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.3 MiB      0.0 MiB        1770           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.3 MiB     62.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.3 MiB   -358.5 MiB         257       for row in grid:
    30     62.3 MiB -92041.7 MiB       65792           for spot in row:
    31     62.3 MiB -91684.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.8 MiB     -2.5 MiB           1       count = 0
    34     59.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.8 MiB      0.0 MiB           1       came_from = {}
    37     62.4 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.2 MiB      4.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.3 MiB    -64.6 MiB        1536       while not open_set.empty():
    47     67.3 MiB    -64.6 MiB        1536           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.3 MiB    -64.6 MiB        1536           current = open_set.get()[2]
    53     67.3 MiB    -64.6 MiB        1536           open_set_hash.remove(current)
    54                                         
    55     67.3 MiB    -64.6 MiB        1536           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.3 MiB    -64.6 MiB        1536           if current == end:
    60     67.2 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.3 MiB   -581.3 MiB       13815           for neighbor in current.neighbors:
    65     67.3 MiB   -516.7 MiB       12280               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.3 MiB   -258.4 MiB        6140                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.3 MiB   -258.4 MiB        6140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.3 MiB   -516.8 MiB       12280               if temp_g_score < g_score[neighbor]:
    71     67.3 MiB    -71.6 MiB        1758                   came_from[neighbor] = current
    72     67.3 MiB    -71.6 MiB        1758                   g_score[neighbor] = temp_g_score
    73     67.3 MiB    -71.6 MiB        1758                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.3 MiB    -71.6 MiB        1758                   if neighbor not in open_set_hash:
    75     67.3 MiB    -71.6 MiB        1758                       count += 1
    76     67.3 MiB    -71.6 MiB        1758                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.3 MiB    -71.6 MiB        1758                       open_set_hash.add(neighbor)
    78                                                             
    79     67.3 MiB    -64.6 MiB        1535           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.3 MiB    -64.6 MiB        1535           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.7 MiB    103.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.7 MiB  -1072.2 MiB         257       for row in grid:
    30    103.7 MiB -274509.3 MiB       65792           for spot in row:
    31    103.7 MiB -273440.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.2 MiB     -5.5 MiB           1       count = 0
    34     98.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.2 MiB      0.0 MiB           1       came_from = {}
    37    102.7 MiB  -3026.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.8 MiB     -0.9 MiB           1       g_score[start] = 0
    39    102.8 MiB -13332.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.8 MiB -13539.0 MiB        3150       while not open_set.empty():
    47    102.8 MiB -13539.0 MiB        3150           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.8 MiB -13539.0 MiB        3150           current = open_set.get()[2]
    53    102.8 MiB -13539.1 MiB        3150           open_set_hash.remove(current)
    54                                         
    55    102.8 MiB -13539.1 MiB        3150           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.8 MiB -13539.2 MiB        3150           if current == end:
    60     98.0 MiB     -4.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.8 MiB -121820.3 MiB       28341           for neighbor in current.neighbors:
    65    102.8 MiB -108281.2 MiB       25192               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.8 MiB -54143.7 MiB       12596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.8 MiB -54137.7 MiB       12596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.8 MiB -108285.2 MiB       25192               if temp_g_score < g_score[neighbor]:
    71    102.8 MiB -15335.1 MiB        3628                   came_from[neighbor] = current
    72    102.8 MiB -15335.2 MiB        3628                   g_score[neighbor] = temp_g_score
    73    102.8 MiB -15335.2 MiB        3628                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.8 MiB -15335.2 MiB        3628                   if neighbor not in open_set_hash:
    75    102.8 MiB -15335.2 MiB        3628                       count += 1
    76    102.8 MiB -15334.9 MiB        3628                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.8 MiB -15334.9 MiB        3628                       open_set_hash.add(neighbor)
    78                                                             
    79    102.8 MiB -13538.9 MiB        3149           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.8 MiB -13538.9 MiB        3149           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.0 MiB     98.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.1 MiB  -5629.1 MiB         257       for row in grid:
    30     98.1 MiB -1443700.4 MiB       65792           for spot in row:
    31     98.1 MiB -1438085.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     74.7 MiB    -23.4 MiB           1       count = 0
    34     74.8 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     74.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.8 MiB      0.0 MiB           1       came_from = {}
    37     79.7 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     79.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     82.1 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     82.2 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     82.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     82.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     82.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     82.6 MiB  -2530.4 MiB        3069       while not open_set.empty():
    47     82.6 MiB  -2530.6 MiB        3069           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     82.6 MiB  -2530.7 MiB        3069           current = open_set.get()[2]
    53     82.6 MiB  -2530.7 MiB        3069           open_set_hash.remove(current)
    54                                         
    55     82.6 MiB  -2530.7 MiB        3069           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     82.6 MiB  -2530.7 MiB        3069           if current == end:
    60     81.1 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     81.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     82.6 MiB -22764.5 MiB       27612           for neighbor in current.neighbors:
    65     82.6 MiB -20234.8 MiB       24544               if current.row != neighbor.row and current.col != neighbor.col:
    66     82.6 MiB -10118.2 MiB       12272                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     82.6 MiB -10116.7 MiB       12272                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     82.6 MiB -20234.9 MiB       24544               if temp_g_score < g_score[neighbor]:
    71     82.6 MiB  -2735.3 MiB        3389                   came_from[neighbor] = current
    72     82.6 MiB  -2735.6 MiB        3389                   g_score[neighbor] = temp_g_score
    73     82.6 MiB  -2735.9 MiB        3389                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     82.6 MiB  -2735.9 MiB        3389                   if neighbor not in open_set_hash:
    75     82.6 MiB  -2736.0 MiB        3389                       count += 1
    76     82.6 MiB  -2736.0 MiB        3389                       open_set.put((f_score[neighbor], count, neighbor))
    77     82.6 MiB  -2736.0 MiB        3389                       open_set_hash.add(neighbor)
    78                                                             
    79     82.6 MiB  -2529.7 MiB        3068           if draw is not None:
    80                                                     draw()
    81                                         
    82     82.6 MiB  -2529.9 MiB        3068           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     81.1 MiB     81.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     81.4 MiB  -6070.5 MiB         257       for row in grid:
    30     81.4 MiB -1556504.8 MiB       65792           for spot in row:
    31     81.4 MiB -1550448.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     50.2 MiB    -31.2 MiB           1       count = 0
    34     50.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     50.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     50.2 MiB      0.0 MiB           1       came_from = {}
    37     54.5 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     54.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     58.8 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     58.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     58.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     58.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     58.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     58.9 MiB -14873.8 MiB        7372       while not open_set.empty():
    47     58.9 MiB -14873.8 MiB        7372           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     58.9 MiB -14874.1 MiB        7372           current = open_set.get()[2]
    53     58.9 MiB -14874.1 MiB        7372           open_set_hash.remove(current)
    54                                         
    55     58.9 MiB -14874.1 MiB        7372           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     58.9 MiB -14874.1 MiB        7372           if current == end:
    60     51.0 MiB     -7.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     51.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     58.9 MiB -133829.0 MiB       66339           for neighbor in current.neighbors:
    65     58.9 MiB -118956.5 MiB       58968               if current.row != neighbor.row and current.col != neighbor.col:
    66     58.9 MiB -59488.4 MiB       29484                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     58.9 MiB -59468.8 MiB       29484                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     58.9 MiB -118958.1 MiB       58968               if temp_g_score < g_score[neighbor]:
    71     58.9 MiB -15881.7 MiB        7910                   came_from[neighbor] = current
    72     58.9 MiB -15881.9 MiB        7910                   g_score[neighbor] = temp_g_score
    73     58.9 MiB -15882.1 MiB        7910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     58.9 MiB -15882.2 MiB        7910                   if neighbor not in open_set_hash:
    75     58.9 MiB -15882.8 MiB        7910                       count += 1
    76     58.9 MiB -15883.0 MiB        7910                       open_set.put((f_score[neighbor], count, neighbor))
    77     58.9 MiB -15883.0 MiB        7910                       open_set_hash.add(neighbor)
    78                                                             
    79     58.9 MiB -14873.6 MiB        7371           if draw is not None:
    80                                                     draw()
    81                                         
    82     58.9 MiB -14873.7 MiB        7371           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     53.6 MiB     53.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     54.9 MiB   -941.6 MiB         257       for row in grid:
    30     54.9 MiB -241578.0 MiB       65792           for spot in row:
    31     54.9 MiB -240639.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     53.4 MiB     -1.5 MiB           1       count = 0
    34     53.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     53.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     53.4 MiB      0.0 MiB           1       came_from = {}
    37     57.8 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.8 MiB  -3077.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.0 MiB     -0.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.1 MiB   -264.6 MiB         198       while not open_set.empty():
    47     61.1 MiB   -264.6 MiB         198           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.1 MiB   -264.7 MiB         198           current = open_set.get()[2]
    53     61.1 MiB   -264.7 MiB         198           open_set_hash.remove(current)
    54                                         
    55     61.1 MiB   -264.7 MiB         198           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.1 MiB   -264.7 MiB         198           if current == end:
    60     58.0 MiB     -3.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.1 MiB  -2368.2 MiB        1773           for neighbor in current.neighbors:
    65     61.1 MiB  -2104.5 MiB        1576               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.1 MiB  -1054.4 MiB         788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.1 MiB  -1050.6 MiB         788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.1 MiB  -2105.6 MiB        1576               if temp_g_score < g_score[neighbor]:
    71     61.1 MiB   -358.6 MiB         290                   came_from[neighbor] = current
    72     61.1 MiB   -358.6 MiB         290                   g_score[neighbor] = temp_g_score
    73     61.1 MiB   -358.6 MiB         290                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.1 MiB   -358.6 MiB         290                   if neighbor not in open_set_hash:
    75     61.1 MiB   -358.6 MiB         290                       count += 1
    76     61.1 MiB   -358.6 MiB         290                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.1 MiB   -358.6 MiB         290                       open_set_hash.add(neighbor)
    78                                                             
    79     61.1 MiB   -264.6 MiB         197           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.1 MiB   -264.6 MiB         197           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     58.0 MiB     58.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.0 MiB  -2944.5 MiB         257       for row in grid:
    30     58.0 MiB -753430.5 MiB       65792           for spot in row:
    31     58.0 MiB -750497.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     41.5 MiB    -16.5 MiB           1       count = 0
    34     41.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     42.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     42.0 MiB      0.0 MiB           1       came_from = {}
    37     46.2 MiB  -2280.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     46.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     48.1 MiB -16663.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     48.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     48.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     48.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     48.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     48.3 MiB    -68.3 MiB        1254       while not open_set.empty():
    47     48.3 MiB    -68.3 MiB        1254           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     48.3 MiB    -68.3 MiB        1254           current = open_set.get()[2]
    53     48.3 MiB    -68.3 MiB        1254           open_set_hash.remove(current)
    54                                         
    55     48.3 MiB    -68.3 MiB        1254           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     48.3 MiB    -68.3 MiB        1254           if current == end:
    60     48.2 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     48.3 MiB   -615.0 MiB       11277           for neighbor in current.neighbors:
    65     48.3 MiB   -546.7 MiB       10024               if current.row != neighbor.row and current.col != neighbor.col:
    66     48.3 MiB   -273.3 MiB        5012                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     48.3 MiB   -273.4 MiB        5012                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     48.3 MiB   -546.7 MiB       10024               if temp_g_score < g_score[neighbor]:
    71     48.3 MiB    -93.0 MiB        1730                   came_from[neighbor] = current
    72     48.3 MiB    -93.1 MiB        1730                   g_score[neighbor] = temp_g_score
    73     48.3 MiB    -93.1 MiB        1730                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     48.3 MiB    -93.1 MiB        1730                   if neighbor not in open_set_hash:
    75     48.3 MiB    -93.1 MiB        1730                       count += 1
    76     48.3 MiB    -93.0 MiB        1730                       open_set.put((f_score[neighbor], count, neighbor))
    77     48.3 MiB    -93.1 MiB        1730                       open_set_hash.add(neighbor)
    78                                                             
    79     48.3 MiB    -68.3 MiB        1253           if draw is not None:
    80                                                     draw()
    81                                         
    82     48.3 MiB    -68.3 MiB        1253           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.4 MiB     94.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.4 MiB  -1218.5 MiB         257       for row in grid:
    30     94.4 MiB -312395.8 MiB       65792           for spot in row:
    31     94.4 MiB -311181.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.2 MiB     -6.2 MiB           1       count = 0
    34     88.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.2 MiB      0.0 MiB           1       came_from = {}
    37     88.2 MiB -200412.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     84.7 MiB     -3.5 MiB           1       g_score[start] = 0
    39     85.0 MiB -394578.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     80.1 MiB     -4.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     80.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     80.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     80.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     80.7 MiB   -734.7 MiB         644       while not open_set.empty():
    47     80.7 MiB   -734.8 MiB         644           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     80.7 MiB   -734.6 MiB         644           current = open_set.get()[2]
    53     80.7 MiB   -734.9 MiB         644           open_set_hash.remove(current)
    54                                         
    55     80.7 MiB   -734.9 MiB         644           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     80.7 MiB   -734.9 MiB         644           if current == end:
    60     74.5 MiB     -6.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     80.7 MiB  -6586.1 MiB        5787           for neighbor in current.neighbors:
    65     80.7 MiB  -5851.8 MiB        5144               if current.row != neighbor.row and current.col != neighbor.col:
    66     80.7 MiB  -2932.2 MiB        2572                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     80.7 MiB  -2920.5 MiB        2572                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     80.7 MiB  -5853.4 MiB        5144               if temp_g_score < g_score[neighbor]:
    71     80.7 MiB   -898.4 MiB         800                   came_from[neighbor] = current
    72     80.7 MiB   -898.4 MiB         800                   g_score[neighbor] = temp_g_score
    73     80.7 MiB   -898.4 MiB         800                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     80.7 MiB   -898.4 MiB         800                   if neighbor not in open_set_hash:
    75     80.7 MiB   -898.4 MiB         800                       count += 1
    76     80.7 MiB   -898.4 MiB         800                       open_set.put((f_score[neighbor], count, neighbor))
    77     80.7 MiB   -901.3 MiB         800                       open_set_hash.add(neighbor)
    78                                                             
    79     80.7 MiB   -736.2 MiB         643           if draw is not None:
    80                                                     draw()
    81                                         
    82     80.7 MiB   -734.8 MiB         643           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     79.2 MiB  -6698.9 MiB         257       for row in grid:
    30     79.2 MiB -1718174.4 MiB       65792           for spot in row:
    31     79.2 MiB -1711494.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.1 MiB    -20.1 MiB           1       count = 0
    34     59.2 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     59.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.2 MiB      0.0 MiB           1       came_from = {}
    37     61.4 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     63.9 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.9 MiB      0.0 MiB         465       while not open_set.empty():
    47     63.9 MiB      0.0 MiB         465           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.9 MiB      0.0 MiB         465           current = open_set.get()[2]
    53     63.9 MiB      0.0 MiB         465           open_set_hash.remove(current)
    54                                         
    55     63.9 MiB      0.0 MiB         465           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.9 MiB      0.0 MiB         465           if current == end:
    60     63.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.9 MiB      0.0 MiB        4176           for neighbor in current.neighbors:
    65     63.9 MiB      0.0 MiB        3712               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.9 MiB      0.0 MiB        1856                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.9 MiB      0.0 MiB        1856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.9 MiB      0.0 MiB        3712               if temp_g_score < g_score[neighbor]:
    71     63.9 MiB      0.0 MiB         617                   came_from[neighbor] = current
    72     63.9 MiB      0.0 MiB         617                   g_score[neighbor] = temp_g_score
    73     63.9 MiB      0.0 MiB         617                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.9 MiB      0.0 MiB         617                   if neighbor not in open_set_hash:
    75     63.9 MiB      0.0 MiB         617                       count += 1
    76     63.9 MiB      0.0 MiB         617                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.9 MiB      0.0 MiB         617                       open_set_hash.add(neighbor)
    78                                                             
    79     63.9 MiB      0.0 MiB         464           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.9 MiB      0.0 MiB         464           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.0 MiB     64.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.0 MiB   -112.4 MiB         257       for row in grid:
    30     64.0 MiB -28863.5 MiB       65792           for spot in row:
    31     64.0 MiB -28751.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.0 MiB     -1.0 MiB           1       count = 0
    34     63.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.0 MiB      0.0 MiB           1       came_from = {}
    37     65.7 MiB  -2245.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.0 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.2 MiB  -5682.9 MiB        3712       while not open_set.empty():
    47     70.2 MiB  -5682.9 MiB        3712           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.2 MiB  -5682.9 MiB        3712           current = open_set.get()[2]
    53     70.2 MiB  -5682.9 MiB        3712           open_set_hash.remove(current)
    54                                         
    55     70.2 MiB  -5682.9 MiB        3712           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.2 MiB  -5682.9 MiB        3712           if current == end:
    60     66.3 MiB     -4.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.3 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.2 MiB -51121.9 MiB       33399           for neighbor in current.neighbors:
    65     70.2 MiB -45439.2 MiB       29688               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.2 MiB -22725.9 MiB       14844                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.2 MiB -22716.9 MiB       14844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.2 MiB -45442.8 MiB       29688               if temp_g_score < g_score[neighbor]:
    71     70.2 MiB  -6091.6 MiB        4070                   came_from[neighbor] = current
    72     70.2 MiB  -6091.8 MiB        4070                   g_score[neighbor] = temp_g_score
    73     70.2 MiB  -6091.8 MiB        4070                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.2 MiB  -6091.8 MiB        4070                   if neighbor not in open_set_hash:
    75     70.2 MiB  -6091.8 MiB        4070                       count += 1
    76     70.2 MiB  -6092.0 MiB        4070                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.2 MiB  -6091.9 MiB        4070                       open_set_hash.add(neighbor)
    78                                                             
    79     70.2 MiB  -5682.9 MiB        3711           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.2 MiB  -5682.9 MiB        3711           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     66.4 MiB     66.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     66.4 MiB      0.0 MiB         257       for row in grid:
    30     66.4 MiB      0.0 MiB       65792           for spot in row:
    31     66.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.4 MiB      0.0 MiB           1       count = 0
    34     66.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.4 MiB      0.0 MiB           1       came_from = {}
    37     66.5 MiB      0.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.9 MiB -72390.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.8 MiB     -2.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.8 MiB   -381.6 MiB        2058       while not open_set.empty():
    47     64.8 MiB   -381.6 MiB        2058           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.8 MiB   -381.6 MiB        2058           current = open_set.get()[2]
    53     64.8 MiB   -381.6 MiB        2058           open_set_hash.remove(current)
    54                                         
    55     64.8 MiB   -381.6 MiB        2058           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.8 MiB   -381.6 MiB        2058           if current == end:
    60     64.3 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.8 MiB  -3431.3 MiB       18513           for neighbor in current.neighbors:
    65     64.8 MiB  -3050.1 MiB       16456               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.8 MiB  -1525.3 MiB        8228                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.8 MiB  -1524.8 MiB        8228                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.8 MiB  -3050.1 MiB       16456               if temp_g_score < g_score[neighbor]:
    71     64.8 MiB   -453.0 MiB        2490                   came_from[neighbor] = current
    72     64.8 MiB   -453.0 MiB        2490                   g_score[neighbor] = temp_g_score
    73     64.8 MiB   -453.0 MiB        2490                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.8 MiB   -453.0 MiB        2490                   if neighbor not in open_set_hash:
    75     64.8 MiB   -453.0 MiB        2490                       count += 1
    76     64.8 MiB   -453.0 MiB        2490                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.8 MiB   -453.0 MiB        2490                       open_set_hash.add(neighbor)
    78                                                             
    79     64.8 MiB   -381.6 MiB        2057           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.8 MiB   -381.6 MiB        2057           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.3 MiB     64.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.3 MiB   -159.8 MiB         257       for row in grid:
    30     64.3 MiB -40530.6 MiB       65792           for spot in row:
    31     64.3 MiB -40370.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.4 MiB     -2.9 MiB           1       count = 0
    34     61.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.4 MiB      0.0 MiB           1       came_from = {}
    37     66.0 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.4 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.5 MiB   -521.8 MiB        2912       while not open_set.empty():
    47     67.5 MiB   -521.8 MiB        2912           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.5 MiB   -521.8 MiB        2912           current = open_set.get()[2]
    53     67.5 MiB   -521.8 MiB        2912           open_set_hash.remove(current)
    54                                         
    55     67.5 MiB   -521.8 MiB        2912           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.5 MiB   -521.8 MiB        2912           if current == end:
    60     67.1 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.5 MiB  -4694.6 MiB       26199           for neighbor in current.neighbors:
    65     67.5 MiB  -4173.0 MiB       23288               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.5 MiB  -2087.2 MiB       11644                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.5 MiB  -2085.9 MiB       11644                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.5 MiB  -4173.1 MiB       23288               if temp_g_score < g_score[neighbor]:
    71     67.5 MiB   -563.7 MiB        3220                   came_from[neighbor] = current
    72     67.5 MiB   -563.8 MiB        3220                   g_score[neighbor] = temp_g_score
    73     67.5 MiB   -563.8 MiB        3220                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.5 MiB   -563.8 MiB        3220                   if neighbor not in open_set_hash:
    75     67.5 MiB   -563.8 MiB        3220                       count += 1
    76     67.5 MiB   -563.8 MiB        3220                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.5 MiB   -563.8 MiB        3220                       open_set_hash.add(neighbor)
    78                                                             
    79     67.5 MiB   -521.8 MiB        2911           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.5 MiB   -521.8 MiB        2911           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.8 MiB     98.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.8 MiB   -946.2 MiB         257       for row in grid:
    30     98.8 MiB -242131.3 MiB       65792           for spot in row:
    31     98.8 MiB -241191.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.0 MiB     -7.8 MiB           1       count = 0
    34     91.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.1 MiB      0.0 MiB           1       came_from = {}
    37     96.2 MiB  -6141.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.8 MiB     -0.4 MiB           1       g_score[start] = 0
    39     98.6 MiB  -3411.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.6 MiB -25337.8 MiB        4601       while not open_set.empty():
    47     98.6 MiB -25338.1 MiB        4601           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.6 MiB -25338.3 MiB        4601           current = open_set.get()[2]
    53     98.6 MiB -25338.6 MiB        4601           open_set_hash.remove(current)
    54                                         
    55     98.6 MiB -25338.8 MiB        4601           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.6 MiB -25339.0 MiB        4601           if current == end:
    60     86.7 MiB    -11.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     86.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.6 MiB -228001.7 MiB       41400           for neighbor in current.neighbors:
    65     98.6 MiB -202666.1 MiB       36800               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.6 MiB -101345.3 MiB       18400                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.6 MiB -101322.2 MiB       18400                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.6 MiB -202669.5 MiB       36800               if temp_g_score < g_score[neighbor]:
    71     98.6 MiB -27878.6 MiB        5113                   came_from[neighbor] = current
    72     98.6 MiB -27879.2 MiB        5113                   g_score[neighbor] = temp_g_score
    73     98.6 MiB -27880.2 MiB        5113                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.6 MiB -27880.4 MiB        5113                   if neighbor not in open_set_hash:
    75     98.6 MiB -27880.7 MiB        5113                       count += 1
    76     98.6 MiB -27880.9 MiB        5113                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.6 MiB -27881.5 MiB        5113                       open_set_hash.add(neighbor)
    78                                                             
    79     98.6 MiB -25337.6 MiB        4600           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.6 MiB -25337.6 MiB        4600           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.2 MiB     89.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.5 MiB   -169.4 MiB         257       for row in grid:
    30     90.5 MiB -43207.8 MiB       65792           for spot in row:
    31     90.5 MiB -43040.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     86.1 MiB     -4.3 MiB           1       count = 0
    34     86.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     86.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     86.1 MiB      0.0 MiB           1       came_from = {}
    37     90.9 MiB      4.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     90.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     91.3 MiB -109433.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     89.0 MiB     -2.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     89.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     89.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     89.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     89.1 MiB -62519.1 MiB        7918       while not open_set.empty():
    47     89.1 MiB -62519.9 MiB        7918           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     89.1 MiB -62520.9 MiB        7918           current = open_set.get()[2]
    53     89.1 MiB -62521.7 MiB        7918           open_set_hash.remove(current)
    54                                         
    55     89.1 MiB -62522.6 MiB        7918           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     89.1 MiB -62523.2 MiB        7918           if current == end:
    60     55.9 MiB    -33.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     89.1 MiB -562522.6 MiB       71253           for neighbor in current.neighbors:
    65     89.1 MiB -500012.6 MiB       63336               if current.row != neighbor.row and current.col != neighbor.col:
    66     89.1 MiB -250031.5 MiB       31668                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     89.1 MiB -249985.6 MiB       31668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     89.1 MiB -500023.0 MiB       63336               if temp_g_score < g_score[neighbor]:
    71     89.1 MiB -66389.4 MiB        8426                   came_from[neighbor] = current
    72     89.1 MiB -66389.8 MiB        8426                   g_score[neighbor] = temp_g_score
    73     89.1 MiB -66390.3 MiB        8426                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     89.1 MiB -66390.6 MiB        8426                   if neighbor not in open_set_hash:
    75     89.1 MiB -66391.1 MiB        8426                       count += 1
    76     89.1 MiB -66392.7 MiB        8426                       open_set.put((f_score[neighbor], count, neighbor))
    77     89.1 MiB -66393.4 MiB        8426                       open_set_hash.add(neighbor)
    78                                                             
    79     89.1 MiB -62517.1 MiB        7917           if draw is not None:
    80                                                     draw()
    81                                         
    82     89.1 MiB -62518.1 MiB        7917           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     55.9 MiB     55.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     57.8 MiB     -6.3 MiB         257       for row in grid:
    30     57.8 MiB  -1623.2 MiB       65792           for spot in row:
    31     57.8 MiB  -1615.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.8 MiB      0.0 MiB           1       count = 0
    34     57.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.9 MiB      0.0 MiB           1       came_from = {}
    37     60.1 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.4 MiB -225359.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     56.7 MiB     -3.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     56.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     56.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     56.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     56.8 MiB   -139.7 MiB        6716       while not open_set.empty():
    47     56.8 MiB   -139.7 MiB        6716           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     56.8 MiB   -139.7 MiB        6716           current = open_set.get()[2]
    53     56.8 MiB   -139.7 MiB        6716           open_set_hash.remove(current)
    54                                         
    55     56.8 MiB   -139.7 MiB        6716           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     56.8 MiB   -139.7 MiB        6716           if current == end:
    60     56.7 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     56.8 MiB  -1257.1 MiB       60435           for neighbor in current.neighbors:
    65     56.8 MiB  -1117.5 MiB       53720               if current.row != neighbor.row and current.col != neighbor.col:
    66     56.8 MiB   -558.8 MiB       26860                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     56.8 MiB   -558.7 MiB       26860                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     56.8 MiB  -1117.5 MiB       53720               if temp_g_score < g_score[neighbor]:
    71     56.8 MiB   -150.6 MiB        7190                   came_from[neighbor] = current
    72     56.8 MiB   -150.7 MiB        7190                   g_score[neighbor] = temp_g_score
    73     56.8 MiB   -150.7 MiB        7190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     56.8 MiB   -150.7 MiB        7190                   if neighbor not in open_set_hash:
    75     56.8 MiB   -150.7 MiB        7190                       count += 1
    76     56.8 MiB   -150.7 MiB        7190                       open_set.put((f_score[neighbor], count, neighbor))
    77     56.8 MiB   -150.7 MiB        7190                       open_set_hash.add(neighbor)
    78                                                             
    79     56.8 MiB   -139.7 MiB        6715           if draw is not None:
    80                                                     draw()
    81                                         
    82     56.8 MiB   -139.7 MiB        6715           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     56.7 MiB     56.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     56.7 MiB  -1073.1 MiB         257       for row in grid:
    30     56.7 MiB -274903.9 MiB       65792           for spot in row:
    31     56.7 MiB -273836.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     49.3 MiB     -7.4 MiB           1       count = 0
    34     49.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     49.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     49.7 MiB      0.0 MiB           1       came_from = {}
    37     53.8 MiB  -1724.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     53.5 MiB     -0.2 MiB           1       g_score[start] = 0
    39     58.4 MiB      4.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     58.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     58.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     58.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     58.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     58.4 MiB      0.0 MiB         920       while not open_set.empty():
    47     58.4 MiB      0.0 MiB         920           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     58.4 MiB      0.0 MiB         920           current = open_set.get()[2]
    53     58.4 MiB      0.0 MiB         920           open_set_hash.remove(current)
    54                                         
    55     58.4 MiB      0.0 MiB         920           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     58.4 MiB      0.0 MiB         920           if current == end:
    60     58.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     58.4 MiB      0.0 MiB        8271           for neighbor in current.neighbors:
    65     58.4 MiB      0.0 MiB        7352               if current.row != neighbor.row and current.col != neighbor.col:
    66     58.4 MiB      0.0 MiB        3676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     58.4 MiB      0.0 MiB        3676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     58.4 MiB      0.0 MiB        7352               if temp_g_score < g_score[neighbor]:
    71     58.4 MiB      0.0 MiB        1090                   came_from[neighbor] = current
    72     58.4 MiB      0.0 MiB        1090                   g_score[neighbor] = temp_g_score
    73     58.4 MiB      0.0 MiB        1090                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     58.4 MiB      0.0 MiB        1090                   if neighbor not in open_set_hash:
    75     58.4 MiB      0.0 MiB        1090                       count += 1
    76     58.4 MiB      0.0 MiB        1090                       open_set.put((f_score[neighbor], count, neighbor))
    77     58.4 MiB      0.0 MiB        1090                       open_set_hash.add(neighbor)
    78                                                             
    79     58.4 MiB      0.0 MiB         919           if draw is not None:
    80                                                     draw()
    81                                         
    82     58.4 MiB      0.0 MiB         919           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     58.5 MiB     58.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.5 MiB    -41.6 MiB         257       for row in grid:
    30     58.5 MiB -10655.3 MiB       65792           for spot in row:
    31     58.5 MiB -10613.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.5 MiB     -0.0 MiB           1       count = 0
    34     58.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.5 MiB      0.0 MiB           1       came_from = {}
    37     60.3 MiB    -35.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     62.2 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.3 MiB      0.0 MiB        1794       while not open_set.empty():
    47     62.3 MiB      0.0 MiB        1794           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.3 MiB      0.0 MiB        1794           current = open_set.get()[2]
    53     62.3 MiB      0.0 MiB        1794           open_set_hash.remove(current)
    54                                         
    55     62.3 MiB      0.0 MiB        1794           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.3 MiB      0.0 MiB        1794           if current == end:
    60     62.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.3 MiB      0.0 MiB       16137           for neighbor in current.neighbors:
    65     62.3 MiB      0.0 MiB       14344               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.3 MiB      0.0 MiB        7172                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.3 MiB      0.0 MiB        7172                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.3 MiB      0.0 MiB       14344               if temp_g_score < g_score[neighbor]:
    71     62.3 MiB      0.1 MiB        2054                   came_from[neighbor] = current
    72     62.3 MiB      0.0 MiB        2054                   g_score[neighbor] = temp_g_score
    73     62.3 MiB      0.0 MiB        2054                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.3 MiB      0.0 MiB        2054                   if neighbor not in open_set_hash:
    75     62.3 MiB      0.0 MiB        2054                       count += 1
    76     62.3 MiB      0.0 MiB        2054                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.3 MiB      0.0 MiB        2054                       open_set_hash.add(neighbor)
    78                                                             
    79     62.3 MiB      0.0 MiB        1793           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.3 MiB      0.0 MiB        1793           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.6 MiB    100.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.6 MiB   -467.9 MiB         257       for row in grid:
    30    100.6 MiB -119546.6 MiB       65792           for spot in row:
    31    100.6 MiB -119085.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.7 MiB     -8.0 MiB           1       count = 0
    34     92.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.7 MiB      0.0 MiB           1       came_from = {}
    37     92.8 MiB -267544.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     84.5 MiB     -8.3 MiB           1       g_score[start] = 0
    39     85.2 MiB -1063645.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     36.8 MiB    -48.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     36.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     36.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     36.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     40.6 MiB  -3541.6 MiB        1680       while not open_set.empty():
    47     40.6 MiB  -3542.2 MiB        1680           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     40.6 MiB  -3541.9 MiB        1680           current = open_set.get()[2]
    53     40.6 MiB  -3542.3 MiB        1680           open_set_hash.remove(current)
    54                                         
    55     40.6 MiB  -3542.3 MiB        1680           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     40.6 MiB  -3542.3 MiB        1680           if current == end:
    60     33.7 MiB     -6.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     33.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     40.6 MiB -31899.8 MiB       15111           for neighbor in current.neighbors:
    65     40.6 MiB -28369.5 MiB       13432               if current.row != neighbor.row and current.col != neighbor.col:
    66     40.6 MiB -14195.8 MiB        6716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     40.6 MiB -14177.0 MiB        6716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     40.6 MiB -28327.3 MiB       13432               if temp_g_score < g_score[neighbor]:
    71     40.6 MiB  -4001.7 MiB        1926                   came_from[neighbor] = current
    72     40.6 MiB  -3990.0 MiB        1926                   g_score[neighbor] = temp_g_score
    73     40.6 MiB  -3990.0 MiB        1926                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     40.6 MiB  -3990.6 MiB        1926                   if neighbor not in open_set_hash:
    75     40.6 MiB  -3990.9 MiB        1926                       count += 1
    76     40.6 MiB  -3991.3 MiB        1926                       open_set.put((f_score[neighbor], count, neighbor))
    77     40.6 MiB  -3993.2 MiB        1926                       open_set_hash.add(neighbor)
    78                                                             
    79     40.6 MiB  -3552.8 MiB        1679           if draw is not None:
    80                                                     draw()
    81                                         
    82     40.6 MiB  -3541.8 MiB        1679           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     38.8 MiB     38.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     59.0 MiB     -1.2 MiB         257       for row in grid:
    30     59.0 MiB   -273.8 MiB       65792           for spot in row:
    31     59.0 MiB   -252.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.8 MiB     -0.2 MiB           1       count = 0
    34     58.9 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     58.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.9 MiB      0.0 MiB           1       came_from = {}
    37     62.8 MiB -10743.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.2 MiB     -0.5 MiB           1       g_score[start] = 0
    39     66.6 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.7 MiB      0.0 MiB        1166       while not open_set.empty():
    47     66.7 MiB      0.0 MiB        1166           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.7 MiB      0.0 MiB        1166           current = open_set.get()[2]
    53     66.7 MiB      0.0 MiB        1166           open_set_hash.remove(current)
    54                                         
    55     66.7 MiB      0.0 MiB        1166           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.7 MiB      0.0 MiB        1166           if current == end:
    60     66.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.7 MiB      0.0 MiB       10485           for neighbor in current.neighbors:
    65     66.7 MiB      0.0 MiB        9320               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.7 MiB      0.0 MiB        4660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.7 MiB      0.0 MiB        4660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.7 MiB      0.0 MiB        9320               if temp_g_score < g_score[neighbor]:
    71     66.7 MiB      0.1 MiB        1358                   came_from[neighbor] = current
    72     66.7 MiB      0.0 MiB        1358                   g_score[neighbor] = temp_g_score
    73     66.7 MiB      0.0 MiB        1358                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.7 MiB      0.0 MiB        1358                   if neighbor not in open_set_hash:
    75     66.7 MiB      0.0 MiB        1358                       count += 1
    76     66.7 MiB      0.0 MiB        1358                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.7 MiB      0.0 MiB        1358                       open_set_hash.add(neighbor)
    78                                                             
    79     66.7 MiB      0.0 MiB        1165           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.7 MiB      0.0 MiB        1165           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     66.7 MiB     66.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     66.7 MiB    -40.3 MiB         257       for row in grid:
    30     66.7 MiB -10316.3 MiB       65792           for spot in row:
    31     66.7 MiB -10276.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.4 MiB     -0.3 MiB           1       count = 0
    34     66.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.4 MiB      0.0 MiB           1       came_from = {}
    37     67.5 MiB  -3440.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.4 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.5 MiB      0.0 MiB         456       while not open_set.empty():
    47     70.5 MiB      0.0 MiB         456           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.5 MiB      0.0 MiB         456           current = open_set.get()[2]
    53     70.5 MiB      0.0 MiB         456           open_set_hash.remove(current)
    54                                         
    55     70.5 MiB      0.0 MiB         456           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.5 MiB      0.0 MiB         456           if current == end:
    60     70.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.5 MiB      0.0 MiB        4095           for neighbor in current.neighbors:
    65     70.5 MiB      0.0 MiB        3640               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.5 MiB      0.0 MiB        1820                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.5 MiB      0.0 MiB        1820                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.5 MiB      0.0 MiB        3640               if temp_g_score < g_score[neighbor]:
    71     70.5 MiB      0.0 MiB         600                   came_from[neighbor] = current
    72     70.5 MiB      0.0 MiB         600                   g_score[neighbor] = temp_g_score
    73     70.5 MiB      0.0 MiB         600                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.5 MiB      0.0 MiB         600                   if neighbor not in open_set_hash:
    75     70.5 MiB      0.0 MiB         600                       count += 1
    76     70.5 MiB      0.0 MiB         600                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.5 MiB      0.0 MiB         600                       open_set_hash.add(neighbor)
    78                                                             
    79     70.5 MiB      0.0 MiB         455           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.5 MiB      0.0 MiB         455           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.5 MiB     70.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     70.5 MiB   -670.8 MiB         257       for row in grid:
    30     70.5 MiB -172232.9 MiB       65792           for spot in row:
    31     70.5 MiB -171563.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     67.7 MiB     -2.8 MiB           1       count = 0
    34     67.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.7 MiB      0.0 MiB           1       came_from = {}
    37     71.3 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.6 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.6 MiB      0.0 MiB         492       while not open_set.empty():
    47     74.6 MiB      0.0 MiB         492           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.6 MiB      0.0 MiB         492           current = open_set.get()[2]
    53     74.6 MiB      0.0 MiB         492           open_set_hash.remove(current)
    54                                         
    55     74.6 MiB      0.0 MiB         492           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.6 MiB      0.0 MiB         492           if current == end:
    60     74.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.6 MiB      0.0 MiB        4419           for neighbor in current.neighbors:
    65     74.6 MiB      0.0 MiB        3928               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.6 MiB      0.0 MiB        1964                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.6 MiB      0.0 MiB        1964                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.6 MiB      0.0 MiB        3928               if temp_g_score < g_score[neighbor]:
    71     74.6 MiB      0.0 MiB         830                   came_from[neighbor] = current
    72     74.6 MiB      0.0 MiB         830                   g_score[neighbor] = temp_g_score
    73     74.6 MiB      0.0 MiB         830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.6 MiB      0.0 MiB         830                   if neighbor not in open_set_hash:
    75     74.6 MiB      0.0 MiB         830                       count += 1
    76     74.6 MiB      0.0 MiB         830                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.6 MiB      0.0 MiB         830                       open_set_hash.add(neighbor)
    78                                                             
    79     74.6 MiB      0.0 MiB         491           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.6 MiB      0.0 MiB         491           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.6 MiB     74.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.6 MiB      0.0 MiB         257       for row in grid:
    30     74.6 MiB      0.0 MiB       65792           for spot in row:
    31     74.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     74.6 MiB      0.0 MiB           1       count = 0
    34     74.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.6 MiB      0.0 MiB           1       came_from = {}
    37     76.5 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     79.6 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     79.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     79.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     79.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     79.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     79.6 MiB      0.0 MiB         208       while not open_set.empty():
    47     79.6 MiB      0.0 MiB         208           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     79.6 MiB      0.0 MiB         208           current = open_set.get()[2]
    53     79.6 MiB      0.0 MiB         208           open_set_hash.remove(current)
    54                                         
    55     79.6 MiB      0.0 MiB         208           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     79.6 MiB      0.0 MiB         208           if current == end:
    60     79.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     79.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     79.6 MiB      0.0 MiB        1863           for neighbor in current.neighbors:
    65     79.6 MiB      0.0 MiB        1656               if current.row != neighbor.row and current.col != neighbor.col:
    66     79.6 MiB      0.0 MiB         828                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     79.6 MiB      0.0 MiB         828                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     79.6 MiB      0.0 MiB        1656               if temp_g_score < g_score[neighbor]:
    71     79.6 MiB      0.0 MiB         626                   came_from[neighbor] = current
    72     79.6 MiB      0.0 MiB         626                   g_score[neighbor] = temp_g_score
    73     79.6 MiB      0.0 MiB         626                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     79.6 MiB      0.0 MiB         626                   if neighbor not in open_set_hash:
    75     79.6 MiB      0.0 MiB         626                       count += 1
    76     79.6 MiB      0.0 MiB         626                       open_set.put((f_score[neighbor], count, neighbor))
    77     79.6 MiB      0.0 MiB         626                       open_set_hash.add(neighbor)
    78                                                             
    79     79.6 MiB      0.0 MiB         207           if draw is not None:
    80                                                     draw()
    81                                         
    82     79.6 MiB      0.0 MiB         207           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


