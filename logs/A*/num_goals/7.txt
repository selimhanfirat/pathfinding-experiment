Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.4 MiB     67.4 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.4 MiB  -2355.0 MiB         257       for row in grid:
    30     68.4 MiB -605491.8 MiB       65792           for spot in row:
    31     68.4 MiB -603139.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.8 MiB     -6.6 MiB           1       count = 0
    34     61.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.8 MiB      0.0 MiB           1       came_from = {}
    37     68.1 MiB -11958.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.2 MiB     -0.8 MiB           1       g_score[start] = 0
    39     70.1 MiB -60282.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.4 MiB   -311.9 MiB        2000       while not open_set.empty():
    47     71.4 MiB   -311.9 MiB        2000           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.4 MiB   -311.9 MiB        2000           current = open_set.get()[2]
    53     71.4 MiB   -311.9 MiB        2000           open_set_hash.remove(current)
    54                                         
    55     71.4 MiB   -312.0 MiB        2000           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.4 MiB   -312.0 MiB        2000           if current == end:
    60     71.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.4 MiB  -2802.8 MiB       17991           for neighbor in current.neighbors:
    65     71.4 MiB  -2491.8 MiB       15992               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.4 MiB  -1247.6 MiB        7996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.4 MiB  -1244.9 MiB        7996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.4 MiB  -2492.1 MiB       15992               if temp_g_score < g_score[neighbor]:
    71     71.4 MiB   -373.2 MiB        2438                   came_from[neighbor] = current
    72     71.4 MiB   -373.3 MiB        2438                   g_score[neighbor] = temp_g_score
    73     71.4 MiB   -373.2 MiB        2438                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.4 MiB   -373.2 MiB        2438                   if neighbor not in open_set_hash:
    75     71.4 MiB   -373.2 MiB        2438                       count += 1
    76     71.4 MiB   -373.2 MiB        2438                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.4 MiB   -373.2 MiB        2438                       open_set_hash.add(neighbor)
    78                                                             
    79     71.4 MiB   -311.9 MiB        1999           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.4 MiB   -311.9 MiB        1999           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     71.7 MiB  -2942.3 MiB         257       for row in grid:
    30     71.7 MiB -749234.1 MiB       65792           for spot in row:
    31     71.7 MiB -746319.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     37.7 MiB    -34.0 MiB           1       count = 0
    34     38.1 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     38.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     38.3 MiB      0.0 MiB           1       came_from = {}
    37     46.0 MiB -16439.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     46.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     51.8 MiB    -10.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     52.0 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     52.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     52.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     52.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     53.3 MiB  -2575.5 MiB        1848       while not open_set.empty():
    47     53.3 MiB  -2575.5 MiB        1848           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     53.3 MiB  -2575.5 MiB        1848           current = open_set.get()[2]
    53     53.3 MiB  -2575.5 MiB        1848           open_set_hash.remove(current)
    54                                         
    55     53.3 MiB  -2575.5 MiB        1848           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     53.3 MiB  -2575.5 MiB        1848           if current == end:
    60     49.5 MiB     -3.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     49.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     53.3 MiB -23151.5 MiB       16623           for neighbor in current.neighbors:
    65     53.3 MiB -20576.2 MiB       14776               if current.row != neighbor.row and current.col != neighbor.col:
    66     53.3 MiB -10292.5 MiB        7388                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     53.3 MiB -10285.9 MiB        7388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     53.3 MiB -20578.6 MiB       14776               if temp_g_score < g_score[neighbor]:
    71     53.3 MiB  -2994.2 MiB        2202                   came_from[neighbor] = current
    72     53.3 MiB  -2994.2 MiB        2202                   g_score[neighbor] = temp_g_score
    73     53.3 MiB  -2994.2 MiB        2202                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     53.3 MiB  -2994.2 MiB        2202                   if neighbor not in open_set_hash:
    75     53.3 MiB  -2994.2 MiB        2202                       count += 1
    76     53.3 MiB  -2994.8 MiB        2202                       open_set.put((f_score[neighbor], count, neighbor))
    77     53.3 MiB  -2994.8 MiB        2202                       open_set_hash.add(neighbor)
    78                                                             
    79     53.3 MiB  -2575.5 MiB        1847           if draw is not None:
    80                                                     draw()
    81                                         
    82     53.3 MiB  -2575.5 MiB        1847           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     52.3 MiB     52.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     52.8 MiB   -420.7 MiB         257       for row in grid:
    30     52.8 MiB -107572.5 MiB       65792           for spot in row:
    31     52.8 MiB -107153.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     50.0 MiB     -2.7 MiB           1       count = 0
    34     50.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     50.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     50.0 MiB      0.0 MiB           1       came_from = {}
    37     55.5 MiB   -821.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.8 MiB  -5454.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.5 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.7 MiB  -8375.2 MiB        2346       while not open_set.empty():
    47     60.7 MiB  -8375.3 MiB        2346           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.7 MiB  -8375.3 MiB        2346           current = open_set.get()[2]
    53     60.7 MiB  -8375.5 MiB        2346           open_set_hash.remove(current)
    54                                         
    55     60.7 MiB  -8375.5 MiB        2346           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.7 MiB  -8375.6 MiB        2346           if current == end:
    60     50.8 MiB    -10.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     50.9 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.7 MiB -75315.9 MiB       21105           for neighbor in current.neighbors:
    65     60.7 MiB -66942.5 MiB       18760               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.7 MiB -33477.9 MiB        9380                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.7 MiB -33467.0 MiB        9380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.7 MiB -66949.2 MiB       18760               if temp_g_score < g_score[neighbor]:
    71     60.7 MiB  -9283.8 MiB        2640                   came_from[neighbor] = current
    72     60.7 MiB  -9283.8 MiB        2640                   g_score[neighbor] = temp_g_score
    73     60.7 MiB  -9283.9 MiB        2640                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.7 MiB  -9283.9 MiB        2640                   if neighbor not in open_set_hash:
    75     60.7 MiB  -9283.9 MiB        2640                       count += 1
    76     60.7 MiB  -9283.9 MiB        2640                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.7 MiB  -9283.9 MiB        2640                       open_set_hash.add(neighbor)
    78                                                             
    79     60.7 MiB  -8375.1 MiB        2345           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.7 MiB  -8375.2 MiB        2345           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     52.0 MiB     52.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     53.9 MiB   -158.1 MiB         257       for row in grid:
    30     53.9 MiB -40365.5 MiB       65792           for spot in row:
    31     53.9 MiB -40206.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.4 MiB     -1.5 MiB           1       count = 0
    34     52.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.4 MiB      0.0 MiB           1       came_from = {}
    37     56.6 MiB   -101.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.8 MiB      5.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.8 MiB      0.0 MiB         198       while not open_set.empty():
    47     62.8 MiB      0.0 MiB         198           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.8 MiB      0.0 MiB         198           current = open_set.get()[2]
    53     62.8 MiB      0.0 MiB         198           open_set_hash.remove(current)
    54                                         
    55     62.8 MiB      0.0 MiB         198           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.8 MiB      0.0 MiB         198           if current == end:
    60     62.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.8 MiB      0.5 MiB        1773           for neighbor in current.neighbors:
    65     62.8 MiB      0.4 MiB        1576               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.8 MiB      0.0 MiB         788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.8 MiB      0.0 MiB         788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.8 MiB      0.0 MiB        1576               if temp_g_score < g_score[neighbor]:
    71     62.8 MiB      0.0 MiB         340                   came_from[neighbor] = current
    72     62.8 MiB      0.0 MiB         340                   g_score[neighbor] = temp_g_score
    73     62.8 MiB      0.0 MiB         340                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.8 MiB      0.0 MiB         340                   if neighbor not in open_set_hash:
    75     62.8 MiB      0.0 MiB         340                       count += 1
    76     62.8 MiB      0.0 MiB         340                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.8 MiB      0.0 MiB         340                       open_set_hash.add(neighbor)
    78                                                             
    79     62.8 MiB      0.0 MiB         197           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.8 MiB      0.0 MiB         197           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.8 MiB     62.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.0 MiB    -23.2 MiB         257       for row in grid:
    30     63.0 MiB  -5894.3 MiB       65792           for spot in row:
    31     63.0 MiB  -5870.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.0 MiB      0.0 MiB           1       count = 0
    34     63.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.0 MiB      0.0 MiB           1       came_from = {}
    37     67.3 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.7 MiB      3.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.7 MiB      0.0 MiB         672       while not open_set.empty():
    47     70.7 MiB      0.0 MiB         672           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.7 MiB      0.0 MiB         672           current = open_set.get()[2]
    53     70.7 MiB      0.0 MiB         672           open_set_hash.remove(current)
    54                                         
    55     70.7 MiB      0.0 MiB         672           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.7 MiB      0.0 MiB         672           if current == end:
    60     70.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.7 MiB      0.0 MiB        6039           for neighbor in current.neighbors:
    65     70.7 MiB      0.0 MiB        5368               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.7 MiB      0.0 MiB        2684                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.7 MiB      0.0 MiB        2684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.7 MiB      0.0 MiB        5368               if temp_g_score < g_score[neighbor]:
    71     70.7 MiB      0.0 MiB         890                   came_from[neighbor] = current
    72     70.7 MiB      0.0 MiB         890                   g_score[neighbor] = temp_g_score
    73     70.7 MiB      0.0 MiB         890                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.7 MiB      0.0 MiB         890                   if neighbor not in open_set_hash:
    75     70.7 MiB      0.0 MiB         890                       count += 1
    76     70.7 MiB      0.0 MiB         890                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.7 MiB      0.0 MiB         890                       open_set_hash.add(neighbor)
    78                                                             
    79     70.7 MiB      0.0 MiB         671           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.7 MiB      0.0 MiB         671           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.7 MiB     69.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.7 MiB    -12.6 MiB         257       for row in grid:
    30     69.7 MiB  -3223.0 MiB       65792           for spot in row:
    31     69.7 MiB  -3210.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     69.5 MiB     -0.2 MiB           1       count = 0
    34     69.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     69.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     69.5 MiB      0.0 MiB           1       came_from = {}
    37     69.6 MiB -185694.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.2 MiB     -4.4 MiB           1       g_score[start] = 0
    39     66.2 MiB -66973.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.3 MiB      0.0 MiB        1536       while not open_set.empty():
    47     66.3 MiB      0.0 MiB        1536           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.3 MiB      0.0 MiB        1536           current = open_set.get()[2]
    53     66.3 MiB      0.0 MiB        1536           open_set_hash.remove(current)
    54                                         
    55     66.3 MiB      0.0 MiB        1536           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.3 MiB      0.0 MiB        1536           if current == end:
    60     66.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.3 MiB      0.0 MiB       13815           for neighbor in current.neighbors:
    65     66.3 MiB      0.0 MiB       12280               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.3 MiB      0.0 MiB        6140                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.3 MiB      0.0 MiB        6140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.3 MiB      0.0 MiB       12280               if temp_g_score < g_score[neighbor]:
    71     66.3 MiB      0.1 MiB        1838                   came_from[neighbor] = current
    72     66.3 MiB      0.0 MiB        1838                   g_score[neighbor] = temp_g_score
    73     66.3 MiB      0.0 MiB        1838                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.3 MiB      0.0 MiB        1838                   if neighbor not in open_set_hash:
    75     66.3 MiB      0.0 MiB        1838                       count += 1
    76     66.3 MiB      0.0 MiB        1838                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.3 MiB      0.0 MiB        1838                       open_set_hash.add(neighbor)
    78                                                             
    79     66.3 MiB      0.0 MiB        1535           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.3 MiB      0.0 MiB        1535           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     66.3 MiB     66.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     66.3 MiB  -2850.3 MiB         257       for row in grid:
    30     66.3 MiB -729179.8 MiB       65792           for spot in row:
    31     66.3 MiB -726342.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     44.6 MiB    -21.8 MiB           1       count = 0
    34     44.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     44.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     44.6 MiB      0.0 MiB           1       came_from = {}
    37     46.6 MiB -152305.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     46.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     51.5 MiB -56801.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     47.6 MiB     -3.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     47.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     47.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     47.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     48.7 MiB -22314.8 MiB        3825       while not open_set.empty():
    47     48.7 MiB -22315.2 MiB        3825           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     48.7 MiB -22315.2 MiB        3825           current = open_set.get()[2]
    53     48.7 MiB -22315.4 MiB        3825           open_set_hash.remove(current)
    54                                         
    55     48.7 MiB -22316.9 MiB        3825           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     48.7 MiB -22317.0 MiB        3825           if current == end:
    60     41.5 MiB     -7.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     41.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     48.7 MiB -200788.3 MiB       34416           for neighbor in current.neighbors:
    65     48.7 MiB -178473.9 MiB       30592               if current.row != neighbor.row and current.col != neighbor.col:
    66     48.7 MiB -89250.8 MiB       15296                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     48.7 MiB -89226.3 MiB       15296                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     48.7 MiB -178479.2 MiB       30592               if temp_g_score < g_score[neighbor]:
    71     48.7 MiB -23848.2 MiB        4173                   came_from[neighbor] = current
    72     48.7 MiB -23848.3 MiB        4173                   g_score[neighbor] = temp_g_score
    73     48.7 MiB -23848.4 MiB        4173                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     48.7 MiB -23848.4 MiB        4173                   if neighbor not in open_set_hash:
    75     48.7 MiB -23848.4 MiB        4173                       count += 1
    76     48.7 MiB -23848.5 MiB        4173                       open_set.put((f_score[neighbor], count, neighbor))
    77     48.7 MiB -23848.5 MiB        4173                       open_set_hash.add(neighbor)
    78                                                             
    79     48.7 MiB -22314.3 MiB        3824           if draw is not None:
    80                                                     draw()
    81                                         
    82     48.7 MiB -22314.3 MiB        3824           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.7 MiB     92.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.1 MiB  -2790.0 MiB         257       for row in grid:
    30     94.1 MiB -713345.1 MiB       65792           for spot in row:
    31     94.1 MiB -710554.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     78.0 MiB    -16.1 MiB           1       count = 0
    34     78.2 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     78.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     78.4 MiB      0.0 MiB           1       came_from = {}
    37     82.3 MiB -251800.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     73.4 MiB     -8.9 MiB           1       g_score[start] = 0
    39     80.0 MiB      6.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     80.2 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     80.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     80.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     80.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     82.3 MiB      0.0 MiB         736       while not open_set.empty():
    47     82.3 MiB      0.0 MiB         736           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     82.3 MiB      0.0 MiB         736           current = open_set.get()[2]
    53     82.3 MiB      0.0 MiB         736           open_set_hash.remove(current)
    54                                         
    55     82.3 MiB      0.0 MiB         736           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     82.3 MiB      0.0 MiB         736           if current == end:
    60     82.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     82.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     82.3 MiB      1.5 MiB        6615           for neighbor in current.neighbors:
    65     82.3 MiB      0.3 MiB        5880               if current.row != neighbor.row and current.col != neighbor.col:
    66     82.3 MiB      0.0 MiB        2940                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     82.3 MiB      0.0 MiB        2940                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     82.3 MiB      0.0 MiB        5880               if temp_g_score < g_score[neighbor]:
    71     82.3 MiB      0.1 MiB         950                   came_from[neighbor] = current
    72     82.3 MiB      0.0 MiB         950                   g_score[neighbor] = temp_g_score
    73     82.3 MiB      0.0 MiB         950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     82.3 MiB      0.0 MiB         950                   if neighbor not in open_set_hash:
    75     82.3 MiB      0.0 MiB         950                       count += 1
    76     82.3 MiB      0.1 MiB         950                       open_set.put((f_score[neighbor], count, neighbor))
    77     82.3 MiB      0.0 MiB         950                       open_set_hash.add(neighbor)
    78                                                             
    79     82.3 MiB      0.0 MiB         735           if draw is not None:
    80                                                     draw()
    81                                         
    82     82.3 MiB      0.0 MiB         735           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     83.9 MiB     83.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     86.1 MiB  -4603.0 MiB         257       for row in grid:
    30     86.1 MiB -1177720.8 MiB       65792           for spot in row:
    31     86.1 MiB -1173119.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.5 MiB    -26.6 MiB           1       count = 0
    34     59.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.5 MiB      0.0 MiB           1       came_from = {}
    37     60.6 MiB  -8929.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.0 MiB     -0.7 MiB           1       g_score[start] = 0
    39     63.6 MiB  -5924.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.6 MiB   -229.7 MiB        2356       while not open_set.empty():
    47     63.6 MiB   -229.7 MiB        2356           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.6 MiB   -229.7 MiB        2356           current = open_set.get()[2]
    53     63.6 MiB   -229.7 MiB        2356           open_set_hash.remove(current)
    54                                         
    55     63.6 MiB   -229.7 MiB        2356           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.6 MiB   -229.7 MiB        2356           if current == end:
    60     63.0 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.6 MiB  -2063.7 MiB       21195           for neighbor in current.neighbors:
    65     63.6 MiB  -1834.0 MiB       18840               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.6 MiB   -918.0 MiB        9420                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.6 MiB   -916.5 MiB        9420                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.6 MiB  -1834.6 MiB       18840               if temp_g_score < g_score[neighbor]:
    71     63.6 MiB   -261.3 MiB        2720                   came_from[neighbor] = current
    72     63.6 MiB   -261.4 MiB        2720                   g_score[neighbor] = temp_g_score
    73     63.6 MiB   -261.4 MiB        2720                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.6 MiB   -261.4 MiB        2720                   if neighbor not in open_set_hash:
    75     63.6 MiB   -261.4 MiB        2720                       count += 1
    76     63.6 MiB   -261.4 MiB        2720                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.6 MiB   -261.3 MiB        2720                       open_set_hash.add(neighbor)
    78                                                             
    79     63.6 MiB   -229.7 MiB        2355           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.6 MiB   -229.7 MiB        2355           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.0 MiB     63.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.0 MiB  -1714.8 MiB         257       for row in grid:
    30     63.0 MiB -440669.8 MiB       65792           for spot in row:
    31     63.0 MiB -438954.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.6 MiB     -4.5 MiB           1       count = 0
    34     58.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     59.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     59.1 MiB      0.0 MiB           1       came_from = {}
    37     60.8 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.0 MiB -187779.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     59.8 MiB     -1.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     59.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     59.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     59.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.0 MiB    -54.0 MiB         285       while not open_set.empty():
    47     60.0 MiB    -54.0 MiB         285           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.0 MiB    -54.0 MiB         285           current = open_set.get()[2]
    53     60.0 MiB    -54.0 MiB         285           open_set_hash.remove(current)
    54                                         
    55     60.0 MiB    -54.0 MiB         285           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.0 MiB    -54.0 MiB         285           if current == end:
    60     59.1 MiB     -0.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.0 MiB   -484.2 MiB        2556           for neighbor in current.neighbors:
    65     60.0 MiB   -430.3 MiB        2272               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.0 MiB   -216.0 MiB        1136                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.0 MiB   -214.5 MiB        1136                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.0 MiB   -430.8 MiB        2272               if temp_g_score < g_score[neighbor]:
    71     60.0 MiB    -71.2 MiB         381                   came_from[neighbor] = current
    72     60.0 MiB    -71.2 MiB         381                   g_score[neighbor] = temp_g_score
    73     60.0 MiB    -71.4 MiB         381                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.0 MiB    -71.4 MiB         381                   if neighbor not in open_set_hash:
    75     60.0 MiB    -71.4 MiB         381                       count += 1
    76     60.0 MiB    -71.3 MiB         381                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.0 MiB    -71.4 MiB         381                       open_set_hash.add(neighbor)
    78                                                             
    79     60.0 MiB    -54.0 MiB         284           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.0 MiB    -54.0 MiB         284           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.7 MiB     61.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     65.3 MiB  -2494.0 MiB         257       for row in grid:
    30     65.3 MiB -638409.5 MiB       65792           for spot in row:
    31     65.3 MiB -635919.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     50.0 MiB    -15.2 MiB           1       count = 0
    34     50.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     50.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     50.1 MiB      0.0 MiB           1       came_from = {}
    37     56.6 MiB      6.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     62.7 MiB      6.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.8 MiB      0.0 MiB         658       while not open_set.empty():
    47     62.8 MiB      0.0 MiB         658           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.8 MiB      0.0 MiB         658           current = open_set.get()[2]
    53     62.8 MiB      0.0 MiB         658           open_set_hash.remove(current)
    54                                         
    55     62.8 MiB      0.0 MiB         658           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.8 MiB      0.0 MiB         658           if current == end:
    60     62.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.8 MiB      0.0 MiB        5913           for neighbor in current.neighbors:
    65     62.8 MiB      0.0 MiB        5256               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.8 MiB      0.0 MiB        2628                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.8 MiB      0.0 MiB        2628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.8 MiB      0.0 MiB        5256               if temp_g_score < g_score[neighbor]:
    71     62.8 MiB      0.0 MiB         806                   came_from[neighbor] = current
    72     62.8 MiB      0.0 MiB         806                   g_score[neighbor] = temp_g_score
    73     62.8 MiB      0.0 MiB         806                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.8 MiB      0.0 MiB         806                   if neighbor not in open_set_hash:
    75     62.8 MiB      0.0 MiB         806                       count += 1
    76     62.8 MiB      0.1 MiB         806                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.8 MiB      0.0 MiB         806                       open_set_hash.add(neighbor)
    78                                                             
    79     62.8 MiB      0.0 MiB         657           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.8 MiB      0.0 MiB         657           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.8 MiB     62.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.8 MiB  -3731.9 MiB         257       for row in grid:
    30     62.8 MiB -955562.0 MiB       65792           for spot in row:
    31     62.8 MiB -951839.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     44.2 MiB    -18.6 MiB           1       count = 0
    34     44.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     44.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     44.2 MiB      0.0 MiB           1       came_from = {}
    37     52.4 MiB   -228.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     52.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     59.0 MiB      6.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     59.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     59.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     59.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     59.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.5 MiB      0.0 MiB        3185       while not open_set.empty():
    47     59.5 MiB      0.0 MiB        3185           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.5 MiB      0.0 MiB        3185           current = open_set.get()[2]
    53     59.5 MiB      0.0 MiB        3185           open_set_hash.remove(current)
    54                                         
    55     59.5 MiB      0.0 MiB        3185           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.5 MiB      0.0 MiB        3185           if current == end:
    60     59.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.5 MiB      0.0 MiB       28656           for neighbor in current.neighbors:
    65     59.5 MiB      0.0 MiB       25472               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.5 MiB      0.0 MiB       12736                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.5 MiB      0.0 MiB       12736                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.5 MiB      0.0 MiB       25472               if temp_g_score < g_score[neighbor]:
    71     59.5 MiB      0.4 MiB        3509                   came_from[neighbor] = current
    72     59.5 MiB      0.0 MiB        3509                   g_score[neighbor] = temp_g_score
    73     59.5 MiB      0.0 MiB        3509                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.5 MiB      0.0 MiB        3509                   if neighbor not in open_set_hash:
    75     59.5 MiB      0.0 MiB        3509                       count += 1
    76     59.5 MiB      0.1 MiB        3509                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.5 MiB      0.0 MiB        3509                       open_set_hash.add(neighbor)
    78                                                             
    79     59.5 MiB      0.0 MiB        3184           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.5 MiB      0.0 MiB        3184           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.6 MiB     59.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.8 MiB    -46.9 MiB         257       for row in grid:
    30     62.8 MiB -11845.9 MiB       65792           for spot in row:
    31     62.8 MiB -11796.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.7 MiB     -1.1 MiB           1       count = 0
    34     61.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.7 MiB      0.0 MiB           1       came_from = {}
    37     65.9 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.5 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.5 MiB      0.0 MiB        1152       while not open_set.empty():
    47     68.5 MiB      0.0 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.5 MiB      0.0 MiB        1152           current = open_set.get()[2]
    53     68.5 MiB      0.0 MiB        1152           open_set_hash.remove(current)
    54                                         
    55     68.5 MiB      0.0 MiB        1152           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.5 MiB      0.0 MiB        1152           if current == end:
    60     68.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.5 MiB      0.0 MiB       10359           for neighbor in current.neighbors:
    65     68.5 MiB      0.0 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.5 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.5 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.5 MiB      0.0 MiB        9208               if temp_g_score < g_score[neighbor]:
    71     68.5 MiB      0.0 MiB        1442                   came_from[neighbor] = current
    72     68.5 MiB      0.0 MiB        1442                   g_score[neighbor] = temp_g_score
    73     68.5 MiB      0.0 MiB        1442                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.5 MiB      0.0 MiB        1442                   if neighbor not in open_set_hash:
    75     68.5 MiB      0.0 MiB        1442                       count += 1
    76     68.5 MiB      0.0 MiB        1442                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.5 MiB      0.0 MiB        1442                       open_set_hash.add(neighbor)
    78                                                             
    79     68.5 MiB      0.0 MiB        1151           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.5 MiB      0.0 MiB        1151           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     68.5 MiB     68.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.5 MiB   -171.4 MiB         257       for row in grid:
    30     68.5 MiB -43362.2 MiB       65792           for spot in row:
    31     68.5 MiB -43194.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.4 MiB     -4.1 MiB           1       count = 0
    34     64.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     64.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     64.4 MiB      0.0 MiB           1       came_from = {}
    37     69.0 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.2 MiB -22863.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.4 MiB      0.0 MiB        3531       while not open_set.empty():
    47     71.4 MiB      0.0 MiB        3531           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.4 MiB      0.0 MiB        3531           current = open_set.get()[2]
    53     71.4 MiB      0.0 MiB        3531           open_set_hash.remove(current)
    54                                         
    55     71.4 MiB      0.0 MiB        3531           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.4 MiB      0.0 MiB        3531           if current == end:
    60     71.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.4 MiB      0.0 MiB       31770           for neighbor in current.neighbors:
    65     71.4 MiB      0.0 MiB       28240               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.4 MiB      0.0 MiB       14120                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.4 MiB      0.0 MiB       14120                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.4 MiB      0.0 MiB       28240               if temp_g_score < g_score[neighbor]:
    71     71.4 MiB      0.1 MiB        4023                   came_from[neighbor] = current
    72     71.4 MiB      0.0 MiB        4023                   g_score[neighbor] = temp_g_score
    73     71.4 MiB      0.0 MiB        4023                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.4 MiB      0.0 MiB        4023                   if neighbor not in open_set_hash:
    75     71.4 MiB      0.0 MiB        4023                       count += 1
    76     71.4 MiB      0.0 MiB        4023                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.4 MiB      0.0 MiB        4023                       open_set_hash.add(neighbor)
    78                                                             
    79     71.4 MiB      0.0 MiB        3530           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.4 MiB      0.0 MiB        3530           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.5 MiB    109.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.5 MiB      0.0 MiB         257       for row in grid:
    30    109.5 MiB      0.0 MiB       65792           for spot in row:
    31    109.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.5 MiB      0.0 MiB           1       count = 0
    34    109.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.5 MiB      0.0 MiB           1       came_from = {}
    37    110.1 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.1 MiB -18022.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.7 MiB -68808.8 MiB       14238       while not open_set.empty():
    47    113.7 MiB -68808.8 MiB       14238           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.7 MiB -68808.8 MiB       14238           current = open_set.get()[2]
    53    113.7 MiB -68808.8 MiB       14238           open_set_hash.remove(current)
    54                                         
    55    113.7 MiB -68808.8 MiB       14238           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.7 MiB -68808.8 MiB       14238           if current == end:
    60    106.2 MiB     -7.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.7 MiB -619240.7 MiB      128133           for neighbor in current.neighbors:
    65    113.7 MiB -550433.7 MiB      113896               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.7 MiB -275226.4 MiB       56948                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.7 MiB -275209.3 MiB       56948                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.7 MiB -550437.0 MiB      113896               if temp_g_score < g_score[neighbor]:
    71    113.7 MiB -71238.3 MiB       14966                   came_from[neighbor] = current
    72    113.7 MiB -71238.9 MiB       14966                   g_score[neighbor] = temp_g_score
    73    113.7 MiB -71238.9 MiB       14966                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.7 MiB -71238.9 MiB       14966                   if neighbor not in open_set_hash:
    75    113.7 MiB -71238.9 MiB       14966                       count += 1
    76    113.7 MiB -71239.2 MiB       14966                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.7 MiB -71239.5 MiB       14966                       open_set_hash.add(neighbor)
    78                                                             
    79    113.7 MiB -68808.6 MiB       14237           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.7 MiB -68808.8 MiB       14237           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB    -15.6 MiB         257       for row in grid:
    30    106.2 MiB  -3992.6 MiB       65792           for spot in row:
    31    106.2 MiB  -3977.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.1 MiB     -0.1 MiB           1       count = 0
    34    106.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.1 MiB      0.0 MiB           1       came_from = {}
    37    110.0 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.3 MiB -11274.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.4 MiB     -0.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.4 MiB -18198.9 MiB        3184       while not open_set.empty():
    47    110.4 MiB -18199.0 MiB        3184           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.4 MiB -18199.1 MiB        3184           current = open_set.get()[2]
    53    110.4 MiB -18199.2 MiB        3184           open_set_hash.remove(current)
    54                                         
    55    110.4 MiB -18199.2 MiB        3184           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.4 MiB -18199.2 MiB        3184           if current == end:
    60    103.7 MiB     -6.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.4 MiB -163753.2 MiB       28647           for neighbor in current.neighbors:
    65    110.4 MiB -145555.8 MiB       25464               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.4 MiB -72785.5 MiB       12732                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.4 MiB -72772.5 MiB       12732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.4 MiB -145559.1 MiB       25464               if temp_g_score < g_score[neighbor]:
    71    110.4 MiB -22735.2 MiB        4010                   came_from[neighbor] = current
    72    110.4 MiB -22735.3 MiB        4010                   g_score[neighbor] = temp_g_score
    73    110.4 MiB -22735.4 MiB        4010                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.4 MiB -22735.5 MiB        4010                   if neighbor not in open_set_hash:
    75    110.4 MiB -22735.7 MiB        4010                       count += 1
    76    110.4 MiB -22735.8 MiB        4010                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.4 MiB -22735.9 MiB        4010                       open_set_hash.add(neighbor)
    78                                                             
    79    110.4 MiB -18198.9 MiB        3183           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.4 MiB -18198.9 MiB        3183           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.7 MiB    103.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.7 MiB   -506.6 MiB         257       for row in grid:
    30    103.7 MiB -129545.4 MiB       65792           for spot in row:
    31    103.7 MiB -129041.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.7 MiB     -5.0 MiB           1       count = 0
    34     98.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.7 MiB      0.0 MiB           1       came_from = {}
    37    101.9 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.7 MiB   -178.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.7 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.7 MiB  -4124.8 MiB        4347       while not open_set.empty():
    47    105.7 MiB  -4124.8 MiB        4347           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.7 MiB  -4124.8 MiB        4347           current = open_set.get()[2]
    53    105.7 MiB  -4124.8 MiB        4347           open_set_hash.remove(current)
    54                                         
    55    105.7 MiB  -4124.8 MiB        4347           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.7 MiB  -4124.8 MiB        4347           if current == end:
    60    102.4 MiB     -3.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.7 MiB -37105.2 MiB       39114           for neighbor in current.neighbors:
    65    105.7 MiB -32982.2 MiB       34768               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.7 MiB -16494.7 MiB       17384                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.7 MiB -16487.8 MiB       17384                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.7 MiB -32982.9 MiB       34768               if temp_g_score < g_score[neighbor]:
    71    105.7 MiB  -4505.3 MiB        4775                   came_from[neighbor] = current
    72    105.7 MiB  -4505.3 MiB        4775                   g_score[neighbor] = temp_g_score
    73    105.7 MiB  -4505.4 MiB        4775                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.7 MiB  -4505.5 MiB        4775                   if neighbor not in open_set_hash:
    75    105.7 MiB  -4505.6 MiB        4775                       count += 1
    76    105.7 MiB  -4505.6 MiB        4775                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.7 MiB  -4505.6 MiB        4775                       open_set_hash.add(neighbor)
    78                                                             
    79    105.7 MiB  -4124.8 MiB        4346           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.7 MiB  -4124.8 MiB        4346           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.4 MiB    102.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.4 MiB    -81.0 MiB         257       for row in grid:
    30    102.4 MiB -20524.2 MiB       65792           for spot in row:
    31    102.4 MiB -20444.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.9 MiB     -1.5 MiB           1       count = 0
    34    100.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.9 MiB      0.0 MiB           1       came_from = {}
    37    101.6 MiB   -345.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.5 MiB     -0.1 MiB           1       g_score[start] = 0
    39    102.0 MiB  -1852.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.8 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.8 MiB  -3855.5 MiB        1932       while not open_set.empty():
    47    101.8 MiB  -3855.5 MiB        1932           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.8 MiB  -3855.5 MiB        1932           current = open_set.get()[2]
    53    101.8 MiB  -3855.5 MiB        1932           open_set_hash.remove(current)
    54                                         
    55    101.8 MiB  -3855.5 MiB        1932           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.8 MiB  -3855.5 MiB        1932           if current == end:
    60     99.1 MiB     -2.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.8 MiB -34686.6 MiB       17379           for neighbor in current.neighbors:
    65    101.8 MiB -30831.7 MiB       15448               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.8 MiB -15420.2 MiB        7724                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.8 MiB -15411.7 MiB        7724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.8 MiB -30832.0 MiB       15448               if temp_g_score < g_score[neighbor]:
    71    101.8 MiB  -4265.5 MiB        2198                   came_from[neighbor] = current
    72    101.8 MiB  -4265.5 MiB        2198                   g_score[neighbor] = temp_g_score
    73    101.8 MiB  -4265.5 MiB        2198                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.8 MiB  -4265.8 MiB        2198                   if neighbor not in open_set_hash:
    75    101.8 MiB  -4266.1 MiB        2198                       count += 1
    76    101.8 MiB  -4266.3 MiB        2198                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.8 MiB  -4266.5 MiB        2198                       open_set_hash.add(neighbor)
    78                                                             
    79    101.8 MiB  -3855.4 MiB        1931           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.8 MiB  -3855.5 MiB        1931           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.1 MiB     99.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.1 MiB   -296.2 MiB         257       for row in grid:
    30     99.1 MiB -75897.3 MiB       65792           for spot in row:
    31     99.1 MiB -75602.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.8 MiB     -1.2 MiB           1       count = 0
    34     97.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.8 MiB      0.0 MiB           1       came_from = {}
    37     99.8 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.6 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.6 MiB   -403.8 MiB        1683       while not open_set.empty():
    47    103.6 MiB   -403.8 MiB        1683           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.6 MiB   -403.9 MiB        1683           current = open_set.get()[2]
    53    103.6 MiB   -404.0 MiB        1683           open_set_hash.remove(current)
    54                                         
    55    103.6 MiB   -404.0 MiB        1683           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.6 MiB   -404.0 MiB        1683           if current == end:
    60    103.1 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.6 MiB  -3633.6 MiB       15138           for neighbor in current.neighbors:
    65    103.6 MiB  -3230.0 MiB       13456               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.6 MiB  -1615.2 MiB        6728                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.6 MiB  -1614.9 MiB        6728                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.6 MiB  -3230.2 MiB       13456               if temp_g_score < g_score[neighbor]:
    71    103.6 MiB   -445.0 MiB        1915                   came_from[neighbor] = current
    72    103.6 MiB   -445.0 MiB        1915                   g_score[neighbor] = temp_g_score
    73    103.6 MiB   -445.0 MiB        1915                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.6 MiB   -445.0 MiB        1915                   if neighbor not in open_set_hash:
    75    103.6 MiB   -445.0 MiB        1915                       count += 1
    76    103.6 MiB   -445.0 MiB        1915                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.6 MiB   -445.0 MiB        1915                       open_set_hash.add(neighbor)
    78                                                             
    79    103.6 MiB   -403.8 MiB        1682           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.6 MiB   -403.8 MiB        1682           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.1 MiB    103.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.1 MiB  -2448.6 MiB         257       for row in grid:
    30    103.1 MiB -628078.5 MiB       65792           for spot in row:
    31    103.1 MiB -625653.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     78.8 MiB    -24.3 MiB           1       count = 0
    34     78.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     78.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     78.8 MiB      0.0 MiB           1       came_from = {}
    37     82.1 MiB -23976.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     79.1 MiB     -3.0 MiB           1       g_score[start] = 0
    39     81.7 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     81.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     81.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     81.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     81.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     81.7 MiB      0.0 MiB          72       while not open_set.empty():
    47     81.7 MiB      0.0 MiB          72           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     81.7 MiB      0.0 MiB          72           current = open_set.get()[2]
    53     81.7 MiB      0.0 MiB          72           open_set_hash.remove(current)
    54                                         
    55     81.7 MiB      0.0 MiB          72           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     81.7 MiB      0.0 MiB          72           if current == end:
    60     81.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     81.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     81.7 MiB      0.0 MiB         639           for neighbor in current.neighbors:
    65     81.7 MiB      0.0 MiB         568               if current.row != neighbor.row and current.col != neighbor.col:
    66     81.7 MiB      0.0 MiB         284                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     81.7 MiB      0.0 MiB         284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     81.7 MiB      0.0 MiB         568               if temp_g_score < g_score[neighbor]:
    71     81.7 MiB      0.0 MiB         118                   came_from[neighbor] = current
    72     81.7 MiB      0.0 MiB         118                   g_score[neighbor] = temp_g_score
    73     81.7 MiB      0.0 MiB         118                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     81.7 MiB      0.0 MiB         118                   if neighbor not in open_set_hash:
    75     81.7 MiB      0.0 MiB         118                       count += 1
    76     81.7 MiB      0.0 MiB         118                       open_set.put((f_score[neighbor], count, neighbor))
    77     81.7 MiB      0.0 MiB         118                       open_set_hash.add(neighbor)
    78                                                             
    79     81.7 MiB      0.0 MiB          71           if draw is not None:
    80                                                     draw()
    81                                         
    82     81.7 MiB      0.0 MiB          71           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     81.7 MiB     81.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     81.7 MiB   -316.5 MiB         257       for row in grid:
    30     81.7 MiB -80759.8 MiB       65792           for spot in row:
    31     81.7 MiB -80446.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     77.8 MiB     -3.9 MiB           1       count = 0
    34     77.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     77.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     77.8 MiB      0.0 MiB           1       came_from = {}
    37     80.5 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     80.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     81.3 MiB -30783.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     78.8 MiB     -2.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     78.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     78.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     78.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     78.9 MiB      0.0 MiB         128       while not open_set.empty():
    47     78.9 MiB      0.0 MiB         128           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     78.9 MiB      0.0 MiB         128           current = open_set.get()[2]
    53     78.9 MiB      0.0 MiB         128           open_set_hash.remove(current)
    54                                         
    55     78.9 MiB      0.0 MiB         128           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     78.9 MiB      0.0 MiB         128           if current == end:
    60     78.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     78.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     78.9 MiB      0.0 MiB        1143           for neighbor in current.neighbors:
    65     78.9 MiB      0.0 MiB        1016               if current.row != neighbor.row and current.col != neighbor.col:
    66     78.9 MiB      0.0 MiB         508                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     78.9 MiB      0.0 MiB         508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     78.9 MiB      0.0 MiB        1016               if temp_g_score < g_score[neighbor]:
    71     78.9 MiB      0.0 MiB         386                   came_from[neighbor] = current
    72     78.9 MiB      0.0 MiB         386                   g_score[neighbor] = temp_g_score
    73     78.9 MiB      0.0 MiB         386                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     78.9 MiB      0.0 MiB         386                   if neighbor not in open_set_hash:
    75     78.9 MiB      0.0 MiB         386                       count += 1
    76     78.9 MiB      0.0 MiB         386                       open_set.put((f_score[neighbor], count, neighbor))
    77     78.9 MiB      0.0 MiB         386                       open_set_hash.add(neighbor)
    78                                                             
    79     78.9 MiB      0.0 MiB         127           if draw is not None:
    80                                                     draw()
    81                                         
    82     78.9 MiB      0.0 MiB         127           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.6 MiB    116.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.6 MiB   -541.9 MiB         257       for row in grid:
    30    116.6 MiB -138672.9 MiB       65792           for spot in row:
    31    116.6 MiB -138133.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.9 MiB     -3.8 MiB           1       count = 0
    34    112.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.9 MiB      0.0 MiB           1       came_from = {}
    37    115.5 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.5 MiB -32977.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.5 MiB      0.0 MiB        2926       while not open_set.empty():
    47    116.5 MiB      0.0 MiB        2926           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.5 MiB      0.0 MiB        2926           current = open_set.get()[2]
    53    116.5 MiB      0.0 MiB        2926           open_set_hash.remove(current)
    54                                         
    55    116.5 MiB      0.0 MiB        2926           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.5 MiB      0.0 MiB        2926           if current == end:
    60    116.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.5 MiB      0.0 MiB       26325           for neighbor in current.neighbors:
    65    116.5 MiB      0.0 MiB       23400               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.5 MiB      0.0 MiB       11700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.5 MiB      0.0 MiB       11700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.5 MiB      0.0 MiB       23400               if temp_g_score < g_score[neighbor]:
    71    116.5 MiB      0.0 MiB        3278                   came_from[neighbor] = current
    72    116.5 MiB      0.0 MiB        3278                   g_score[neighbor] = temp_g_score
    73    116.5 MiB      0.0 MiB        3278                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.5 MiB      0.0 MiB        3278                   if neighbor not in open_set_hash:
    75    116.5 MiB      0.0 MiB        3278                       count += 1
    76    116.5 MiB      0.0 MiB        3278                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.5 MiB      0.0 MiB        3278                       open_set_hash.add(neighbor)
    78                                                             
    79    116.5 MiB      0.0 MiB        2925           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.5 MiB      0.0 MiB        2925           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.5 MiB    116.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.5 MiB   -975.3 MiB         257       for row in grid:
    30    116.5 MiB -249637.3 MiB       65792           for spot in row:
    31    116.5 MiB -248666.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.9 MiB     -4.6 MiB           1       count = 0
    34    111.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.9 MiB      0.0 MiB           1       came_from = {}
    37    115.0 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.9 MiB  -2210.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.6 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.6 MiB  -8383.2 MiB        2490       while not open_set.empty():
    47    116.6 MiB  -8383.2 MiB        2490           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.6 MiB  -8383.2 MiB        2490           current = open_set.get()[2]
    53    116.6 MiB  -8383.2 MiB        2490           open_set_hash.remove(current)
    54                                         
    55    116.6 MiB  -8383.2 MiB        2490           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.6 MiB  -8383.2 MiB        2490           if current == end:
    60    105.9 MiB    -10.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.6 MiB -75405.8 MiB       22401           for neighbor in current.neighbors:
    65    116.6 MiB -67023.8 MiB       19912               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.6 MiB -33524.8 MiB        9956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.6 MiB -33499.3 MiB        9956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.6 MiB -67029.4 MiB       19912               if temp_g_score < g_score[neighbor]:
    71    116.6 MiB  -9488.6 MiB        2880                   came_from[neighbor] = current
    72    116.6 MiB  -9488.6 MiB        2880                   g_score[neighbor] = temp_g_score
    73    116.6 MiB  -9488.6 MiB        2880                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.6 MiB  -9488.6 MiB        2880                   if neighbor not in open_set_hash:
    75    116.6 MiB  -9488.6 MiB        2880                       count += 1
    76    116.6 MiB  -9488.6 MiB        2880                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.6 MiB  -9488.6 MiB        2880                       open_set_hash.add(neighbor)
    78                                                             
    79    116.6 MiB  -8383.2 MiB        2489           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.6 MiB  -8383.2 MiB        2489           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.0 MiB    106.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.0 MiB  -2757.0 MiB         257       for row in grid:
    30    106.0 MiB -706557.9 MiB       65792           for spot in row:
    31    106.0 MiB -703817.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.0 MiB    -14.9 MiB           1       count = 0
    34     91.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.0 MiB      0.0 MiB           1       came_from = {}
    37     92.0 MiB -640291.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     80.5 MiB    -11.5 MiB           1       g_score[start] = 0
    39     81.2 MiB -578704.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.5 MiB    -10.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.5 MiB      0.0 MiB         840       while not open_set.empty():
    47     71.5 MiB      0.0 MiB         840           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.5 MiB      0.0 MiB         840           current = open_set.get()[2]
    53     71.5 MiB      0.0 MiB         840           open_set_hash.remove(current)
    54                                         
    55     71.5 MiB      0.0 MiB         840           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.5 MiB      0.0 MiB         840           if current == end:
    60     71.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.5 MiB      0.3 MiB        7551           for neighbor in current.neighbors:
    65     71.5 MiB      0.5 MiB        6712               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.5 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.5 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.5 MiB      0.0 MiB        6712               if temp_g_score < g_score[neighbor]:
    71     71.5 MiB      0.0 MiB        1142                   came_from[neighbor] = current
    72     71.5 MiB      0.0 MiB        1142                   g_score[neighbor] = temp_g_score
    73     71.5 MiB      0.0 MiB        1142                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.5 MiB      0.0 MiB        1142                   if neighbor not in open_set_hash:
    75     71.5 MiB      0.0 MiB        1142                       count += 1
    76     71.5 MiB      0.1 MiB        1142                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.5 MiB      0.0 MiB        1142                       open_set_hash.add(neighbor)
    78                                                             
    79     71.5 MiB      0.0 MiB         839           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.5 MiB      0.0 MiB         839           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.0 MiB     74.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     77.3 MiB  -2577.9 MiB         257       for row in grid:
    30     77.3 MiB -659679.8 MiB       65792           for spot in row:
    31     77.3 MiB -657107.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.8 MiB    -13.5 MiB           1       count = 0
    34     63.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.8 MiB      0.0 MiB           1       came_from = {}
    37     68.4 MiB  -1176.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.3 MiB     -0.1 MiB           1       g_score[start] = 0
    39     71.9 MiB -16015.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.7 MiB     -2.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.8 MiB      0.0 MiB          73       while not open_set.empty():
    47     69.8 MiB      0.0 MiB          73           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.8 MiB      0.0 MiB          73           current = open_set.get()[2]
    53     69.8 MiB      0.0 MiB          73           open_set_hash.remove(current)
    54                                         
    55     69.8 MiB      0.0 MiB          73           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.8 MiB      0.0 MiB          73           if current == end:
    60     69.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.8 MiB      0.0 MiB         648           for neighbor in current.neighbors:
    65     69.8 MiB      0.0 MiB         576               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.8 MiB      0.0 MiB         288                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.8 MiB      0.0 MiB         288                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.8 MiB      0.0 MiB         576               if temp_g_score < g_score[neighbor]:
    71     69.8 MiB      0.0 MiB         363                   came_from[neighbor] = current
    72     69.8 MiB      0.0 MiB         363                   g_score[neighbor] = temp_g_score
    73     69.8 MiB      0.0 MiB         363                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.8 MiB      0.0 MiB         363                   if neighbor not in open_set_hash:
    75     69.8 MiB      0.0 MiB         363                       count += 1
    76     69.8 MiB      0.0 MiB         363                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.8 MiB      0.0 MiB         363                       open_set_hash.add(neighbor)
    78                                                             
    79     69.8 MiB      0.0 MiB          72           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.8 MiB      0.0 MiB          72           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.8 MiB     69.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.8 MiB   -155.4 MiB         257       for row in grid:
    30     69.8 MiB -39844.5 MiB       65792           for spot in row:
    31     69.8 MiB -39689.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     69.0 MiB     -0.8 MiB           1       count = 0
    34     69.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     69.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     69.0 MiB      0.0 MiB           1       came_from = {}
    37     71.4 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.1 MiB -14156.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.2 MiB      0.0 MiB         256       while not open_set.empty():
    47     74.2 MiB      0.0 MiB         256           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.2 MiB      0.0 MiB         256           current = open_set.get()[2]
    53     74.2 MiB      0.0 MiB         256           open_set_hash.remove(current)
    54                                         
    55     74.2 MiB      0.0 MiB         256           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.2 MiB      0.0 MiB         256           if current == end:
    60     74.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.2 MiB      0.0 MiB        2295           for neighbor in current.neighbors:
    65     74.2 MiB      0.0 MiB        2040               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.2 MiB      0.0 MiB        1020                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.2 MiB      0.0 MiB        1020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.2 MiB      0.0 MiB        2040               if temp_g_score < g_score[neighbor]:
    71     74.2 MiB      0.0 MiB         350                   came_from[neighbor] = current
    72     74.2 MiB      0.0 MiB         350                   g_score[neighbor] = temp_g_score
    73     74.2 MiB      0.0 MiB         350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.2 MiB      0.0 MiB         350                   if neighbor not in open_set_hash:
    75     74.2 MiB      0.0 MiB         350                       count += 1
    76     74.2 MiB      0.0 MiB         350                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.2 MiB      0.0 MiB         350                       open_set_hash.add(neighbor)
    78                                                             
    79     74.2 MiB      0.0 MiB         255           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.2 MiB      0.0 MiB         255           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.2 MiB     74.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.2 MiB  -2090.5 MiB         257       for row in grid:
    30     74.2 MiB -535496.3 MiB       65792           for spot in row:
    31     74.2 MiB -533415.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.8 MiB    -13.4 MiB           1       count = 0
    34     60.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.8 MiB      0.0 MiB           1       came_from = {}
    37     65.4 MiB   -868.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.2 MiB  -2924.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.0 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.1 MiB      0.0 MiB         902       while not open_set.empty():
    47     68.1 MiB      0.0 MiB         902           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.1 MiB      0.0 MiB         902           current = open_set.get()[2]
    53     68.1 MiB      0.0 MiB         902           open_set_hash.remove(current)
    54                                         
    55     68.1 MiB      0.0 MiB         902           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.1 MiB      0.0 MiB         902           if current == end:
    60     68.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.1 MiB      0.0 MiB        8109           for neighbor in current.neighbors:
    65     68.1 MiB      0.0 MiB        7208               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.1 MiB      0.0 MiB        3604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.1 MiB      0.0 MiB        3604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.1 MiB      0.0 MiB        7208               if temp_g_score < g_score[neighbor]:
    71     68.1 MiB      0.0 MiB        1108                   came_from[neighbor] = current
    72     68.1 MiB      0.0 MiB        1108                   g_score[neighbor] = temp_g_score
    73     68.1 MiB      0.0 MiB        1108                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.1 MiB      0.0 MiB        1108                   if neighbor not in open_set_hash:
    75     68.1 MiB      0.0 MiB        1108                       count += 1
    76     68.1 MiB      0.0 MiB        1108                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.1 MiB      0.0 MiB        1108                       open_set_hash.add(neighbor)
    78                                                             
    79     68.1 MiB      0.0 MiB         901           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.1 MiB      0.0 MiB         901           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     68.1 MiB     68.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.3 MiB      0.0 MiB         257       for row in grid:
    30     68.3 MiB      0.0 MiB       65792           for spot in row:
    31     68.3 MiB      0.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     68.3 MiB      0.0 MiB           1       count = 0
    34     68.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     68.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     68.3 MiB      0.0 MiB           1       came_from = {}
    37     70.5 MiB -32638.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.9 MiB -81030.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.9 MiB   -521.5 MiB         918       while not open_set.empty():
    47     70.9 MiB   -521.5 MiB         918           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.9 MiB   -521.5 MiB         918           current = open_set.get()[2]
    53     70.9 MiB   -521.5 MiB         918           open_set_hash.remove(current)
    54                                         
    55     70.9 MiB   -521.5 MiB         918           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.9 MiB   -521.5 MiB         918           if current == end:
    60     69.5 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.9 MiB  -4686.4 MiB        8253           for neighbor in current.neighbors:
    65     70.9 MiB  -4164.9 MiB        7336               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.9 MiB  -2084.5 MiB        3668                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.9 MiB  -2080.4 MiB        3668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.9 MiB  -4164.9 MiB        7336               if temp_g_score < g_score[neighbor]:
    71     70.9 MiB   -642.5 MiB        1156                   came_from[neighbor] = current
    72     70.9 MiB   -643.0 MiB        1156                   g_score[neighbor] = temp_g_score
    73     70.9 MiB   -643.0 MiB        1156                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.9 MiB   -643.2 MiB        1156                   if neighbor not in open_set_hash:
    75     70.9 MiB   -643.8 MiB        1156                       count += 1
    76     70.9 MiB   -643.8 MiB        1156                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.9 MiB   -643.9 MiB        1156                       open_set_hash.add(neighbor)
    78                                                             
    79     70.9 MiB   -521.5 MiB         917           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.9 MiB   -521.5 MiB         917           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.2 MiB    110.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.2 MiB    -76.5 MiB         257       for row in grid:
    30    110.2 MiB -19598.6 MiB       65792           for spot in row:
    31    110.2 MiB -19522.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.6 MiB     -0.6 MiB           1       count = 0
    34    109.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.6 MiB      0.0 MiB           1       came_from = {}
    37    110.8 MiB -16155.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.1 MiB -39303.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.1 MiB    -17.5 MiB        1365       while not open_set.empty():
    47    111.1 MiB    -17.5 MiB        1365           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.1 MiB    -17.5 MiB        1365           current = open_set.get()[2]
    53    111.1 MiB    -17.5 MiB        1365           open_set_hash.remove(current)
    54                                         
    55    111.1 MiB    -17.5 MiB        1365           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.1 MiB    -17.5 MiB        1365           if current == end:
    60    111.1 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.1 MiB   -157.3 MiB       12276           for neighbor in current.neighbors:
    65    111.1 MiB   -139.8 MiB       10912               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.1 MiB    -70.0 MiB        5456                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.1 MiB    -69.8 MiB        5456                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.1 MiB   -139.8 MiB       10912               if temp_g_score < g_score[neighbor]:
    71    111.1 MiB    -20.8 MiB        1605                   came_from[neighbor] = current
    72    111.1 MiB    -20.8 MiB        1605                   g_score[neighbor] = temp_g_score
    73    111.1 MiB    -20.8 MiB        1605                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.1 MiB    -20.8 MiB        1605                   if neighbor not in open_set_hash:
    75    111.1 MiB    -20.8 MiB        1605                       count += 1
    76    111.1 MiB    -20.8 MiB        1605                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.1 MiB    -20.8 MiB        1605                       open_set_hash.add(neighbor)
    78                                                             
    79    111.1 MiB    -17.5 MiB        1364           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.1 MiB    -17.5 MiB        1364           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.1 MiB    111.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.1 MiB   -461.2 MiB         257       for row in grid:
    30    111.1 MiB -118021.1 MiB       65792           for spot in row:
    31    111.1 MiB -117561.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.7 MiB     -2.4 MiB           1       count = 0
    34    108.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.7 MiB      0.0 MiB           1       came_from = {}
    37    111.4 MiB  -5426.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.8 MiB     -1.6 MiB           1       g_score[start] = 0
    39    110.3 MiB -499865.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.5 MiB    -11.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.6 MiB      0.0 MiB        1080       while not open_set.empty():
    47     98.6 MiB      0.0 MiB        1080           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.6 MiB      0.0 MiB        1080           current = open_set.get()[2]
    53     98.6 MiB      0.0 MiB        1080           open_set_hash.remove(current)
    54                                         
    55     98.6 MiB      0.0 MiB        1080           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.6 MiB      0.0 MiB        1080           if current == end:
    60     98.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.6 MiB      0.0 MiB        9711           for neighbor in current.neighbors:
    65     98.6 MiB      0.0 MiB        8632               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.6 MiB      0.0 MiB        4316                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.6 MiB      0.0 MiB        4316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.6 MiB      0.0 MiB        8632               if temp_g_score < g_score[neighbor]:
    71     98.6 MiB      0.1 MiB        1266                   came_from[neighbor] = current
    72     98.6 MiB      0.0 MiB        1266                   g_score[neighbor] = temp_g_score
    73     98.6 MiB      0.0 MiB        1266                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.6 MiB      0.0 MiB        1266                   if neighbor not in open_set_hash:
    75     98.6 MiB      0.0 MiB        1266                       count += 1
    76     98.6 MiB      0.0 MiB        1266                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.6 MiB      0.0 MiB        1266                       open_set_hash.add(neighbor)
    78                                                             
    79     98.6 MiB      0.0 MiB        1079           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.6 MiB      0.0 MiB        1079           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.7 MiB     98.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.1 MiB   -339.4 MiB         257       for row in grid:
    30     99.1 MiB -87006.2 MiB       65792           for spot in row:
    31     99.1 MiB -86669.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.1 MiB     -5.0 MiB           1       count = 0
    34     94.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.1 MiB      0.0 MiB           1       came_from = {}
    37     95.2 MiB -13509.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.8 MiB     -0.3 MiB           1       g_score[start] = 0
    39     97.8 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.8 MiB      0.0 MiB         450       while not open_set.empty():
    47     97.8 MiB      0.0 MiB         450           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.8 MiB      0.0 MiB         450           current = open_set.get()[2]
    53     97.8 MiB      0.0 MiB         450           open_set_hash.remove(current)
    54                                         
    55     97.8 MiB      0.0 MiB         450           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.8 MiB      0.0 MiB         450           if current == end:
    60     97.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.8 MiB      0.0 MiB        4041           for neighbor in current.neighbors:
    65     97.8 MiB      0.0 MiB        3592               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.8 MiB      0.0 MiB        1796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.8 MiB      0.0 MiB        1796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.8 MiB      0.0 MiB        3592               if temp_g_score < g_score[neighbor]:
    71     97.8 MiB      0.0 MiB         578                   came_from[neighbor] = current
    72     97.8 MiB      0.0 MiB         578                   g_score[neighbor] = temp_g_score
    73     97.8 MiB      0.0 MiB         578                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.8 MiB      0.0 MiB         578                   if neighbor not in open_set_hash:
    75     97.8 MiB      0.0 MiB         578                       count += 1
    76     97.8 MiB      0.0 MiB         578                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.8 MiB      0.0 MiB         578                       open_set_hash.add(neighbor)
    78                                                             
    79     97.8 MiB      0.0 MiB         449           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.8 MiB      0.0 MiB         449           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.8 MiB     97.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.8 MiB      0.0 MiB         257       for row in grid:
    30     97.8 MiB      0.0 MiB       65792           for spot in row:
    31     97.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.8 MiB      0.0 MiB           1       count = 0
    34     97.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.8 MiB      0.0 MiB           1       came_from = {}
    37    101.0 MiB  -9014.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.3 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.3 MiB      0.0 MiB         585       while not open_set.empty():
    47    102.3 MiB      0.0 MiB         585           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.3 MiB      0.0 MiB         585           current = open_set.get()[2]
    53    102.3 MiB      0.0 MiB         585           open_set_hash.remove(current)
    54                                         
    55    102.3 MiB      0.0 MiB         585           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.3 MiB      0.0 MiB         585           if current == end:
    60    102.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.3 MiB      0.0 MiB        5256           for neighbor in current.neighbors:
    65    102.3 MiB      0.0 MiB        4672               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.3 MiB      0.0 MiB        2336                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.3 MiB      0.0 MiB        2336                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.3 MiB      0.0 MiB        4672               if temp_g_score < g_score[neighbor]:
    71    102.3 MiB      0.0 MiB         725                   came_from[neighbor] = current
    72    102.3 MiB      0.0 MiB         725                   g_score[neighbor] = temp_g_score
    73    102.3 MiB      0.0 MiB         725                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.3 MiB      0.0 MiB         725                   if neighbor not in open_set_hash:
    75    102.3 MiB      0.0 MiB         725                       count += 1
    76    102.3 MiB      0.0 MiB         725                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.3 MiB      0.0 MiB         725                       open_set_hash.add(neighbor)
    78                                                             
    79    102.3 MiB      0.0 MiB         584           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.3 MiB      0.0 MiB         584           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.3 MiB    102.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.3 MiB   -106.5 MiB         257       for row in grid:
    30    102.3 MiB -27247.3 MiB       65792           for spot in row:
    31    102.3 MiB -27141.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.6 MiB     -0.7 MiB           1       count = 0
    34    101.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.6 MiB      0.0 MiB           1       came_from = {}
    37    105.3 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.8 MiB  -3958.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.6 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.6 MiB  -1129.6 MiB         585       while not open_set.empty():
    47    105.6 MiB  -1129.6 MiB         585           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.6 MiB  -1130.5 MiB         585           current = open_set.get()[2]
    53    105.6 MiB  -1130.6 MiB         585           open_set_hash.remove(current)
    54                                         
    55    105.6 MiB  -1130.8 MiB         585           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.6 MiB  -1130.8 MiB         585           if current == end:
    60     98.7 MiB     -6.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.6 MiB -10118.6 MiB        5256           for neighbor in current.neighbors:
    65    105.6 MiB  -8990.6 MiB        4672               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.6 MiB  -4495.6 MiB        2336                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.6 MiB  -4495.3 MiB        2336                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.6 MiB  -8991.5 MiB        4672               if temp_g_score < g_score[neighbor]:
    71    105.6 MiB  -1604.3 MiB         861                   came_from[neighbor] = current
    72    105.6 MiB  -1604.3 MiB         861                   g_score[neighbor] = temp_g_score
    73    105.6 MiB  -1604.3 MiB         861                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.6 MiB  -1604.3 MiB         861                   if neighbor not in open_set_hash:
    75    105.6 MiB  -1604.7 MiB         861                       count += 1
    76    105.6 MiB  -1604.8 MiB         861                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.6 MiB  -1606.5 MiB         861                       open_set_hash.add(neighbor)
    78                                                             
    79    105.6 MiB  -1129.6 MiB         584           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.6 MiB  -1129.6 MiB         584           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.7 MiB     98.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.7 MiB   -225.2 MiB         257       for row in grid:
    30     98.7 MiB -56006.3 MiB       65792           for spot in row:
    31     98.7 MiB -55788.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.6 MiB    -11.1 MiB           1       count = 0
    34     87.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     87.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     87.6 MiB      0.0 MiB           1       came_from = {}
    37     91.4 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     93.8 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.9 MiB -40406.4 MiB        2204       while not open_set.empty():
    47     93.9 MiB -40406.4 MiB        2204           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.9 MiB -40406.4 MiB        2204           current = open_set.get()[2]
    53     93.9 MiB -40406.4 MiB        2204           open_set_hash.remove(current)
    54                                         
    55     93.9 MiB -40406.4 MiB        2204           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.9 MiB -40406.4 MiB        2204           if current == end:
    60     74.2 MiB    -19.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.9 MiB -363580.0 MiB       19827           for neighbor in current.neighbors:
    65     93.9 MiB -323174.5 MiB       17624               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.9 MiB -161625.2 MiB        8812                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.9 MiB -161550.2 MiB        8812                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.9 MiB -323192.6 MiB       17624               if temp_g_score < g_score[neighbor]:
    71     93.9 MiB -44298.2 MiB        2470                   came_from[neighbor] = current
    72     93.9 MiB -44298.3 MiB        2470                   g_score[neighbor] = temp_g_score
    73     93.9 MiB -44298.3 MiB        2470                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.9 MiB -44298.3 MiB        2470                   if neighbor not in open_set_hash:
    75     93.9 MiB -44298.3 MiB        2470                       count += 1
    76     93.9 MiB -44298.3 MiB        2470                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.9 MiB -44298.3 MiB        2470                       open_set_hash.add(neighbor)
    78                                                             
    79     93.9 MiB -40406.4 MiB        2203           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.9 MiB -40406.4 MiB        2203           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.2 MiB     74.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.2 MiB  -3869.5 MiB         257       for row in grid:
    30     74.2 MiB -991513.1 MiB       65792           for spot in row:
    31     74.2 MiB -987655.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.2 MiB    -18.1 MiB           1       count = 0
    34     56.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     56.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.2 MiB      0.0 MiB           1       came_from = {}
    37     58.3 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     62.5 MiB  -6846.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.6 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.8 MiB  -2040.3 MiB        2688       while not open_set.empty():
    47     62.8 MiB  -2040.3 MiB        2688           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.8 MiB  -2040.3 MiB        2688           current = open_set.get()[2]
    53     62.8 MiB  -2040.4 MiB        2688           open_set_hash.remove(current)
    54                                         
    55     62.8 MiB  -2040.4 MiB        2688           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.8 MiB  -2040.4 MiB        2688           if current == end:
    60     60.6 MiB     -2.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.8 MiB -18355.9 MiB       24183           for neighbor in current.neighbors:
    65     62.8 MiB -16316.2 MiB       21496               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.8 MiB  -8160.8 MiB       10748                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.8 MiB  -8155.8 MiB       10748                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.8 MiB -16317.2 MiB       21496               if temp_g_score < g_score[neighbor]:
    71     62.8 MiB  -2272.0 MiB        3026                   came_from[neighbor] = current
    72     62.8 MiB  -2272.0 MiB        3026                   g_score[neighbor] = temp_g_score
    73     62.8 MiB  -2272.0 MiB        3026                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.8 MiB  -2272.0 MiB        3026                   if neighbor not in open_set_hash:
    75     62.8 MiB  -2272.0 MiB        3026                       count += 1
    76     62.8 MiB  -2272.0 MiB        3026                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.8 MiB  -2272.0 MiB        3026                       open_set_hash.add(neighbor)
    78                                                             
    79     62.8 MiB  -2040.3 MiB        2687           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.8 MiB  -2040.3 MiB        2687           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.0 MiB    106.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.0 MiB    -34.9 MiB         257       for row in grid:
    30    106.0 MiB  -8666.8 MiB       65792           for spot in row:
    31    106.0 MiB  -8635.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.8 MiB     -4.2 MiB           1       count = 0
    34    101.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.8 MiB      0.0 MiB           1       came_from = {}
    37    106.8 MiB  -2184.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.2 MiB     -0.6 MiB           1       g_score[start] = 0
    39    109.5 MiB      3.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.5 MiB  -1092.1 MiB         178       while not open_set.empty():
    47    109.5 MiB  -1092.5 MiB         178           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.5 MiB  -1092.7 MiB         178           current = open_set.get()[2]
    53    109.5 MiB  -1092.7 MiB         178           open_set_hash.remove(current)
    54                                         
    55    109.5 MiB  -1092.7 MiB         178           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.5 MiB  -1092.7 MiB         178           if current == end:
    60    102.8 MiB     -6.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.5 MiB  -9786.8 MiB        1593           for neighbor in current.neighbors:
    65    109.5 MiB  -8696.4 MiB        1416               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.5 MiB  -4351.0 MiB         708                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.5 MiB  -4346.4 MiB         708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.5 MiB  -8698.1 MiB        1416               if temp_g_score < g_score[neighbor]:
    71    109.5 MiB  -5437.4 MiB         888                   came_from[neighbor] = current
    72    109.5 MiB  -5437.5 MiB         888                   g_score[neighbor] = temp_g_score
    73    109.5 MiB  -5437.7 MiB         888                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.5 MiB  -5438.1 MiB         888                   if neighbor not in open_set_hash:
    75    109.5 MiB  -5438.4 MiB         888                       count += 1
    76    109.5 MiB  -5438.3 MiB         888                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.5 MiB  -5438.6 MiB         888                       open_set_hash.add(neighbor)
    78                                                             
    79    109.5 MiB  -1091.5 MiB         177           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.5 MiB  -1091.8 MiB         177           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.8 MiB    102.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.9 MiB      0.0 MiB         257       for row in grid:
    30    102.9 MiB      0.0 MiB       65792           for spot in row:
    31    102.9 MiB      0.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.9 MiB      0.0 MiB           1       count = 0
    34    102.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.9 MiB      0.0 MiB           1       came_from = {}
    37    103.0 MiB -140600.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.4 MiB     -3.6 MiB           1       g_score[start] = 0
    39    101.9 MiB -19553.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.0 MiB  -9180.7 MiB        4495       while not open_set.empty():
    47    102.0 MiB  -9180.7 MiB        4495           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.0 MiB  -9180.7 MiB        4495           current = open_set.get()[2]
    53    102.0 MiB  -9180.7 MiB        4495           open_set_hash.remove(current)
    54                                         
    55    102.0 MiB  -9180.7 MiB        4495           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.0 MiB  -9180.7 MiB        4495           if current == end:
    60     99.4 MiB     -2.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.0 MiB -82610.8 MiB       40446           for neighbor in current.neighbors:
    65    102.0 MiB -73430.4 MiB       35952               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.0 MiB -36718.4 MiB       17976                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.0 MiB -36712.6 MiB       17976                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.0 MiB -73431.1 MiB       35952               if temp_g_score < g_score[neighbor]:
    71    102.0 MiB -10354.6 MiB        5135                   came_from[neighbor] = current
    72    102.0 MiB -10354.9 MiB        5135                   g_score[neighbor] = temp_g_score
    73    102.0 MiB -10355.3 MiB        5135                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.0 MiB -10355.5 MiB        5135                   if neighbor not in open_set_hash:
    75    102.0 MiB -10355.8 MiB        5135                       count += 1
    76    102.0 MiB -10356.4 MiB        5135                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.0 MiB -10356.3 MiB        5135                       open_set_hash.add(neighbor)
    78                                                             
    79    102.0 MiB  -9180.7 MiB        4494           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.0 MiB  -9180.7 MiB        4494           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.4 MiB     99.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.4 MiB   -403.2 MiB         257       for row in grid:
    30     99.4 MiB -102902.7 MiB       65792           for spot in row:
    31     99.4 MiB -102501.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.8 MiB     -3.6 MiB           1       count = 0
    34     95.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.8 MiB      0.0 MiB           1       came_from = {}
    37     97.9 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.6 MiB  -5551.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.6 MiB  -5694.3 MiB        6952       while not open_set.empty():
    47    101.6 MiB  -5694.3 MiB        6952           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.6 MiB  -5694.3 MiB        6952           current = open_set.get()[2]
    53    101.6 MiB  -5694.3 MiB        6952           open_set_hash.remove(current)
    54                                         
    55    101.6 MiB  -5694.3 MiB        6952           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.6 MiB  -5694.3 MiB        6952           if current == end:
    60     98.7 MiB     -2.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.6 MiB -51231.7 MiB       62559           for neighbor in current.neighbors:
    65    101.6 MiB -45537.8 MiB       55608               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.6 MiB -22772.3 MiB       27804                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.6 MiB -22765.8 MiB       27804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.6 MiB -45538.5 MiB       55608               if temp_g_score < g_score[neighbor]:
    71    101.6 MiB  -6041.8 MiB        7460                   came_from[neighbor] = current
    72    101.6 MiB  -6042.0 MiB        7460                   g_score[neighbor] = temp_g_score
    73    101.6 MiB  -6042.4 MiB        7460                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.6 MiB  -6042.6 MiB        7460                   if neighbor not in open_set_hash:
    75    101.6 MiB  -6042.8 MiB        7460                       count += 1
    76    101.6 MiB  -6043.1 MiB        7460                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.6 MiB  -6043.3 MiB        7460                       open_set_hash.add(neighbor)
    78                                                             
    79    101.6 MiB  -5694.3 MiB        6951           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.6 MiB  -5694.3 MiB        6951           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.7 MiB     98.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.7 MiB      0.0 MiB         257       for row in grid:
    30     98.7 MiB      0.0 MiB       65792           for spot in row:
    31     98.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.7 MiB      0.0 MiB           1       count = 0
    34     98.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.7 MiB      0.0 MiB           1       came_from = {}
    37    100.6 MiB      1.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.8 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.9 MiB  -3495.3 MiB        6042       while not open_set.empty():
    47    100.9 MiB  -3495.3 MiB        6042           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.9 MiB  -3495.3 MiB        6042           current = open_set.get()[2]
    53    100.9 MiB  -3495.3 MiB        6042           open_set_hash.remove(current)
    54                                         
    55    100.9 MiB  -3495.3 MiB        6042           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.9 MiB  -3495.3 MiB        6042           if current == end:
    60     96.1 MiB     -4.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.9 MiB -31427.2 MiB       54369           for neighbor in current.neighbors:
    65    100.9 MiB -27932.4 MiB       48328               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.9 MiB -13973.4 MiB       24164                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.9 MiB -13962.2 MiB       24164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.9 MiB -27935.9 MiB       48328               if temp_g_score < g_score[neighbor]:
    71    100.9 MiB  -3844.7 MiB        6578                   came_from[neighbor] = current
    72    100.9 MiB  -3844.8 MiB        6578                   g_score[neighbor] = temp_g_score
    73    100.9 MiB  -3844.8 MiB        6578                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.9 MiB  -3844.8 MiB        6578                   if neighbor not in open_set_hash:
    75    100.9 MiB  -3844.8 MiB        6578                       count += 1
    76    100.9 MiB  -3844.9 MiB        6578                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.9 MiB  -3844.9 MiB        6578                       open_set_hash.add(neighbor)
    78                                                             
    79    100.9 MiB  -3495.3 MiB        6041           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.9 MiB  -3495.3 MiB        6041           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.1 MiB     96.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.1 MiB   -186.8 MiB         257       for row in grid:
    30     96.1 MiB -47866.4 MiB       65792           for spot in row:
    31     96.1 MiB -47680.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.0 MiB     -1.1 MiB           1       count = 0
    34     95.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.0 MiB      0.0 MiB           1       came_from = {}
    37     97.4 MiB -13924.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.2 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.2 MiB   -693.7 MiB        1178       while not open_set.empty():
    47    101.2 MiB   -693.7 MiB        1178           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.2 MiB   -693.7 MiB        1178           current = open_set.get()[2]
    53    101.2 MiB   -693.7 MiB        1178           open_set_hash.remove(current)
    54                                         
    55    101.2 MiB   -693.7 MiB        1178           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.2 MiB   -693.7 MiB        1178           if current == end:
    60    100.5 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.2 MiB  -6241.5 MiB       10593           for neighbor in current.neighbors:
    65    101.2 MiB  -5548.0 MiB        9416               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.2 MiB  -2774.7 MiB        4708                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.2 MiB  -2773.3 MiB        4708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.2 MiB  -5548.0 MiB        9416               if temp_g_score < g_score[neighbor]:
    71    101.2 MiB   -784.9 MiB        1390                   came_from[neighbor] = current
    72    101.2 MiB   -784.9 MiB        1390                   g_score[neighbor] = temp_g_score
    73    101.2 MiB   -784.9 MiB        1390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.2 MiB   -784.9 MiB        1390                   if neighbor not in open_set_hash:
    75    101.2 MiB   -784.9 MiB        1390                       count += 1
    76    101.2 MiB   -784.9 MiB        1390                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.2 MiB   -785.0 MiB        1390                       open_set_hash.add(neighbor)
    78                                                             
    79    101.2 MiB   -693.7 MiB        1177           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.2 MiB   -693.7 MiB        1177           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.5 MiB    100.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.5 MiB  -5286.2 MiB         257       for row in grid:
    30    100.5 MiB -1352910.6 MiB       65792           for spot in row:
    31    100.5 MiB -1347641.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     68.8 MiB    -31.6 MiB           1       count = 0
    34     68.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     68.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     68.8 MiB      0.0 MiB           1       came_from = {}
    37     71.1 MiB  -7671.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.4 MiB -715904.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     54.0 MiB    -17.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     54.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     54.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     54.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     54.3 MiB -122095.1 MiB        6944       while not open_set.empty():
    47     54.3 MiB -122095.2 MiB        6944           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     54.3 MiB -122095.4 MiB        6944           current = open_set.get()[2]
    53     54.3 MiB -122095.4 MiB        6944           open_set_hash.remove(current)
    54                                         
    55     54.3 MiB -122095.4 MiB        6944           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     54.3 MiB -122095.4 MiB        6944           if current == end:
    60     34.0 MiB    -20.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     34.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     54.3 MiB -1098780.0 MiB       62487           for neighbor in current.neighbors:
    65     54.3 MiB -976691.3 MiB       55544               if current.row != neighbor.row and current.col != neighbor.col:
    66     54.3 MiB -488365.5 MiB       27772                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     54.3 MiB -488328.5 MiB       27772                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     54.3 MiB -976698.2 MiB       55544               if temp_g_score < g_score[neighbor]:
    71     54.3 MiB -128316.8 MiB        7414                   came_from[neighbor] = current
    72     54.3 MiB -128317.0 MiB        7414                   g_score[neighbor] = temp_g_score
    73     54.3 MiB -128317.1 MiB        7414                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     54.3 MiB -128317.2 MiB        7414                   if neighbor not in open_set_hash:
    75     54.3 MiB -128317.4 MiB        7414                       count += 1
    76     54.3 MiB -128318.0 MiB        7414                       open_set.put((f_score[neighbor], count, neighbor))
    77     54.3 MiB -128317.9 MiB        7414                       open_set_hash.add(neighbor)
    78                                                             
    79     54.3 MiB -122093.8 MiB        6943           if draw is not None:
    80                                                     draw()
    81                                         
    82     54.3 MiB -122094.0 MiB        6943           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     41.1 MiB     41.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     57.6 MiB      0.0 MiB         257       for row in grid:
    30     57.6 MiB      0.0 MiB       65792           for spot in row:
    31     57.6 MiB     16.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.6 MiB      0.0 MiB           1       count = 0
    34     57.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.7 MiB      0.0 MiB           1       came_from = {}
    37     62.3 MiB      4.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.5 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.5 MiB      0.0 MiB         507       while not open_set.empty():
    47     64.5 MiB      0.0 MiB         507           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.5 MiB      0.0 MiB         507           current = open_set.get()[2]
    53     64.5 MiB      0.0 MiB         507           open_set_hash.remove(current)
    54                                         
    55     64.5 MiB      0.0 MiB         507           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.5 MiB      0.0 MiB         507           if current == end:
    60     64.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.5 MiB      0.0 MiB        4554           for neighbor in current.neighbors:
    65     64.5 MiB      0.0 MiB        4048               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.5 MiB      0.0 MiB        2024                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.5 MiB      0.0 MiB        2024                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.5 MiB      0.0 MiB        4048               if temp_g_score < g_score[neighbor]:
    71     64.5 MiB      0.0 MiB         635                   came_from[neighbor] = current
    72     64.5 MiB      0.0 MiB         635                   g_score[neighbor] = temp_g_score
    73     64.5 MiB      0.0 MiB         635                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.5 MiB      0.0 MiB         635                   if neighbor not in open_set_hash:
    75     64.5 MiB      0.0 MiB         635                       count += 1
    76     64.5 MiB      0.0 MiB         635                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.5 MiB      0.0 MiB         635                       open_set_hash.add(neighbor)
    78                                                             
    79     64.5 MiB      0.0 MiB         506           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.5 MiB      0.0 MiB         506           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.0 MiB    102.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.0 MiB    -49.4 MiB         257       for row in grid:
    30    102.0 MiB -12501.1 MiB       65792           for spot in row:
    31    102.0 MiB -12452.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.6 MiB     -1.4 MiB           1       count = 0
    34    100.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.6 MiB      0.0 MiB           1       came_from = {}
    37    102.2 MiB  -8926.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.9 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.3 MiB      0.0 MiB        8512       while not open_set.empty():
    47    104.3 MiB      0.0 MiB        8512           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.3 MiB      0.0 MiB        8512           current = open_set.get()[2]
    53    104.3 MiB      0.0 MiB        8512           open_set_hash.remove(current)
    54                                         
    55    104.3 MiB      0.0 MiB        8512           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.3 MiB      0.0 MiB        8512           if current == end:
    60    104.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.3 MiB      0.0 MiB       76599           for neighbor in current.neighbors:
    65    104.3 MiB      0.0 MiB       68088               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.3 MiB      0.0 MiB       34044                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.3 MiB      0.0 MiB       34044                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.3 MiB      0.0 MiB       68088               if temp_g_score < g_score[neighbor]:
    71    104.3 MiB      0.3 MiB        9038                   came_from[neighbor] = current
    72    104.3 MiB      0.0 MiB        9038                   g_score[neighbor] = temp_g_score
    73    104.3 MiB      0.0 MiB        9038                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.3 MiB      0.0 MiB        9038                   if neighbor not in open_set_hash:
    75    104.3 MiB      0.0 MiB        9038                       count += 1
    76    104.3 MiB      0.0 MiB        9038                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.3 MiB      0.0 MiB        9038                       open_set_hash.add(neighbor)
    78                                                             
    79    104.3 MiB      0.0 MiB        8511           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.3 MiB      0.0 MiB        8511           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.3 MiB    104.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.3 MiB      0.0 MiB         257       for row in grid:
    30    104.3 MiB      0.0 MiB       65792           for spot in row:
    31    104.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.3 MiB      0.0 MiB           1       count = 0
    34    104.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.3 MiB      0.0 MiB           1       came_from = {}
    37    107.2 MiB  -8204.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.8 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.8 MiB  -7971.2 MiB        7372       while not open_set.empty():
    47    110.8 MiB  -7971.2 MiB        7372           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.8 MiB  -7971.2 MiB        7372           current = open_set.get()[2]
    53    110.8 MiB  -7971.2 MiB        7372           open_set_hash.remove(current)
    54                                         
    55    110.8 MiB  -7971.3 MiB        7372           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.8 MiB  -7971.3 MiB        7372           if current == end:
    60    109.5 MiB     -1.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.8 MiB -71733.6 MiB       66339           for neighbor in current.neighbors:
    65    110.8 MiB -63762.3 MiB       58968               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.8 MiB -31882.5 MiB       29484                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.8 MiB -31879.9 MiB       29484                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.8 MiB -63762.5 MiB       58968               if temp_g_score < g_score[neighbor]:
    71    110.8 MiB  -8410.4 MiB        7910                   came_from[neighbor] = current
    72    110.8 MiB  -8410.8 MiB        7910                   g_score[neighbor] = temp_g_score
    73    110.8 MiB  -8410.8 MiB        7910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.8 MiB  -8410.8 MiB        7910                   if neighbor not in open_set_hash:
    75    110.8 MiB  -8410.8 MiB        7910                       count += 1
    76    110.8 MiB  -8410.9 MiB        7910                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.8 MiB  -8410.9 MiB        7910                       open_set_hash.add(neighbor)
    78                                                             
    79    110.8 MiB  -7971.2 MiB        7371           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.8 MiB  -7971.2 MiB        7371           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.5 MiB    109.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.5 MiB   -455.4 MiB         257       for row in grid:
    30    109.5 MiB -116693.4 MiB       65792           for spot in row:
    31    109.5 MiB -116240.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.1 MiB     -2.4 MiB           1       count = 0
    34    107.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.1 MiB      0.0 MiB           1       came_from = {}
    37    108.5 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.9 MiB -289928.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.9 MiB    -16.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.9 MiB -78884.1 MiB        4712       while not open_set.empty():
    47     93.9 MiB -78885.0 MiB        4712           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.9 MiB -78886.4 MiB        4712           current = open_set.get()[2]
    53     93.9 MiB -78887.2 MiB        4712           open_set_hash.remove(current)
    54                                         
    55     93.9 MiB -78887.6 MiB        4712           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.9 MiB -78888.3 MiB        4712           if current == end:
    60     47.5 MiB    -46.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.9 MiB -709741.8 MiB       42399           for neighbor in current.neighbors:
    65     93.9 MiB -630865.0 MiB       37688               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.9 MiB -315477.7 MiB       18844                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.9 MiB -315396.9 MiB       18844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.9 MiB -630882.3 MiB       37688               if temp_g_score < g_score[neighbor]:
    71     93.9 MiB -84524.3 MiB        5110                   came_from[neighbor] = current
    72     93.9 MiB -84525.8 MiB        5110                   g_score[neighbor] = temp_g_score
    73     93.9 MiB -84528.7 MiB        5110                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.9 MiB -84529.7 MiB        5110                   if neighbor not in open_set_hash:
    75     93.9 MiB -84530.8 MiB        5110                       count += 1
    76     93.9 MiB -84532.7 MiB        5110                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.9 MiB -84533.9 MiB        5110                       open_set_hash.add(neighbor)
    78                                                             
    79     93.9 MiB -78882.5 MiB        4711           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.9 MiB -78883.2 MiB        4711           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     51.5 MiB     51.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     55.9 MiB   -456.0 MiB         257       for row in grid:
    30     55.9 MiB -117099.2 MiB       65792           for spot in row:
    31     55.9 MiB -116636.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     55.9 MiB      0.0 MiB           1       count = 0
    34     56.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     56.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.0 MiB      0.0 MiB           1       came_from = {}
    37     59.7 MiB    -90.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.7 MiB     -0.0 MiB           1       g_score[start] = 0
    39     63.3 MiB  -9874.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.3 MiB  -3701.9 MiB        3100       while not open_set.empty():
    47     63.3 MiB  -3701.9 MiB        3100           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.3 MiB  -3701.9 MiB        3100           current = open_set.get()[2]
    53     63.3 MiB  -3701.9 MiB        3100           open_set_hash.remove(current)
    54                                         
    55     63.3 MiB  -3701.9 MiB        3100           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.3 MiB  -3701.9 MiB        3100           if current == end:
    60     62.3 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.3 MiB -33312.8 MiB       27891           for neighbor in current.neighbors:
    65     63.3 MiB -29610.9 MiB       24792               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.3 MiB -14807.6 MiB       12396                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.3 MiB -14803.3 MiB       12396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.3 MiB -29610.9 MiB       24792               if temp_g_score < g_score[neighbor]:
    71     63.3 MiB  -4097.3 MiB        3446                   came_from[neighbor] = current
    72     63.3 MiB  -4097.3 MiB        3446                   g_score[neighbor] = temp_g_score
    73     63.3 MiB  -4097.3 MiB        3446                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.3 MiB  -4097.3 MiB        3446                   if neighbor not in open_set_hash:
    75     63.3 MiB  -4097.4 MiB        3446                       count += 1
    76     63.3 MiB  -4097.3 MiB        3446                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.3 MiB  -4097.3 MiB        3446                       open_set_hash.add(neighbor)
    78                                                             
    79     63.3 MiB  -3701.9 MiB        3099           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.3 MiB  -3701.9 MiB        3099           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.3 MiB     62.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.3 MiB  -2275.0 MiB         257       for row in grid:
    30     62.3 MiB -584076.7 MiB       65792           for spot in row:
    31     62.3 MiB -581809.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.1 MiB    -10.2 MiB           1       count = 0
    34     52.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.1 MiB      0.0 MiB           1       came_from = {}
    37     56.4 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.2 MiB      4.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.3 MiB      0.0 MiB        1900       while not open_set.empty():
    47     61.3 MiB      0.0 MiB        1900           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.3 MiB      0.0 MiB        1900           current = open_set.get()[2]
    53     61.3 MiB      0.0 MiB        1900           open_set_hash.remove(current)
    54                                         
    55     61.3 MiB      0.0 MiB        1900           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.3 MiB      0.0 MiB        1900           if current == end:
    60     61.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.3 MiB      0.0 MiB       17091           for neighbor in current.neighbors:
    65     61.3 MiB      0.0 MiB       15192               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.3 MiB      0.0 MiB        7596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.3 MiB      0.0 MiB        7596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.3 MiB      0.0 MiB       15192               if temp_g_score < g_score[neighbor]:
    71     61.3 MiB      0.1 MiB        2174                   came_from[neighbor] = current
    72     61.3 MiB      0.0 MiB        2174                   g_score[neighbor] = temp_g_score
    73     61.3 MiB      0.0 MiB        2174                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.3 MiB      0.0 MiB        2174                   if neighbor not in open_set_hash:
    75     61.3 MiB      0.0 MiB        2174                       count += 1
    76     61.3 MiB      0.0 MiB        2174                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.3 MiB      0.0 MiB        2174                       open_set_hash.add(neighbor)
    78                                                             
    79     61.3 MiB      0.0 MiB        1899           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.3 MiB      0.0 MiB        1899           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.3 MiB     61.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.3 MiB   -191.0 MiB         257       for row in grid:
    30     61.3 MiB -48299.5 MiB       65792           for spot in row:
    31     61.3 MiB -48110.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.5 MiB     -3.8 MiB           1       count = 0
    34     57.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.5 MiB      0.0 MiB           1       came_from = {}
    37     60.8 MiB  -1909.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.6 MiB     -0.2 MiB           1       g_score[start] = 0
    39     63.7 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.7 MiB   -133.4 MiB        3570       while not open_set.empty():
    47     63.7 MiB   -133.4 MiB        3570           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.7 MiB   -133.4 MiB        3570           current = open_set.get()[2]
    53     63.7 MiB   -133.4 MiB        3570           open_set_hash.remove(current)
    54                                         
    55     63.7 MiB   -133.4 MiB        3570           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.7 MiB   -133.4 MiB        3570           if current == end:
    60     63.6 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.7 MiB  -1200.3 MiB       32121           for neighbor in current.neighbors:
    65     63.7 MiB  -1066.9 MiB       28552               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.7 MiB   -533.5 MiB       14276                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.7 MiB   -533.4 MiB       14276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.7 MiB  -1066.9 MiB       28552               if temp_g_score < g_score[neighbor]:
    71     63.7 MiB   -144.4 MiB        3906                   came_from[neighbor] = current
    72     63.7 MiB   -144.4 MiB        3906                   g_score[neighbor] = temp_g_score
    73     63.7 MiB   -144.4 MiB        3906                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.7 MiB   -144.4 MiB        3906                   if neighbor not in open_set_hash:
    75     63.7 MiB   -144.4 MiB        3906                       count += 1
    76     63.7 MiB   -144.4 MiB        3906                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.7 MiB   -144.3 MiB        3906                       open_set_hash.add(neighbor)
    78                                                             
    79     63.7 MiB   -133.4 MiB        3569           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.7 MiB   -133.4 MiB        3569           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.7 MiB     63.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.7 MiB   -239.5 MiB         257       for row in grid:
    30     63.7 MiB -61421.8 MiB       65792           for spot in row:
    31     63.7 MiB -61183.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.3 MiB     -1.4 MiB           1       count = 0
    34     62.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.3 MiB      0.0 MiB           1       came_from = {}
    37     66.4 MiB -34023.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.2 MiB     -2.1 MiB           1       g_score[start] = 0
    39     68.5 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.5 MiB      0.0 MiB         336       while not open_set.empty():
    47     68.5 MiB      0.0 MiB         336           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.5 MiB      0.0 MiB         336           current = open_set.get()[2]
    53     68.5 MiB      0.0 MiB         336           open_set_hash.remove(current)
    54                                         
    55     68.5 MiB      0.0 MiB         336           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.5 MiB      0.0 MiB         336           if current == end:
    60     68.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.5 MiB      0.0 MiB        3015           for neighbor in current.neighbors:
    65     68.5 MiB      0.0 MiB        2680               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.5 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.5 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.5 MiB      0.0 MiB        2680               if temp_g_score < g_score[neighbor]:
    71     68.5 MiB      0.0 MiB         450                   came_from[neighbor] = current
    72     68.5 MiB      0.0 MiB         450                   g_score[neighbor] = temp_g_score
    73     68.5 MiB      0.0 MiB         450                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.5 MiB      0.0 MiB         450                   if neighbor not in open_set_hash:
    75     68.5 MiB      0.0 MiB         450                       count += 1
    76     68.5 MiB      0.0 MiB         450                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.5 MiB      0.0 MiB         450                       open_set_hash.add(neighbor)
    78                                                             
    79     68.5 MiB      0.0 MiB         335           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.5 MiB      0.0 MiB         335           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB     -2.5 MiB         257       for row in grid:
    30    106.2 MiB   -633.4 MiB       65792           for spot in row:
    31    106.2 MiB   -630.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.1 MiB     -0.0 MiB           1       count = 0
    34    106.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.1 MiB      0.0 MiB           1       came_from = {}
    37    107.2 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.5 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.5 MiB      0.0 MiB          15       while not open_set.empty():
    47    107.5 MiB      0.0 MiB          15           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.5 MiB      0.0 MiB          15           current = open_set.get()[2]
    53    107.5 MiB      0.0 MiB          15           open_set_hash.remove(current)
    54                                         
    55    107.5 MiB      0.0 MiB          15           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.5 MiB      0.0 MiB          15           if current == end:
    60    107.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.5 MiB      0.0 MiB         126           for neighbor in current.neighbors:
    65    107.5 MiB      0.0 MiB         112               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.5 MiB      0.0 MiB          56                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.5 MiB      0.0 MiB          56                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.5 MiB      0.0 MiB         112               if temp_g_score < g_score[neighbor]:
    71    107.5 MiB      0.0 MiB          39                   came_from[neighbor] = current
    72    107.5 MiB      0.0 MiB          39                   g_score[neighbor] = temp_g_score
    73    107.5 MiB      0.0 MiB          39                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.5 MiB      0.0 MiB          39                   if neighbor not in open_set_hash:
    75    107.5 MiB      0.0 MiB          39                       count += 1
    76    107.5 MiB      0.0 MiB          39                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.5 MiB      0.0 MiB          39                       open_set_hash.add(neighbor)
    78                                                             
    79    107.5 MiB      0.0 MiB          14           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.5 MiB      0.0 MiB          14           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.5 MiB    107.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.5 MiB  -1082.3 MiB         257       for row in grid:
    30    107.5 MiB -277467.3 MiB       65792           for spot in row:
    31    107.5 MiB -276390.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.2 MiB     -6.3 MiB           1       count = 0
    34    101.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.2 MiB      0.0 MiB           1       came_from = {}
    37    101.5 MiB -117326.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.3 MiB     -1.2 MiB           1       g_score[start] = 0
    39    104.2 MiB      3.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.3 MiB      0.0 MiB        1180       while not open_set.empty():
    47    104.3 MiB      0.0 MiB        1180           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.3 MiB      0.0 MiB        1180           current = open_set.get()[2]
    53    104.3 MiB      0.0 MiB        1180           open_set_hash.remove(current)
    54                                         
    55    104.3 MiB      0.0 MiB        1180           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.3 MiB      0.0 MiB        1180           if current == end:
    60    104.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.3 MiB      0.0 MiB       10611           for neighbor in current.neighbors:
    65    104.3 MiB      0.0 MiB        9432               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.3 MiB      0.0 MiB        4716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.3 MiB      0.0 MiB        4716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.3 MiB      0.0 MiB        9432               if temp_g_score < g_score[neighbor]:
    71    104.3 MiB      0.1 MiB        1376                   came_from[neighbor] = current
    72    104.3 MiB      0.0 MiB        1376                   g_score[neighbor] = temp_g_score
    73    104.3 MiB      0.0 MiB        1376                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.3 MiB      0.0 MiB        1376                   if neighbor not in open_set_hash:
    75    104.3 MiB      0.0 MiB        1376                       count += 1
    76    104.3 MiB      0.0 MiB        1376                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.3 MiB      0.0 MiB        1376                       open_set_hash.add(neighbor)
    78                                                             
    79    104.3 MiB      0.0 MiB        1179           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.3 MiB      0.0 MiB        1179           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.3 MiB    104.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.3 MiB   -230.5 MiB         257       for row in grid:
    30    104.3 MiB -58861.8 MiB       65792           for spot in row:
    31    104.3 MiB -58632.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.4 MiB     -2.8 MiB           1       count = 0
    34    101.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.4 MiB      0.0 MiB           1       came_from = {}
    37    104.2 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.9 MiB  -3506.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.9 MiB     -8.6 MiB        4690       while not open_set.empty():
    47    106.9 MiB     -8.6 MiB        4690           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.9 MiB     -8.6 MiB        4690           current = open_set.get()[2]
    53    106.9 MiB     -8.6 MiB        4690           open_set_hash.remove(current)
    54                                         
    55    106.9 MiB     -8.6 MiB        4690           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.9 MiB     -8.6 MiB        4690           if current == end:
    60    106.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.9 MiB    -77.4 MiB       42201           for neighbor in current.neighbors:
    65    106.9 MiB    -68.8 MiB       37512               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.9 MiB    -34.5 MiB       18756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.9 MiB    -34.4 MiB       18756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.9 MiB    -68.9 MiB       37512               if temp_g_score < g_score[neighbor]:
    71    106.9 MiB     -8.8 MiB        5096                   came_from[neighbor] = current
    72    106.9 MiB     -8.9 MiB        5096                   g_score[neighbor] = temp_g_score
    73    106.9 MiB     -8.9 MiB        5096                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.9 MiB     -8.9 MiB        5096                   if neighbor not in open_set_hash:
    75    106.9 MiB     -8.9 MiB        5096                       count += 1
    76    106.9 MiB     -8.9 MiB        5096                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.9 MiB     -8.9 MiB        5096                       open_set_hash.add(neighbor)
    78                                                             
    79    106.9 MiB     -8.6 MiB        4689           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.9 MiB     -8.6 MiB        4689           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.9 MiB    106.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.9 MiB     -5.6 MiB         257       for row in grid:
    30    106.9 MiB  -1407.7 MiB       65792           for spot in row:
    31    106.9 MiB  -1402.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.8 MiB     -0.2 MiB           1       count = 0
    34    106.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.8 MiB      0.0 MiB           1       came_from = {}
    37    110.2 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.4 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.4 MiB  -6947.5 MiB        4410       while not open_set.empty():
    47    111.4 MiB  -6947.5 MiB        4410           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.4 MiB  -6947.5 MiB        4410           current = open_set.get()[2]
    53    111.4 MiB  -6947.5 MiB        4410           open_set_hash.remove(current)
    54                                         
    55    111.4 MiB  -6947.5 MiB        4410           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.4 MiB  -6947.5 MiB        4410           if current == end:
    60    107.6 MiB     -3.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.4 MiB -62502.3 MiB       39681           for neighbor in current.neighbors:
    65    111.4 MiB -55555.1 MiB       35272               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.4 MiB -27778.9 MiB       17636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.4 MiB -27776.5 MiB       17636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.4 MiB -55556.0 MiB       35272               if temp_g_score < g_score[neighbor]:
    71    111.4 MiB  -7395.7 MiB        4784                   came_from[neighbor] = current
    72    111.4 MiB  -7396.3 MiB        4784                   g_score[neighbor] = temp_g_score
    73    111.4 MiB  -7396.9 MiB        4784                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.4 MiB  -7397.3 MiB        4784                   if neighbor not in open_set_hash:
    75    111.4 MiB  -7397.6 MiB        4784                       count += 1
    76    111.4 MiB  -7397.7 MiB        4784                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.4 MiB  -7397.7 MiB        4784                       open_set_hash.add(neighbor)
    78                                                             
    79    111.4 MiB  -6947.5 MiB        4409           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.4 MiB  -6947.5 MiB        4409           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.6 MiB    107.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.6 MiB    -69.4 MiB         257       for row in grid:
    30    107.6 MiB -17765.7 MiB       65792           for spot in row:
    31    107.6 MiB -17696.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.3 MiB     -0.4 MiB           1       count = 0
    34    107.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.3 MiB      0.0 MiB           1       came_from = {}
    37    107.3 MiB -129592.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.8 MiB     -2.5 MiB           1       g_score[start] = 0
    39    108.0 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.0 MiB  -2021.4 MiB        1677       while not open_set.empty():
    47    108.0 MiB  -2021.4 MiB        1677           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.0 MiB  -2021.4 MiB        1677           current = open_set.get()[2]
    53    108.0 MiB  -2021.4 MiB        1677           open_set_hash.remove(current)
    54                                         
    55    108.0 MiB  -2021.4 MiB        1677           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.0 MiB  -2021.4 MiB        1677           if current == end:
    60    106.6 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.0 MiB -18187.3 MiB       15084           for neighbor in current.neighbors:
    65    108.0 MiB -16166.2 MiB       13408               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.0 MiB  -8085.6 MiB        6704                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.0 MiB  -8081.0 MiB        6704                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.0 MiB -16166.8 MiB       13408               if temp_g_score < g_score[neighbor]:
    71    108.0 MiB  -2641.3 MiB        2217                   came_from[neighbor] = current
    72    108.0 MiB  -2641.3 MiB        2217                   g_score[neighbor] = temp_g_score
    73    108.0 MiB  -2641.3 MiB        2217                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.0 MiB  -2641.3 MiB        2217                   if neighbor not in open_set_hash:
    75    108.0 MiB  -2641.3 MiB        2217                       count += 1
    76    108.0 MiB  -2641.3 MiB        2217                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.0 MiB  -2641.3 MiB        2217                       open_set_hash.add(neighbor)
    78                                                             
    79    108.0 MiB  -2021.4 MiB        1676           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.0 MiB  -2021.4 MiB        1676           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.6 MiB    106.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.6 MiB   -523.5 MiB         257       for row in grid:
    30    106.6 MiB -133701.6 MiB       65792           for spot in row:
    31    106.6 MiB -133181.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.9 MiB     -4.7 MiB           1       count = 0
    34    101.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.9 MiB      0.0 MiB           1       came_from = {}
    37    101.9 MiB -45480.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.1 MiB     -0.8 MiB           1       g_score[start] = 0
    39    103.1 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.1 MiB   -236.3 MiB        6298       while not open_set.empty():
    47    103.1 MiB   -236.3 MiB        6298           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.1 MiB   -236.3 MiB        6298           current = open_set.get()[2]
    53    103.1 MiB   -236.3 MiB        6298           open_set_hash.remove(current)
    54                                         
    55    103.1 MiB   -236.3 MiB        6298           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.1 MiB   -236.3 MiB        6298           if current == end:
    60    103.0 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.1 MiB  -2126.2 MiB       56673           for neighbor in current.neighbors:
    65    103.1 MiB  -1889.9 MiB       50376               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.1 MiB   -945.0 MiB       25188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.1 MiB   -944.9 MiB       25188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.1 MiB  -1889.9 MiB       50376               if temp_g_score < g_score[neighbor]:
    71    103.1 MiB   -250.1 MiB        6806                   came_from[neighbor] = current
    72    103.1 MiB   -250.1 MiB        6806                   g_score[neighbor] = temp_g_score
    73    103.1 MiB   -250.2 MiB        6806                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.1 MiB   -250.2 MiB        6806                   if neighbor not in open_set_hash:
    75    103.1 MiB   -250.2 MiB        6806                       count += 1
    76    103.1 MiB   -250.2 MiB        6806                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.1 MiB   -250.1 MiB        6806                       open_set_hash.add(neighbor)
    78                                                             
    79    103.1 MiB   -236.3 MiB        6297           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.1 MiB   -236.3 MiB        6297           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.0 MiB    103.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.0 MiB  -1443.1 MiB         257       for row in grid:
    30    103.0 MiB -369626.2 MiB       65792           for spot in row:
    31    103.0 MiB -368191.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.2 MiB    -11.8 MiB           1       count = 0
    34     91.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.2 MiB      0.0 MiB           1       came_from = {}
    37     91.9 MiB -11593.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     95.6 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     95.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     95.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     95.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     95.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.6 MiB -86722.0 MiB        7705       while not open_set.empty():
    47     95.6 MiB -86722.4 MiB        7705           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.6 MiB -86722.4 MiB        7705           current = open_set.get()[2]
    53     95.6 MiB -86722.4 MiB        7705           open_set_hash.remove(current)
    54                                         
    55     95.6 MiB -86722.4 MiB        7705           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.6 MiB -86722.4 MiB        7705           if current == end:
    60     68.6 MiB    -27.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.6 MiB -780355.0 MiB       69336           for neighbor in current.neighbors:
    65     95.6 MiB -693638.9 MiB       61632               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.6 MiB -346854.1 MiB       30816                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.6 MiB -346788.2 MiB       30816                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.6 MiB -693645.1 MiB       61632               if temp_g_score < g_score[neighbor]:
    71     95.6 MiB -91857.4 MiB        8297                   came_from[neighbor] = current
    72     95.6 MiB -91858.0 MiB        8297                   g_score[neighbor] = temp_g_score
    73     95.6 MiB -91858.9 MiB        8297                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.6 MiB -91859.6 MiB        8297                   if neighbor not in open_set_hash:
    75     95.6 MiB -91860.3 MiB        8297                       count += 1
    76     95.6 MiB -91861.4 MiB        8297                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.6 MiB -91864.4 MiB        8297                       open_set_hash.add(neighbor)
    78                                                             
    79     95.6 MiB -86721.4 MiB        7704           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.6 MiB -86721.4 MiB        7704           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.8 MiB    102.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.8 MiB      0.0 MiB         257       for row in grid:
    30    102.8 MiB      0.0 MiB       65792           for spot in row:
    31    102.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.8 MiB      0.0 MiB           1       count = 0
    34    102.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.8 MiB      0.0 MiB           1       came_from = {}
    37    105.6 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.9 MiB      4.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.0 MiB -19615.8 MiB        7105       while not open_set.empty():
    47    110.0 MiB -19615.8 MiB        7105           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.0 MiB -19615.8 MiB        7105           current = open_set.get()[2]
    53    110.0 MiB -19615.8 MiB        7105           open_set_hash.remove(current)
    54                                         
    55    110.0 MiB -19615.8 MiB        7105           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.0 MiB -19615.8 MiB        7105           if current == end:
    60    104.9 MiB     -5.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.0 MiB -176515.3 MiB       63936           for neighbor in current.neighbors:
    65    110.0 MiB -156900.0 MiB       56832               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.0 MiB -78457.1 MiB       28416                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.0 MiB -78445.6 MiB       28416                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.0 MiB -156903.9 MiB       56832               if temp_g_score < g_score[neighbor]:
    71    110.0 MiB -20644.6 MiB        7589                   came_from[neighbor] = current
    72    110.0 MiB -20644.7 MiB        7589                   g_score[neighbor] = temp_g_score
    73    110.0 MiB -20644.8 MiB        7589                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.0 MiB -20645.0 MiB        7589                   if neighbor not in open_set_hash:
    75    110.0 MiB -20645.0 MiB        7589                       count += 1
    76    110.0 MiB -20645.0 MiB        7589                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.0 MiB -20645.0 MiB        7589                       open_set_hash.add(neighbor)
    78                                                             
    79    110.0 MiB -19615.8 MiB        7104           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.0 MiB -19615.8 MiB        7104           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.9 MiB    104.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.9 MiB   -251.8 MiB         257       for row in grid:
    30    104.9 MiB -64533.3 MiB       65792           for spot in row:
    31    104.9 MiB -64282.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.7 MiB     -1.2 MiB           1       count = 0
    34    103.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.7 MiB      0.0 MiB           1       came_from = {}
    37    106.9 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.7 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.7 MiB -22145.3 MiB        5215       while not open_set.empty():
    47    110.7 MiB -22145.8 MiB        5215           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.7 MiB -22145.9 MiB        5215           current = open_set.get()[2]
    53    110.7 MiB -22146.0 MiB        5215           open_set_hash.remove(current)
    54                                         
    55    110.7 MiB -22146.2 MiB        5215           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.7 MiB -22146.4 MiB        5215           if current == end:
    60    104.1 MiB     -6.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.7 MiB -199277.3 MiB       46926           for neighbor in current.neighbors:
    65    110.7 MiB -177133.6 MiB       41712               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.7 MiB -88572.3 MiB       20856                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.7 MiB -88561.8 MiB       20856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.7 MiB -177134.9 MiB       41712               if temp_g_score < g_score[neighbor]:
    71    110.7 MiB -23614.3 MiB        5651                   came_from[neighbor] = current
    72    110.7 MiB -23614.5 MiB        5651                   g_score[neighbor] = temp_g_score
    73    110.7 MiB -23614.6 MiB        5651                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.7 MiB -23614.6 MiB        5651                   if neighbor not in open_set_hash:
    75    110.7 MiB -23614.7 MiB        5651                       count += 1
    76    110.7 MiB -23615.2 MiB        5651                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.7 MiB -23615.5 MiB        5651                       open_set_hash.add(neighbor)
    78                                                             
    79    110.7 MiB -22144.5 MiB        5214           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.7 MiB -22144.7 MiB        5214           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.1 MiB    104.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.1 MiB      0.0 MiB         257       for row in grid:
    30    104.1 MiB      0.0 MiB       65792           for spot in row:
    31    104.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.1 MiB      0.0 MiB           1       count = 0
    34    104.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.1 MiB      0.0 MiB           1       came_from = {}
    37    107.4 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.3 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.5 MiB    -22.6 MiB        4719       while not open_set.empty():
    47    109.5 MiB    -22.6 MiB        4719           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.5 MiB    -22.6 MiB        4719           current = open_set.get()[2]
    53    109.5 MiB    -22.6 MiB        4719           open_set_hash.remove(current)
    54                                         
    55    109.5 MiB    -22.6 MiB        4719           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.5 MiB    -22.6 MiB        4719           if current == end:
    60    109.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.5 MiB   -203.2 MiB       42462           for neighbor in current.neighbors:
    65    109.5 MiB   -180.6 MiB       37744               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.5 MiB    -90.3 MiB       18872                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.5 MiB    -90.3 MiB       18872                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.5 MiB   -180.6 MiB       37744               if temp_g_score < g_score[neighbor]:
    71    109.5 MiB    -24.9 MiB        5355                   came_from[neighbor] = current
    72    109.5 MiB    -25.1 MiB        5355                   g_score[neighbor] = temp_g_score
    73    109.5 MiB    -25.1 MiB        5355                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.5 MiB    -25.1 MiB        5355                   if neighbor not in open_set_hash:
    75    109.5 MiB    -25.1 MiB        5355                       count += 1
    76    109.5 MiB    -25.1 MiB        5355                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.5 MiB    -25.0 MiB        5355                       open_set_hash.add(neighbor)
    78                                                             
    79    109.5 MiB    -22.6 MiB        4718           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.5 MiB    -22.6 MiB        4718           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.5 MiB    109.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.5 MiB     -2.6 MiB         257       for row in grid:
    30    109.5 MiB   -662.0 MiB       65792           for spot in row:
    31    109.5 MiB   -659.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.5 MiB     -0.0 MiB           1       count = 0
    34    109.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.5 MiB      0.0 MiB           1       came_from = {}
    37    109.8 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.3 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.4 MiB      0.0 MiB        1312       while not open_set.empty():
    47    112.4 MiB      0.0 MiB        1312           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.4 MiB      0.0 MiB        1312           current = open_set.get()[2]
    53    112.4 MiB      0.0 MiB        1312           open_set_hash.remove(current)
    54                                         
    55    112.4 MiB      0.0 MiB        1312           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.4 MiB      0.0 MiB        1312           if current == end:
    60    112.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.4 MiB      0.0 MiB       11799           for neighbor in current.neighbors:
    65    112.4 MiB      0.0 MiB       10488               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.4 MiB      0.0 MiB        5244                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.4 MiB      0.0 MiB        5244                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.4 MiB      0.0 MiB       10488               if temp_g_score < g_score[neighbor]:
    71    112.4 MiB      0.1 MiB        1538                   came_from[neighbor] = current
    72    112.4 MiB      0.0 MiB        1538                   g_score[neighbor] = temp_g_score
    73    112.4 MiB      0.0 MiB        1538                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.4 MiB      0.0 MiB        1538                   if neighbor not in open_set_hash:
    75    112.4 MiB      0.0 MiB        1538                       count += 1
    76    112.4 MiB      0.0 MiB        1538                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.4 MiB      0.0 MiB        1538                       open_set_hash.add(neighbor)
    78                                                             
    79    112.4 MiB      0.0 MiB        1311           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.4 MiB      0.0 MiB        1311           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.4 MiB    112.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.4 MiB      0.0 MiB         257       for row in grid:
    30    112.4 MiB      0.0 MiB       65792           for spot in row:
    31    112.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.4 MiB      0.0 MiB           1       count = 0
    34    112.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.4 MiB      0.0 MiB           1       came_from = {}
    37    112.6 MiB -238978.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.6 MiB     -3.0 MiB           1       g_score[start] = 0
    39    110.9 MiB -90815.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.8 MiB    -17.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.2 MiB   -649.0 MiB        1740       while not open_set.empty():
    47     94.2 MiB   -649.0 MiB        1740           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.2 MiB   -649.0 MiB        1740           current = open_set.get()[2]
    53     94.2 MiB   -649.0 MiB        1740           open_set_hash.remove(current)
    54                                         
    55     94.2 MiB   -649.1 MiB        1740           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.2 MiB   -649.1 MiB        1740           if current == end:
    60     92.7 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.2 MiB  -5832.3 MiB       15651           for neighbor in current.neighbors:
    65     94.2 MiB  -5183.3 MiB       13912               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.2 MiB  -2592.1 MiB        6956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.2 MiB  -2591.5 MiB        6956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.2 MiB  -5184.0 MiB       13912               if temp_g_score < g_score[neighbor]:
    71     94.2 MiB   -728.2 MiB        1974                   came_from[neighbor] = current
    72     94.2 MiB   -728.4 MiB        1974                   g_score[neighbor] = temp_g_score
    73     94.2 MiB   -728.4 MiB        1974                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.2 MiB   -728.5 MiB        1974                   if neighbor not in open_set_hash:
    75     94.2 MiB   -728.6 MiB        1974                       count += 1
    76     94.2 MiB   -728.4 MiB        1974                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.2 MiB   -728.5 MiB        1974                       open_set_hash.add(neighbor)
    78                                                             
    79     94.2 MiB   -649.0 MiB        1739           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.2 MiB   -649.0 MiB        1739           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.4 MiB     95.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.2 MiB   -476.3 MiB         257       for row in grid:
    30     99.2 MiB -120512.1 MiB       65792           for spot in row:
    31     99.2 MiB -120038.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.4 MiB    -13.8 MiB           1       count = 0
    34     85.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     85.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     85.4 MiB      0.0 MiB           1       came_from = {}
    37     86.1 MiB -730976.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.7 MiB    -23.3 MiB           1       g_score[start] = 0
    39     63.0 MiB -69282.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.6 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.6 MiB   -359.8 MiB        2528       while not open_set.empty():
    47     62.6 MiB   -359.8 MiB        2528           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.6 MiB   -359.8 MiB        2528           current = open_set.get()[2]
    53     62.6 MiB   -359.8 MiB        2528           open_set_hash.remove(current)
    54                                         
    55     62.6 MiB   -360.0 MiB        2528           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.6 MiB   -360.0 MiB        2528           if current == end:
    60     62.6 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.6 MiB  -3239.4 MiB       22743           for neighbor in current.neighbors:
    65     62.6 MiB  -2879.6 MiB       20216               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.6 MiB  -1439.7 MiB       10108                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.6 MiB  -1439.9 MiB       10108                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.6 MiB  -2879.6 MiB       20216               if temp_g_score < g_score[neighbor]:
    71     62.6 MiB   -385.2 MiB        2812                   came_from[neighbor] = current
    72     62.6 MiB   -385.2 MiB        2812                   g_score[neighbor] = temp_g_score
    73     62.6 MiB   -385.2 MiB        2812                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.6 MiB   -385.2 MiB        2812                   if neighbor not in open_set_hash:
    75     62.6 MiB   -385.2 MiB        2812                       count += 1
    76     62.6 MiB   -385.2 MiB        2812                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.6 MiB   -385.2 MiB        2812                       open_set_hash.add(neighbor)
    78                                                             
    79     62.6 MiB   -359.8 MiB        2527           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.6 MiB   -359.8 MiB        2527           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.6 MiB     62.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.6 MiB      0.0 MiB         257       for row in grid:
    30     62.6 MiB      0.0 MiB       65792           for spot in row:
    31     62.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.6 MiB      0.0 MiB           1       count = 0
    34     62.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.6 MiB      0.0 MiB           1       came_from = {}
    37     64.4 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.9 MiB  -4360.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.1 MiB     -0.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.2 MiB      0.0 MiB         624       while not open_set.empty():
    47     66.2 MiB      0.0 MiB         624           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.2 MiB      0.0 MiB         624           current = open_set.get()[2]
    53     66.2 MiB      0.0 MiB         624           open_set_hash.remove(current)
    54                                         
    55     66.2 MiB      0.0 MiB         624           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.2 MiB      0.0 MiB         624           if current == end:
    60     66.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.2 MiB      0.0 MiB        5607           for neighbor in current.neighbors:
    65     66.2 MiB      0.0 MiB        4984               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.2 MiB      0.0 MiB        2492                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.2 MiB      0.0 MiB        2492                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.2 MiB      0.0 MiB        4984               if temp_g_score < g_score[neighbor]:
    71     66.2 MiB      0.1 MiB         774                   came_from[neighbor] = current
    72     66.2 MiB      0.0 MiB         774                   g_score[neighbor] = temp_g_score
    73     66.2 MiB      0.0 MiB         774                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.2 MiB      0.0 MiB         774                   if neighbor not in open_set_hash:
    75     66.2 MiB      0.0 MiB         774                       count += 1
    76     66.2 MiB      0.0 MiB         774                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.2 MiB      0.0 MiB         774                       open_set_hash.add(neighbor)
    78                                                             
    79     66.2 MiB      0.0 MiB         623           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.2 MiB      0.0 MiB         623           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.7 MiB    102.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.7 MiB      0.0 MiB         257       for row in grid:
    30    102.7 MiB      0.0 MiB       65792           for spot in row:
    31    102.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.7 MiB      0.0 MiB           1       count = 0
    34    102.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.7 MiB      0.0 MiB           1       came_from = {}
    37    102.9 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.8 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.9 MiB -13462.4 MiB        6622       while not open_set.empty():
    47    104.9 MiB -13464.0 MiB        6622           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.9 MiB -13464.2 MiB        6622           current = open_set.get()[2]
    53    104.9 MiB -13464.2 MiB        6622           open_set_hash.remove(current)
    54                                         
    55    104.9 MiB -13464.2 MiB        6622           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.9 MiB -13464.2 MiB        6622           if current == end:
    60    100.2 MiB     -4.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.9 MiB -121141.5 MiB       59589           for neighbor in current.neighbors:
    65    104.9 MiB -107680.2 MiB       52968               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.9 MiB -53842.0 MiB       26484                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.9 MiB -53838.6 MiB       26484                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.9 MiB -107680.8 MiB       52968               if temp_g_score < g_score[neighbor]:
    71    104.9 MiB -14175.6 MiB        7100                   came_from[neighbor] = current
    72    104.9 MiB -14175.6 MiB        7100                   g_score[neighbor] = temp_g_score
    73    104.9 MiB -14175.6 MiB        7100                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.9 MiB -14175.6 MiB        7100                   if neighbor not in open_set_hash:
    75    104.9 MiB -14175.6 MiB        7100                       count += 1
    76    104.9 MiB -14175.7 MiB        7100                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.9 MiB -14176.0 MiB        7100                       open_set_hash.add(neighbor)
    78                                                             
    79    104.9 MiB -13461.6 MiB        6621           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.9 MiB -13461.9 MiB        6621           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.2 MiB    100.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.2 MiB   -105.0 MiB         257       for row in grid:
    30    100.2 MiB -26847.3 MiB       65792           for spot in row:
    31    100.2 MiB -26743.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.5 MiB     -0.7 MiB           1       count = 0
    34     99.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.5 MiB      0.0 MiB           1       came_from = {}
    37    102.7 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.4 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.5 MiB      0.0 MiB         447       while not open_set.empty():
    47    105.5 MiB      0.0 MiB         447           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.5 MiB      0.0 MiB         447           current = open_set.get()[2]
    53    105.5 MiB      0.0 MiB         447           open_set_hash.remove(current)
    54                                         
    55    105.5 MiB      0.0 MiB         447           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.5 MiB      0.0 MiB         447           if current == end:
    60    105.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.5 MiB      0.0 MiB        4014           for neighbor in current.neighbors:
    65    105.5 MiB      0.0 MiB        3568               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.5 MiB      0.0 MiB        1784                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.5 MiB      0.0 MiB        1784                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.5 MiB      0.0 MiB        3568               if temp_g_score < g_score[neighbor]:
    71    105.5 MiB      0.0 MiB        1047                   came_from[neighbor] = current
    72    105.5 MiB      0.0 MiB        1047                   g_score[neighbor] = temp_g_score
    73    105.5 MiB      0.0 MiB        1047                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.5 MiB      0.0 MiB        1047                   if neighbor not in open_set_hash:
    75    105.5 MiB      0.0 MiB        1047                       count += 1
    76    105.5 MiB      0.0 MiB        1047                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.5 MiB      0.1 MiB        1047                       open_set_hash.add(neighbor)
    78                                                             
    79    105.5 MiB      0.0 MiB         446           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.5 MiB      0.0 MiB         446           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.5 MiB    105.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.5 MiB   -331.0 MiB         257       for row in grid:
    30    105.5 MiB -84758.2 MiB       65792           for spot in row:
    31    105.5 MiB -84428.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.0 MiB     -1.5 MiB           1       count = 0
    34    104.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.0 MiB      0.0 MiB           1       came_from = {}
    37    107.2 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.8 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.8 MiB  -3213.1 MiB        5148       while not open_set.empty():
    47    107.8 MiB  -3213.1 MiB        5148           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.8 MiB  -3213.1 MiB        5148           current = open_set.get()[2]
    53    107.8 MiB  -3213.1 MiB        5148           open_set_hash.remove(current)
    54                                         
    55    107.8 MiB  -3213.1 MiB        5148           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.8 MiB  -3213.1 MiB        5148           if current == end:
    60    106.4 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.8 MiB -28910.9 MiB       46323           for neighbor in current.neighbors:
    65    107.8 MiB -25698.2 MiB       41176               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.8 MiB -12850.5 MiB       20588                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.8 MiB -12848.6 MiB       20588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.8 MiB -25699.1 MiB       41176               if temp_g_score < g_score[neighbor]:
    71    107.8 MiB  -3501.5 MiB        5702                   came_from[neighbor] = current
    72    107.8 MiB  -3501.5 MiB        5702                   g_score[neighbor] = temp_g_score
    73    107.8 MiB  -3501.6 MiB        5702                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.8 MiB  -3501.6 MiB        5702                   if neighbor not in open_set_hash:
    75    107.8 MiB  -3501.6 MiB        5702                       count += 1
    76    107.8 MiB  -3501.6 MiB        5702                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.8 MiB  -3501.6 MiB        5702                       open_set_hash.add(neighbor)
    78                                                             
    79    107.8 MiB  -3213.1 MiB        5147           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.8 MiB  -3213.1 MiB        5147           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.4 MiB    106.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.4 MiB      0.0 MiB         257       for row in grid:
    30    106.4 MiB      0.0 MiB       65792           for spot in row:
    31    106.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.4 MiB      0.0 MiB           1       count = 0
    34    106.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.4 MiB      0.0 MiB           1       came_from = {}
    37    108.9 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.3 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.3 MiB      0.0 MiB        1911       while not open_set.empty():
    47    109.3 MiB      0.0 MiB        1911           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.3 MiB      0.0 MiB        1911           current = open_set.get()[2]
    53    109.3 MiB      0.0 MiB        1911           open_set_hash.remove(current)
    54                                         
    55    109.3 MiB      0.0 MiB        1911           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.3 MiB      0.0 MiB        1911           if current == end:
    60    109.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.3 MiB      0.0 MiB       17190           for neighbor in current.neighbors:
    65    109.3 MiB      0.0 MiB       15280               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.3 MiB      0.0 MiB        7640                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.3 MiB      0.0 MiB        7640                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.3 MiB      0.0 MiB       15280               if temp_g_score < g_score[neighbor]:
    71    109.3 MiB      0.0 MiB        2183                   came_from[neighbor] = current
    72    109.3 MiB      0.0 MiB        2183                   g_score[neighbor] = temp_g_score
    73    109.3 MiB      0.0 MiB        2183                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.3 MiB      0.0 MiB        2183                   if neighbor not in open_set_hash:
    75    109.3 MiB      0.0 MiB        2183                       count += 1
    76    109.3 MiB      0.0 MiB        2183                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.3 MiB      0.0 MiB        2183                       open_set_hash.add(neighbor)
    78                                                             
    79    109.3 MiB      0.0 MiB        1910           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.3 MiB      0.0 MiB        1910           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.3 MiB    109.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.3 MiB      0.0 MiB         257       for row in grid:
    30    109.3 MiB      0.0 MiB       65792           for spot in row:
    31    109.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.3 MiB      0.0 MiB           1       count = 0
    34    109.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.3 MiB      0.0 MiB           1       came_from = {}
    37    111.2 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.3 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.3 MiB -16146.9 MiB        5152       while not open_set.empty():
    47    111.3 MiB -16146.9 MiB        5152           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.3 MiB -16148.6 MiB        5152           current = open_set.get()[2]
    53    111.3 MiB -16148.8 MiB        5152           open_set_hash.remove(current)
    54                                         
    55    111.3 MiB -16149.2 MiB        5152           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.3 MiB -16149.5 MiB        5152           if current == end:
    60    102.1 MiB     -9.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.3 MiB -145299.1 MiB       46359           for neighbor in current.neighbors:
    65    111.3 MiB -129153.2 MiB       41208               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.3 MiB -64582.3 MiB       20604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.3 MiB -64572.7 MiB       20604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.3 MiB -129157.2 MiB       41208               if temp_g_score < g_score[neighbor]:
    71    111.3 MiB -17337.7 MiB        5600                   came_from[neighbor] = current
    72    111.3 MiB -17338.2 MiB        5600                   g_score[neighbor] = temp_g_score
    73    111.3 MiB -17338.3 MiB        5600                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.3 MiB -17338.3 MiB        5600                   if neighbor not in open_set_hash:
    75    111.3 MiB -17338.3 MiB        5600                       count += 1
    76    111.3 MiB -17338.3 MiB        5600                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.3 MiB -17338.3 MiB        5600                       open_set_hash.add(neighbor)
    78                                                             
    79    111.3 MiB -16146.8 MiB        5151           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.3 MiB -16146.9 MiB        5151           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.1 MiB    102.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.1 MiB   -265.1 MiB         257       for row in grid:
    30    102.1 MiB -67908.9 MiB       65792           for spot in row:
    31    102.1 MiB -67644.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.7 MiB     -1.5 MiB           1       count = 0
    34    100.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.7 MiB      0.0 MiB           1       came_from = {}
    37    103.4 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.0 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.0 MiB      0.0 MiB         462       while not open_set.empty():
    47    106.0 MiB      0.0 MiB         462           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.0 MiB      0.0 MiB         462           current = open_set.get()[2]
    53    106.0 MiB      0.0 MiB         462           open_set_hash.remove(current)
    54                                         
    55    106.0 MiB      0.0 MiB         462           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.0 MiB      0.0 MiB         462           if current == end:
    60    106.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.0 MiB      0.0 MiB        4149           for neighbor in current.neighbors:
    65    106.0 MiB      0.0 MiB        3688               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.0 MiB      0.0 MiB        1844                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.0 MiB      0.0 MiB        1844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.0 MiB      0.0 MiB        3688               if temp_g_score < g_score[neighbor]:
    71    106.0 MiB      0.0 MiB         590                   came_from[neighbor] = current
    72    106.0 MiB      0.0 MiB         590                   g_score[neighbor] = temp_g_score
    73    106.0 MiB      0.0 MiB         590                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.0 MiB      0.0 MiB         590                   if neighbor not in open_set_hash:
    75    106.0 MiB      0.0 MiB         590                       count += 1
    76    106.0 MiB      0.0 MiB         590                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.0 MiB      0.0 MiB         590                       open_set_hash.add(neighbor)
    78                                                             
    79    106.0 MiB      0.0 MiB         461           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.0 MiB      0.0 MiB         461           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.0 MiB    106.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.0 MiB  -1011.4 MiB         257       for row in grid:
    30    106.0 MiB -258967.9 MiB       65792           for spot in row:
    31    106.0 MiB -257960.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.2 MiB     -4.8 MiB           1       count = 0
    34    101.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.2 MiB      0.0 MiB           1       came_from = {}
    37    103.6 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.5 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.5 MiB   -352.8 MiB        3698       while not open_set.empty():
    47    105.5 MiB   -352.8 MiB        3698           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.5 MiB   -352.8 MiB        3698           current = open_set.get()[2]
    53    105.5 MiB   -352.8 MiB        3698           open_set_hash.remove(current)
    54                                         
    55    105.5 MiB   -352.8 MiB        3698           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.5 MiB   -352.8 MiB        3698           if current == end:
    60    103.5 MiB     -2.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.5 MiB  -3163.7 MiB       33273           for neighbor in current.neighbors:
    65    105.5 MiB  -2811.4 MiB       29576               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.5 MiB  -1408.5 MiB       14788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.5 MiB  -1403.4 MiB       14788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.5 MiB  -2812.2 MiB       29576               if temp_g_score < g_score[neighbor]:
    71    105.5 MiB   -419.7 MiB        4040                   came_from[neighbor] = current
    72    105.5 MiB   -419.7 MiB        4040                   g_score[neighbor] = temp_g_score
    73    105.5 MiB   -419.7 MiB        4040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.5 MiB   -419.7 MiB        4040                   if neighbor not in open_set_hash:
    75    105.5 MiB   -419.7 MiB        4040                       count += 1
    76    105.5 MiB   -419.7 MiB        4040                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.5 MiB   -419.7 MiB        4040                       open_set_hash.add(neighbor)
    78                                                             
    79    105.5 MiB   -352.8 MiB        3697           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.5 MiB   -352.8 MiB        3697           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.4 MiB    101.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.4 MiB    -17.2 MiB         257       for row in grid:
    30    101.4 MiB  -4414.0 MiB       65792           for spot in row:
    31    101.4 MiB  -4396.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.3 MiB     -0.1 MiB           1       count = 0
    34    101.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.3 MiB      0.0 MiB           1       came_from = {}
    37    104.0 MiB   -604.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.1 MiB      0.0 MiB         352       while not open_set.empty():
    47    104.1 MiB      0.0 MiB         352           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.1 MiB      0.0 MiB         352           current = open_set.get()[2]
    53    104.1 MiB      0.0 MiB         352           open_set_hash.remove(current)
    54                                         
    55    104.1 MiB      0.0 MiB         352           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.1 MiB      0.0 MiB         352           if current == end:
    60    104.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.1 MiB      0.0 MiB        3159           for neighbor in current.neighbors:
    65    104.1 MiB      0.0 MiB        2808               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.1 MiB      0.0 MiB        1404                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.1 MiB      0.0 MiB        1404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.1 MiB      0.0 MiB        2808               if temp_g_score < g_score[neighbor]:
    71    104.1 MiB      0.0 MiB         470                   came_from[neighbor] = current
    72    104.1 MiB      0.0 MiB         470                   g_score[neighbor] = temp_g_score
    73    104.1 MiB      0.0 MiB         470                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.1 MiB      0.0 MiB         470                   if neighbor not in open_set_hash:
    75    104.1 MiB      0.0 MiB         470                       count += 1
    76    104.1 MiB      0.0 MiB         470                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.1 MiB      0.0 MiB         470                       open_set_hash.add(neighbor)
    78                                                             
    79    104.1 MiB      0.0 MiB         351           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.1 MiB      0.0 MiB         351           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.1 MiB    104.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.1 MiB      0.0 MiB         257       for row in grid:
    30    104.1 MiB      0.0 MiB       65792           for spot in row:
    31    104.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.1 MiB      0.0 MiB           1       count = 0
    34    104.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.1 MiB      0.0 MiB           1       came_from = {}
    37    105.4 MiB -26257.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.6 MiB      4.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.7 MiB      0.0 MiB         416       while not open_set.empty():
    47    109.7 MiB      0.0 MiB         416           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.7 MiB      0.0 MiB         416           current = open_set.get()[2]
    53    109.7 MiB      0.0 MiB         416           open_set_hash.remove(current)
    54                                         
    55    109.7 MiB      0.0 MiB         416           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.7 MiB      0.0 MiB         416           if current == end:
    60    109.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.7 MiB      0.0 MiB        3735           for neighbor in current.neighbors:
    65    109.7 MiB      0.0 MiB        3320               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.7 MiB      0.0 MiB        1660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.7 MiB      0.0 MiB        1660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.7 MiB      0.0 MiB        3320               if temp_g_score < g_score[neighbor]:
    71    109.7 MiB      0.0 MiB         638                   came_from[neighbor] = current
    72    109.7 MiB      0.0 MiB         638                   g_score[neighbor] = temp_g_score
    73    109.7 MiB      0.0 MiB         638                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.7 MiB      0.0 MiB         638                   if neighbor not in open_set_hash:
    75    109.7 MiB      0.0 MiB         638                       count += 1
    76    109.7 MiB      0.0 MiB         638                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.7 MiB      0.0 MiB         638                       open_set_hash.add(neighbor)
    78                                                             
    79    109.7 MiB      0.0 MiB         415           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.7 MiB      0.0 MiB         415           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.7 MiB    109.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.7 MiB    -92.8 MiB         257       for row in grid:
    30    109.7 MiB -23709.0 MiB       65792           for spot in row:
    31    109.7 MiB -23616.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.6 MiB     -1.0 MiB           1       count = 0
    34    108.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.6 MiB      0.0 MiB           1       came_from = {}
    37    111.3 MiB -26992.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.7 MiB     -2.6 MiB           1       g_score[start] = 0
    39    110.6 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.6 MiB  -3235.5 MiB        1088       while not open_set.empty():
    47    110.6 MiB  -3235.6 MiB        1088           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.6 MiB  -3236.0 MiB        1088           current = open_set.get()[2]
    53    110.6 MiB  -3236.3 MiB        1088           open_set_hash.remove(current)
    54                                         
    55    110.6 MiB  -3236.6 MiB        1088           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.6 MiB  -3236.6 MiB        1088           if current == end:
    60     92.2 MiB    -18.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.6 MiB -29026.9 MiB        9783           for neighbor in current.neighbors:
    65    110.6 MiB -25793.8 MiB        8696               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.6 MiB -12916.1 MiB        4348                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.6 MiB -12879.8 MiB        4348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.6 MiB -25801.5 MiB        8696               if temp_g_score < g_score[neighbor]:
    71    110.6 MiB  -4004.4 MiB        1390                   came_from[neighbor] = current
    72    110.6 MiB  -4004.6 MiB        1390                   g_score[neighbor] = temp_g_score
    73    110.6 MiB  -4005.0 MiB        1390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.6 MiB  -4005.3 MiB        1390                   if neighbor not in open_set_hash:
    75    110.6 MiB  -4005.3 MiB        1390                       count += 1
    76    110.6 MiB  -4005.5 MiB        1390                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.6 MiB  -4005.7 MiB        1390                       open_set_hash.add(neighbor)
    78                                                             
    79    110.6 MiB  -3235.2 MiB        1087           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.6 MiB  -3235.3 MiB        1087           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.2 MiB     92.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.2 MiB      0.0 MiB         257       for row in grid:
    30     92.2 MiB      0.0 MiB       65792           for spot in row:
    31     92.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.2 MiB      0.0 MiB           1       count = 0
    34     92.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.2 MiB      0.0 MiB           1       came_from = {}
    37     93.2 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     93.7 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.7 MiB -68391.0 MiB        6237       while not open_set.empty():
    47     93.7 MiB -68391.0 MiB        6237           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.7 MiB -68391.1 MiB        6237           current = open_set.get()[2]
    53     93.7 MiB -68391.1 MiB        6237           open_set_hash.remove(current)
    54                                         
    55     93.7 MiB -68391.1 MiB        6237           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.7 MiB -68391.1 MiB        6237           if current == end:
    60     81.7 MiB    -12.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     81.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.7 MiB -615477.8 MiB       56124           for neighbor in current.neighbors:
    65     93.7 MiB -547088.7 MiB       49888               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.7 MiB -273562.7 MiB       24944                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.7 MiB -273532.2 MiB       24944                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.7 MiB -547097.4 MiB       49888               if temp_g_score < g_score[neighbor]:
    71     93.7 MiB -72497.1 MiB        6713                   came_from[neighbor] = current
    72     93.7 MiB -72497.2 MiB        6713                   g_score[neighbor] = temp_g_score
    73     93.7 MiB -72497.2 MiB        6713                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.7 MiB -72497.2 MiB        6713                   if neighbor not in open_set_hash:
    75     93.7 MiB -72497.2 MiB        6713                       count += 1
    76     93.7 MiB -72497.3 MiB        6713                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.7 MiB -72497.3 MiB        6713                       open_set_hash.add(neighbor)
    78                                                             
    79     93.7 MiB -68390.9 MiB        6236           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.7 MiB -68391.0 MiB        6236           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     81.7 MiB     81.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     81.7 MiB  -1155.4 MiB         257       for row in grid:
    30     81.7 MiB -296215.5 MiB       65792           for spot in row:
    31     81.7 MiB -295066.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.4 MiB    -10.3 MiB           1       count = 0
    34     71.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.4 MiB      0.0 MiB           1       came_from = {}
    37     73.3 MiB      1.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     73.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.6 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.7 MiB -14889.1 MiB        6032       while not open_set.empty():
    47     75.7 MiB -14889.1 MiB        6032           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.7 MiB -14889.7 MiB        6032           current = open_set.get()[2]
    53     75.7 MiB -14890.1 MiB        6032           open_set_hash.remove(current)
    54                                         
    55     75.7 MiB -14890.1 MiB        6032           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.7 MiB -14890.1 MiB        6032           if current == end:
    60     71.9 MiB     -3.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.7 MiB -133989.3 MiB       54279           for neighbor in current.neighbors:
    65     75.7 MiB -119100.5 MiB       48248               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.7 MiB -59554.8 MiB       24124                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.7 MiB -59547.0 MiB       24124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.7 MiB -119102.7 MiB       48248               if temp_g_score < g_score[neighbor]:
    71     75.7 MiB -15903.4 MiB        6562                   came_from[neighbor] = current
    72     75.7 MiB -15903.5 MiB        6562                   g_score[neighbor] = temp_g_score
    73     75.7 MiB -15903.5 MiB        6562                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.7 MiB -15903.5 MiB        6562                   if neighbor not in open_set_hash:
    75     75.7 MiB -15903.5 MiB        6562                       count += 1
    76     75.7 MiB -15903.5 MiB        6562                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.7 MiB -15903.5 MiB        6562                       open_set_hash.add(neighbor)
    78                                                             
    79     75.7 MiB -14889.1 MiB        6031           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.7 MiB -14889.1 MiB        6031           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     72.0 MiB     72.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     72.0 MiB      0.0 MiB         257       for row in grid:
    30     72.0 MiB      0.0 MiB       65792           for spot in row:
    31     72.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.0 MiB      0.0 MiB           1       count = 0
    34     72.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.0 MiB      0.0 MiB           1       came_from = {}
    37     73.9 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     73.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.9 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.9 MiB  -9474.7 MiB        3339       while not open_set.empty():
    47     75.9 MiB  -9474.9 MiB        3339           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.9 MiB  -9475.5 MiB        3339           current = open_set.get()[2]
    53     75.9 MiB  -9475.5 MiB        3339           open_set_hash.remove(current)
    54                                         
    55     75.9 MiB  -9475.6 MiB        3339           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.9 MiB  -9475.9 MiB        3339           if current == end:
    60     72.9 MiB     -3.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.9 MiB -85258.7 MiB       30042           for neighbor in current.neighbors:
    65     75.9 MiB -75784.8 MiB       26704               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.9 MiB -37892.6 MiB       13352                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.9 MiB -37892.4 MiB       13352                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.9 MiB -75785.3 MiB       26704               if temp_g_score < g_score[neighbor]:
    71     75.9 MiB -10465.3 MiB        3739                   came_from[neighbor] = current
    72     75.9 MiB -10465.3 MiB        3739                   g_score[neighbor] = temp_g_score
    73     75.9 MiB -10465.3 MiB        3739                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.9 MiB -10465.3 MiB        3739                   if neighbor not in open_set_hash:
    75     75.9 MiB -10465.3 MiB        3739                       count += 1
    76     75.9 MiB -10465.3 MiB        3739                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.9 MiB -10465.3 MiB        3739                       open_set_hash.add(neighbor)
    78                                                             
    79     75.9 MiB  -9474.3 MiB        3338           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.9 MiB  -9474.5 MiB        3338           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     72.9 MiB      0.0 MiB         257       for row in grid:
    30     72.9 MiB      0.0 MiB       65792           for spot in row:
    31     72.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.9 MiB      0.0 MiB           1       count = 0
    34     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.9 MiB      0.0 MiB           1       came_from = {}
    37     74.7 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.4 MiB  -6676.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.8 MiB  -1526.9 MiB        7830       while not open_set.empty():
    47     75.8 MiB  -1526.9 MiB        7830           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.8 MiB  -1526.9 MiB        7830           current = open_set.get()[2]
    53     75.8 MiB  -1526.9 MiB        7830           open_set_hash.remove(current)
    54                                         
    55     75.8 MiB  -1526.9 MiB        7830           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.8 MiB  -1526.9 MiB        7830           if current == end:
    60     75.1 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.8 MiB -13740.3 MiB       70461           for neighbor in current.neighbors:
    65     75.8 MiB -12213.4 MiB       62632               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.8 MiB  -6107.0 MiB       31316                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.8 MiB  -6106.5 MiB       31316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.8 MiB -12213.8 MiB       62632               if temp_g_score < g_score[neighbor]:
    71     75.8 MiB  -1630.7 MiB        8484                   came_from[neighbor] = current
    72     75.8 MiB  -1631.1 MiB        8484                   g_score[neighbor] = temp_g_score
    73     75.8 MiB  -1631.1 MiB        8484                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.8 MiB  -1631.1 MiB        8484                   if neighbor not in open_set_hash:
    75     75.8 MiB  -1631.1 MiB        8484                       count += 1
    76     75.8 MiB  -1631.1 MiB        8484                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.8 MiB  -1631.2 MiB        8484                       open_set_hash.add(neighbor)
    78                                                             
    79     75.8 MiB  -1526.9 MiB        7829           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.8 MiB  -1526.9 MiB        7829           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.4 MiB    110.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.4 MiB   -148.0 MiB         257       for row in grid:
    30    110.4 MiB -37897.1 MiB       65792           for spot in row:
    31    110.4 MiB -37749.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.8 MiB     -0.6 MiB           1       count = 0
    34    109.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.8 MiB      0.0 MiB           1       came_from = {}
    37    113.4 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.2 MiB -18420.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.4 MiB     -1.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.4 MiB      0.0 MiB        1768       while not open_set.empty():
    47    115.4 MiB      0.0 MiB        1768           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.4 MiB      0.0 MiB        1768           current = open_set.get()[2]
    53    115.4 MiB      0.0 MiB        1768           open_set_hash.remove(current)
    54                                         
    55    115.4 MiB      0.0 MiB        1768           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.4 MiB      0.0 MiB        1768           if current == end:
    60    115.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.4 MiB      0.0 MiB       15903           for neighbor in current.neighbors:
    65    115.4 MiB      0.0 MiB       14136               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.4 MiB      0.0 MiB        7068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.4 MiB      0.0 MiB        7068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.4 MiB      0.0 MiB       14136               if temp_g_score < g_score[neighbor]:
    71    115.4 MiB      0.1 MiB        2090                   came_from[neighbor] = current
    72    115.4 MiB      0.0 MiB        2090                   g_score[neighbor] = temp_g_score
    73    115.4 MiB      0.0 MiB        2090                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.4 MiB      0.0 MiB        2090                   if neighbor not in open_set_hash:
    75    115.4 MiB      0.0 MiB        2090                       count += 1
    76    115.4 MiB      0.0 MiB        2090                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.4 MiB      0.0 MiB        2090                       open_set_hash.add(neighbor)
    78                                                             
    79    115.4 MiB      0.0 MiB        1767           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.4 MiB      0.0 MiB        1767           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.4 MiB    115.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.4 MiB      0.0 MiB         257       for row in grid:
    30    115.4 MiB      0.0 MiB       65792           for spot in row:
    31    115.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.4 MiB      0.0 MiB           1       count = 0
    34    115.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.4 MiB      0.0 MiB           1       came_from = {}
    37    117.0 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    117.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.9 MiB -17077.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.4 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.4 MiB  -2732.6 MiB         720       while not open_set.empty():
    47    117.4 MiB  -2732.6 MiB         720           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.4 MiB  -2732.7 MiB         720           current = open_set.get()[2]
    53    117.4 MiB  -2732.7 MiB         720           open_set_hash.remove(current)
    54                                         
    55    117.4 MiB  -2732.7 MiB         720           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.4 MiB  -2732.7 MiB         720           if current == end:
    60    110.7 MiB     -6.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.4 MiB -24563.6 MiB        6471           for neighbor in current.neighbors:
    65    117.4 MiB -21832.1 MiB        5752               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.4 MiB -10924.2 MiB        2876                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.4 MiB -10910.1 MiB        2876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.4 MiB -21836.4 MiB        5752               if temp_g_score < g_score[neighbor]:
    71    117.4 MiB  -3834.9 MiB        1026                   came_from[neighbor] = current
    72    117.4 MiB  -3834.9 MiB        1026                   g_score[neighbor] = temp_g_score
    73    117.4 MiB  -3834.9 MiB        1026                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.4 MiB  -3834.9 MiB        1026                   if neighbor not in open_set_hash:
    75    117.4 MiB  -3834.9 MiB        1026                       count += 1
    76    117.4 MiB  -3834.9 MiB        1026                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.4 MiB  -3834.9 MiB        1026                       open_set_hash.add(neighbor)
    78                                                             
    79    117.4 MiB  -2732.6 MiB         719           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.4 MiB  -2732.6 MiB         719           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.7 MiB    110.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.7 MiB   -357.7 MiB         257       for row in grid:
    30    110.7 MiB -91626.9 MiB       65792           for spot in row:
    31    110.7 MiB -91270.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.0 MiB     -3.8 MiB           1       count = 0
    34    107.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.0 MiB      0.0 MiB           1       came_from = {}
    37    109.3 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.4 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.4 MiB   -782.2 MiB        2346       while not open_set.empty():
    47    112.4 MiB   -782.2 MiB        2346           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.4 MiB   -782.2 MiB        2346           current = open_set.get()[2]
    53    112.4 MiB   -782.2 MiB        2346           open_set_hash.remove(current)
    54                                         
    55    112.4 MiB   -782.2 MiB        2346           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.4 MiB   -782.2 MiB        2346           if current == end:
    60    109.2 MiB     -3.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.4 MiB  -7026.8 MiB       21105           for neighbor in current.neighbors:
    65    112.4 MiB  -6245.0 MiB       18760               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.4 MiB  -3126.7 MiB        9380                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.4 MiB  -3120.2 MiB        9380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.4 MiB  -6246.9 MiB       18760               if temp_g_score < g_score[neighbor]:
    71    112.4 MiB   -910.0 MiB        2640                   came_from[neighbor] = current
    72    112.4 MiB   -910.2 MiB        2640                   g_score[neighbor] = temp_g_score
    73    112.4 MiB   -910.5 MiB        2640                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.4 MiB   -910.9 MiB        2640                   if neighbor not in open_set_hash:
    75    112.4 MiB   -910.9 MiB        2640                       count += 1
    76    112.4 MiB   -910.9 MiB        2640                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.4 MiB   -910.9 MiB        2640                       open_set_hash.add(neighbor)
    78                                                             
    79    112.4 MiB   -782.2 MiB        2345           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.4 MiB   -782.2 MiB        2345           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.2 MiB    109.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.2 MiB      0.0 MiB         257       for row in grid:
    30    109.2 MiB      0.0 MiB       65792           for spot in row:
    31    109.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.2 MiB      0.0 MiB           1       count = 0
    34    109.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.2 MiB      0.0 MiB           1       came_from = {}
    37    109.3 MiB -418944.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.2 MiB     -7.1 MiB           1       g_score[start] = 0
    39    102.2 MiB -209794.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.6 MiB     -2.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.7 MiB      0.0 MiB        3149       while not open_set.empty():
    47     99.7 MiB      0.0 MiB        3149           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.7 MiB      0.0 MiB        3149           current = open_set.get()[2]
    53     99.7 MiB      0.0 MiB        3149           open_set_hash.remove(current)
    54                                         
    55     99.7 MiB      0.0 MiB        3149           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.7 MiB      0.0 MiB        3149           if current == end:
    60     99.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.7 MiB      0.0 MiB       28332           for neighbor in current.neighbors:
    65     99.7 MiB      0.0 MiB       25184               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.7 MiB      0.0 MiB       12592                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.7 MiB      0.0 MiB       12592                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.7 MiB      0.0 MiB       25184               if temp_g_score < g_score[neighbor]:
    71     99.7 MiB      0.0 MiB        3509                   came_from[neighbor] = current
    72     99.7 MiB      0.0 MiB        3509                   g_score[neighbor] = temp_g_score
    73     99.7 MiB      0.0 MiB        3509                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.7 MiB      0.0 MiB        3509                   if neighbor not in open_set_hash:
    75     99.7 MiB      0.0 MiB        3509                       count += 1
    76     99.7 MiB      0.0 MiB        3509                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.7 MiB      0.0 MiB        3509                       open_set_hash.add(neighbor)
    78                                                             
    79     99.7 MiB      0.0 MiB        3148           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.7 MiB      0.0 MiB        3148           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.7 MiB     99.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.7 MiB    -89.5 MiB         257       for row in grid:
    30     99.7 MiB -22256.8 MiB       65792           for spot in row:
    31     99.7 MiB -22169.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.7 MiB     -3.0 MiB           1       count = 0
    34     96.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.7 MiB      0.0 MiB           1       came_from = {}
    37    100.0 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.8 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.9 MiB      0.0 MiB         810       while not open_set.empty():
    47    102.9 MiB      0.0 MiB         810           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.9 MiB      0.0 MiB         810           current = open_set.get()[2]
    53    102.9 MiB      0.0 MiB         810           open_set_hash.remove(current)
    54                                         
    55    102.9 MiB      0.0 MiB         810           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.9 MiB      0.0 MiB         810           if current == end:
    60    102.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.9 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.9 MiB      0.0 MiB        7281           for neighbor in current.neighbors:
    65    102.9 MiB      0.0 MiB        6472               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.9 MiB      0.0 MiB        3236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.9 MiB      0.0 MiB        3236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.9 MiB      0.0 MiB        6472               if temp_g_score < g_score[neighbor]:
    71    102.9 MiB      0.0 MiB        1186                   came_from[neighbor] = current
    72    102.9 MiB      0.0 MiB        1186                   g_score[neighbor] = temp_g_score
    73    102.9 MiB      0.0 MiB        1186                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.9 MiB      0.0 MiB        1186                   if neighbor not in open_set_hash:
    75    102.9 MiB      0.0 MiB        1186                       count += 1
    76    102.9 MiB      0.0 MiB        1186                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.9 MiB      0.0 MiB        1186                       open_set_hash.add(neighbor)
    78                                                             
    79    102.9 MiB      0.0 MiB         809           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.9 MiB      0.0 MiB         809           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.9 MiB    102.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.9 MiB   -253.1 MiB         257       for row in grid:
    30    102.9 MiB -64911.2 MiB       65792           for spot in row:
    31    102.9 MiB -64660.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.5 MiB     -3.4 MiB           1       count = 0
    34     99.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.6 MiB      0.0 MiB           1       came_from = {}
    37     99.7 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.0 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.1 MiB -19385.6 MiB        8148       while not open_set.empty():
    47    103.1 MiB -19385.6 MiB        8148           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.1 MiB -19385.6 MiB        8148           current = open_set.get()[2]
    53    103.1 MiB -19385.6 MiB        8148           open_set_hash.remove(current)
    54                                         
    55    103.1 MiB -19385.6 MiB        8148           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.1 MiB -19385.6 MiB        8148           if current == end:
    60     99.5 MiB     -3.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.1 MiB -174447.2 MiB       73323           for neighbor in current.neighbors:
    65    103.1 MiB -155062.8 MiB       65176               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.1 MiB -77535.1 MiB       32588                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.1 MiB -77528.2 MiB       32588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.1 MiB -155063.5 MiB       65176               if temp_g_score < g_score[neighbor]:
    71    103.1 MiB -20299.0 MiB        8702                   came_from[neighbor] = current
    72    103.1 MiB -20299.0 MiB        8702                   g_score[neighbor] = temp_g_score
    73    103.1 MiB -20299.0 MiB        8702                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.1 MiB -20299.2 MiB        8702                   if neighbor not in open_set_hash:
    75    103.1 MiB -20299.8 MiB        8702                       count += 1
    76    103.1 MiB -20300.5 MiB        8702                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.1 MiB -20300.5 MiB        8702                       open_set_hash.add(neighbor)
    78                                                             
    79    103.1 MiB -19385.6 MiB        8147           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.1 MiB -19385.6 MiB        8147           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.5 MiB     99.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.5 MiB      0.0 MiB         257       for row in grid:
    30     99.5 MiB      0.0 MiB       65792           for spot in row:
    31     99.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.5 MiB      0.0 MiB           1       count = 0
    34     99.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.5 MiB      0.0 MiB           1       came_from = {}
    37     99.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.7 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.7 MiB      0.0 MiB         784       while not open_set.empty():
    47    101.7 MiB      0.0 MiB         784           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.7 MiB      0.0 MiB         784           current = open_set.get()[2]
    53    101.7 MiB      0.0 MiB         784           open_set_hash.remove(current)
    54                                         
    55    101.7 MiB      0.0 MiB         784           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.7 MiB      0.0 MiB         784           if current == end:
    60    101.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.7 MiB      0.0 MiB        7047           for neighbor in current.neighbors:
    65    101.7 MiB      0.0 MiB        6264               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.7 MiB      0.0 MiB        3132                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.7 MiB      0.0 MiB        3132                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.7 MiB      0.0 MiB        6264               if temp_g_score < g_score[neighbor]:
    71    101.7 MiB      0.0 MiB        1010                   came_from[neighbor] = current
    72    101.7 MiB      0.0 MiB        1010                   g_score[neighbor] = temp_g_score
    73    101.7 MiB      0.0 MiB        1010                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.7 MiB      0.0 MiB        1010                   if neighbor not in open_set_hash:
    75    101.7 MiB      0.0 MiB        1010                       count += 1
    76    101.7 MiB      0.0 MiB        1010                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.7 MiB      0.0 MiB        1010                       open_set_hash.add(neighbor)
    78                                                             
    79    101.7 MiB      0.0 MiB         783           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.7 MiB      0.0 MiB         783           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    117.5 MiB    117.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    117.5 MiB -11958.7 MiB         257       for row in grid:
    30    117.5 MiB -3065209.3 MiB       65792           for spot in row:
    31    117.5 MiB -3053280.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.8 MiB    -52.7 MiB           1       count = 0
    34     65.1 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     65.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     65.3 MiB      0.0 MiB           1       came_from = {}
    37     71.1 MiB      5.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.4 MiB -58545.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.8 MiB     -2.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.4 MiB      0.0 MiB         819       while not open_set.empty():
    47     72.4 MiB      0.0 MiB         819           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.4 MiB      0.0 MiB         819           current = open_set.get()[2]
    53     72.4 MiB      0.0 MiB         819           open_set_hash.remove(current)
    54                                         
    55     72.4 MiB      0.0 MiB         819           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.4 MiB      0.0 MiB         819           if current == end:
    60     72.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.4 MiB      0.1 MiB        7362           for neighbor in current.neighbors:
    65     72.4 MiB      0.3 MiB        6544               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.4 MiB      0.0 MiB        3272                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.4 MiB      0.0 MiB        3272                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.4 MiB      0.0 MiB        6544               if temp_g_score < g_score[neighbor]:
    71     72.4 MiB      0.0 MiB        1035                   came_from[neighbor] = current
    72     72.4 MiB      0.0 MiB        1035                   g_score[neighbor] = temp_g_score
    73     72.4 MiB      0.0 MiB        1035                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.4 MiB      0.0 MiB        1035                   if neighbor not in open_set_hash:
    75     72.4 MiB      0.0 MiB        1035                       count += 1
    76     72.4 MiB      0.1 MiB        1035                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.4 MiB      0.0 MiB        1035                       open_set_hash.add(neighbor)
    78                                                             
    79     72.4 MiB      0.0 MiB         818           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.4 MiB      0.0 MiB         818           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.8 MiB     74.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.8 MiB  -3808.3 MiB         257       for row in grid:
    30     76.8 MiB -974514.7 MiB       65792           for spot in row:
    31     76.8 MiB -970719.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     49.5 MiB    -27.3 MiB           1       count = 0
    34     49.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     49.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     49.5 MiB      0.0 MiB           1       came_from = {}
    37     56.0 MiB      6.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.0 MiB  -1149.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.1 MiB      0.0 MiB          40       while not open_set.empty():
    47     61.1 MiB      0.0 MiB          40           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.1 MiB      0.0 MiB          40           current = open_set.get()[2]
    53     61.1 MiB      0.0 MiB          40           open_set_hash.remove(current)
    54                                         
    55     61.1 MiB      0.0 MiB          40           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.1 MiB      0.0 MiB          40           if current == end:
    60     61.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.1 MiB      0.0 MiB         351           for neighbor in current.neighbors:
    65     61.1 MiB      0.0 MiB         312               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.1 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.1 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.1 MiB      0.0 MiB         312               if temp_g_score < g_score[neighbor]:
    71     61.1 MiB      0.0 MiB          86                   came_from[neighbor] = current
    72     61.1 MiB      0.0 MiB          86                   g_score[neighbor] = temp_g_score
    73     61.1 MiB      0.0 MiB          86                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.1 MiB      0.0 MiB          86                   if neighbor not in open_set_hash:
    75     61.1 MiB      0.0 MiB          86                       count += 1
    76     61.1 MiB      0.0 MiB          86                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.1 MiB      0.0 MiB          86                       open_set_hash.add(neighbor)
    78                                                             
    79     61.1 MiB      0.0 MiB          39           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.1 MiB      0.0 MiB          39           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.2 MiB     61.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.7 MiB      0.0 MiB         257       for row in grid:
    30     61.7 MiB      0.0 MiB       65792           for spot in row:
    31     61.7 MiB      0.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.7 MiB      0.0 MiB           1       count = 0
    34     61.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.7 MiB      0.0 MiB           1       came_from = {}
    37     64.7 MiB -70123.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.1 MiB     -7.5 MiB           1       g_score[start] = 0
    39     57.4 MiB -793464.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     38.1 MiB    -19.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     38.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     38.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     38.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     40.4 MiB     -1.2 MiB         324       while not open_set.empty():
    47     40.4 MiB     -1.3 MiB         324           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     40.4 MiB     -1.1 MiB         324           current = open_set.get()[2]
    53     40.4 MiB     -1.4 MiB         324           open_set_hash.remove(current)
    54                                         
    55     40.4 MiB     -1.4 MiB         324           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     40.4 MiB     -1.4 MiB         324           if current == end:
    60     40.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     40.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     40.4 MiB    -11.2 MiB        2907           for neighbor in current.neighbors:
    65     40.4 MiB     -9.3 MiB        2584               if current.row != neighbor.row and current.col != neighbor.col:
    66     40.4 MiB     -5.2 MiB        1292                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     40.4 MiB     -5.1 MiB        1292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     40.4 MiB    -10.4 MiB        2584               if temp_g_score < g_score[neighbor]:
    71     40.4 MiB     -1.7 MiB         430                   came_from[neighbor] = current
    72     40.4 MiB     -1.8 MiB         430                   g_score[neighbor] = temp_g_score
    73     40.4 MiB     -1.8 MiB         430                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     40.4 MiB     -1.8 MiB         430                   if neighbor not in open_set_hash:
    75     40.4 MiB     -1.8 MiB         430                       count += 1
    76     40.4 MiB     -1.6 MiB         430                       open_set.put((f_score[neighbor], count, neighbor))
    77     40.4 MiB     -1.8 MiB         430                       open_set_hash.add(neighbor)
    78                                                             
    79     40.4 MiB     -1.3 MiB         323           if draw is not None:
    80                                                     draw()
    81                                         
    82     40.4 MiB     -1.3 MiB         323           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     43.4 MiB     43.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     59.1 MiB    -73.4 MiB         257       for row in grid:
    30     59.1 MiB -18722.2 MiB       65792           for spot in row:
    31     59.1 MiB -18632.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.1 MiB      0.0 MiB           1       count = 0
    34     59.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.1 MiB      0.0 MiB           1       came_from = {}
    37     61.1 MiB  -4642.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.2 MiB     -0.9 MiB           1       g_score[start] = 0
    39     63.3 MiB  -9120.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.5 MiB      0.0 MiB         407       while not open_set.empty():
    47     63.5 MiB      0.0 MiB         407           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.5 MiB      0.0 MiB         407           current = open_set.get()[2]
    53     63.5 MiB      0.0 MiB         407           open_set_hash.remove(current)
    54                                         
    55     63.5 MiB      0.0 MiB         407           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.5 MiB      0.0 MiB         407           if current == end:
    60     63.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.5 MiB      0.0 MiB        3654           for neighbor in current.neighbors:
    65     63.5 MiB      0.0 MiB        3248               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.5 MiB      0.0 MiB        1624                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.5 MiB      0.0 MiB        1624                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.5 MiB      0.0 MiB        3248               if temp_g_score < g_score[neighbor]:
    71     63.5 MiB      0.0 MiB         575                   came_from[neighbor] = current
    72     63.5 MiB      0.0 MiB         575                   g_score[neighbor] = temp_g_score
    73     63.5 MiB      0.0 MiB         575                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.5 MiB      0.0 MiB         575                   if neighbor not in open_set_hash:
    75     63.5 MiB      0.0 MiB         575                       count += 1
    76     63.5 MiB      0.0 MiB         575                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.5 MiB      0.0 MiB         575                       open_set_hash.add(neighbor)
    78                                                             
    79     63.5 MiB      0.0 MiB         406           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.5 MiB      0.0 MiB         406           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.5 MiB     63.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.5 MiB     -9.9 MiB         257       for row in grid:
    30     63.5 MiB  -2530.8 MiB       65792           for spot in row:
    31     63.5 MiB  -2520.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.4 MiB     -0.1 MiB           1       count = 0
    34     63.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.4 MiB      0.0 MiB           1       came_from = {}
    37     63.6 MiB      0.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.1 MiB    -93.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.1 MiB      0.0 MiB         152       while not open_set.empty():
    47     68.1 MiB      0.0 MiB         152           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.1 MiB      0.0 MiB         152           current = open_set.get()[2]
    53     68.1 MiB      0.0 MiB         152           open_set_hash.remove(current)
    54                                         
    55     68.1 MiB      0.0 MiB         152           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.1 MiB      0.0 MiB         152           if current == end:
    60     68.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.1 MiB      0.0 MiB        1359           for neighbor in current.neighbors:
    65     68.1 MiB      0.0 MiB        1208               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.1 MiB      0.0 MiB         604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.1 MiB      0.0 MiB         604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.1 MiB      0.0 MiB        1208               if temp_g_score < g_score[neighbor]:
    71     68.1 MiB      0.0 MiB         242                   came_from[neighbor] = current
    72     68.1 MiB      0.0 MiB         242                   g_score[neighbor] = temp_g_score
    73     68.1 MiB      0.0 MiB         242                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.1 MiB      0.0 MiB         242                   if neighbor not in open_set_hash:
    75     68.1 MiB      0.0 MiB         242                       count += 1
    76     68.1 MiB      0.0 MiB         242                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.1 MiB      0.0 MiB         242                       open_set_hash.add(neighbor)
    78                                                             
    79     68.1 MiB      0.0 MiB         151           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.1 MiB      0.0 MiB         151           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     68.1 MiB     68.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.1 MiB      0.0 MiB         257       for row in grid:
    30     68.1 MiB      0.0 MiB       65792           for spot in row:
    31     68.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     68.1 MiB      0.0 MiB           1       count = 0
    34     68.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     68.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     68.1 MiB      0.0 MiB           1       came_from = {}
    37     70.9 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     72.3 MiB -16069.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.8 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.8 MiB      0.0 MiB         768       while not open_set.empty():
    47     71.8 MiB      0.0 MiB         768           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.8 MiB      0.0 MiB         768           current = open_set.get()[2]
    53     71.8 MiB      0.0 MiB         768           open_set_hash.remove(current)
    54                                         
    55     71.8 MiB      0.0 MiB         768           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.8 MiB      0.0 MiB         768           if current == end:
    60     71.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.8 MiB      0.0 MiB        6903           for neighbor in current.neighbors:
    65     71.8 MiB      0.0 MiB        6136               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.8 MiB      0.0 MiB        3068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.8 MiB      0.0 MiB        3068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.8 MiB      0.0 MiB        6136               if temp_g_score < g_score[neighbor]:
    71     71.8 MiB      0.0 MiB         942                   came_from[neighbor] = current
    72     71.8 MiB      0.0 MiB         942                   g_score[neighbor] = temp_g_score
    73     71.8 MiB      0.0 MiB         942                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.8 MiB      0.0 MiB         942                   if neighbor not in open_set_hash:
    75     71.8 MiB      0.0 MiB         942                       count += 1
    76     71.8 MiB      0.0 MiB         942                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.8 MiB      0.0 MiB         942                       open_set_hash.add(neighbor)
    78                                                             
    79     71.8 MiB      0.0 MiB         767           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.8 MiB      0.0 MiB         767           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     71.8 MiB     71.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     71.8 MiB    -91.1 MiB         257       for row in grid:
    30     71.8 MiB -23358.8 MiB       65792           for spot in row:
    31     71.8 MiB -23268.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.3 MiB     -0.5 MiB           1       count = 0
    34     71.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.3 MiB      0.0 MiB           1       came_from = {}
    37     71.8 MiB -14542.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.2 MiB     -0.6 MiB           1       g_score[start] = 0
    39     72.2 MiB  -2443.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.3 MiB    -15.8 MiB        2106       while not open_set.empty():
    47     72.3 MiB    -15.8 MiB        2106           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.3 MiB    -15.8 MiB        2106           current = open_set.get()[2]
    53     72.3 MiB    -15.8 MiB        2106           open_set_hash.remove(current)
    54                                         
    55     72.3 MiB    -15.8 MiB        2106           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.3 MiB    -15.8 MiB        2106           if current == end:
    60     72.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.3 MiB   -142.5 MiB       18945           for neighbor in current.neighbors:
    65     72.3 MiB   -126.7 MiB       16840               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.3 MiB    -63.3 MiB        8420                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.3 MiB    -63.3 MiB        8420                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.3 MiB   -126.7 MiB       16840               if temp_g_score < g_score[neighbor]:
    71     72.3 MiB    -18.3 MiB        2480                   came_from[neighbor] = current
    72     72.3 MiB    -18.3 MiB        2480                   g_score[neighbor] = temp_g_score
    73     72.3 MiB    -18.3 MiB        2480                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.3 MiB    -18.3 MiB        2480                   if neighbor not in open_set_hash:
    75     72.3 MiB    -18.3 MiB        2480                       count += 1
    76     72.3 MiB    -18.2 MiB        2480                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.3 MiB    -18.2 MiB        2480                       open_set_hash.add(neighbor)
    78                                                             
    79     72.3 MiB    -15.8 MiB        2105           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.3 MiB    -15.8 MiB        2105           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.4 MiB    109.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.4 MiB   -639.8 MiB         257       for row in grid:
    30    109.4 MiB -162456.7 MiB       65792           for spot in row:
    31    109.4 MiB -161823.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.8 MiB     -9.6 MiB           1       count = 0
    34     99.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.8 MiB      0.0 MiB           1       came_from = {}
    37    100.7 MiB -39636.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.1 MiB     -0.6 MiB           1       g_score[start] = 0
    39    104.2 MiB   -956.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.5 MiB     -0.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.5 MiB -14324.3 MiB        2546       while not open_set.empty():
    47    103.5 MiB -14324.7 MiB        2546           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.5 MiB -14325.2 MiB        2546           current = open_set.get()[2]
    53    103.5 MiB -14325.5 MiB        2546           open_set_hash.remove(current)
    54                                         
    55    103.5 MiB -14325.7 MiB        2546           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.5 MiB -14326.1 MiB        2546           if current == end:
    60     87.9 MiB    -15.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     87.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.5 MiB -128855.1 MiB       22905           for neighbor in current.neighbors:
    65    103.5 MiB -114534.2 MiB       20360               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.5 MiB -57282.2 MiB       10180                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.5 MiB -57254.2 MiB       10180                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.5 MiB -114538.8 MiB       20360               if temp_g_score < g_score[neighbor]:
    71    103.5 MiB -16061.5 MiB        2888                   came_from[neighbor] = current
    72    103.5 MiB -16061.8 MiB        2888                   g_score[neighbor] = temp_g_score
    73    103.5 MiB -16062.8 MiB        2888                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.5 MiB -16063.2 MiB        2888                   if neighbor not in open_set_hash:
    75    103.5 MiB -16063.4 MiB        2888                       count += 1
    76    103.5 MiB -16063.7 MiB        2888                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.5 MiB -16064.0 MiB        2888                       open_set_hash.add(neighbor)
    78                                                             
    79    103.5 MiB -14323.9 MiB        2545           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.5 MiB -14324.1 MiB        2545           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.3 MiB     90.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.0 MiB   -228.2 MiB         257       for row in grid:
    30     93.0 MiB -58750.2 MiB       65792           for spot in row:
    31     93.0 MiB -58517.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.0 MiB      0.0 MiB           1       count = 0
    34     93.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.0 MiB      0.0 MiB           1       came_from = {}
    37     93.0 MiB -195186.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     89.2 MiB     -3.8 MiB           1       g_score[start] = 0
    39     90.9 MiB -51682.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     91.0 MiB      0.0 MiB         477       while not open_set.empty():
    47     91.0 MiB      0.0 MiB         477           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     91.0 MiB      0.0 MiB         477           current = open_set.get()[2]
    53     91.0 MiB      0.0 MiB         477           open_set_hash.remove(current)
    54                                         
    55     91.0 MiB      0.0 MiB         477           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     91.0 MiB      0.0 MiB         477           if current == end:
    60     91.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     91.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     91.0 MiB      0.0 MiB        4284           for neighbor in current.neighbors:
    65     91.0 MiB      0.0 MiB        3808               if current.row != neighbor.row and current.col != neighbor.col:
    66     91.0 MiB      0.0 MiB        1904                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     91.0 MiB      0.0 MiB        1904                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     91.0 MiB      0.0 MiB        3808               if temp_g_score < g_score[neighbor]:
    71     91.0 MiB      0.0 MiB         617                   came_from[neighbor] = current
    72     91.0 MiB      0.0 MiB         617                   g_score[neighbor] = temp_g_score
    73     91.0 MiB      0.0 MiB         617                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     91.0 MiB      0.0 MiB         617                   if neighbor not in open_set_hash:
    75     91.0 MiB      0.0 MiB         617                       count += 1
    76     91.0 MiB      0.0 MiB         617                       open_set.put((f_score[neighbor], count, neighbor))
    77     91.0 MiB      0.0 MiB         617                       open_set_hash.add(neighbor)
    78                                                             
    79     91.0 MiB      0.0 MiB         476           if draw is not None:
    80                                                     draw()
    81                                         
    82     91.0 MiB      0.0 MiB         476           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.0 MiB     91.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.0 MiB   -658.0 MiB         257       for row in grid:
    30     91.0 MiB -168056.9 MiB       65792           for spot in row:
    31     91.0 MiB -167403.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.5 MiB     -5.5 MiB           1       count = 0
    34     85.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     85.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     85.5 MiB      0.0 MiB           1       came_from = {}
    37     89.2 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     89.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     92.3 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     92.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     92.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     92.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     92.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     92.3 MiB      0.0 MiB         578       while not open_set.empty():
    47     92.3 MiB      0.0 MiB         578           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     92.3 MiB      0.0 MiB         578           current = open_set.get()[2]
    53     92.3 MiB      0.0 MiB         578           open_set_hash.remove(current)
    54                                         
    55     92.3 MiB      0.0 MiB         578           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     92.3 MiB      0.0 MiB         578           if current == end:
    60     92.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     92.3 MiB      0.0 MiB        5193           for neighbor in current.neighbors:
    65     92.3 MiB      0.0 MiB        4616               if current.row != neighbor.row and current.col != neighbor.col:
    66     92.3 MiB      0.0 MiB        2308                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     92.3 MiB      0.0 MiB        2308                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     92.3 MiB      0.0 MiB        4616               if temp_g_score < g_score[neighbor]:
    71     92.3 MiB      0.0 MiB         712                   came_from[neighbor] = current
    72     92.3 MiB      0.0 MiB         712                   g_score[neighbor] = temp_g_score
    73     92.3 MiB      0.0 MiB         712                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     92.3 MiB      0.0 MiB         712                   if neighbor not in open_set_hash:
    75     92.3 MiB      0.0 MiB         712                       count += 1
    76     92.3 MiB      0.0 MiB         712                       open_set.put((f_score[neighbor], count, neighbor))
    77     92.3 MiB      0.0 MiB         712                       open_set_hash.add(neighbor)
    78                                                             
    79     92.3 MiB      0.0 MiB         577           if draw is not None:
    80                                                     draw()
    81                                         
    82     92.3 MiB      0.0 MiB         577           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.3 MiB     92.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.3 MiB      0.0 MiB         257       for row in grid:
    30     92.3 MiB      0.0 MiB       65792           for spot in row:
    31     92.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.3 MiB      0.0 MiB           1       count = 0
    34     92.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.3 MiB      0.0 MiB           1       came_from = {}
    37     94.4 MiB   -381.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.3 MiB     -0.0 MiB           1       g_score[start] = 0
    39     94.4 MiB -938886.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB    -22.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.2 MiB -56825.6 MiB        4464       while not open_set.empty():
    47     72.2 MiB -56825.8 MiB        4464           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.2 MiB -56826.7 MiB        4464           current = open_set.get()[2]
    53     72.2 MiB -56827.2 MiB        4464           open_set_hash.remove(current)
    54                                         
    55     72.2 MiB -56827.6 MiB        4464           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.2 MiB -56828.0 MiB        4464           if current == end:
    60     53.0 MiB    -19.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     53.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.2 MiB -511346.2 MiB       40167           for neighbor in current.neighbors:
    65     72.2 MiB -454524.5 MiB       35704               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.2 MiB -227276.1 MiB       17852                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.2 MiB -227252.5 MiB       17852                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.2 MiB -454532.0 MiB       35704               if temp_g_score < g_score[neighbor]:
    71     72.2 MiB -60221.3 MiB        4840                   came_from[neighbor] = current
    72     72.2 MiB -60221.5 MiB        4840                   g_score[neighbor] = temp_g_score
    73     72.2 MiB -60222.0 MiB        4840                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.2 MiB -60222.5 MiB        4840                   if neighbor not in open_set_hash:
    75     72.2 MiB -60222.8 MiB        4840                       count += 1
    76     72.2 MiB -60223.5 MiB        4840                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.2 MiB -60223.7 MiB        4840                       open_set_hash.add(neighbor)
    78                                                             
    79     72.2 MiB -56825.2 MiB        4463           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.2 MiB -56825.4 MiB        4463           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     54.0 MiB     54.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.2 MiB   -155.6 MiB         257       for row in grid:
    30     58.2 MiB -39954.7 MiB       65792           for spot in row:
    31     58.2 MiB -39794.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.4 MiB     -1.8 MiB           1       count = 0
    34     56.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     56.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.4 MiB      0.0 MiB           1       came_from = {}
    37     58.6 MiB -32584.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.0 MiB     -0.6 MiB           1       g_score[start] = 0
    39     61.6 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.8 MiB      0.0 MiB        2244       while not open_set.empty():
    47     61.8 MiB      0.0 MiB        2244           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.8 MiB      0.0 MiB        2244           current = open_set.get()[2]
    53     61.8 MiB      0.0 MiB        2244           open_set_hash.remove(current)
    54                                         
    55     61.8 MiB      0.0 MiB        2244           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.8 MiB      0.0 MiB        2244           if current == end:
    60     61.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.8 MiB      0.0 MiB       20187           for neighbor in current.neighbors:
    65     61.8 MiB      0.0 MiB       17944               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.8 MiB      0.0 MiB        8972                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.8 MiB      0.0 MiB        8972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.8 MiB      0.0 MiB       17944               if temp_g_score < g_score[neighbor]:
    71     61.8 MiB      0.2 MiB        2574                   came_from[neighbor] = current
    72     61.8 MiB      0.0 MiB        2574                   g_score[neighbor] = temp_g_score
    73     61.8 MiB      0.0 MiB        2574                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.8 MiB      0.0 MiB        2574                   if neighbor not in open_set_hash:
    75     61.8 MiB      0.0 MiB        2574                       count += 1
    76     61.8 MiB      0.1 MiB        2574                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.8 MiB      0.0 MiB        2574                       open_set_hash.add(neighbor)
    78                                                             
    79     61.8 MiB      0.0 MiB        2243           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.8 MiB      0.0 MiB        2243           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.9 MiB     61.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.9 MiB      0.0 MiB         257       for row in grid:
    30     61.9 MiB      0.0 MiB       65792           for spot in row:
    31     61.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.9 MiB      0.0 MiB           1       count = 0
    34     61.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.9 MiB      0.0 MiB           1       came_from = {}
    37     65.1 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.4 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.5 MiB      0.0 MiB        1836       while not open_set.empty():
    47     69.5 MiB      0.0 MiB        1836           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.5 MiB      0.0 MiB        1836           current = open_set.get()[2]
    53     69.5 MiB      0.0 MiB        1836           open_set_hash.remove(current)
    54                                         
    55     69.5 MiB      0.0 MiB        1836           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.5 MiB      0.0 MiB        1836           if current == end:
    60     69.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.5 MiB      0.0 MiB       16515           for neighbor in current.neighbors:
    65     69.5 MiB      0.0 MiB       14680               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.5 MiB      0.0 MiB        7340                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.5 MiB      0.0 MiB        7340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.5 MiB      0.0 MiB       14680               if temp_g_score < g_score[neighbor]:
    71     69.5 MiB      0.1 MiB        2188                   came_from[neighbor] = current
    72     69.5 MiB      0.0 MiB        2188                   g_score[neighbor] = temp_g_score
    73     69.5 MiB      0.0 MiB        2188                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.5 MiB      0.0 MiB        2188                   if neighbor not in open_set_hash:
    75     69.5 MiB      0.0 MiB        2188                       count += 1
    76     69.5 MiB      0.0 MiB        2188                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.5 MiB      0.0 MiB        2188                       open_set_hash.add(neighbor)
    78                                                             
    79     69.5 MiB      0.0 MiB        1835           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.5 MiB      0.0 MiB        1835           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.5 MiB     69.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.5 MiB      0.0 MiB         257       for row in grid:
    30     69.5 MiB      0.0 MiB       65792           for spot in row:
    31     69.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     69.5 MiB      0.0 MiB           1       count = 0
    34     69.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     69.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     69.5 MiB      0.0 MiB           1       came_from = {}
    37     74.0 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.8 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.9 MiB      0.0 MiB        1932       while not open_set.empty():
    47     75.9 MiB      0.0 MiB        1932           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.9 MiB      0.0 MiB        1932           current = open_set.get()[2]
    53     75.9 MiB      0.0 MiB        1932           open_set_hash.remove(current)
    54                                         
    55     75.9 MiB      0.0 MiB        1932           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.9 MiB      0.0 MiB        1932           if current == end:
    60     75.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.9 MiB      0.0 MiB       17379           for neighbor in current.neighbors:
    65     75.9 MiB      0.0 MiB       15448               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.9 MiB      0.0 MiB        7724                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.9 MiB      0.0 MiB        7724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.9 MiB      0.0 MiB       15448               if temp_g_score < g_score[neighbor]:
    71     75.9 MiB      0.1 MiB        2300                   came_from[neighbor] = current
    72     75.9 MiB      0.0 MiB        2300                   g_score[neighbor] = temp_g_score
    73     75.9 MiB      0.0 MiB        2300                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.9 MiB      0.0 MiB        2300                   if neighbor not in open_set_hash:
    75     75.9 MiB      0.0 MiB        2300                       count += 1
    76     75.9 MiB      0.0 MiB        2300                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.9 MiB      0.0 MiB        2300                       open_set_hash.add(neighbor)
    78                                                             
    79     75.9 MiB      0.0 MiB        1931           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.9 MiB      0.0 MiB        1931           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.3 MiB    111.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.3 MiB      0.0 MiB         257       for row in grid:
    30    111.3 MiB      0.0 MiB       65792           for spot in row:
    31    111.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.3 MiB      0.0 MiB           1       count = 0
    34    111.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.3 MiB      0.0 MiB           1       came_from = {}
    37    112.4 MiB -13546.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.4 MiB     -2.9 MiB           1       g_score[start] = 0
    39    113.8 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.9 MiB      0.0 MiB        2262       while not open_set.empty():
    47    113.9 MiB      0.0 MiB        2262           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.9 MiB      0.0 MiB        2262           current = open_set.get()[2]
    53    113.9 MiB      0.0 MiB        2262           open_set_hash.remove(current)
    54                                         
    55    113.9 MiB      0.0 MiB        2262           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.9 MiB      0.0 MiB        2262           if current == end:
    60    113.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.9 MiB      0.0 MiB       20349           for neighbor in current.neighbors:
    65    113.9 MiB      0.0 MiB       18088               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.9 MiB      0.0 MiB        9044                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.9 MiB      0.0 MiB        9044                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.9 MiB      0.0 MiB       18088               if temp_g_score < g_score[neighbor]:
    71    113.9 MiB      0.0 MiB        2532                   came_from[neighbor] = current
    72    113.9 MiB      0.0 MiB        2532                   g_score[neighbor] = temp_g_score
    73    113.9 MiB      0.0 MiB        2532                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.9 MiB      0.0 MiB        2532                   if neighbor not in open_set_hash:
    75    113.9 MiB      0.0 MiB        2532                       count += 1
    76    113.9 MiB      0.0 MiB        2532                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.9 MiB      0.0 MiB        2532                       open_set_hash.add(neighbor)
    78                                                             
    79    113.9 MiB      0.0 MiB        2261           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.9 MiB      0.0 MiB        2261           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.9 MiB    113.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.9 MiB   -390.5 MiB         257       for row in grid:
    30    113.9 MiB -99688.9 MiB       65792           for spot in row:
    31    113.9 MiB -99300.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.8 MiB     -3.0 MiB           1       count = 0
    34    110.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.8 MiB      0.0 MiB           1       came_from = {}
    37    112.1 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.9 MiB      0.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.9 MiB  -4086.3 MiB        4524       while not open_set.empty():
    47    112.9 MiB  -4086.3 MiB        4524           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.9 MiB  -4086.3 MiB        4524           current = open_set.get()[2]
    53    112.9 MiB  -4086.3 MiB        4524           open_set_hash.remove(current)
    54                                         
    55    112.9 MiB  -4086.3 MiB        4524           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.9 MiB  -4086.3 MiB        4524           if current == end:
    60    110.1 MiB     -2.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.9 MiB -36764.2 MiB       40707           for neighbor in current.neighbors:
    65    112.9 MiB -32679.0 MiB       36184               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.9 MiB -16343.6 MiB       18092                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.9 MiB -16335.8 MiB       18092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.9 MiB -32679.7 MiB       36184               if temp_g_score < g_score[neighbor]:
    71    112.9 MiB  -4392.4 MiB        4974                   came_from[neighbor] = current
    72    112.9 MiB  -4392.4 MiB        4974                   g_score[neighbor] = temp_g_score
    73    112.9 MiB  -4392.4 MiB        4974                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.9 MiB  -4392.4 MiB        4974                   if neighbor not in open_set_hash:
    75    112.9 MiB  -4392.4 MiB        4974                       count += 1
    76    112.9 MiB  -4392.4 MiB        4974                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.9 MiB  -4392.6 MiB        4974                       open_set_hash.add(neighbor)
    78                                                             
    79    112.9 MiB  -4086.3 MiB        4523           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.9 MiB  -4086.3 MiB        4523           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.1 MiB    110.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.1 MiB   -677.3 MiB         257       for row in grid:
    30    110.1 MiB -173241.1 MiB       65792           for spot in row:
    31    110.1 MiB -172568.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.3 MiB     -6.8 MiB           1       count = 0
    34    103.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.3 MiB      0.0 MiB           1       came_from = {}
    37    106.2 MiB -22030.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.7 MiB     -2.5 MiB           1       g_score[start] = 0
    39    107.1 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.1 MiB    -68.3 MiB        1984       while not open_set.empty():
    47    107.1 MiB    -68.3 MiB        1984           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.1 MiB    -68.3 MiB        1984           current = open_set.get()[2]
    53    107.1 MiB    -68.3 MiB        1984           open_set_hash.remove(current)
    54                                         
    55    107.1 MiB    -68.3 MiB        1984           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.1 MiB    -68.3 MiB        1984           if current == end:
    60    107.1 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.1 MiB   -614.1 MiB       17847           for neighbor in current.neighbors:
    65    107.1 MiB   -545.8 MiB       15864               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.1 MiB   -272.9 MiB        7932                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.1 MiB   -272.9 MiB        7932                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.1 MiB   -545.9 MiB       15864               if temp_g_score < g_score[neighbor]:
    71    107.1 MiB    -73.9 MiB        2234                   came_from[neighbor] = current
    72    107.1 MiB    -73.9 MiB        2234                   g_score[neighbor] = temp_g_score
    73    107.1 MiB    -73.9 MiB        2234                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.1 MiB    -73.9 MiB        2234                   if neighbor not in open_set_hash:
    75    107.1 MiB    -73.9 MiB        2234                       count += 1
    76    107.1 MiB    -73.9 MiB        2234                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.1 MiB    -73.8 MiB        2234                       open_set_hash.add(neighbor)
    78                                                             
    79    107.1 MiB    -68.3 MiB        1983           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.1 MiB    -68.3 MiB        1983           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.1 MiB    107.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.1 MiB   -155.8 MiB         257       for row in grid:
    30    107.1 MiB -39867.6 MiB       65792           for spot in row:
    31    107.1 MiB -39712.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.9 MiB     -1.2 MiB           1       count = 0
    34    105.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.9 MiB      0.0 MiB           1       came_from = {}
    37    107.2 MiB -173711.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.6 MiB     -4.5 MiB           1       g_score[start] = 0
    39    102.6 MiB -252954.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.4 MiB     -6.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.4 MiB  -1138.8 MiB        1253       while not open_set.empty():
    47     96.4 MiB  -1138.8 MiB        1253           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.4 MiB  -1138.8 MiB        1253           current = open_set.get()[2]
    53     96.4 MiB  -1138.8 MiB        1253           open_set_hash.remove(current)
    54                                         
    55     96.4 MiB  -1138.8 MiB        1253           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.4 MiB  -1138.8 MiB        1253           if current == end:
    60     95.0 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.4 MiB -10244.7 MiB       11268           for neighbor in current.neighbors:
    65     96.4 MiB  -9106.3 MiB       10016               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.4 MiB  -4554.9 MiB        5008                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.4 MiB  -4551.4 MiB        5008                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.4 MiB  -9107.1 MiB       10016               if temp_g_score < g_score[neighbor]:
    71     96.4 MiB  -1468.3 MiB        1637                   came_from[neighbor] = current
    72     96.4 MiB  -1468.3 MiB        1637                   g_score[neighbor] = temp_g_score
    73     96.4 MiB  -1468.3 MiB        1637                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.4 MiB  -1468.3 MiB        1637                   if neighbor not in open_set_hash:
    75     96.4 MiB  -1468.3 MiB        1637                       count += 1
    76     96.4 MiB  -1468.3 MiB        1637                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.4 MiB  -1468.3 MiB        1637                       open_set_hash.add(neighbor)
    78                                                             
    79     96.4 MiB  -1138.8 MiB        1252           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.4 MiB  -1138.8 MiB        1252           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.0 MiB     95.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.0 MiB      0.0 MiB         257       for row in grid:
    30     95.0 MiB      0.0 MiB       65792           for spot in row:
    31     95.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.0 MiB      0.0 MiB           1       count = 0
    34     95.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.0 MiB      0.0 MiB           1       came_from = {}
    37     97.1 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.6 MiB      1.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.6 MiB      0.0 MiB         570       while not open_set.empty():
    47     98.6 MiB      0.0 MiB         570           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.6 MiB      0.0 MiB         570           current = open_set.get()[2]
    53     98.6 MiB      0.0 MiB         570           open_set_hash.remove(current)
    54                                         
    55     98.6 MiB      0.0 MiB         570           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.6 MiB      0.0 MiB         570           if current == end:
    60     98.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.6 MiB      0.0 MiB        5121           for neighbor in current.neighbors:
    65     98.6 MiB      0.0 MiB        4552               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.6 MiB      0.0 MiB        2276                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.6 MiB      0.0 MiB        2276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.6 MiB      0.0 MiB        4552               if temp_g_score < g_score[neighbor]:
    71     98.6 MiB      0.0 MiB         816                   came_from[neighbor] = current
    72     98.6 MiB      0.0 MiB         816                   g_score[neighbor] = temp_g_score
    73     98.6 MiB      0.0 MiB         816                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.6 MiB      0.0 MiB         816                   if neighbor not in open_set_hash:
    75     98.6 MiB      0.0 MiB         816                       count += 1
    76     98.6 MiB      0.0 MiB         816                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.6 MiB      0.0 MiB         816                       open_set_hash.add(neighbor)
    78                                                             
    79     98.6 MiB      0.0 MiB         569           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.6 MiB      0.0 MiB         569           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.6 MiB     98.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.6 MiB      0.0 MiB         257       for row in grid:
    30     98.6 MiB      0.0 MiB       65792           for spot in row:
    31     98.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.6 MiB      0.0 MiB           1       count = 0
    34     98.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.6 MiB      0.0 MiB           1       came_from = {}
    37     99.8 MiB      1.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.5 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.7 MiB      0.0 MiB        1665       while not open_set.empty():
    47    101.7 MiB      0.0 MiB        1665           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.7 MiB      0.0 MiB        1665           current = open_set.get()[2]
    53    101.7 MiB      0.0 MiB        1665           open_set_hash.remove(current)
    54                                         
    55    101.7 MiB      0.0 MiB        1665           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.7 MiB      0.0 MiB        1665           if current == end:
    60    101.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.7 MiB      0.0 MiB       14976           for neighbor in current.neighbors:
    65    101.7 MiB      0.0 MiB       13312               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.7 MiB      0.0 MiB        6656                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.7 MiB      0.0 MiB        6656                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.7 MiB      0.0 MiB       13312               if temp_g_score < g_score[neighbor]:
    71    101.7 MiB      0.1 MiB        1945                   came_from[neighbor] = current
    72    101.7 MiB      0.0 MiB        1945                   g_score[neighbor] = temp_g_score
    73    101.7 MiB      0.0 MiB        1945                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.7 MiB      0.0 MiB        1945                   if neighbor not in open_set_hash:
    75    101.7 MiB      0.0 MiB        1945                       count += 1
    76    101.7 MiB      0.0 MiB        1945                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.7 MiB      0.0 MiB        1945                       open_set_hash.add(neighbor)
    78                                                             
    79    101.7 MiB      0.0 MiB        1664           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.7 MiB      0.0 MiB        1664           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.7 MiB    101.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.7 MiB    -33.9 MiB         257       for row in grid:
    30    101.7 MiB  -8613.3 MiB       65792           for spot in row:
    31    101.7 MiB  -8580.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.6 MiB     -1.0 MiB           1       count = 0
    34    100.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.6 MiB      0.0 MiB           1       came_from = {}
    37    101.7 MiB -767543.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.7 MiB    -26.9 MiB           1       g_score[start] = 0
    39     77.3 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     77.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     77.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     77.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     77.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     77.3 MiB -52752.3 MiB        3977       while not open_set.empty():
    47     77.3 MiB -52752.4 MiB        3977           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     77.3 MiB -52752.4 MiB        3977           current = open_set.get()[2]
    53     77.3 MiB -52752.6 MiB        3977           open_set_hash.remove(current)
    54                                         
    55     77.3 MiB -52752.6 MiB        3977           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     77.3 MiB -52752.6 MiB        3977           if current == end:
    60     61.0 MiB    -16.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     77.3 MiB -474672.8 MiB       35784           for neighbor in current.neighbors:
    65     77.3 MiB -421922.5 MiB       31808               if current.row != neighbor.row and current.col != neighbor.col:
    66     77.3 MiB -210973.4 MiB       15904                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     77.3 MiB -210950.5 MiB       15904                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     77.3 MiB -421925.5 MiB       31808               if temp_g_score < g_score[neighbor]:
    71     77.3 MiB -56392.8 MiB        4333                   came_from[neighbor] = current
    72     77.3 MiB -56393.2 MiB        4333                   g_score[neighbor] = temp_g_score
    73     77.3 MiB -56399.8 MiB        4333                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     77.3 MiB -56400.5 MiB        4333                   if neighbor not in open_set_hash:
    75     77.3 MiB -56401.0 MiB        4333                       count += 1
    76     77.3 MiB -56401.8 MiB        4333                       open_set.put((f_score[neighbor], count, neighbor))
    77     77.3 MiB -56402.1 MiB        4333                       open_set_hash.add(neighbor)
    78                                                             
    79     77.3 MiB -52752.3 MiB        3976           if draw is not None:
    80                                                     draw()
    81                                         
    82     77.3 MiB -52752.3 MiB        3976           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.7 MiB     97.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.7 MiB      0.0 MiB         257       for row in grid:
    30     97.7 MiB      0.0 MiB       65792           for spot in row:
    31     97.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.7 MiB      0.0 MiB           1       count = 0
    34     97.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.7 MiB      0.0 MiB           1       came_from = {}
    37     99.3 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.4 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.5 MiB      0.0 MiB        4536       while not open_set.empty():
    47    102.5 MiB      0.0 MiB        4536           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.5 MiB      0.0 MiB        4536           current = open_set.get()[2]
    53    102.5 MiB      0.0 MiB        4536           open_set_hash.remove(current)
    54                                         
    55    102.5 MiB      0.0 MiB        4536           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.5 MiB      0.0 MiB        4536           if current == end:
    60    102.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.5 MiB      0.0 MiB       40815           for neighbor in current.neighbors:
    65    102.5 MiB      0.0 MiB       36280               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.5 MiB      0.0 MiB       18140                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.5 MiB      0.0 MiB       18140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.5 MiB      0.0 MiB       36280               if temp_g_score < g_score[neighbor]:
    71    102.5 MiB      0.1 MiB        4930                   came_from[neighbor] = current
    72    102.5 MiB      0.0 MiB        4930                   g_score[neighbor] = temp_g_score
    73    102.5 MiB      0.0 MiB        4930                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.5 MiB      0.0 MiB        4930                   if neighbor not in open_set_hash:
    75    102.5 MiB      0.0 MiB        4930                       count += 1
    76    102.5 MiB      0.0 MiB        4930                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.5 MiB      0.0 MiB        4930                       open_set_hash.add(neighbor)
    78                                                             
    79    102.5 MiB      0.0 MiB        4535           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.5 MiB      0.0 MiB        4535           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.5 MiB    102.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.5 MiB   -974.0 MiB         257       for row in grid:
    30    102.5 MiB -246856.1 MiB       65792           for spot in row:
    31    102.5 MiB -245888.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     82.8 MiB    -19.7 MiB           1       count = 0
    34     82.9 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     82.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     82.9 MiB      0.0 MiB           1       came_from = {}
    37     84.0 MiB -392956.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     78.5 MiB     -5.5 MiB           1       g_score[start] = 0
    39     81.7 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     81.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     81.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     81.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     81.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     82.9 MiB      0.0 MiB         432       while not open_set.empty():
    47     82.9 MiB      0.0 MiB         432           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     82.9 MiB      0.0 MiB         432           current = open_set.get()[2]
    53     82.9 MiB      0.0 MiB         432           open_set_hash.remove(current)
    54                                         
    55     82.9 MiB      0.0 MiB         432           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     82.9 MiB      0.0 MiB         432           if current == end:
    60     82.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     82.9 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     82.9 MiB      0.1 MiB        3879           for neighbor in current.neighbors:
    65     82.9 MiB      0.1 MiB        3448               if current.row != neighbor.row and current.col != neighbor.col:
    66     82.9 MiB      0.0 MiB        1724                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     82.9 MiB      0.0 MiB        1724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     82.9 MiB      0.0 MiB        3448               if temp_g_score < g_score[neighbor]:
    71     82.9 MiB      0.0 MiB         662                   came_from[neighbor] = current
    72     82.9 MiB      0.0 MiB         662                   g_score[neighbor] = temp_g_score
    73     82.9 MiB      0.0 MiB         662                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     82.9 MiB      0.0 MiB         662                   if neighbor not in open_set_hash:
    75     82.9 MiB      0.0 MiB         662                       count += 1
    76     82.9 MiB      0.9 MiB         662                       open_set.put((f_score[neighbor], count, neighbor))
    77     82.9 MiB      0.0 MiB         662                       open_set_hash.add(neighbor)
    78                                                             
    79     82.9 MiB      0.0 MiB         431           if draw is not None:
    80                                                     draw()
    81                                         
    82     82.9 MiB      0.0 MiB         431           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     85.5 MiB     85.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.2 MiB      0.0 MiB         257       for row in grid:
    30     88.2 MiB      0.0 MiB       65792           for spot in row:
    31     88.2 MiB      2.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.2 MiB      0.0 MiB           1       count = 0
    34     88.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.2 MiB      0.0 MiB           1       came_from = {}
    37     92.9 MiB      4.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.0 MiB -11282.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.1 MiB   -359.6 MiB        1700       while not open_set.empty():
    47     96.1 MiB   -359.6 MiB        1700           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.1 MiB   -359.6 MiB        1700           current = open_set.get()[2]
    53     96.1 MiB   -359.8 MiB        1700           open_set_hash.remove(current)
    54                                         
    55     96.1 MiB   -359.9 MiB        1700           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.1 MiB   -359.9 MiB        1700           if current == end:
    60     95.4 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.1 MiB  -3234.8 MiB       15291           for neighbor in current.neighbors:
    65     96.1 MiB  -2875.2 MiB       13592               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.1 MiB  -1437.9 MiB        6796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.1 MiB  -1437.4 MiB        6796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.1 MiB  -2875.3 MiB       13592               if temp_g_score < g_score[neighbor]:
    71     96.1 MiB   -403.4 MiB        1966                   came_from[neighbor] = current
    72     96.1 MiB   -403.4 MiB        1966                   g_score[neighbor] = temp_g_score
    73     96.1 MiB   -403.4 MiB        1966                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.1 MiB   -403.4 MiB        1966                   if neighbor not in open_set_hash:
    75     96.1 MiB   -403.5 MiB        1966                       count += 1
    76     96.1 MiB   -403.7 MiB        1966                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.1 MiB   -403.6 MiB        1966                       open_set_hash.add(neighbor)
    78                                                             
    79     96.1 MiB   -359.6 MiB        1699           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.1 MiB   -359.6 MiB        1699           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.4 MiB     95.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.4 MiB   -213.4 MiB         257       for row in grid:
    30     95.4 MiB -54406.7 MiB       65792           for spot in row:
    31     95.4 MiB -54193.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.0 MiB     -4.4 MiB           1       count = 0
    34     91.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.0 MiB      0.0 MiB           1       came_from = {}
    37     91.8 MiB  -6058.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.7 MiB     -0.1 MiB           1       g_score[start] = 0
    39     95.7 MiB -38316.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.5 MiB     -5.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     90.5 MiB -109850.0 MiB        4697       while not open_set.empty():
    47     90.5 MiB -109850.2 MiB        4697           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     90.5 MiB -109852.0 MiB        4697           current = open_set.get()[2]
    53     90.5 MiB -109852.1 MiB        4697           open_set_hash.remove(current)
    54                                         
    55     90.5 MiB -109852.2 MiB        4697           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     90.5 MiB -109852.3 MiB        4697           if current == end:
    60     63.7 MiB    -26.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     90.5 MiB -988526.9 MiB       42264           for neighbor in current.neighbors:
    65     90.5 MiB -878682.2 MiB       37568               if current.row != neighbor.row and current.col != neighbor.col:
    66     90.5 MiB -439370.5 MiB       18784                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     90.5 MiB -439315.8 MiB       18784                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     90.5 MiB -878691.1 MiB       37568               if temp_g_score < g_score[neighbor]:
    71     90.5 MiB -116708.4 MiB        5093                   came_from[neighbor] = current
    72     90.5 MiB -116709.0 MiB        5093                   g_score[neighbor] = temp_g_score
    73     90.5 MiB -116709.9 MiB        5093                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     90.5 MiB -116710.6 MiB        5093                   if neighbor not in open_set_hash:
    75     90.5 MiB -116711.2 MiB        5093                       count += 1
    76     90.5 MiB -116712.1 MiB        5093                       open_set.put((f_score[neighbor], count, neighbor))
    77     90.5 MiB -116712.6 MiB        5093                       open_set_hash.add(neighbor)
    78                                                             
    79     90.5 MiB -109849.4 MiB        4696           if draw is not None:
    80                                                     draw()
    81                                         
    82     90.5 MiB -109849.6 MiB        4696           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.8 MiB     63.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.8 MiB      0.0 MiB         257       for row in grid:
    30     63.8 MiB      0.0 MiB       65792           for spot in row:
    31     63.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.8 MiB      0.0 MiB           1       count = 0
    34     63.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.8 MiB      0.0 MiB           1       came_from = {}
    37     66.5 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.0 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.0 MiB      0.0 MiB        1938       while not open_set.empty():
    47     69.0 MiB      0.0 MiB        1938           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.0 MiB      0.0 MiB        1938           current = open_set.get()[2]
    53     69.0 MiB      0.0 MiB        1938           open_set_hash.remove(current)
    54                                         
    55     69.0 MiB      0.0 MiB        1938           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.0 MiB      0.0 MiB        1938           if current == end:
    60     69.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.0 MiB      0.0 MiB       17433           for neighbor in current.neighbors:
    65     69.0 MiB      0.0 MiB       15496               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.0 MiB      0.0 MiB        7748                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.0 MiB      0.0 MiB        7748                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.0 MiB      0.0 MiB       15496               if temp_g_score < g_score[neighbor]:
    71     69.0 MiB      0.0 MiB        2216                   came_from[neighbor] = current
    72     69.0 MiB      0.0 MiB        2216                   g_score[neighbor] = temp_g_score
    73     69.0 MiB      0.0 MiB        2216                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.0 MiB      0.0 MiB        2216                   if neighbor not in open_set_hash:
    75     69.0 MiB      0.0 MiB        2216                       count += 1
    76     69.0 MiB      0.0 MiB        2216                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.0 MiB      0.0 MiB        2216                       open_set_hash.add(neighbor)
    78                                                             
    79     69.0 MiB      0.0 MiB        1937           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.0 MiB      0.0 MiB        1937           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.0 MiB     69.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.0 MiB   -151.8 MiB         257       for row in grid:
    30     69.0 MiB -38461.0 MiB       65792           for spot in row:
    31     69.0 MiB -38310.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.0 MiB     -2.9 MiB           1       count = 0
    34     66.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.0 MiB      0.0 MiB           1       came_from = {}
    37     68.1 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.5 MiB -21433.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.5 MiB  -7438.5 MiB        4995       while not open_set.empty():
    47     69.5 MiB  -7438.5 MiB        4995           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.5 MiB  -7438.5 MiB        4995           current = open_set.get()[2]
    53     69.5 MiB  -7438.5 MiB        4995           open_set_hash.remove(current)
    54                                         
    55     69.5 MiB  -7438.5 MiB        4995           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.5 MiB  -7438.5 MiB        4995           if current == end:
    60     67.9 MiB     -1.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.5 MiB -66933.7 MiB       44946           for neighbor in current.neighbors:
    65     69.5 MiB -59495.2 MiB       39952               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.5 MiB -29747.5 MiB       19976                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.5 MiB -29747.6 MiB       19976                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.5 MiB -59495.2 MiB       39952               if temp_g_score < g_score[neighbor]:
    71     69.5 MiB  -8023.6 MiB        5471                   came_from[neighbor] = current
    72     69.5 MiB  -8025.4 MiB        5471                   g_score[neighbor] = temp_g_score
    73     69.5 MiB  -8025.4 MiB        5471                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.5 MiB  -8025.4 MiB        5471                   if neighbor not in open_set_hash:
    75     69.5 MiB  -8025.4 MiB        5471                       count += 1
    76     69.5 MiB  -8025.3 MiB        5471                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.5 MiB  -8025.3 MiB        5471                       open_set_hash.add(neighbor)
    78                                                             
    79     69.5 MiB  -7438.5 MiB        4994           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.5 MiB  -7438.5 MiB        4994           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.9 MiB     67.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.9 MiB      0.0 MiB         257       for row in grid:
    30     67.9 MiB      0.0 MiB       65792           for spot in row:
    31     67.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     67.9 MiB      0.0 MiB           1       count = 0
    34     67.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.9 MiB      0.0 MiB           1       came_from = {}
    37     69.6 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.9 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.0 MiB      0.0 MiB         392       while not open_set.empty():
    47     70.0 MiB      0.0 MiB         392           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.0 MiB      0.0 MiB         392           current = open_set.get()[2]
    53     70.0 MiB      0.0 MiB         392           open_set_hash.remove(current)
    54                                         
    55     70.0 MiB      0.0 MiB         392           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.0 MiB      0.0 MiB         392           if current == end:
    60     70.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.0 MiB      0.0 MiB        3519           for neighbor in current.neighbors:
    65     70.0 MiB      0.0 MiB        3128               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.0 MiB      0.0 MiB        1564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.0 MiB      0.0 MiB        1564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.0 MiB      0.0 MiB        3128               if temp_g_score < g_score[neighbor]:
    71     70.0 MiB      0.0 MiB         520                   came_from[neighbor] = current
    72     70.0 MiB      0.0 MiB         520                   g_score[neighbor] = temp_g_score
    73     70.0 MiB      0.0 MiB         520                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.0 MiB      0.0 MiB         520                   if neighbor not in open_set_hash:
    75     70.0 MiB      0.0 MiB         520                       count += 1
    76     70.0 MiB      0.0 MiB         520                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.0 MiB      0.0 MiB         520                       open_set_hash.add(neighbor)
    78                                                             
    79     70.0 MiB      0.0 MiB         391           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.0 MiB      0.0 MiB         391           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.8 MiB    102.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.8 MiB      0.0 MiB         257       for row in grid:
    30    102.8 MiB      0.0 MiB       65792           for spot in row:
    31    102.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.8 MiB      0.0 MiB           1       count = 0
    34    102.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.8 MiB      0.0 MiB           1       came_from = {}
    37    105.8 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.4 MiB      1.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.5 MiB      0.0 MiB         760       while not open_set.empty():
    47    107.5 MiB      0.0 MiB         760           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.5 MiB      0.0 MiB         760           current = open_set.get()[2]
    53    107.5 MiB      0.0 MiB         760           open_set_hash.remove(current)
    54                                         
    55    107.5 MiB      0.0 MiB         760           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.5 MiB      0.0 MiB         760           if current == end:
    60    107.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.5 MiB      0.0 MiB        6831           for neighbor in current.neighbors:
    65    107.5 MiB      0.0 MiB        6072               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.5 MiB      0.0 MiB        3036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.5 MiB      0.0 MiB        3036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.5 MiB      0.0 MiB        6072               if temp_g_score < g_score[neighbor]:
    71    107.5 MiB      0.0 MiB        1154                   came_from[neighbor] = current
    72    107.5 MiB      0.0 MiB        1154                   g_score[neighbor] = temp_g_score
    73    107.5 MiB      0.0 MiB        1154                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.5 MiB      0.0 MiB        1154                   if neighbor not in open_set_hash:
    75    107.5 MiB      0.0 MiB        1154                       count += 1
    76    107.5 MiB      0.0 MiB        1154                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.5 MiB      0.0 MiB        1154                       open_set_hash.add(neighbor)
    78                                                             
    79    107.5 MiB      0.0 MiB         759           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.5 MiB      0.0 MiB         759           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.5 MiB    107.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.5 MiB   -429.0 MiB         257       for row in grid:
    30    107.5 MiB -108986.8 MiB       65792           for spot in row:
    31    107.5 MiB -108563.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.9 MiB     -7.6 MiB           1       count = 0
    34     99.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.9 MiB      0.0 MiB           1       came_from = {}
    37    103.7 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.9 MiB    -68.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.9 MiB      0.0 MiB         224       while not open_set.empty():
    47    106.9 MiB      0.0 MiB         224           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.9 MiB      0.0 MiB         224           current = open_set.get()[2]
    53    106.9 MiB      0.0 MiB         224           open_set_hash.remove(current)
    54                                         
    55    106.9 MiB      0.0 MiB         224           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.9 MiB      0.0 MiB         224           if current == end:
    60    106.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.9 MiB      0.0 MiB        2007           for neighbor in current.neighbors:
    65    106.9 MiB      0.0 MiB        1784               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.9 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.9 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.9 MiB      0.0 MiB        1784               if temp_g_score < g_score[neighbor]:
    71    106.9 MiB      0.0 MiB         350                   came_from[neighbor] = current
    72    106.9 MiB      0.0 MiB         350                   g_score[neighbor] = temp_g_score
    73    106.9 MiB      0.0 MiB         350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.9 MiB      0.0 MiB         350                   if neighbor not in open_set_hash:
    75    106.9 MiB      0.0 MiB         350                       count += 1
    76    106.9 MiB      0.0 MiB         350                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.9 MiB      0.0 MiB         350                       open_set_hash.add(neighbor)
    78                                                             
    79    106.9 MiB      0.0 MiB         223           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.9 MiB      0.0 MiB         223           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.9 MiB    106.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.9 MiB    -37.4 MiB         257       for row in grid:
    30    106.9 MiB  -9584.9 MiB       65792           for spot in row:
    31    106.9 MiB  -9547.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.6 MiB     -0.3 MiB           1       count = 0
    34    106.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.6 MiB      0.0 MiB           1       came_from = {}
    37    107.1 MiB      0.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.4 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.4 MiB  -5611.8 MiB         798       while not open_set.empty():
    47    108.4 MiB  -5611.9 MiB         798           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.4 MiB  -5611.9 MiB         798           current = open_set.get()[2]
    53    108.4 MiB  -5611.9 MiB         798           open_set_hash.remove(current)
    54                                         
    55    108.4 MiB  -5611.9 MiB         798           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.4 MiB  -5611.9 MiB         798           if current == end:
    60     92.1 MiB    -16.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.4 MiB -50402.8 MiB        7173           for neighbor in current.neighbors:
    65    108.4 MiB -44794.0 MiB        6376               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.4 MiB -22412.6 MiB        3188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.4 MiB -22384.9 MiB        3188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.4 MiB -44800.1 MiB        6376               if temp_g_score < g_score[neighbor]:
    71    108.4 MiB  -6659.3 MiB         990                   came_from[neighbor] = current
    72    108.4 MiB  -6659.5 MiB         990                   g_score[neighbor] = temp_g_score
    73    108.4 MiB  -6659.9 MiB         990                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.4 MiB  -6662.4 MiB         990                   if neighbor not in open_set_hash:
    75    108.4 MiB  -6663.0 MiB         990                       count += 1
    76    108.4 MiB  -6663.1 MiB         990                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.4 MiB  -6663.3 MiB         990                       open_set_hash.add(neighbor)
    78                                                             
    79    108.4 MiB  -5611.7 MiB         797           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.4 MiB  -5611.7 MiB         797           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.1 MiB     92.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.1 MiB -11440.7 MiB         257       for row in grid:
    30     92.1 MiB -2934028.1 MiB       65792           for spot in row:
    31     92.1 MiB -2922626.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     36.4 MiB    -55.6 MiB           1       count = 0
    34     36.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     37.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     37.0 MiB      0.0 MiB           1       came_from = {}
    37     45.7 MiB      7.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     45.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     49.0 MiB -61792.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     47.4 MiB     -1.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     47.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     47.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     47.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     48.5 MiB   -156.0 MiB         544       while not open_set.empty():
    47     48.5 MiB   -156.1 MiB         544           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     48.5 MiB   -156.3 MiB         544           current = open_set.get()[2]
    53     48.5 MiB   -156.5 MiB         544           open_set_hash.remove(current)
    54                                         
    55     48.5 MiB   -156.6 MiB         544           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     48.5 MiB   -156.6 MiB         544           if current == end:
    60     48.2 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     48.5 MiB  -1400.0 MiB        4887           for neighbor in current.neighbors:
    65     48.5 MiB  -1243.4 MiB        4344               if current.row != neighbor.row and current.col != neighbor.col:
    66     48.5 MiB   -623.1 MiB        2172                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     48.5 MiB   -620.8 MiB        2172                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     48.5 MiB  -1244.5 MiB        4344               if temp_g_score < g_score[neighbor]:
    71     48.5 MiB   -195.5 MiB         710                   came_from[neighbor] = current
    72     48.5 MiB   -195.5 MiB         710                   g_score[neighbor] = temp_g_score
    73     48.5 MiB   -195.5 MiB         710                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     48.5 MiB   -195.5 MiB         710                   if neighbor not in open_set_hash:
    75     48.5 MiB   -195.5 MiB         710                       count += 1
    76     48.5 MiB   -195.4 MiB         710                       open_set.put((f_score[neighbor], count, neighbor))
    77     48.5 MiB   -195.4 MiB         710                       open_set_hash.add(neighbor)
    78                                                             
    79     48.5 MiB   -155.8 MiB         543           if draw is not None:
    80                                                     draw()
    81                                         
    82     48.5 MiB   -156.0 MiB         543           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     50.8 MiB     50.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     54.6 MiB  -1253.4 MiB         257       for row in grid:
    30     54.6 MiB -321576.7 MiB       65792           for spot in row:
    31     54.6 MiB -320321.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     46.8 MiB     -7.8 MiB           1       count = 0
    34     47.2 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     47.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     47.4 MiB      0.0 MiB           1       came_from = {}
    37     54.8 MiB  -1347.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     54.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.9 MiB   -864.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.0 MiB  -3119.9 MiB        1764       while not open_set.empty():
    47     61.0 MiB  -3119.9 MiB        1764           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.0 MiB  -3120.0 MiB        1764           current = open_set.get()[2]
    53     61.0 MiB  -3120.0 MiB        1764           open_set_hash.remove(current)
    54                                         
    55     61.0 MiB  -3120.0 MiB        1764           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.0 MiB  -3120.0 MiB        1764           if current == end:
    60     57.2 MiB     -3.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.0 MiB -28061.4 MiB       15867           for neighbor in current.neighbors:
    65     61.0 MiB -24941.7 MiB       14104               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.0 MiB -12475.2 MiB        7052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.0 MiB -12466.7 MiB        7052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.0 MiB -24942.3 MiB       14104               if temp_g_score < g_score[neighbor]:
    71     61.0 MiB  -3558.8 MiB        2070                   came_from[neighbor] = current
    72     61.0 MiB  -3558.9 MiB        2070                   g_score[neighbor] = temp_g_score
    73     61.0 MiB  -3559.1 MiB        2070                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.0 MiB  -3559.2 MiB        2070                   if neighbor not in open_set_hash:
    75     61.0 MiB  -3559.4 MiB        2070                       count += 1
    76     61.0 MiB  -3559.4 MiB        2070                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.0 MiB  -3559.6 MiB        2070                       open_set_hash.add(neighbor)
    78                                                             
    79     61.0 MiB  -3119.9 MiB        1763           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.0 MiB  -3119.9 MiB        1763           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     57.4 MiB     57.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     57.4 MiB   -664.4 MiB         257       for row in grid:
    30     57.4 MiB -170079.4 MiB       65792           for spot in row:
    31     57.4 MiB -169416.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     54.7 MiB     -2.7 MiB           1       count = 0
    34     54.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     54.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     54.7 MiB      0.0 MiB           1       came_from = {}
    37     56.3 MiB    -46.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.2 MiB      3.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.3 MiB      0.0 MiB        1640       while not open_set.empty():
    47     60.3 MiB      0.0 MiB        1640           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.3 MiB      0.0 MiB        1640           current = open_set.get()[2]
    53     60.3 MiB      0.0 MiB        1640           open_set_hash.remove(current)
    54                                         
    55     60.3 MiB      0.0 MiB        1640           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.3 MiB      0.0 MiB        1640           if current == end:
    60     60.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.3 MiB      0.0 MiB       14751           for neighbor in current.neighbors:
    65     60.3 MiB      0.0 MiB       13112               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.3 MiB      0.0 MiB        6556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.3 MiB      0.0 MiB        6556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.3 MiB      0.0 MiB       13112               if temp_g_score < g_score[neighbor]:
    71     60.3 MiB      0.1 MiB        1882                   came_from[neighbor] = current
    72     60.3 MiB      0.0 MiB        1882                   g_score[neighbor] = temp_g_score
    73     60.3 MiB      0.0 MiB        1882                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.3 MiB      0.0 MiB        1882                   if neighbor not in open_set_hash:
    75     60.3 MiB      0.0 MiB        1882                       count += 1
    76     60.3 MiB      0.0 MiB        1882                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.3 MiB      0.0 MiB        1882                       open_set_hash.add(neighbor)
    78                                                             
    79     60.3 MiB      0.0 MiB        1639           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.3 MiB      0.0 MiB        1639           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     60.4 MiB     60.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.4 MiB  -3723.0 MiB         257       for row in grid:
    30     60.4 MiB -952071.2 MiB       65792           for spot in row:
    31     60.4 MiB -948370.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     24.2 MiB    -36.2 MiB           1       count = 0
    34     24.5 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     24.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     24.8 MiB      0.0 MiB           1       came_from = {}
    37     35.9 MiB      8.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     35.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     42.7 MiB   -594.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     42.9 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     42.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     42.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     42.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.2 MiB  -2220.8 MiB        9991       while not open_set.empty():
    47     55.2 MiB  -2220.9 MiB        9991           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.2 MiB  -2220.8 MiB        9991           current = open_set.get()[2]
    53     55.2 MiB  -2220.9 MiB        9991           open_set_hash.remove(current)
    54                                         
    55     55.2 MiB  -2220.9 MiB        9991           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.2 MiB  -2220.9 MiB        9991           if current == end:
    60     55.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.3 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.2 MiB -19978.8 MiB       89910           for neighbor in current.neighbors:
    65     55.2 MiB -17755.7 MiB       79920               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.2 MiB  -8881.0 MiB       39960                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.2 MiB  -8879.5 MiB       39960                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.2 MiB -17760.7 MiB       79920               if temp_g_score < g_score[neighbor]:
    71     55.2 MiB  -2341.2 MiB       10595                   came_from[neighbor] = current
    72     55.2 MiB  -2341.9 MiB       10595                   g_score[neighbor] = temp_g_score
    73     55.2 MiB  -2342.4 MiB       10595                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.2 MiB  -2342.6 MiB       10595                   if neighbor not in open_set_hash:
    75     55.2 MiB  -2342.6 MiB       10595                       count += 1
    76     55.2 MiB  -2338.2 MiB       10595                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.2 MiB  -2342.4 MiB       10595                       open_set_hash.add(neighbor)
    78                                                             
    79     55.2 MiB  -2220.8 MiB        9990           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.2 MiB  -2220.9 MiB        9990           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.1 MiB     92.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.1 MiB   -348.4 MiB         257       for row in grid:
    30     92.1 MiB -89158.0 MiB       65792           for spot in row:
    31     92.1 MiB -88812.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.7 MiB     -4.4 MiB           1       count = 0
    34     87.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     87.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     87.7 MiB      0.0 MiB           1       came_from = {}
    37     91.0 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.0 MiB -210174.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     77.1 MiB    -18.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     77.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     77.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     77.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     77.8 MiB -10489.5 MiB        3640       while not open_set.empty():
    47     77.8 MiB -10489.8 MiB        3640           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     77.8 MiB -10489.5 MiB        3640           current = open_set.get()[2]
    53     77.8 MiB -10489.9 MiB        3640           open_set_hash.remove(current)
    54                                         
    55     77.8 MiB -10490.0 MiB        3640           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     77.8 MiB -10490.0 MiB        3640           if current == end:
    60     74.4 MiB     -3.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     77.9 MiB -95285.0 MiB       32751           for neighbor in current.neighbors:
    65     77.9 MiB -84794.8 MiB       29112               if current.row != neighbor.row and current.col != neighbor.col:
    66     77.9 MiB -42402.3 MiB       14556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     77.9 MiB -42393.2 MiB       14556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     77.9 MiB -84796.0 MiB       29112               if temp_g_score < g_score[neighbor]:
    71     77.9 MiB -11656.6 MiB        4022                   came_from[neighbor] = current
    72     77.9 MiB -11656.7 MiB        4022                   g_score[neighbor] = temp_g_score
    73     77.9 MiB -11656.8 MiB        4022                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     77.9 MiB -11656.9 MiB        4022                   if neighbor not in open_set_hash:
    75     77.9 MiB -11657.0 MiB        4022                       count += 1
    76     77.9 MiB -11657.2 MiB        4022                       open_set.put((f_score[neighbor], count, neighbor))
    77     77.9 MiB -11658.8 MiB        4022                       open_set_hash.add(neighbor)
    78                                                             
    79     77.8 MiB -10602.3 MiB        3639           if draw is not None:
    80                                                     draw()
    81                                         
    82     77.8 MiB -10489.5 MiB        3639           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.9 MiB     76.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     79.7 MiB  -4740.9 MiB         257       for row in grid:
    30     79.7 MiB -1213448.4 MiB       65792           for spot in row:
    31     79.7 MiB -1208723.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.6 MiB    -27.1 MiB           1       count = 0
    34     52.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.6 MiB      0.0 MiB           1       came_from = {}
    37     58.2 MiB      5.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     63.1 MiB      4.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.4 MiB      0.0 MiB        4424       while not open_set.empty():
    47     63.4 MiB      0.0 MiB        4424           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.4 MiB      0.0 MiB        4424           current = open_set.get()[2]
    53     63.4 MiB      0.0 MiB        4424           open_set_hash.remove(current)
    54                                         
    55     63.4 MiB      0.0 MiB        4424           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.4 MiB      0.0 MiB        4424           if current == end:
    60     63.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.4 MiB      0.0 MiB       39807           for neighbor in current.neighbors:
    65     63.4 MiB      0.0 MiB       35384               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.4 MiB      0.0 MiB       17692                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.4 MiB      0.0 MiB       17692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.4 MiB      0.0 MiB       35384               if temp_g_score < g_score[neighbor]:
    71     63.4 MiB      0.2 MiB        4804                   came_from[neighbor] = current
    72     63.4 MiB      0.0 MiB        4804                   g_score[neighbor] = temp_g_score
    73     63.4 MiB      0.0 MiB        4804                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.4 MiB      0.0 MiB        4804                   if neighbor not in open_set_hash:
    75     63.4 MiB      0.0 MiB        4804                       count += 1
    76     63.4 MiB      0.0 MiB        4804                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.4 MiB      0.1 MiB        4804                       open_set_hash.add(neighbor)
    78                                                             
    79     63.4 MiB      0.0 MiB        4423           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.4 MiB      0.0 MiB        4423           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.4 MiB     63.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.5 MiB      0.0 MiB         257       for row in grid:
    30     63.5 MiB      0.0 MiB       65792           for spot in row:
    31     63.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.5 MiB      0.0 MiB           1       count = 0
    34     63.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.5 MiB      0.0 MiB           1       came_from = {}
    37     64.8 MiB  -1850.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.2 MiB     -0.6 MiB           1       g_score[start] = 0
    39     64.9 MiB      0.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.0 MiB      0.0 MiB        2538       while not open_set.empty():
    47     65.0 MiB      0.0 MiB        2538           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.0 MiB      0.0 MiB        2538           current = open_set.get()[2]
    53     65.0 MiB      0.0 MiB        2538           open_set_hash.remove(current)
    54                                         
    55     65.0 MiB      0.0 MiB        2538           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.0 MiB      0.0 MiB        2538           if current == end:
    60     65.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.0 MiB      0.0 MiB       22833           for neighbor in current.neighbors:
    65     65.0 MiB      0.0 MiB       20296               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.0 MiB      0.0 MiB       10148                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.0 MiB      0.0 MiB       10148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.0 MiB      0.0 MiB       20296               if temp_g_score < g_score[neighbor]:
    71     65.0 MiB      0.1 MiB        2846                   came_from[neighbor] = current
    72     65.0 MiB      0.0 MiB        2846                   g_score[neighbor] = temp_g_score
    73     65.0 MiB      0.0 MiB        2846                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.0 MiB      0.0 MiB        2846                   if neighbor not in open_set_hash:
    75     65.0 MiB      0.0 MiB        2846                       count += 1
    76     65.0 MiB      0.0 MiB        2846                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.0 MiB      0.0 MiB        2846                       open_set_hash.add(neighbor)
    78                                                             
    79     65.0 MiB      0.0 MiB        2537           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.0 MiB      0.0 MiB        2537           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     65.1 MiB     65.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     65.1 MiB   -277.8 MiB         257       for row in grid:
    30     65.1 MiB -70895.8 MiB       65792           for spot in row:
    31     65.1 MiB -70619.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.7 MiB     -2.4 MiB           1       count = 0
    34     62.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.7 MiB      0.0 MiB           1       came_from = {}
    37     64.0 MiB      1.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.8 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.9 MiB   -148.3 MiB         184       while not open_set.empty():
    47     64.9 MiB   -148.3 MiB         184           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.9 MiB   -148.3 MiB         184           current = open_set.get()[2]
    53     64.9 MiB   -148.3 MiB         184           open_set_hash.remove(current)
    54                                         
    55     64.9 MiB   -148.3 MiB         184           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.9 MiB   -148.3 MiB         184           if current == end:
    60     60.8 MiB     -4.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.9 MiB  -1311.4 MiB        1647           for neighbor in current.neighbors:
    65     64.9 MiB  -1163.5 MiB        1464               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.9 MiB   -586.1 MiB         732                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.9 MiB   -577.5 MiB         732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.9 MiB  -1165.9 MiB        1464               if temp_g_score < g_score[neighbor]:
    71     64.9 MiB   -200.1 MiB         260                   came_from[neighbor] = current
    72     64.9 MiB   -200.2 MiB         260                   g_score[neighbor] = temp_g_score
    73     64.9 MiB   -200.2 MiB         260                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.9 MiB   -200.2 MiB         260                   if neighbor not in open_set_hash:
    75     64.9 MiB   -200.2 MiB         260                       count += 1
    76     64.9 MiB   -200.2 MiB         260                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.9 MiB   -200.2 MiB         260                       open_set_hash.add(neighbor)
    78                                                             
    79     64.9 MiB   -148.3 MiB         183           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.9 MiB   -148.3 MiB         183           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     60.8 MiB     60.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.8 MiB   -193.5 MiB         257       for row in grid:
    30     60.8 MiB -49544.5 MiB       65792           for spot in row:
    31     60.8 MiB -49352.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.5 MiB     -1.3 MiB           1       count = 0
    34     59.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.5 MiB      0.0 MiB           1       came_from = {}
    37     63.8 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.2 MiB  -2679.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.9 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.9 MiB      0.0 MiB        1083       while not open_set.empty():
    47     66.9 MiB      0.0 MiB        1083           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.9 MiB      0.0 MiB        1083           current = open_set.get()[2]
    53     66.9 MiB      0.0 MiB        1083           open_set_hash.remove(current)
    54                                         
    55     66.9 MiB      0.0 MiB        1083           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.9 MiB      0.0 MiB        1083           if current == end:
    60     66.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.9 MiB      0.0 MiB        9738           for neighbor in current.neighbors:
    65     66.9 MiB      0.0 MiB        8656               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.9 MiB      0.0 MiB        4328                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.9 MiB      0.0 MiB        4328                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.9 MiB      0.0 MiB        8656               if temp_g_score < g_score[neighbor]:
    71     66.9 MiB      0.0 MiB        1271                   came_from[neighbor] = current
    72     66.9 MiB      0.0 MiB        1271                   g_score[neighbor] = temp_g_score
    73     66.9 MiB      0.0 MiB        1271                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.9 MiB      0.0 MiB        1271                   if neighbor not in open_set_hash:
    75     66.9 MiB      0.0 MiB        1271                       count += 1
    76     66.9 MiB      0.0 MiB        1271                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.9 MiB      0.0 MiB        1271                       open_set_hash.add(neighbor)
    78                                                             
    79     66.9 MiB      0.0 MiB        1082           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.9 MiB      0.0 MiB        1082           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     66.9 MiB     66.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     66.9 MiB      0.0 MiB         257       for row in grid:
    30     66.9 MiB      0.0 MiB       65792           for spot in row:
    31     66.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.9 MiB      0.0 MiB           1       count = 0
    34     66.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.9 MiB      0.0 MiB           1       came_from = {}
    37     68.2 MiB -81747.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.2 MiB     -4.0 MiB           1       g_score[start] = 0
    39     65.2 MiB -21207.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.8 MiB     -2.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.8 MiB -26082.3 MiB        2002       while not open_set.empty():
    47     62.8 MiB -26082.5 MiB        2002           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.8 MiB -26082.8 MiB        2002           current = open_set.get()[2]
    53     62.8 MiB -26083.3 MiB        2002           open_set_hash.remove(current)
    54                                         
    55     62.8 MiB -26083.5 MiB        2002           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.8 MiB -26083.8 MiB        2002           if current == end:
    60     48.8 MiB    -13.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.8 MiB -234666.5 MiB       18009           for neighbor in current.neighbors:
    65     62.8 MiB -208586.6 MiB       16008               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.8 MiB -104309.9 MiB        8004                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.8 MiB -104279.9 MiB        8004                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.8 MiB -208593.4 MiB       16008               if temp_g_score < g_score[neighbor]:
    71     62.8 MiB -30108.8 MiB        2360                   came_from[neighbor] = current
    72     62.8 MiB -30109.1 MiB        2360                   g_score[neighbor] = temp_g_score
    73     62.8 MiB -30109.1 MiB        2360                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.8 MiB -30109.2 MiB        2360                   if neighbor not in open_set_hash:
    75     62.8 MiB -30109.3 MiB        2360                       count += 1
    76     62.8 MiB -30109.6 MiB        2360                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.8 MiB -30109.9 MiB        2360                       open_set_hash.add(neighbor)
    78                                                             
    79     62.8 MiB -26081.4 MiB        2001           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.8 MiB -26082.0 MiB        2001           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     49.3 MiB     49.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     52.2 MiB   -732.9 MiB         257       for row in grid:
    30     52.2 MiB -188406.8 MiB       65792           for spot in row:
    31     52.2 MiB -187675.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     46.6 MiB     -5.5 MiB           1       count = 0
    34     46.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     46.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     46.7 MiB      0.0 MiB           1       came_from = {}
    37     52.5 MiB   -275.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     52.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     56.9 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     56.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     56.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     56.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     56.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     57.0 MiB  -5102.9 MiB        5400       while not open_set.empty():
    47     57.0 MiB  -5102.9 MiB        5400           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     57.0 MiB  -5102.9 MiB        5400           current = open_set.get()[2]
    53     57.0 MiB  -5102.9 MiB        5400           open_set_hash.remove(current)
    54                                         
    55     57.0 MiB  -5102.9 MiB        5400           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     57.0 MiB  -5102.9 MiB        5400           if current == end:
    60     56.1 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     57.0 MiB -45918.5 MiB       48591           for neighbor in current.neighbors:
    65     57.0 MiB -40815.6 MiB       43192               if current.row != neighbor.row and current.col != neighbor.col:
    66     57.0 MiB -20407.8 MiB       21596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     57.0 MiB -20407.8 MiB       21596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     57.0 MiB -40815.6 MiB       43192               if temp_g_score < g_score[neighbor]:
    71     57.0 MiB  -5434.2 MiB        5878                   came_from[neighbor] = current
    72     57.0 MiB  -5434.3 MiB        5878                   g_score[neighbor] = temp_g_score
    73     57.0 MiB  -5434.3 MiB        5878                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     57.0 MiB  -5434.3 MiB        5878                   if neighbor not in open_set_hash:
    75     57.0 MiB  -5434.3 MiB        5878                       count += 1
    76     57.0 MiB  -5434.3 MiB        5878                       open_set.put((f_score[neighbor], count, neighbor))
    77     57.0 MiB  -5435.5 MiB        5878                       open_set_hash.add(neighbor)
    78                                                             
    79     57.0 MiB  -5102.9 MiB        5399           if draw is not None:
    80                                                     draw()
    81                                         
    82     57.0 MiB  -5102.9 MiB        5399           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.4 MiB     94.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.4 MiB    -34.1 MiB         257       for row in grid:
    30     94.4 MiB  -8770.1 MiB       65792           for spot in row:
    31     94.4 MiB  -8736.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.0 MiB     -0.3 MiB           1       count = 0
    34     94.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.0 MiB      0.0 MiB           1       came_from = {}
    37     98.4 MiB   -874.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.9 MiB      1.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.0 MiB      0.0 MiB        1104       while not open_set.empty():
    47    100.0 MiB      0.0 MiB        1104           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.0 MiB      0.0 MiB        1104           current = open_set.get()[2]
    53    100.0 MiB      0.0 MiB        1104           open_set_hash.remove(current)
    54                                         
    55    100.0 MiB      0.0 MiB        1104           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.0 MiB      0.0 MiB        1104           if current == end:
    60    100.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.0 MiB      0.0 MiB        9927           for neighbor in current.neighbors:
    65    100.0 MiB      0.0 MiB        8824               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.0 MiB      0.0 MiB        4412                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.0 MiB      0.0 MiB        4412                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.0 MiB      0.0 MiB        8824               if temp_g_score < g_score[neighbor]:
    71    100.0 MiB      0.1 MiB        1494                   came_from[neighbor] = current
    72    100.0 MiB      0.0 MiB        1494                   g_score[neighbor] = temp_g_score
    73    100.0 MiB      0.0 MiB        1494                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.0 MiB      0.0 MiB        1494                   if neighbor not in open_set_hash:
    75    100.0 MiB      0.0 MiB        1494                       count += 1
    76    100.0 MiB      0.0 MiB        1494                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.0 MiB      0.0 MiB        1494                       open_set_hash.add(neighbor)
    78                                                             
    79    100.0 MiB      0.0 MiB        1103           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.0 MiB      0.0 MiB        1103           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.0 MiB    100.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.0 MiB   -493.0 MiB         257       for row in grid:
    30    100.0 MiB -125956.8 MiB       65792           for spot in row:
    31    100.0 MiB -125465.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.9 MiB     -3.1 MiB           1       count = 0
    34     96.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.9 MiB      0.0 MiB           1       came_from = {}
    37     98.6 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.8 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.8 MiB      0.0 MiB         155       while not open_set.empty():
    47    101.8 MiB      0.0 MiB         155           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.8 MiB      0.0 MiB         155           current = open_set.get()[2]
    53    101.8 MiB      0.0 MiB         155           open_set_hash.remove(current)
    54                                         
    55    101.8 MiB      0.0 MiB         155           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.8 MiB      0.0 MiB         155           if current == end:
    60    101.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.8 MiB      0.0 MiB        1386           for neighbor in current.neighbors:
    65    101.8 MiB      0.0 MiB        1232               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.8 MiB      0.0 MiB         616                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.8 MiB      0.0 MiB         616                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.8 MiB      0.0 MiB        1232               if temp_g_score < g_score[neighbor]:
    71    101.8 MiB      0.0 MiB         235                   came_from[neighbor] = current
    72    101.8 MiB      0.0 MiB         235                   g_score[neighbor] = temp_g_score
    73    101.8 MiB      0.0 MiB         235                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.8 MiB      0.0 MiB         235                   if neighbor not in open_set_hash:
    75    101.8 MiB      0.0 MiB         235                       count += 1
    76    101.8 MiB      0.0 MiB         235                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.8 MiB      0.0 MiB         235                       open_set_hash.add(neighbor)
    78                                                             
    79    101.8 MiB      0.0 MiB         154           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.8 MiB      0.0 MiB         154           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.8 MiB    101.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.8 MiB  -1338.7 MiB         257       for row in grid:
    30    101.8 MiB -342911.0 MiB       65792           for spot in row:
    31    101.8 MiB -341576.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.0 MiB     -6.8 MiB           1       count = 0
    34     95.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.0 MiB      0.0 MiB           1       came_from = {}
    37     95.7 MiB -49518.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.6 MiB -18005.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.6 MiB      0.0 MiB        1260       while not open_set.empty():
    47     97.6 MiB      0.0 MiB        1260           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.6 MiB      0.0 MiB        1260           current = open_set.get()[2]
    53     97.6 MiB      0.0 MiB        1260           open_set_hash.remove(current)
    54                                         
    55     97.6 MiB      0.0 MiB        1260           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.6 MiB      0.0 MiB        1260           if current == end:
    60     97.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.6 MiB      0.0 MiB       11331           for neighbor in current.neighbors:
    65     97.6 MiB      0.0 MiB       10072               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.6 MiB      0.0 MiB        5036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.6 MiB      0.0 MiB        5036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.6 MiB      0.0 MiB       10072               if temp_g_score < g_score[neighbor]:
    71     97.6 MiB      0.0 MiB        1470                   came_from[neighbor] = current
    72     97.6 MiB      0.0 MiB        1470                   g_score[neighbor] = temp_g_score
    73     97.6 MiB      0.0 MiB        1470                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.6 MiB      0.0 MiB        1470                   if neighbor not in open_set_hash:
    75     97.6 MiB      0.0 MiB        1470                       count += 1
    76     97.6 MiB      0.0 MiB        1470                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.6 MiB      0.0 MiB        1470                       open_set_hash.add(neighbor)
    78                                                             
    79     97.6 MiB      0.0 MiB        1259           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.6 MiB      0.0 MiB        1259           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.6 MiB     97.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.6 MiB   -340.9 MiB         257       for row in grid:
    30     97.6 MiB -87252.5 MiB       65792           for spot in row:
    31     97.6 MiB -86913.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.3 MiB     -2.3 MiB           1       count = 0
    34     95.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.3 MiB      0.0 MiB           1       came_from = {}
    37     96.7 MiB -15235.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.1 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.1 MiB    -41.3 MiB        1045       while not open_set.empty():
    47    101.1 MiB    -41.3 MiB        1045           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.1 MiB    -41.4 MiB        1045           current = open_set.get()[2]
    53    101.1 MiB    -41.4 MiB        1045           open_set_hash.remove(current)
    54                                         
    55    101.1 MiB    -41.4 MiB        1045           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.1 MiB    -41.4 MiB        1045           if current == end:
    60    100.0 MiB     -1.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.1 MiB   -365.5 MiB        9396           for neighbor in current.neighbors:
    65    101.1 MiB   -324.4 MiB        8352               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.1 MiB   -163.1 MiB        4176                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.1 MiB   -161.3 MiB        4176                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.1 MiB   -324.7 MiB        8352               if temp_g_score < g_score[neighbor]:
    71    101.1 MiB    -55.9 MiB        1277                   came_from[neighbor] = current
    72    101.1 MiB    -55.9 MiB        1277                   g_score[neighbor] = temp_g_score
    73    101.1 MiB    -55.9 MiB        1277                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.1 MiB    -55.9 MiB        1277                   if neighbor not in open_set_hash:
    75    101.1 MiB    -55.9 MiB        1277                       count += 1
    76    101.1 MiB    -56.3 MiB        1277                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.1 MiB    -56.3 MiB        1277                       open_set_hash.add(neighbor)
    78                                                             
    79    101.1 MiB    -41.3 MiB        1044           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.1 MiB    -41.3 MiB        1044           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.0 MiB    100.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.0 MiB   -818.3 MiB         257       for row in grid:
    30    100.0 MiB -209860.2 MiB       65792           for spot in row:
    31    100.0 MiB -209049.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.3 MiB     -9.6 MiB           1       count = 0
    34     90.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     90.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     90.3 MiB      0.0 MiB           1       came_from = {}
    37     90.5 MiB -67180.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     89.0 MiB     -1.5 MiB           1       g_score[start] = 0
    39     92.1 MiB -66538.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     88.5 MiB     -3.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     88.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     88.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     88.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     88.5 MiB  -3526.5 MiB        4896       while not open_set.empty():
    47     88.5 MiB  -3526.5 MiB        4896           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     88.5 MiB  -3526.6 MiB        4896           current = open_set.get()[2]
    53     88.5 MiB  -3526.6 MiB        4896           open_set_hash.remove(current)
    54                                         
    55     88.5 MiB  -3526.6 MiB        4896           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     88.5 MiB  -3526.6 MiB        4896           if current == end:
    60     86.6 MiB     -1.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     86.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     88.5 MiB -31733.8 MiB       44055           for neighbor in current.neighbors:
    65     88.5 MiB -28207.4 MiB       39160               if current.row != neighbor.row and current.col != neighbor.col:
    66     88.5 MiB -14105.3 MiB       19580                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     88.5 MiB -14102.2 MiB       19580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     88.5 MiB -28207.5 MiB       39160               if temp_g_score < g_score[neighbor]:
    71     88.5 MiB  -3729.5 MiB        5290                   came_from[neighbor] = current
    72     88.5 MiB  -3729.6 MiB        5290                   g_score[neighbor] = temp_g_score
    73     88.5 MiB  -3729.6 MiB        5290                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     88.5 MiB  -3729.6 MiB        5290                   if neighbor not in open_set_hash:
    75     88.5 MiB  -3729.7 MiB        5290                       count += 1
    76     88.5 MiB  -3729.7 MiB        5290                       open_set.put((f_score[neighbor], count, neighbor))
    77     88.5 MiB  -3729.7 MiB        5290                       open_set_hash.add(neighbor)
    78                                                             
    79     88.5 MiB  -3526.5 MiB        4895           if draw is not None:
    80                                                     draw()
    81                                         
    82     88.5 MiB  -3526.5 MiB        4895           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     86.8 MiB     -4.2 MiB         257       for row in grid:
    30     86.8 MiB  -1067.4 MiB       65792           for spot in row:
    31     86.8 MiB  -1062.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     86.8 MiB      0.0 MiB           1       count = 0
    34     86.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     86.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     86.8 MiB      0.0 MiB           1       came_from = {}
    37     88.2 MiB -878546.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.2 MiB    -22.0 MiB           1       g_score[start] = 0
    39     68.9 MiB -29095.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.8 MiB     -2.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.8 MiB      0.0 MiB         495       while not open_set.empty():
    47     66.8 MiB      0.0 MiB         495           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.8 MiB      0.0 MiB         495           current = open_set.get()[2]
    53     66.8 MiB      0.0 MiB         495           open_set_hash.remove(current)
    54                                         
    55     66.8 MiB      0.0 MiB         495           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.8 MiB      0.0 MiB         495           if current == end:
    60     66.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.8 MiB      0.0 MiB        4446           for neighbor in current.neighbors:
    65     66.8 MiB      0.0 MiB        3952               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.8 MiB      0.0 MiB        1976                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.8 MiB      0.0 MiB        1976                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.8 MiB      0.0 MiB        3952               if temp_g_score < g_score[neighbor]:
    71     66.8 MiB      0.0 MiB        1159                   came_from[neighbor] = current
    72     66.8 MiB      0.0 MiB        1159                   g_score[neighbor] = temp_g_score
    73     66.8 MiB      0.0 MiB        1159                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.8 MiB      0.0 MiB        1159                   if neighbor not in open_set_hash:
    75     66.8 MiB      0.0 MiB        1159                       count += 1
    76     66.8 MiB      0.0 MiB        1159                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.8 MiB      0.0 MiB        1159                       open_set_hash.add(neighbor)
    78                                                             
    79     66.8 MiB      0.0 MiB         494           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.8 MiB      0.0 MiB         494           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     66.8 MiB     66.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     66.8 MiB    -54.0 MiB         257       for row in grid:
    30     66.8 MiB -13692.6 MiB       65792           for spot in row:
    31     66.8 MiB -13639.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     65.3 MiB     -1.5 MiB           1       count = 0
    34     65.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     65.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     65.3 MiB      0.0 MiB           1       came_from = {}
    37     65.5 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.8 MiB  -7315.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.8 MiB   -182.1 MiB        9322       while not open_set.empty():
    47     66.8 MiB   -182.1 MiB        9322           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.8 MiB   -182.1 MiB        9322           current = open_set.get()[2]
    53     66.8 MiB   -182.1 MiB        9322           open_set_hash.remove(current)
    54                                         
    55     66.8 MiB   -182.1 MiB        9322           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.8 MiB   -182.1 MiB        9322           if current == end:
    60     66.7 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.8 MiB  -1638.3 MiB       83889           for neighbor in current.neighbors:
    65     66.8 MiB  -1456.3 MiB       74568               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.8 MiB   -728.2 MiB       37284                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.8 MiB   -728.1 MiB       37284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.8 MiB  -1456.3 MiB       74568               if temp_g_score < g_score[neighbor]:
    71     66.8 MiB   -194.0 MiB        9950                   came_from[neighbor] = current
    72     66.8 MiB   -194.0 MiB        9950                   g_score[neighbor] = temp_g_score
    73     66.8 MiB   -194.0 MiB        9950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.8 MiB   -194.0 MiB        9950                   if neighbor not in open_set_hash:
    75     66.8 MiB   -194.0 MiB        9950                       count += 1
    76     66.8 MiB   -194.0 MiB        9950                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.8 MiB   -194.0 MiB        9950                       open_set_hash.add(neighbor)
    78                                                             
    79     66.8 MiB   -182.1 MiB        9321           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.8 MiB   -182.1 MiB        9321           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.5 MiB    100.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.5 MiB   -737.8 MiB         257       for row in grid:
    30    100.5 MiB -189180.4 MiB       65792           for spot in row:
    31    100.5 MiB -188446.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.5 MiB     -5.0 MiB           1       count = 0
    34     95.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.5 MiB      0.0 MiB           1       came_from = {}
    37     95.7 MiB -44138.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.8 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.8 MiB      0.0 MiB         192       while not open_set.empty():
    47     97.8 MiB      0.0 MiB         192           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.8 MiB      0.0 MiB         192           current = open_set.get()[2]
    53     97.8 MiB      0.0 MiB         192           open_set_hash.remove(current)
    54                                         
    55     97.8 MiB      0.0 MiB         192           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.8 MiB      0.0 MiB         192           if current == end:
    60     97.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.8 MiB      0.0 MiB        1719           for neighbor in current.neighbors:
    65     97.8 MiB      0.0 MiB        1528               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.8 MiB      0.0 MiB         764                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.8 MiB      0.0 MiB         764                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.8 MiB      0.0 MiB        1528               if temp_g_score < g_score[neighbor]:
    71     97.8 MiB      0.0 MiB         330                   came_from[neighbor] = current
    72     97.8 MiB      0.0 MiB         330                   g_score[neighbor] = temp_g_score
    73     97.8 MiB      0.0 MiB         330                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.8 MiB      0.0 MiB         330                   if neighbor not in open_set_hash:
    75     97.8 MiB      0.0 MiB         330                       count += 1
    76     97.8 MiB      0.0 MiB         330                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.8 MiB      0.0 MiB         330                       open_set_hash.add(neighbor)
    78                                                             
    79     97.8 MiB      0.0 MiB         191           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.8 MiB      0.0 MiB         191           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.8 MiB     97.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.8 MiB   -202.7 MiB         257       for row in grid:
    30     97.8 MiB -51729.2 MiB       65792           for spot in row:
    31     97.8 MiB -51527.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.9 MiB     -1.9 MiB           1       count = 0
    34     95.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.9 MiB      0.0 MiB           1       came_from = {}
    37     99.3 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.0 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.0 MiB      0.0 MiB         328       while not open_set.empty():
    47    103.0 MiB      0.0 MiB         328           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.0 MiB      0.0 MiB         328           current = open_set.get()[2]
    53    103.0 MiB      0.0 MiB         328           open_set_hash.remove(current)
    54                                         
    55    103.0 MiB      0.0 MiB         328           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.0 MiB      0.0 MiB         328           if current == end:
    60    103.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.0 MiB      0.0 MiB        2943           for neighbor in current.neighbors:
    65    103.0 MiB      0.0 MiB        2616               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.0 MiB      0.0 MiB        1308                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.0 MiB      0.0 MiB        1308                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.0 MiB      0.0 MiB        2616               if temp_g_score < g_score[neighbor]:
    71    103.0 MiB      0.0 MiB         662                   came_from[neighbor] = current
    72    103.0 MiB      0.0 MiB         662                   g_score[neighbor] = temp_g_score
    73    103.0 MiB      0.0 MiB         662                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.0 MiB      0.0 MiB         662                   if neighbor not in open_set_hash:
    75    103.0 MiB      0.0 MiB         662                       count += 1
    76    103.0 MiB      0.0 MiB         662                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.0 MiB      0.0 MiB         662                       open_set_hash.add(neighbor)
    78                                                             
    79    103.0 MiB      0.0 MiB         327           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.0 MiB      0.0 MiB         327           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.0 MiB    103.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.0 MiB     -5.0 MiB         257       for row in grid:
    30    103.0 MiB  -1282.1 MiB       65792           for spot in row:
    31    103.0 MiB  -1277.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.9 MiB     -0.0 MiB           1       count = 0
    34    102.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.9 MiB      0.0 MiB           1       came_from = {}
    37    104.7 MiB  -1883.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.6 MiB     -0.1 MiB           1       g_score[start] = 0
    39    105.9 MiB -31504.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.9 MiB      0.0 MiB        1376       while not open_set.empty():
    47    105.9 MiB      0.0 MiB        1376           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.9 MiB      0.0 MiB        1376           current = open_set.get()[2]
    53    105.9 MiB      0.0 MiB        1376           open_set_hash.remove(current)
    54                                         
    55    105.9 MiB      0.0 MiB        1376           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.9 MiB      0.0 MiB        1376           if current == end:
    60    105.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.9 MiB      0.0 MiB       12375           for neighbor in current.neighbors:
    65    105.9 MiB      0.0 MiB       11000               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.9 MiB      0.0 MiB        5500                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.9 MiB      0.0 MiB        5500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.9 MiB      0.0 MiB       11000               if temp_g_score < g_score[neighbor]:
    71    105.9 MiB      0.0 MiB        1750                   came_from[neighbor] = current
    72    105.9 MiB      0.0 MiB        1750                   g_score[neighbor] = temp_g_score
    73    105.9 MiB      0.0 MiB        1750                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.9 MiB      0.0 MiB        1750                   if neighbor not in open_set_hash:
    75    105.9 MiB      0.0 MiB        1750                       count += 1
    76    105.9 MiB      0.0 MiB        1750                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.9 MiB      0.0 MiB        1750                       open_set_hash.add(neighbor)
    78                                                             
    79    105.9 MiB      0.0 MiB        1375           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.9 MiB      0.0 MiB        1375           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.9 MiB    105.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.9 MiB   -134.6 MiB         257       for row in grid:
    30    105.9 MiB -34474.8 MiB       65792           for spot in row:
    31    105.9 MiB -34340.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.0 MiB     -0.9 MiB           1       count = 0
    34    105.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.0 MiB      0.0 MiB           1       came_from = {}
    37    108.7 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.1 MiB      1.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.1 MiB      0.0 MiB        3744       while not open_set.empty():
    47    110.1 MiB      0.0 MiB        3744           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.1 MiB      0.0 MiB        3744           current = open_set.get()[2]
    53    110.1 MiB      0.0 MiB        3744           open_set_hash.remove(current)
    54                                         
    55    110.1 MiB      0.0 MiB        3744           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.1 MiB      0.0 MiB        3744           if current == end:
    60    110.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.1 MiB      0.0 MiB       33687           for neighbor in current.neighbors:
    65    110.1 MiB      0.0 MiB       29944               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.1 MiB      0.0 MiB       14972                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.1 MiB      0.0 MiB       14972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.1 MiB      0.0 MiB       29944               if temp_g_score < g_score[neighbor]:
    71    110.1 MiB      0.0 MiB        4090                   came_from[neighbor] = current
    72    110.1 MiB      0.0 MiB        4090                   g_score[neighbor] = temp_g_score
    73    110.1 MiB      0.0 MiB        4090                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.1 MiB      0.0 MiB        4090                   if neighbor not in open_set_hash:
    75    110.1 MiB      0.0 MiB        4090                       count += 1
    76    110.1 MiB      0.0 MiB        4090                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.1 MiB      0.0 MiB        4090                       open_set_hash.add(neighbor)
    78                                                             
    79    110.1 MiB      0.0 MiB        3743           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.1 MiB      0.0 MiB        3743           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.1 MiB    110.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.1 MiB      0.0 MiB         257       for row in grid:
    30    110.1 MiB      0.0 MiB       65792           for spot in row:
    31    110.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.1 MiB      0.0 MiB           1       count = 0
    34    110.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.1 MiB      0.0 MiB           1       came_from = {}
    37    112.2 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.0 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.1 MiB -37615.8 MiB        4929       while not open_set.empty():
    47    114.1 MiB -37615.9 MiB        4929           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.1 MiB -37616.0 MiB        4929           current = open_set.get()[2]
    53    114.1 MiB -37616.1 MiB        4929           open_set_hash.remove(current)
    54                                         
    55    114.1 MiB -37616.5 MiB        4929           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.1 MiB -37616.8 MiB        4929           if current == end:
    60    102.4 MiB    -11.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.1 MiB -338488.7 MiB       44352           for neighbor in current.neighbors:
    65    114.1 MiB -300875.5 MiB       39424               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.1 MiB -150446.1 MiB       19712                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.1 MiB -150431.2 MiB       19712                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.1 MiB -300878.6 MiB       39424               if temp_g_score < g_score[neighbor]:
    71    114.1 MiB -39849.6 MiB        5325                   came_from[neighbor] = current
    72    114.1 MiB -39849.7 MiB        5325                   g_score[neighbor] = temp_g_score
    73    114.1 MiB -39850.1 MiB        5325                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.1 MiB -39850.1 MiB        5325                   if neighbor not in open_set_hash:
    75    114.1 MiB -39850.2 MiB        5325                       count += 1
    76    114.1 MiB -39851.0 MiB        5325                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.1 MiB -39851.5 MiB        5325                       open_set_hash.add(neighbor)
    78                                                             
    79    114.1 MiB -37615.1 MiB        4928           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.1 MiB -37615.6 MiB        4928           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.4 MiB    102.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.4 MiB  -4406.4 MiB         257       for row in grid:
    30    102.4 MiB -1130405.4 MiB       65792           for spot in row:
    31    102.4 MiB -1126014.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     79.4 MiB    -23.0 MiB           1       count = 0
    34     79.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     79.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     79.4 MiB      0.0 MiB           1       came_from = {}
    37     80.3 MiB -682483.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.7 MiB    -23.6 MiB           1       g_score[start] = 0
    39     59.5 MiB -19923.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     59.2 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     59.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     59.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     59.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.8 MiB    -19.4 MiB         728       while not open_set.empty():
    47     59.8 MiB    -19.5 MiB         728           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.8 MiB    -19.3 MiB         728           current = open_set.get()[2]
    53     59.8 MiB    -19.5 MiB         728           open_set_hash.remove(current)
    54                                         
    55     59.8 MiB    -19.5 MiB         728           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.8 MiB    -19.5 MiB         728           if current == end:
    60     59.7 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.8 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.8 MiB   -174.8 MiB        6543           for neighbor in current.neighbors:
    65     59.8 MiB   -155.4 MiB        5816               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.8 MiB    -77.8 MiB        2908                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.8 MiB    -77.6 MiB        2908                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.8 MiB   -155.4 MiB        5816               if temp_g_score < g_score[neighbor]:
    71     59.8 MiB    -24.7 MiB         940                   came_from[neighbor] = current
    72     59.8 MiB    -24.8 MiB         940                   g_score[neighbor] = temp_g_score
    73     59.8 MiB    -24.8 MiB         940                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.8 MiB    -24.8 MiB         940                   if neighbor not in open_set_hash:
    75     59.8 MiB    -24.8 MiB         940                       count += 1
    76     59.8 MiB    -24.7 MiB         940                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.8 MiB    -24.8 MiB         940                       open_set_hash.add(neighbor)
    78                                                             
    79     59.8 MiB    -19.5 MiB         727           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.8 MiB    -19.5 MiB         727           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.8 MiB     59.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.0 MiB   -151.5 MiB         257       for row in grid:
    30     61.0 MiB -38818.2 MiB       65792           for spot in row:
    31     61.0 MiB -38667.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.9 MiB     -1.1 MiB           1       count = 0
    34     59.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.9 MiB      0.0 MiB           1       came_from = {}
    37     60.2 MiB -109566.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.6 MiB     -1.7 MiB           1       g_score[start] = 0
    39     63.3 MiB      4.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.8 MiB      0.0 MiB        5130       while not open_set.empty():
    47     63.8 MiB      0.0 MiB        5130           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.8 MiB      0.0 MiB        5130           current = open_set.get()[2]
    53     63.8 MiB      0.0 MiB        5130           open_set_hash.remove(current)
    54                                         
    55     63.8 MiB      0.0 MiB        5130           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.8 MiB      0.0 MiB        5130           if current == end:
    60     63.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.8 MiB      0.0 MiB       46161           for neighbor in current.neighbors:
    65     63.8 MiB      0.0 MiB       41032               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.8 MiB      0.0 MiB       20516                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.8 MiB      0.0 MiB       20516                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.8 MiB      0.0 MiB       41032               if temp_g_score < g_score[neighbor]:
    71     63.8 MiB      0.4 MiB        5536                   came_from[neighbor] = current
    72     63.8 MiB      0.0 MiB        5536                   g_score[neighbor] = temp_g_score
    73     63.8 MiB      0.0 MiB        5536                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.8 MiB      0.0 MiB        5536                   if neighbor not in open_set_hash:
    75     63.8 MiB      0.0 MiB        5536                       count += 1
    76     63.8 MiB      0.0 MiB        5536                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.8 MiB      0.1 MiB        5536                       open_set_hash.add(neighbor)
    78                                                             
    79     63.8 MiB      0.0 MiB        5129           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.8 MiB      0.0 MiB        5129           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.1 MiB    102.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.1 MiB   -144.1 MiB         257       for row in grid:
    30    102.1 MiB -36839.3 MiB       65792           for spot in row:
    31    102.1 MiB -36696.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.6 MiB     -1.5 MiB           1       count = 0
    34    100.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.6 MiB      0.0 MiB           1       came_from = {}
    37    104.0 MiB   -644.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.6 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.6 MiB      0.0 MiB        1938       while not open_set.empty():
    47    107.6 MiB      0.0 MiB        1938           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.6 MiB      0.0 MiB        1938           current = open_set.get()[2]
    53    107.6 MiB      0.0 MiB        1938           open_set_hash.remove(current)
    54                                         
    55    107.6 MiB      0.0 MiB        1938           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.6 MiB      0.0 MiB        1938           if current == end:
    60    107.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.6 MiB      0.0 MiB       17433           for neighbor in current.neighbors:
    65    107.6 MiB      0.0 MiB       15496               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.6 MiB      0.0 MiB        7748                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.6 MiB      0.0 MiB        7748                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.6 MiB      0.0 MiB       15496               if temp_g_score < g_score[neighbor]:
    71    107.6 MiB      0.0 MiB        2190                   came_from[neighbor] = current
    72    107.6 MiB      0.0 MiB        2190                   g_score[neighbor] = temp_g_score
    73    107.6 MiB      0.0 MiB        2190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.6 MiB      0.0 MiB        2190                   if neighbor not in open_set_hash:
    75    107.6 MiB      0.0 MiB        2190                       count += 1
    76    107.6 MiB      0.0 MiB        2190                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.6 MiB      0.0 MiB        2190                       open_set_hash.add(neighbor)
    78                                                             
    79    107.6 MiB      0.0 MiB        1937           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.6 MiB      0.0 MiB        1937           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.6 MiB    107.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.6 MiB    -59.7 MiB         257       for row in grid:
    30    107.6 MiB -15263.8 MiB       65792           for spot in row:
    31    107.6 MiB -15204.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.3 MiB     -0.3 MiB           1       count = 0
    34    107.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.3 MiB      0.0 MiB           1       came_from = {}
    37    111.4 MiB      4.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.0 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.0 MiB  -7420.1 MiB        6142       while not open_set.empty():
    47    114.0 MiB  -7420.1 MiB        6142           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.0 MiB  -7420.3 MiB        6142           current = open_set.get()[2]
    53    114.0 MiB  -7420.5 MiB        6142           open_set_hash.remove(current)
    54                                         
    55    114.0 MiB  -7420.7 MiB        6142           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.0 MiB  -7421.0 MiB        6142           if current == end:
    60    109.3 MiB     -4.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.0 MiB -66766.0 MiB       55269           for neighbor in current.neighbors:
    65    114.0 MiB -59346.8 MiB       49128               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.0 MiB -29675.2 MiB       24564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.0 MiB -29672.3 MiB       24564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.0 MiB -59349.4 MiB       49128               if temp_g_score < g_score[neighbor]:
    71    114.0 MiB  -7959.6 MiB        6602                   came_from[neighbor] = current
    72    114.0 MiB  -7959.6 MiB        6602                   g_score[neighbor] = temp_g_score
    73    114.0 MiB  -7959.6 MiB        6602                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.0 MiB  -7959.6 MiB        6602                   if neighbor not in open_set_hash:
    75    114.0 MiB  -7959.6 MiB        6602                       count += 1
    76    114.0 MiB  -7959.6 MiB        6602                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.0 MiB  -7959.6 MiB        6602                       open_set_hash.add(neighbor)
    78                                                             
    79    114.0 MiB  -7420.1 MiB        6141           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.0 MiB  -7420.1 MiB        6141           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.3 MiB    109.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.3 MiB     -0.6 MiB         257       for row in grid:
    30    109.3 MiB   -153.3 MiB       65792           for spot in row:
    31    109.3 MiB   -152.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.3 MiB     -0.0 MiB           1       count = 0
    34    109.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.3 MiB      0.0 MiB           1       came_from = {}
    37    111.8 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.3 MiB      1.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.3 MiB      0.0 MiB         550       while not open_set.empty():
    47    113.3 MiB      0.0 MiB         550           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.3 MiB      0.0 MiB         550           current = open_set.get()[2]
    53    113.3 MiB      0.0 MiB         550           open_set_hash.remove(current)
    54                                         
    55    113.3 MiB      0.0 MiB         550           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.3 MiB      0.0 MiB         550           if current == end:
    60    113.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.3 MiB      0.0 MiB        4911           for neighbor in current.neighbors:
    65    113.3 MiB      0.0 MiB        4362               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.3 MiB      0.0 MiB        2176                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.3 MiB      0.0 MiB        2186                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.3 MiB      0.0 MiB        4362               if temp_g_score < g_score[neighbor]:
    71    113.3 MiB      0.0 MiB         758                   came_from[neighbor] = current
    72    113.3 MiB      0.0 MiB         758                   g_score[neighbor] = temp_g_score
    73    113.3 MiB      0.0 MiB         758                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.3 MiB      0.0 MiB         758                   if neighbor not in open_set_hash:
    75    113.3 MiB      0.0 MiB         758                       count += 1
    76    113.3 MiB      0.0 MiB         758                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.3 MiB      0.0 MiB         758                       open_set_hash.add(neighbor)
    78                                                             
    79    113.3 MiB      0.0 MiB         549           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.3 MiB      0.0 MiB         549           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.3 MiB    113.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.3 MiB   -501.3 MiB         257       for row in grid:
    30    113.3 MiB -128554.2 MiB       65792           for spot in row:
    31    113.3 MiB -128055.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.4 MiB     -3.9 MiB           1       count = 0
    34    109.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.4 MiB      0.0 MiB           1       came_from = {}
    37    110.4 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.4 MiB  -1032.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.5 MiB      0.0 MiB        3360       while not open_set.empty():
    47    111.5 MiB      0.0 MiB        3360           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.5 MiB      0.0 MiB        3360           current = open_set.get()[2]
    53    111.5 MiB      0.0 MiB        3360           open_set_hash.remove(current)
    54                                         
    55    111.5 MiB      0.0 MiB        3360           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.5 MiB      0.0 MiB        3360           if current == end:
    60    111.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.5 MiB      0.0 MiB       30231           for neighbor in current.neighbors:
    65    111.5 MiB      0.0 MiB       26872               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.5 MiB      0.0 MiB       13436                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.5 MiB      0.0 MiB       13436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.5 MiB      0.0 MiB       26872               if temp_g_score < g_score[neighbor]:
    71    111.5 MiB      0.1 MiB        3762                   came_from[neighbor] = current
    72    111.5 MiB      0.0 MiB        3762                   g_score[neighbor] = temp_g_score
    73    111.5 MiB      0.0 MiB        3762                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.5 MiB      0.0 MiB        3762                   if neighbor not in open_set_hash:
    75    111.5 MiB      0.0 MiB        3762                       count += 1
    76    111.5 MiB      0.0 MiB        3762                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.5 MiB      0.0 MiB        3762                       open_set_hash.add(neighbor)
    78                                                             
    79    111.5 MiB      0.0 MiB        3359           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.5 MiB      0.0 MiB        3359           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.5 MiB    111.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.5 MiB    -22.3 MiB         257       for row in grid:
    30    111.5 MiB  -5702.6 MiB       65792           for spot in row:
    31    111.5 MiB  -5680.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.3 MiB     -0.1 MiB           1       count = 0
    34    111.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.3 MiB      0.0 MiB           1       came_from = {}
    37    111.3 MiB -115825.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.3 MiB     -2.1 MiB           1       g_score[start] = 0
    39    109.3 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.3 MiB      0.0 MiB         336       while not open_set.empty():
    47    109.3 MiB      0.0 MiB         336           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.3 MiB      0.0 MiB         336           current = open_set.get()[2]
    53    109.3 MiB      0.0 MiB         336           open_set_hash.remove(current)
    54                                         
    55    109.3 MiB      0.0 MiB         336           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.3 MiB      0.0 MiB         336           if current == end:
    60    109.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.3 MiB      0.0 MiB        3015           for neighbor in current.neighbors:
    65    109.3 MiB      0.0 MiB        2680               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.3 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.3 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.3 MiB      0.0 MiB        2680               if temp_g_score < g_score[neighbor]:
    71    109.3 MiB      0.0 MiB         438                   came_from[neighbor] = current
    72    109.3 MiB      0.0 MiB         438                   g_score[neighbor] = temp_g_score
    73    109.3 MiB      0.0 MiB         438                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.3 MiB      0.0 MiB         438                   if neighbor not in open_set_hash:
    75    109.3 MiB      0.0 MiB         438                       count += 1
    76    109.3 MiB      0.0 MiB         438                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.3 MiB      0.0 MiB         438                       open_set_hash.add(neighbor)
    78                                                             
    79    109.3 MiB      0.0 MiB         335           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.3 MiB      0.0 MiB         335           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.3 MiB    109.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.3 MiB  -6536.0 MiB         257       for row in grid:
    30    109.3 MiB -1675538.7 MiB       65792           for spot in row:
    31    109.3 MiB -1669025.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     77.2 MiB    -32.0 MiB           1       count = 0
    34     77.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     77.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     77.3 MiB      0.0 MiB           1       came_from = {}
    37     80.1 MiB -11065.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     80.0 MiB     -0.2 MiB           1       g_score[start] = 0
    39     83.5 MiB  -2322.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     83.6 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     83.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     83.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     83.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     84.4 MiB      0.0 MiB         990       while not open_set.empty():
    47     84.4 MiB      0.0 MiB         990           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     84.4 MiB      0.0 MiB         990           current = open_set.get()[2]
    53     84.4 MiB      0.0 MiB         990           open_set_hash.remove(current)
    54                                         
    55     84.4 MiB      0.0 MiB         990           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     84.4 MiB      0.0 MiB         990           if current == end:
    60     84.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     84.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     84.4 MiB      0.4 MiB        8901           for neighbor in current.neighbors:
    65     84.4 MiB      0.1 MiB        7912               if current.row != neighbor.row and current.col != neighbor.col:
    66     84.4 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     84.4 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     84.4 MiB      0.0 MiB        7912               if temp_g_score < g_score[neighbor]:
    71     84.4 MiB      0.1 MiB        1212                   came_from[neighbor] = current
    72     84.4 MiB      0.0 MiB        1212                   g_score[neighbor] = temp_g_score
    73     84.4 MiB      0.0 MiB        1212                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     84.4 MiB      0.0 MiB        1212                   if neighbor not in open_set_hash:
    75     84.4 MiB      0.0 MiB        1212                       count += 1
    76     84.4 MiB      0.1 MiB        1212                       open_set.put((f_score[neighbor], count, neighbor))
    77     84.4 MiB      0.0 MiB        1212                       open_set_hash.add(neighbor)
    78                                                             
    79     84.4 MiB      0.0 MiB         989           if draw is not None:
    80                                                     draw()
    81                                         
    82     84.4 MiB      0.0 MiB         989           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     84.4 MiB     84.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     85.2 MiB  -5246.0 MiB         257       for row in grid:
    30     85.2 MiB -1341995.3 MiB       65792           for spot in row:
    31     85.2 MiB -1336782.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     42.6 MiB    -42.6 MiB           1       count = 0
    34     42.6 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     42.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     42.6 MiB      0.0 MiB           1       came_from = {}
    37     45.4 MiB -67450.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     44.0 MiB     -1.4 MiB           1       g_score[start] = 0
    39     47.4 MiB -31424.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     45.8 MiB     -1.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     45.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     45.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     45.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     46.3 MiB -27720.5 MiB        3850       while not open_set.empty():
    47     46.3 MiB -27720.7 MiB        3850           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     46.3 MiB -27721.1 MiB        3850           current = open_set.get()[2]
    53     46.3 MiB -27721.3 MiB        3850           open_set_hash.remove(current)
    54                                         
    55     46.3 MiB -27721.5 MiB        3850           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     46.3 MiB -27721.8 MiB        3850           if current == end:
    60     39.5 MiB     -6.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     39.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     46.3 MiB -249451.9 MiB       34641           for neighbor in current.neighbors:
    65     46.3 MiB -221730.6 MiB       30792               if current.row != neighbor.row and current.col != neighbor.col:
    66     46.3 MiB -110873.7 MiB       15396                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     46.3 MiB -110860.1 MiB       15396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     46.3 MiB -221735.9 MiB       30792               if temp_g_score < g_score[neighbor]:
    71     46.3 MiB -29914.7 MiB        4238                   came_from[neighbor] = current
    72     46.3 MiB -29914.8 MiB        4238                   g_score[neighbor] = temp_g_score
    73     46.3 MiB -29915.5 MiB        4238                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     46.3 MiB -29915.6 MiB        4238                   if neighbor not in open_set_hash:
    75     46.3 MiB -29915.8 MiB        4238                       count += 1
    76     46.3 MiB -29916.0 MiB        4238                       open_set.put((f_score[neighbor], count, neighbor))
    77     46.3 MiB -29916.1 MiB        4238                       open_set_hash.add(neighbor)
    78                                                             
    79     46.3 MiB -27720.1 MiB        3849           if draw is not None:
    80                                                     draw()
    81                                         
    82     46.3 MiB -27720.3 MiB        3849           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.0 MiB     97.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.0 MiB   -273.6 MiB         257       for row in grid:
    30     97.0 MiB -70201.0 MiB       65792           for spot in row:
    31     97.0 MiB -69928.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.6 MiB     -1.4 MiB           1       count = 0
    34     95.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.6 MiB      0.0 MiB           1       came_from = {}
    37    100.5 MiB   -312.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.4 MiB     -0.0 MiB           1       g_score[start] = 0
    39    104.0 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.1 MiB      0.0 MiB         825       while not open_set.empty():
    47    104.1 MiB      0.0 MiB         825           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.1 MiB      0.0 MiB         825           current = open_set.get()[2]
    53    104.1 MiB      0.0 MiB         825           open_set_hash.remove(current)
    54                                         
    55    104.1 MiB      0.0 MiB         825           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.1 MiB      0.0 MiB         825           if current == end:
    60    104.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.1 MiB      0.0 MiB        7416           for neighbor in current.neighbors:
    65    104.1 MiB      0.0 MiB        6592               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.1 MiB      0.0 MiB        3296                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.1 MiB      0.0 MiB        3296                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.1 MiB      0.0 MiB        6592               if temp_g_score < g_score[neighbor]:
    71    104.1 MiB      0.1 MiB        1005                   came_from[neighbor] = current
    72    104.1 MiB      0.0 MiB        1005                   g_score[neighbor] = temp_g_score
    73    104.1 MiB      0.0 MiB        1005                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.1 MiB      0.0 MiB        1005                   if neighbor not in open_set_hash:
    75    104.1 MiB      0.0 MiB        1005                       count += 1
    76    104.1 MiB      0.0 MiB        1005                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.1 MiB      0.0 MiB        1005                       open_set_hash.add(neighbor)
    78                                                             
    79    104.1 MiB      0.0 MiB         824           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.1 MiB      0.0 MiB         824           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.1 MiB    104.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.1 MiB      0.0 MiB         257       for row in grid:
    30    104.1 MiB      0.0 MiB       65792           for spot in row:
    31    104.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.1 MiB      0.0 MiB           1       count = 0
    34    104.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.1 MiB      0.0 MiB           1       came_from = {}
    37    108.8 MiB   -156.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.4 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.5 MiB      0.0 MiB        1197       while not open_set.empty():
    47    111.5 MiB      0.0 MiB        1197           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.5 MiB      0.0 MiB        1197           current = open_set.get()[2]
    53    111.5 MiB      0.0 MiB        1197           open_set_hash.remove(current)
    54                                         
    55    111.5 MiB      0.0 MiB        1197           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.5 MiB      0.0 MiB        1197           if current == end:
    60    111.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.5 MiB      0.0 MiB       10764           for neighbor in current.neighbors:
    65    111.5 MiB      0.0 MiB        9568               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.5 MiB      0.0 MiB        4784                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.5 MiB      0.0 MiB        4784                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.5 MiB      0.0 MiB        9568               if temp_g_score < g_score[neighbor]:
    71    111.5 MiB      0.1 MiB        1465                   came_from[neighbor] = current
    72    111.5 MiB      0.0 MiB        1465                   g_score[neighbor] = temp_g_score
    73    111.5 MiB      0.0 MiB        1465                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.5 MiB      0.0 MiB        1465                   if neighbor not in open_set_hash:
    75    111.5 MiB      0.0 MiB        1465                       count += 1
    76    111.5 MiB      0.0 MiB        1465                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.5 MiB      0.0 MiB        1465                       open_set_hash.add(neighbor)
    78                                                             
    79    111.5 MiB      0.0 MiB        1196           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.5 MiB      0.0 MiB        1196           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.5 MiB    111.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.5 MiB   -292.9 MiB         257       for row in grid:
    30    111.5 MiB -74950.8 MiB       65792           for spot in row:
    31    111.5 MiB -74658.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.8 MiB     -1.7 MiB           1       count = 0
    34    109.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.8 MiB      0.0 MiB           1       came_from = {}
    37    113.7 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.2 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.2 MiB      0.0 MiB        1044       while not open_set.empty():
    47    116.2 MiB      0.0 MiB        1044           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.2 MiB      0.0 MiB        1044           current = open_set.get()[2]
    53    116.2 MiB      0.0 MiB        1044           open_set_hash.remove(current)
    54                                         
    55    116.2 MiB      0.0 MiB        1044           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.2 MiB      0.0 MiB        1044           if current == end:
    60    116.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.2 MiB      0.0 MiB        9387           for neighbor in current.neighbors:
    65    116.2 MiB      0.0 MiB        8344               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.2 MiB      0.0 MiB        4172                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.2 MiB      0.0 MiB        4172                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.2 MiB      0.0 MiB        8344               if temp_g_score < g_score[neighbor]:
    71    116.2 MiB      0.0 MiB        1244                   came_from[neighbor] = current
    72    116.2 MiB      0.0 MiB        1244                   g_score[neighbor] = temp_g_score
    73    116.2 MiB      0.0 MiB        1244                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.2 MiB      0.0 MiB        1244                   if neighbor not in open_set_hash:
    75    116.2 MiB      0.0 MiB        1244                       count += 1
    76    116.2 MiB      0.0 MiB        1244                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.2 MiB      0.0 MiB        1244                       open_set_hash.add(neighbor)
    78                                                             
    79    116.2 MiB      0.0 MiB        1043           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.2 MiB      0.0 MiB        1043           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.2 MiB    116.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.2 MiB      0.0 MiB         257       for row in grid:
    30    116.2 MiB      0.0 MiB       65792           for spot in row:
    31    116.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    116.2 MiB      0.0 MiB           1       count = 0
    34    116.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    116.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    116.2 MiB      0.0 MiB           1       came_from = {}
    37    116.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.9 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.0 MiB      0.0 MiB        2349       while not open_set.empty():
    47    118.0 MiB      0.0 MiB        2349           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.0 MiB      0.0 MiB        2349           current = open_set.get()[2]
    53    118.0 MiB      0.0 MiB        2349           open_set_hash.remove(current)
    54                                         
    55    118.0 MiB      0.0 MiB        2349           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.0 MiB      0.0 MiB        2349           if current == end:
    60    118.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    118.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.0 MiB      0.0 MiB       21132           for neighbor in current.neighbors:
    65    118.0 MiB      0.0 MiB       18784               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.0 MiB      0.0 MiB        9392                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.0 MiB      0.0 MiB        9392                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.0 MiB      0.0 MiB       18784               if temp_g_score < g_score[neighbor]:
    71    118.0 MiB      0.0 MiB        2749                   came_from[neighbor] = current
    72    118.0 MiB      0.0 MiB        2749                   g_score[neighbor] = temp_g_score
    73    118.0 MiB      0.0 MiB        2749                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.0 MiB      0.0 MiB        2749                   if neighbor not in open_set_hash:
    75    118.0 MiB      0.0 MiB        2749                       count += 1
    76    118.0 MiB      0.0 MiB        2749                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.0 MiB      0.0 MiB        2749                       open_set_hash.add(neighbor)
    78                                                             
    79    118.0 MiB      0.0 MiB        2348           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.0 MiB      0.0 MiB        2348           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.0 MiB    118.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.0 MiB      0.0 MiB         257       for row in grid:
    30    118.0 MiB      0.0 MiB       65792           for spot in row:
    31    118.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    118.0 MiB      0.0 MiB           1       count = 0
    34    118.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    118.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    118.0 MiB      0.0 MiB           1       came_from = {}
    37    119.8 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    119.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    119.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    119.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    119.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    119.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    119.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    119.8 MiB      0.0 MiB         824       while not open_set.empty():
    47    119.8 MiB      0.0 MiB         824           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    119.8 MiB      0.0 MiB         824           current = open_set.get()[2]
    53    119.8 MiB      0.0 MiB         824           open_set_hash.remove(current)
    54                                         
    55    119.8 MiB      0.0 MiB         824           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    119.8 MiB      0.0 MiB         824           if current == end:
    60    119.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    119.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    119.8 MiB      0.0 MiB        7407           for neighbor in current.neighbors:
    65    119.8 MiB      0.0 MiB        6584               if current.row != neighbor.row and current.col != neighbor.col:
    66    119.8 MiB      0.0 MiB        3292                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    119.8 MiB      0.0 MiB        3292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    119.8 MiB      0.0 MiB        6584               if temp_g_score < g_score[neighbor]:
    71    119.8 MiB      0.0 MiB        1250                   came_from[neighbor] = current
    72    119.8 MiB      0.0 MiB        1250                   g_score[neighbor] = temp_g_score
    73    119.8 MiB      0.0 MiB        1250                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    119.8 MiB      0.0 MiB        1250                   if neighbor not in open_set_hash:
    75    119.8 MiB      0.0 MiB        1250                       count += 1
    76    119.8 MiB      0.0 MiB        1250                       open_set.put((f_score[neighbor], count, neighbor))
    77    119.8 MiB      0.0 MiB        1250                       open_set_hash.add(neighbor)
    78                                                             
    79    119.8 MiB      0.0 MiB         823           if draw is not None:
    80                                                     draw()
    81                                         
    82    119.8 MiB      0.0 MiB         823           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    119.8 MiB    119.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    119.8 MiB   -825.9 MiB         257       for row in grid:
    30    119.8 MiB -211970.4 MiB       65792           for spot in row:
    31    119.8 MiB -211147.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.4 MiB     -4.4 MiB           1       count = 0
    34    115.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.4 MiB      0.0 MiB           1       came_from = {}
    37    116.0 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.5 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.5 MiB    -50.3 MiB        4960       while not open_set.empty():
    47    116.5 MiB    -50.3 MiB        4960           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.5 MiB    -50.3 MiB        4960           current = open_set.get()[2]
    53    116.5 MiB    -50.3 MiB        4960           open_set_hash.remove(current)
    54                                         
    55    116.5 MiB    -50.3 MiB        4960           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.5 MiB    -50.3 MiB        4960           if current == end:
    60    116.5 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.5 MiB   -452.8 MiB       44631           for neighbor in current.neighbors:
    65    116.5 MiB   -402.5 MiB       39672               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.5 MiB   -201.2 MiB       19836                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.5 MiB   -201.2 MiB       19836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.5 MiB   -402.5 MiB       39672               if temp_g_score < g_score[neighbor]:
    71    116.5 MiB    -53.8 MiB        5402                   came_from[neighbor] = current
    72    116.5 MiB    -53.8 MiB        5402                   g_score[neighbor] = temp_g_score
    73    116.5 MiB    -53.8 MiB        5402                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.5 MiB    -53.8 MiB        5402                   if neighbor not in open_set_hash:
    75    116.5 MiB    -53.8 MiB        5402                       count += 1
    76    116.5 MiB    -53.8 MiB        5402                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.5 MiB    -53.8 MiB        5402                       open_set_hash.add(neighbor)
    78                                                             
    79    116.5 MiB    -50.3 MiB        4959           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.5 MiB    -50.3 MiB        4959           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.5 MiB    116.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.5 MiB      0.0 MiB         257       for row in grid:
    30    116.5 MiB      0.0 MiB       65792           for spot in row:
    31    116.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    116.5 MiB      0.0 MiB           1       count = 0
    34    116.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    116.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    116.5 MiB      0.0 MiB           1       came_from = {}
    37    117.1 MiB -59495.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.7 MiB     -3.4 MiB           1       g_score[start] = 0
    39    113.7 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.7 MiB  -5109.1 MiB        5900       while not open_set.empty():
    47    113.7 MiB  -5109.2 MiB        5900           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.7 MiB  -5109.2 MiB        5900           current = open_set.get()[2]
    53    113.7 MiB  -5109.2 MiB        5900           open_set_hash.remove(current)
    54                                         
    55    113.7 MiB  -5109.2 MiB        5900           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.7 MiB  -5109.4 MiB        5900           if current == end:
    60    109.3 MiB     -4.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.7 MiB -45956.8 MiB       53091           for neighbor in current.neighbors:
    65    113.7 MiB -40848.7 MiB       47192               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.7 MiB -20429.2 MiB       23596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.7 MiB -20420.6 MiB       23596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.7 MiB -40851.1 MiB       47192               if temp_g_score < g_score[neighbor]:
    71    113.7 MiB  -5514.3 MiB        6334                   came_from[neighbor] = current
    72    113.7 MiB  -5514.3 MiB        6334                   g_score[neighbor] = temp_g_score
    73    113.7 MiB  -5514.3 MiB        6334                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.7 MiB  -5514.3 MiB        6334                   if neighbor not in open_set_hash:
    75    113.7 MiB  -5514.3 MiB        6334                       count += 1
    76    113.7 MiB  -5514.3 MiB        6334                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.7 MiB  -5514.3 MiB        6334                       open_set_hash.add(neighbor)
    78                                                             
    79    113.7 MiB  -5109.1 MiB        5899           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.7 MiB  -5109.1 MiB        5899           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.6 MiB    110.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.6 MiB    -15.0 MiB         257       for row in grid:
    30    110.6 MiB  -3831.3 MiB       65792           for spot in row:
    31    110.6 MiB  -3816.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.2 MiB     -0.4 MiB           1       count = 0
    34    110.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.2 MiB      0.0 MiB           1       came_from = {}
    37    111.3 MiB -125844.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.5 MiB     -3.8 MiB           1       g_score[start] = 0
    39    110.1 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.2 MiB  -4561.4 MiB        4930       while not open_set.empty():
    47    110.2 MiB  -4561.5 MiB        4930           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.2 MiB  -4561.7 MiB        4930           current = open_set.get()[2]
    53    110.2 MiB  -4561.7 MiB        4930           open_set_hash.remove(current)
    54                                         
    55    110.2 MiB  -4561.7 MiB        4930           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.2 MiB  -4561.7 MiB        4930           if current == end:
    60    106.6 MiB     -3.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.2 MiB -41039.0 MiB       44358           for neighbor in current.neighbors:
    65    110.2 MiB -36478.4 MiB       39429               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.2 MiB -18244.0 MiB       19714                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.2 MiB -18235.2 MiB       19715                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.2 MiB -36479.7 MiB       39429               if temp_g_score < g_score[neighbor]:
    71    110.2 MiB  -5176.7 MiB        5663                   came_from[neighbor] = current
    72    110.2 MiB  -5176.7 MiB        5663                   g_score[neighbor] = temp_g_score
    73    110.2 MiB  -5176.7 MiB        5663                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.2 MiB  -5176.7 MiB        5663                   if neighbor not in open_set_hash:
    75    110.2 MiB  -5176.9 MiB        5663                       count += 1
    76    110.2 MiB  -5177.2 MiB        5663                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.2 MiB  -5177.2 MiB        5663                       open_set_hash.add(neighbor)
    78                                                             
    79    110.2 MiB  -4561.3 MiB        4929           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.2 MiB  -4561.3 MiB        4929           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.6 MiB    106.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.6 MiB      0.0 MiB         257       for row in grid:
    30    106.6 MiB      0.0 MiB       65792           for spot in row:
    31    106.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.6 MiB      0.0 MiB           1       count = 0
    34    106.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.6 MiB      0.0 MiB           1       came_from = {}
    37    107.0 MiB -41534.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.6 MiB     -1.4 MiB           1       g_score[start] = 0
    39    107.7 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.7 MiB -119911.4 MiB        5768       while not open_set.empty():
    47    107.7 MiB -119912.3 MiB        5768           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.7 MiB -119913.7 MiB        5768           current = open_set.get()[2]
    53    107.7 MiB -119914.3 MiB        5768           open_set_hash.remove(current)
    54                                         
    55    107.7 MiB -119915.0 MiB        5768           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.7 MiB -119915.5 MiB        5768           if current == end:
    60     69.0 MiB    -38.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.7 MiB -1075846.8 MiB       51594           for neighbor in current.neighbors:
    65    107.7 MiB -955944.1 MiB       45827               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.7 MiB -477474.5 MiB       22862                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.7 MiB -478475.3 MiB       22965                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.7 MiB -955956.0 MiB       45827               if temp_g_score < g_score[neighbor]:
    71    107.7 MiB -125143.4 MiB        6091                   came_from[neighbor] = current
    72    107.7 MiB -125144.0 MiB        6091                   g_score[neighbor] = temp_g_score
    73    107.7 MiB -125145.1 MiB        6091                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.7 MiB -125145.8 MiB        6091                   if neighbor not in open_set_hash:
    75    107.7 MiB -125146.3 MiB        6091                       count += 1
    76    107.7 MiB -125147.6 MiB        6091                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.7 MiB -125148.6 MiB        6091                       open_set_hash.add(neighbor)
    78                                                             
    79    107.7 MiB -119909.7 MiB        5767           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.7 MiB -119910.4 MiB        5767           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.0 MiB     69.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.0 MiB   -246.5 MiB         257       for row in grid:
    30     69.0 MiB -62821.5 MiB       65792           for spot in row:
    31     69.0 MiB -62576.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.7 MiB     -2.4 MiB           1       count = 0
    34     66.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.7 MiB      0.0 MiB           1       came_from = {}
    37     69.1 MiB -28112.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.7 MiB     -1.3 MiB           1       g_score[start] = 0
    39     71.5 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.5 MiB  -1208.8 MiB        2698       while not open_set.empty():
    47     71.5 MiB  -1208.8 MiB        2698           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.5 MiB  -1208.8 MiB        2698           current = open_set.get()[2]
    53     71.5 MiB  -1208.8 MiB        2698           open_set_hash.remove(current)
    54                                         
    55     71.5 MiB  -1208.8 MiB        2698           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.5 MiB  -1208.8 MiB        2698           if current == end:
    60     69.7 MiB     -1.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.5 MiB -10872.2 MiB       24270           for neighbor in current.neighbors:
    65     71.5 MiB  -9663.8 MiB       21573               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.5 MiB  -4834.2 MiB       10786                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.5 MiB  -4829.8 MiB       10787                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.5 MiB  -9664.4 MiB       21573               if temp_g_score < g_score[neighbor]:
    71     71.5 MiB  -1457.5 MiB        3299                   came_from[neighbor] = current
    72     71.5 MiB  -1457.5 MiB        3299                   g_score[neighbor] = temp_g_score
    73     71.5 MiB  -1457.5 MiB        3299                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.5 MiB  -1457.5 MiB        3299                   if neighbor not in open_set_hash:
    75     71.5 MiB  -1457.9 MiB        3299                       count += 1
    76     71.5 MiB  -1458.0 MiB        3299                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.5 MiB  -1458.0 MiB        3299                       open_set_hash.add(neighbor)
    78                                                             
    79     71.5 MiB  -1208.8 MiB        2697           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.5 MiB  -1208.8 MiB        2697           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.7 MiB     69.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.8 MiB  -2122.3 MiB         257       for row in grid:
    30     69.8 MiB -543878.7 MiB       65792           for spot in row:
    31     69.8 MiB -541764.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.1 MiB    -11.6 MiB           1       count = 0
    34     58.4 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     58.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     58.6 MiB      0.0 MiB           1       came_from = {}
    37     63.1 MiB -23237.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.0 MiB     -2.2 MiB           1       g_score[start] = 0
    39     61.0 MiB -1279245.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     33.8 MiB    -27.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     33.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     33.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     33.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     43.6 MiB  -1455.4 MiB       10488       while not open_set.empty():
    47     43.6 MiB  -1455.5 MiB       10488           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     43.6 MiB  -1455.5 MiB       10488           current = open_set.get()[2]
    53     43.6 MiB  -1455.5 MiB       10488           open_set_hash.remove(current)
    54                                         
    55     43.6 MiB  -1455.5 MiB       10488           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     43.6 MiB  -1455.5 MiB       10488           if current == end:
    60     42.1 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     42.2 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     43.6 MiB -13083.8 MiB       94380           for neighbor in current.neighbors:
    65     43.6 MiB -11628.9 MiB       83893               if current.row != neighbor.row and current.col != neighbor.col:
    66     43.6 MiB  -5818.3 MiB       41946                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     43.6 MiB  -5815.1 MiB       41947                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     43.6 MiB -11633.4 MiB       83893               if temp_g_score < g_score[neighbor]:
    71     43.6 MiB  -1546.2 MiB       11187                   came_from[neighbor] = current
    72     43.6 MiB  -1547.3 MiB       11187                   g_score[neighbor] = temp_g_score
    73     43.6 MiB  -1547.3 MiB       11187                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     43.6 MiB  -1547.3 MiB       11187                   if neighbor not in open_set_hash:
    75     43.6 MiB  -1547.3 MiB       11187                       count += 1
    76     43.6 MiB  -1547.2 MiB       11187                       open_set.put((f_score[neighbor], count, neighbor))
    77     43.6 MiB  -1547.1 MiB       11187                       open_set_hash.add(neighbor)
    78                                                             
    79     43.6 MiB  -1455.4 MiB       10487           if draw is not None:
    80                                                     draw()
    81                                         
    82     43.6 MiB  -1455.5 MiB       10487           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     45.7 MiB     45.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     53.2 MiB    -47.5 MiB         257       for row in grid:
    30     53.2 MiB -11841.8 MiB       65792           for spot in row:
    31     53.2 MiB -11788.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     53.1 MiB     -0.1 MiB           1       count = 0
    34     53.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     53.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     53.1 MiB      0.0 MiB           1       came_from = {}
    37     53.4 MiB -121314.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     53.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     58.5 MiB  -1892.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     58.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     58.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     58.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     58.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     58.5 MiB -21442.2 MiB        6201       while not open_set.empty():
    47     58.5 MiB -21442.3 MiB        6201           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     58.5 MiB -21442.3 MiB        6201           current = open_set.get()[2]
    53     58.5 MiB -21442.3 MiB        6201           open_set_hash.remove(current)
    54                                         
    55     58.5 MiB -21442.7 MiB        6201           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     58.5 MiB -21442.8 MiB        6201           if current == end:
    60     50.8 MiB     -7.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     50.9 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     58.5 MiB -192922.2 MiB       55797           for neighbor in current.neighbors:
    65     58.5 MiB -171484.7 MiB       49597               if current.row != neighbor.row and current.col != neighbor.col:
    66     58.5 MiB -85744.6 MiB       24798                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     58.5 MiB -85741.3 MiB       24799                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     58.5 MiB -171487.0 MiB       49597               if temp_g_score < g_score[neighbor]:
    71     58.5 MiB -23068.2 MiB        6770                   came_from[neighbor] = current
    72     58.5 MiB -23068.2 MiB        6770                   g_score[neighbor] = temp_g_score
    73     58.5 MiB -23068.2 MiB        6770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     58.5 MiB -23068.2 MiB        6770                   if neighbor not in open_set_hash:
    75     58.5 MiB -23068.2 MiB        6770                       count += 1
    76     58.5 MiB -23068.3 MiB        6770                       open_set.put((f_score[neighbor], count, neighbor))
    77     58.5 MiB -23068.5 MiB        6770                       open_set_hash.add(neighbor)
    78                                                             
    79     58.5 MiB -21441.4 MiB        6200           if draw is not None:
    80                                                     draw()
    81                                         
    82     58.5 MiB -21441.8 MiB        6200           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     52.3 MiB     52.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     54.0 MiB     -0.1 MiB         257       for row in grid:
    30     54.0 MiB    -30.4 MiB       65792           for spot in row:
    31     54.0 MiB    -28.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     54.0 MiB      0.0 MiB           1       count = 0
    34     54.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     54.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     54.0 MiB      0.0 MiB           1       came_from = {}
    37     56.8 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.3 MiB      4.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.4 MiB      0.0 MiB         903       while not open_set.empty():
    47     61.4 MiB      0.0 MiB         903           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.4 MiB      0.0 MiB         903           current = open_set.get()[2]
    53     61.4 MiB      0.0 MiB         903           open_set_hash.remove(current)
    54                                         
    55     61.4 MiB      0.0 MiB         903           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.4 MiB      0.0 MiB         903           if current == end:
    60     61.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.4 MiB      0.0 MiB        8115           for neighbor in current.neighbors:
    65     61.4 MiB      0.0 MiB        7213               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.4 MiB      0.0 MiB        3606                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.4 MiB      0.0 MiB        3607                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.4 MiB      0.0 MiB        7213               if temp_g_score < g_score[neighbor]:
    71     61.4 MiB      0.0 MiB        1068                   came_from[neighbor] = current
    72     61.4 MiB      0.0 MiB        1068                   g_score[neighbor] = temp_g_score
    73     61.4 MiB      0.0 MiB        1068                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.4 MiB      0.0 MiB        1068                   if neighbor not in open_set_hash:
    75     61.4 MiB      0.0 MiB        1068                       count += 1
    76     61.4 MiB      0.0 MiB        1068                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.4 MiB      0.0 MiB        1068                       open_set_hash.add(neighbor)
    78                                                             
    79     61.4 MiB      0.0 MiB         902           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.4 MiB      0.0 MiB         902           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.4 MiB     61.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.4 MiB      0.0 MiB         257       for row in grid:
    30     61.4 MiB      0.0 MiB       65792           for spot in row:
    31     61.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.4 MiB      0.0 MiB           1       count = 0
    34     61.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.4 MiB      0.0 MiB           1       came_from = {}
    37     64.7 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.9 MiB   -564.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.0 MiB   -295.8 MiB        2100       while not open_set.empty():
    47     66.0 MiB   -295.8 MiB        2100           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.0 MiB   -295.8 MiB        2100           current = open_set.get()[2]
    53     66.0 MiB   -295.8 MiB        2100           open_set_hash.remove(current)
    54                                         
    55     66.0 MiB   -295.8 MiB        2100           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.0 MiB   -295.8 MiB        2100           if current == end:
    60     65.7 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.0 MiB  -2662.5 MiB       18888           for neighbor in current.neighbors:
    65     66.0 MiB  -2366.9 MiB       16789               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.0 MiB  -1183.5 MiB        8394                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.0 MiB  -1183.5 MiB        8395                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.0 MiB  -2367.0 MiB       16789               if temp_g_score < g_score[neighbor]:
    71     66.0 MiB   -340.8 MiB        2451                   came_from[neighbor] = current
    72     66.0 MiB   -340.8 MiB        2451                   g_score[neighbor] = temp_g_score
    73     66.0 MiB   -340.8 MiB        2451                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.0 MiB   -340.8 MiB        2451                   if neighbor not in open_set_hash:
    75     66.0 MiB   -340.8 MiB        2451                       count += 1
    76     66.0 MiB   -340.8 MiB        2451                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.0 MiB   -340.8 MiB        2451                       open_set_hash.add(neighbor)
    78                                                             
    79     66.0 MiB   -295.8 MiB        2099           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.0 MiB   -295.8 MiB        2099           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.9 MiB    101.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.9 MiB  -1263.8 MiB         257       for row in grid:
    30    101.9 MiB -320661.6 MiB       65792           for spot in row:
    31    101.9 MiB -319419.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.3 MiB    -30.6 MiB           1       count = 0
    34     71.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.3 MiB      0.0 MiB           1       came_from = {}
    37     75.3 MiB -22573.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     79.7 MiB   -996.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     79.8 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     79.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     79.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     79.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     81.5 MiB      0.0 MiB         320       while not open_set.empty():
    47     81.5 MiB      0.0 MiB         320           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     81.5 MiB      0.0 MiB         320           current = open_set.get()[2]
    53     81.5 MiB      0.0 MiB         320           open_set_hash.remove(current)
    54                                         
    55     81.5 MiB      0.0 MiB         320           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     81.5 MiB      0.0 MiB         320           if current == end:
    60     81.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     81.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     81.5 MiB      0.1 MiB        2871           for neighbor in current.neighbors:
    65     81.5 MiB      1.3 MiB        2552               if current.row != neighbor.row and current.col != neighbor.col:
    66     81.5 MiB      0.0 MiB        1276                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     81.5 MiB      0.0 MiB        1276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     81.5 MiB      0.0 MiB        2552               if temp_g_score < g_score[neighbor]:
    71     81.5 MiB      0.1 MiB         494                   came_from[neighbor] = current
    72     81.5 MiB      0.0 MiB         494                   g_score[neighbor] = temp_g_score
    73     81.5 MiB      0.0 MiB         494                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     81.5 MiB      0.0 MiB         494                   if neighbor not in open_set_hash:
    75     81.5 MiB      0.0 MiB         494                       count += 1
    76     81.5 MiB      0.1 MiB         494                       open_set.put((f_score[neighbor], count, neighbor))
    77     81.5 MiB      0.0 MiB         494                       open_set_hash.add(neighbor)
    78                                                             
    79     81.5 MiB      0.0 MiB         319           if draw is not None:
    80                                                     draw()
    81                                         
    82     81.5 MiB      0.0 MiB         319           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     81.7 MiB     81.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     84.6 MiB  -8000.8 MiB         257       for row in grid:
    30     84.6 MiB -2050622.1 MiB       65792           for spot in row:
    31     84.6 MiB -2042637.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     48.1 MiB    -36.5 MiB           1       count = 0
    34     48.3 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     48.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     48.5 MiB      0.0 MiB           1       came_from = {}
    37     55.1 MiB      6.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     58.9 MiB -21035.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     59.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     59.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     59.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     59.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.3 MiB      0.0 MiB         450       while not open_set.empty():
    47     59.3 MiB      0.0 MiB         450           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.3 MiB      0.0 MiB         450           current = open_set.get()[2]
    53     59.3 MiB      0.0 MiB         450           open_set_hash.remove(current)
    54                                         
    55     59.3 MiB      0.0 MiB         450           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.3 MiB      0.0 MiB         450           if current == end:
    60     59.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.3 MiB      0.1 MiB        4041           for neighbor in current.neighbors:
    65     59.3 MiB      0.1 MiB        3592               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.3 MiB      0.0 MiB        1796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.3 MiB      0.0 MiB        1796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.3 MiB      0.0 MiB        3592               if temp_g_score < g_score[neighbor]:
    71     59.3 MiB      0.0 MiB         622                   came_from[neighbor] = current
    72     59.3 MiB      0.0 MiB         622                   g_score[neighbor] = temp_g_score
    73     59.3 MiB      0.0 MiB         622                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.3 MiB      0.0 MiB         622                   if neighbor not in open_set_hash:
    75     59.3 MiB      0.0 MiB         622                       count += 1
    76     59.3 MiB      0.0 MiB         622                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.3 MiB      0.0 MiB         622                       open_set_hash.add(neighbor)
    78                                                             
    79     59.3 MiB      0.0 MiB         449           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.3 MiB      0.0 MiB         449           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.3 MiB     59.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     59.6 MiB  -1483.2 MiB         257       for row in grid:
    30     59.6 MiB -380418.6 MiB       65792           for spot in row:
    31     59.6 MiB -378940.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.7 MiB     -6.9 MiB           1       count = 0
    34     52.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.7 MiB      0.0 MiB           1       came_from = {}
    37     56.1 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.4 MiB      5.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.4 MiB      0.0 MiB         427       while not open_set.empty():
    47     61.4 MiB      0.0 MiB         427           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.4 MiB      0.0 MiB         427           current = open_set.get()[2]
    53     61.4 MiB      0.0 MiB         427           open_set_hash.remove(current)
    54                                         
    55     61.4 MiB      0.0 MiB         427           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.4 MiB      0.0 MiB         427           if current == end:
    60     61.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.4 MiB      0.0 MiB        3834           for neighbor in current.neighbors:
    65     61.4 MiB      0.0 MiB        3408               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.4 MiB      0.0 MiB        1704                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.4 MiB      0.0 MiB        1704                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.4 MiB      0.0 MiB        3408               if temp_g_score < g_score[neighbor]:
    71     61.4 MiB      0.0 MiB         575                   came_from[neighbor] = current
    72     61.4 MiB      0.0 MiB         575                   g_score[neighbor] = temp_g_score
    73     61.4 MiB      0.0 MiB         575                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.4 MiB      0.0 MiB         575                   if neighbor not in open_set_hash:
    75     61.4 MiB      0.0 MiB         575                       count += 1
    76     61.4 MiB      0.0 MiB         575                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.4 MiB      0.0 MiB         575                       open_set_hash.add(neighbor)
    78                                                             
    79     61.4 MiB      0.0 MiB         426           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.4 MiB      0.0 MiB         426           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.4 MiB     61.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.4 MiB      0.0 MiB         257       for row in grid:
    30     61.4 MiB      0.0 MiB       65792           for spot in row:
    31     61.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.4 MiB      0.0 MiB           1       count = 0
    34     61.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.4 MiB      0.0 MiB           1       came_from = {}
    37     65.5 MiB      4.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.5 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.5 MiB      0.0 MiB         252       while not open_set.empty():
    47     68.5 MiB      0.0 MiB         252           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.5 MiB      0.0 MiB         252           current = open_set.get()[2]
    53     68.5 MiB      0.0 MiB         252           open_set_hash.remove(current)
    54                                         
    55     68.5 MiB      0.0 MiB         252           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.5 MiB      0.0 MiB         252           if current == end:
    60     68.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.5 MiB      0.0 MiB        2259           for neighbor in current.neighbors:
    65     68.5 MiB      0.0 MiB        2008               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.5 MiB      0.0 MiB        1004                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.5 MiB      0.0 MiB        1004                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.5 MiB      0.0 MiB        2008               if temp_g_score < g_score[neighbor]:
    71     68.5 MiB      0.0 MiB         358                   came_from[neighbor] = current
    72     68.5 MiB      0.0 MiB         358                   g_score[neighbor] = temp_g_score
    73     68.5 MiB      0.0 MiB         358                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.5 MiB      0.0 MiB         358                   if neighbor not in open_set_hash:
    75     68.5 MiB      0.0 MiB         358                       count += 1
    76     68.5 MiB      0.0 MiB         358                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.5 MiB      0.0 MiB         358                       open_set_hash.add(neighbor)
    78                                                             
    79     68.5 MiB      0.0 MiB         251           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.5 MiB      0.0 MiB         251           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     68.5 MiB     68.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.5 MiB      0.0 MiB         257       for row in grid:
    30     68.5 MiB      0.0 MiB       65792           for spot in row:
    31     68.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     68.5 MiB      0.0 MiB           1       count = 0
    34     68.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     68.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     68.5 MiB      0.0 MiB           1       came_from = {}
    37     70.0 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     72.2 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.2 MiB      0.0 MiB          48       while not open_set.empty():
    47     72.2 MiB      0.0 MiB          48           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.2 MiB      0.0 MiB          48           current = open_set.get()[2]
    53     72.2 MiB      0.0 MiB          48           open_set_hash.remove(current)
    54                                         
    55     72.2 MiB      0.0 MiB          48           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.2 MiB      0.0 MiB          48           if current == end:
    60     72.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.2 MiB      0.0 MiB         423           for neighbor in current.neighbors:
    65     72.2 MiB      0.0 MiB         376               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.2 MiB      0.0 MiB         188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.2 MiB      0.0 MiB         188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.2 MiB      0.0 MiB         376               if temp_g_score < g_score[neighbor]:
    71     72.2 MiB      0.0 MiB          90                   came_from[neighbor] = current
    72     72.2 MiB      0.0 MiB          90                   g_score[neighbor] = temp_g_score
    73     72.2 MiB      0.0 MiB          90                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.2 MiB      0.0 MiB          90                   if neighbor not in open_set_hash:
    75     72.2 MiB      0.0 MiB          90                       count += 1
    76     72.2 MiB      0.0 MiB          90                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.2 MiB      0.0 MiB          90                       open_set_hash.add(neighbor)
    78                                                             
    79     72.2 MiB      0.0 MiB          47           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.2 MiB      0.0 MiB          47           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     72.2 MiB   -365.9 MiB         257       for row in grid:
    30     72.2 MiB -93636.2 MiB       65792           for spot in row:
    31     72.2 MiB -93275.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     65.9 MiB     -6.3 MiB           1       count = 0
    34     65.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     65.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     65.9 MiB      0.0 MiB           1       came_from = {}
    37     67.2 MiB -145878.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.2 MiB     -3.0 MiB           1       g_score[start] = 0
    39     67.1 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.1 MiB  -4136.0 MiB        3010       while not open_set.empty():
    47     67.1 MiB  -4136.0 MiB        3010           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.1 MiB  -4136.0 MiB        3010           current = open_set.get()[2]
    53     67.1 MiB  -4136.0 MiB        3010           open_set_hash.remove(current)
    54                                         
    55     67.1 MiB  -4136.0 MiB        3010           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.1 MiB  -4136.0 MiB        3010           if current == end:
    60     64.6 MiB     -2.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.1 MiB -37218.2 MiB       27081           for neighbor in current.neighbors:
    65     67.1 MiB -33082.4 MiB       24072               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.1 MiB -16543.9 MiB       12036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.1 MiB -16538.9 MiB       12036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.1 MiB -33082.8 MiB       24072               if temp_g_score < g_score[neighbor]:
    71     67.1 MiB  -4607.0 MiB        3422                   came_from[neighbor] = current
    72     67.1 MiB  -4607.0 MiB        3422                   g_score[neighbor] = temp_g_score
    73     67.1 MiB  -4607.0 MiB        3422                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.1 MiB  -4607.0 MiB        3422                   if neighbor not in open_set_hash:
    75     67.1 MiB  -4607.0 MiB        3422                       count += 1
    76     67.1 MiB  -4607.0 MiB        3422                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.1 MiB  -4607.0 MiB        3422                       open_set_hash.add(neighbor)
    78                                                             
    79     67.1 MiB  -4136.0 MiB        3009           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.1 MiB  -4136.0 MiB        3009           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.6 MiB     64.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.6 MiB   -232.8 MiB         257       for row in grid:
    30     64.6 MiB -59573.3 MiB       65792           for spot in row:
    31     64.6 MiB -59341.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.4 MiB     -1.2 MiB           1       count = 0
    34     63.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.4 MiB      0.0 MiB           1       came_from = {}
    37     66.9 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.9 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.9 MiB  -1838.2 MiB        1152       while not open_set.empty():
    47     70.9 MiB  -1838.2 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.9 MiB  -1838.2 MiB        1152           current = open_set.get()[2]
    53     70.9 MiB  -1838.4 MiB        1152           open_set_hash.remove(current)
    54                                         
    55     70.9 MiB  -1838.4 MiB        1152           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.9 MiB  -1838.5 MiB        1152           if current == end:
    60     65.7 MiB     -5.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.9 MiB -16516.2 MiB       10359           for neighbor in current.neighbors:
    65     70.9 MiB -14678.9 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.9 MiB  -7342.6 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.9 MiB  -7337.4 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.9 MiB -14681.3 MiB        9208               if temp_g_score < g_score[neighbor]:
    71     70.9 MiB  -2446.7 MiB        1558                   came_from[neighbor] = current
    72     70.9 MiB  -2447.0 MiB        1558                   g_score[neighbor] = temp_g_score
    73     70.9 MiB  -2447.2 MiB        1558                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.9 MiB  -2447.2 MiB        1558                   if neighbor not in open_set_hash:
    75     70.9 MiB  -2447.2 MiB        1558                       count += 1
    76     70.9 MiB  -2447.2 MiB        1558                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.9 MiB  -2447.1 MiB        1558                       open_set_hash.add(neighbor)
    78                                                             
    79     70.9 MiB  -1838.2 MiB        1151           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.9 MiB  -1838.2 MiB        1151           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.8 MiB     99.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.8 MiB  -1505.3 MiB         257       for row in grid:
    30     99.8 MiB -384876.5 MiB       65792           for spot in row:
    31     99.8 MiB -383379.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.4 MiB     -9.5 MiB           1       count = 0
    34     90.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     90.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     90.4 MiB      0.0 MiB           1       came_from = {}
    37     92.8 MiB  -6374.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     95.7 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     95.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     95.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     95.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     95.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.7 MiB      0.0 MiB         160       while not open_set.empty():
    47     95.7 MiB      0.0 MiB         160           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.7 MiB      0.0 MiB         160           current = open_set.get()[2]
    53     95.7 MiB      0.0 MiB         160           open_set_hash.remove(current)
    54                                         
    55     95.7 MiB      0.0 MiB         160           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.7 MiB      0.0 MiB         160           if current == end:
    60     95.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.7 MiB      0.0 MiB        1431           for neighbor in current.neighbors:
    65     95.7 MiB      0.0 MiB        1272               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.7 MiB      0.0 MiB         636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.7 MiB      0.0 MiB         636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.7 MiB      0.0 MiB        1272               if temp_g_score < g_score[neighbor]:
    71     95.7 MiB      0.0 MiB         230                   came_from[neighbor] = current
    72     95.7 MiB      0.0 MiB         230                   g_score[neighbor] = temp_g_score
    73     95.7 MiB      0.0 MiB         230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.7 MiB      0.0 MiB         230                   if neighbor not in open_set_hash:
    75     95.7 MiB      0.0 MiB         230                       count += 1
    76     95.7 MiB      0.0 MiB         230                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.7 MiB      0.0 MiB         230                       open_set_hash.add(neighbor)
    78                                                             
    79     95.7 MiB      0.0 MiB         159           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.7 MiB      0.0 MiB         159           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.7 MiB     95.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.7 MiB      0.0 MiB         257       for row in grid:
    30     95.7 MiB      0.0 MiB       65792           for spot in row:
    31     95.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.7 MiB      0.0 MiB           1       count = 0
    34     95.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.8 MiB      0.0 MiB           1       came_from = {}
    37     97.9 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.4 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.4 MiB      0.0 MiB         990       while not open_set.empty():
    47    101.4 MiB      0.0 MiB         990           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.4 MiB      0.0 MiB         990           current = open_set.get()[2]
    53    101.4 MiB      0.0 MiB         990           open_set_hash.remove(current)
    54                                         
    55    101.4 MiB      0.0 MiB         990           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.4 MiB      0.0 MiB         990           if current == end:
    60    101.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.4 MiB      0.0 MiB        8901           for neighbor in current.neighbors:
    65    101.4 MiB      0.0 MiB        7912               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.4 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.4 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.4 MiB      0.0 MiB        7912               if temp_g_score < g_score[neighbor]:
    71    101.4 MiB      0.0 MiB        1226                   came_from[neighbor] = current
    72    101.4 MiB      0.0 MiB        1226                   g_score[neighbor] = temp_g_score
    73    101.4 MiB      0.0 MiB        1226                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.4 MiB      0.0 MiB        1226                   if neighbor not in open_set_hash:
    75    101.4 MiB      0.0 MiB        1226                       count += 1
    76    101.4 MiB      0.0 MiB        1226                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.4 MiB      0.0 MiB        1226                       open_set_hash.add(neighbor)
    78                                                             
    79    101.4 MiB      0.0 MiB         989           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.4 MiB      0.0 MiB         989           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.4 MiB    101.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.4 MiB    -14.9 MiB         257       for row in grid:
    30    101.4 MiB  -3716.8 MiB       65792           for spot in row:
    31    101.4 MiB  -3702.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.9 MiB     -0.5 MiB           1       count = 0
    34    100.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.9 MiB      0.0 MiB           1       came_from = {}
    37    102.2 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.7 MiB -16207.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.4 MiB     -1.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.4 MiB      0.0 MiB          40       while not open_set.empty():
    47    101.4 MiB      0.0 MiB          40           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.4 MiB      0.0 MiB          40           current = open_set.get()[2]
    53    101.4 MiB      0.0 MiB          40           open_set_hash.remove(current)
    54                                         
    55    101.4 MiB      0.0 MiB          40           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.4 MiB      0.0 MiB          40           if current == end:
    60    101.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.4 MiB      0.0 MiB         351           for neighbor in current.neighbors:
    65    101.4 MiB      0.0 MiB         312               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.4 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.4 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.4 MiB      0.0 MiB         312               if temp_g_score < g_score[neighbor]:
    71    101.4 MiB      0.0 MiB          74                   came_from[neighbor] = current
    72    101.4 MiB      0.0 MiB          74                   g_score[neighbor] = temp_g_score
    73    101.4 MiB      0.0 MiB          74                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.4 MiB      0.0 MiB          74                   if neighbor not in open_set_hash:
    75    101.4 MiB      0.0 MiB          74                       count += 1
    76    101.4 MiB      0.0 MiB          74                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.4 MiB      0.0 MiB          74                       open_set_hash.add(neighbor)
    78                                                             
    79    101.4 MiB      0.0 MiB          39           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.4 MiB      0.0 MiB          39           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.4 MiB    101.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.4 MiB  -2194.5 MiB         257       for row in grid:
    30    101.4 MiB -559904.3 MiB       65792           for spot in row:
    31    101.4 MiB -557722.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     83.5 MiB    -17.8 MiB           1       count = 0
    34     83.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     83.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     83.6 MiB      0.0 MiB           1       came_from = {}
    37     87.4 MiB -11947.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     86.4 MiB     -1.0 MiB           1       g_score[start] = 0
    39     88.4 MiB -184472.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     77.6 MiB    -10.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     77.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     77.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     77.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     78.3 MiB -17887.2 MiB        3417       while not open_set.empty():
    47     78.3 MiB -17887.3 MiB        3417           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     78.3 MiB -17888.2 MiB        3417           current = open_set.get()[2]
    53     78.3 MiB -17888.4 MiB        3417           open_set_hash.remove(current)
    54                                         
    55     78.3 MiB -17888.6 MiB        3417           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     78.3 MiB -17888.8 MiB        3417           if current == end:
    60     70.6 MiB     -7.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     78.3 MiB -160949.3 MiB       30744           for neighbor in current.neighbors:
    65     78.3 MiB -143064.2 MiB       27328               if current.row != neighbor.row and current.col != neighbor.col:
    66     78.3 MiB -71540.6 MiB       13664                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     78.3 MiB -71525.2 MiB       13664                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     78.3 MiB -143066.1 MiB       27328               if temp_g_score < g_score[neighbor]:
    71     78.3 MiB -19360.5 MiB        3785                   came_from[neighbor] = current
    72     78.3 MiB -19360.5 MiB        3785                   g_score[neighbor] = temp_g_score
    73     78.3 MiB -19360.8 MiB        3785                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     78.3 MiB -19361.1 MiB        3785                   if neighbor not in open_set_hash:
    75     78.3 MiB -19361.3 MiB        3785                       count += 1
    76     78.3 MiB -19361.3 MiB        3785                       open_set.put((f_score[neighbor], count, neighbor))
    77     78.3 MiB -19361.3 MiB        3785                       open_set_hash.add(neighbor)
    78                                                             
    79     78.3 MiB -17886.7 MiB        3416           if draw is not None:
    80                                                     draw()
    81                                         
    82     78.3 MiB -17886.9 MiB        3416           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.1 MiB     74.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     78.1 MiB  -3666.2 MiB         257       for row in grid:
    30     78.1 MiB -941167.5 MiB       65792           for spot in row:
    31     78.1 MiB -937510.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.9 MiB    -21.2 MiB           1       count = 0
    34     56.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     56.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.9 MiB      0.0 MiB           1       came_from = {}
    37     59.5 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     63.4 MiB      3.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.5 MiB      0.0 MiB        3120       while not open_set.empty():
    47     63.5 MiB      0.0 MiB        3120           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.5 MiB      0.0 MiB        3120           current = open_set.get()[2]
    53     63.5 MiB      0.0 MiB        3120           open_set_hash.remove(current)
    54                                         
    55     63.5 MiB      0.0 MiB        3120           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.5 MiB      0.0 MiB        3120           if current == end:
    60     63.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.5 MiB      0.0 MiB       28071           for neighbor in current.neighbors:
    65     63.5 MiB      0.0 MiB       24952               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.5 MiB      0.0 MiB       12476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.5 MiB      0.0 MiB       12476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.5 MiB      0.0 MiB       24952               if temp_g_score < g_score[neighbor]:
    71     63.5 MiB      0.0 MiB        3434                   came_from[neighbor] = current
    72     63.5 MiB      0.0 MiB        3434                   g_score[neighbor] = temp_g_score
    73     63.5 MiB      0.0 MiB        3434                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.5 MiB      0.0 MiB        3434                   if neighbor not in open_set_hash:
    75     63.5 MiB      0.0 MiB        3434                       count += 1
    76     63.5 MiB      0.0 MiB        3434                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.5 MiB      0.0 MiB        3434                       open_set_hash.add(neighbor)
    78                                                             
    79     63.5 MiB      0.0 MiB        3119           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.5 MiB      0.0 MiB        3119           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.5 MiB     63.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.5 MiB      0.0 MiB         257       for row in grid:
    30     63.5 MiB      0.0 MiB       65792           for spot in row:
    31     63.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     63.5 MiB      0.0 MiB           1       count = 0
    34     63.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.5 MiB      0.0 MiB           1       came_from = {}
    37     65.5 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.5 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.5 MiB -33331.6 MiB        4633       while not open_set.empty():
    47     68.5 MiB -33332.0 MiB        4633           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.5 MiB -33332.8 MiB        4633           current = open_set.get()[2]
    53     68.5 MiB -33333.2 MiB        4633           open_set_hash.remove(current)
    54                                         
    55     68.5 MiB -33333.3 MiB        4633           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.5 MiB -33333.4 MiB        4633           if current == end:
    60     61.1 MiB     -7.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.5 MiB -299957.8 MiB       41688           for neighbor in current.neighbors:
    65     68.5 MiB -266627.5 MiB       37056               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.5 MiB -133319.7 MiB       18528                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.5 MiB -133308.7 MiB       18528                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.5 MiB -266630.0 MiB       37056               if temp_g_score < g_score[neighbor]:
    71     68.5 MiB -35620.0 MiB        5021                   came_from[neighbor] = current
    72     68.5 MiB -35620.1 MiB        5021                   g_score[neighbor] = temp_g_score
    73     68.5 MiB -35620.1 MiB        5021                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.5 MiB -35620.1 MiB        5021                   if neighbor not in open_set_hash:
    75     68.5 MiB -35620.1 MiB        5021                       count += 1
    76     68.5 MiB -35620.1 MiB        5021                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.5 MiB -35620.3 MiB        5021                       open_set_hash.add(neighbor)
    78                                                             
    79     68.5 MiB -33331.5 MiB        4632           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.5 MiB -33331.6 MiB        4632           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.5 MiB     61.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.5 MiB   -240.4 MiB         257       for row in grid:
    30     61.5 MiB -61704.8 MiB       65792           for spot in row:
    31     61.5 MiB -61465.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.7 MiB     -0.8 MiB           1       count = 0
    34     60.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.7 MiB      0.0 MiB           1       came_from = {}
    37     64.0 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.8 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.1 MiB      0.0 MiB        3744       while not open_set.empty():
    47     67.1 MiB      0.0 MiB        3744           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.1 MiB      0.0 MiB        3744           current = open_set.get()[2]
    53     67.1 MiB      0.0 MiB        3744           open_set_hash.remove(current)
    54                                         
    55     67.1 MiB      0.0 MiB        3744           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.1 MiB      0.0 MiB        3744           if current == end:
    60     67.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.1 MiB      0.0 MiB       33687           for neighbor in current.neighbors:
    65     67.1 MiB      0.0 MiB       29944               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.1 MiB      0.0 MiB       14972                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.1 MiB      0.0 MiB       14972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.1 MiB      0.0 MiB       29944               if temp_g_score < g_score[neighbor]:
    71     67.1 MiB      0.2 MiB        4150                   came_from[neighbor] = current
    72     67.1 MiB      0.0 MiB        4150                   g_score[neighbor] = temp_g_score
    73     67.1 MiB      0.0 MiB        4150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.1 MiB      0.0 MiB        4150                   if neighbor not in open_set_hash:
    75     67.1 MiB      0.0 MiB        4150                       count += 1
    76     67.1 MiB      0.0 MiB        4150                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.1 MiB      0.0 MiB        4150                       open_set_hash.add(neighbor)
    78                                                             
    79     67.1 MiB      0.0 MiB        3743           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.1 MiB      0.0 MiB        3743           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.4 MiB    101.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.4 MiB   -204.8 MiB         257       for row in grid:
    30    101.4 MiB -52490.3 MiB       65792           for spot in row:
    31    101.4 MiB -52286.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.1 MiB     -1.3 MiB           1       count = 0
    34    100.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.1 MiB      0.0 MiB           1       came_from = {}
    37    100.1 MiB -25256.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.3 MiB     -1.9 MiB           1       g_score[start] = 0
    39    101.0 MiB      2.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.0 MiB    -87.9 MiB         190       while not open_set.empty():
    47    101.0 MiB    -87.9 MiB         190           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.0 MiB    -87.9 MiB         190           current = open_set.get()[2]
    53    101.0 MiB    -87.9 MiB         190           open_set_hash.remove(current)
    54                                         
    55    101.0 MiB    -87.9 MiB         190           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.0 MiB    -87.9 MiB         190           if current == end:
    60     98.6 MiB     -2.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.0 MiB   -773.9 MiB        1701           for neighbor in current.neighbors:
    65    101.0 MiB   -686.9 MiB        1512               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.0 MiB   -345.0 MiB         756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.0 MiB   -342.1 MiB         756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.0 MiB   -687.4 MiB        1512               if temp_g_score < g_score[neighbor]:
    71    101.0 MiB   -116.8 MiB         266                   came_from[neighbor] = current
    72    101.0 MiB   -116.8 MiB         266                   g_score[neighbor] = temp_g_score
    73    101.0 MiB   -117.0 MiB         266                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.0 MiB   -117.1 MiB         266                   if neighbor not in open_set_hash:
    75    101.0 MiB   -117.2 MiB         266                       count += 1
    76    101.0 MiB   -117.5 MiB         266                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.0 MiB   -117.5 MiB         266                       open_set_hash.add(neighbor)
    78                                                             
    79    101.0 MiB    -87.4 MiB         189           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.0 MiB    -87.7 MiB         189           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.6 MiB     98.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.6 MiB  -3653.1 MiB         257       for row in grid:
    30     98.6 MiB -937225.4 MiB       65792           for spot in row:
    31     98.6 MiB -933581.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     84.5 MiB    -14.1 MiB           1       count = 0
    34     84.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     84.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     84.5 MiB      0.0 MiB           1       came_from = {}
    37     84.8 MiB  -9426.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     84.6 MiB     -0.2 MiB           1       g_score[start] = 0
    39     89.1 MiB      4.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     89.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     89.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     89.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     89.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     89.3 MiB      0.0 MiB        1400       while not open_set.empty():
    47     89.3 MiB      0.0 MiB        1400           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     89.3 MiB      0.0 MiB        1400           current = open_set.get()[2]
    53     89.3 MiB      0.0 MiB        1400           open_set_hash.remove(current)
    54                                         
    55     89.3 MiB      0.0 MiB        1400           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     89.3 MiB      0.0 MiB        1400           if current == end:
    60     89.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     89.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     89.3 MiB      0.0 MiB       12591           for neighbor in current.neighbors:
    65     89.3 MiB      0.0 MiB       11192               if current.row != neighbor.row and current.col != neighbor.col:
    66     89.3 MiB      0.0 MiB        5596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     89.3 MiB      0.0 MiB        5596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     89.3 MiB      0.0 MiB       11192               if temp_g_score < g_score[neighbor]:
    71     89.3 MiB      0.0 MiB        1826                   came_from[neighbor] = current
    72     89.3 MiB      0.0 MiB        1826                   g_score[neighbor] = temp_g_score
    73     89.3 MiB      0.0 MiB        1826                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     89.3 MiB      0.0 MiB        1826                   if neighbor not in open_set_hash:
    75     89.3 MiB      0.0 MiB        1826                       count += 1
    76     89.3 MiB      0.0 MiB        1826                       open_set.put((f_score[neighbor], count, neighbor))
    77     89.3 MiB      0.0 MiB        1826                       open_set_hash.add(neighbor)
    78                                                             
    79     89.3 MiB      0.0 MiB        1399           if draw is not None:
    80                                                     draw()
    81                                         
    82     89.3 MiB      0.0 MiB        1399           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.3 MiB     89.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     89.3 MiB      0.0 MiB         257       for row in grid:
    30     89.3 MiB      0.0 MiB       65792           for spot in row:
    31     89.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.3 MiB      0.0 MiB           1       count = 0
    34     89.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     89.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     89.3 MiB      0.0 MiB           1       came_from = {}
    37     90.7 MiB   -445.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     90.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.2 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.2 MiB      0.0 MiB        4410       while not open_set.empty():
    47     94.2 MiB      0.0 MiB        4410           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.2 MiB      0.0 MiB        4410           current = open_set.get()[2]
    53     94.2 MiB      0.0 MiB        4410           open_set_hash.remove(current)
    54                                         
    55     94.2 MiB      0.0 MiB        4410           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.2 MiB      0.0 MiB        4410           if current == end:
    60     94.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.2 MiB      0.0 MiB       39681           for neighbor in current.neighbors:
    65     94.2 MiB      0.0 MiB       35272               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.2 MiB      0.0 MiB       17636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.2 MiB      0.0 MiB       17636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.2 MiB      0.0 MiB       35272               if temp_g_score < g_score[neighbor]:
    71     94.2 MiB      0.0 MiB        4786                   came_from[neighbor] = current
    72     94.2 MiB      0.0 MiB        4786                   g_score[neighbor] = temp_g_score
    73     94.2 MiB      0.0 MiB        4786                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.2 MiB      0.0 MiB        4786                   if neighbor not in open_set_hash:
    75     94.2 MiB      0.0 MiB        4786                       count += 1
    76     94.2 MiB      0.0 MiB        4786                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.2 MiB      0.0 MiB        4786                       open_set_hash.add(neighbor)
    78                                                             
    79     94.2 MiB      0.0 MiB        4409           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.2 MiB      0.0 MiB        4409           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.2 MiB     94.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.2 MiB   -224.6 MiB         257       for row in grid:
    30     94.2 MiB -57438.4 MiB       65792           for spot in row:
    31     94.2 MiB -57215.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.3 MiB     -1.9 MiB           1       count = 0
    34     92.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.3 MiB      0.0 MiB           1       came_from = {}
    37     94.7 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.7 MiB -78837.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.3 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.5 MiB  -4048.2 MiB        5332       while not open_set.empty():
    47     94.5 MiB  -4048.2 MiB        5332           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.5 MiB  -4048.2 MiB        5332           current = open_set.get()[2]
    53     94.5 MiB  -4048.2 MiB        5332           open_set_hash.remove(current)
    54                                         
    55     94.5 MiB  -4048.2 MiB        5332           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.5 MiB  -4048.2 MiB        5332           if current == end:
    60     92.4 MiB     -2.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.5 MiB -36430.0 MiB       47979           for neighbor in current.neighbors:
    65     94.5 MiB -32382.1 MiB       42648               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.5 MiB -16192.8 MiB       21324                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.5 MiB -16189.9 MiB       21324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.5 MiB -32383.4 MiB       42648               if temp_g_score < g_score[neighbor]:
    71     94.5 MiB  -4301.6 MiB        5798                   came_from[neighbor] = current
    72     94.5 MiB  -4301.7 MiB        5798                   g_score[neighbor] = temp_g_score
    73     94.5 MiB  -4301.7 MiB        5798                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.5 MiB  -4301.7 MiB        5798                   if neighbor not in open_set_hash:
    75     94.5 MiB  -4301.7 MiB        5798                       count += 1
    76     94.5 MiB  -4301.7 MiB        5798                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.5 MiB  -4301.7 MiB        5798                       open_set_hash.add(neighbor)
    78                                                             
    79     94.5 MiB  -4048.2 MiB        5331           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.5 MiB  -4048.2 MiB        5331           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.4 MiB     92.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.4 MiB    -13.5 MiB         257       for row in grid:
    30     92.4 MiB  -3455.4 MiB       65792           for spot in row:
    31     92.4 MiB  -3441.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.2 MiB     -0.1 MiB           1       count = 0
    34     92.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.2 MiB      0.0 MiB           1       came_from = {}
    37     94.3 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.4 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.4 MiB  -5962.3 MiB        4116       while not open_set.empty():
    47     94.4 MiB  -5962.3 MiB        4116           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.4 MiB  -5962.3 MiB        4116           current = open_set.get()[2]
    53     94.4 MiB  -5962.3 MiB        4116           open_set_hash.remove(current)
    54                                         
    55     94.4 MiB  -5962.8 MiB        4116           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.4 MiB  -5963.0 MiB        4116           if current == end:
    60     91.2 MiB     -3.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     91.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.4 MiB -53651.3 MiB       37035           for neighbor in current.neighbors:
    65     94.4 MiB -47689.6 MiB       32920               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.4 MiB -23847.4 MiB       16460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.4 MiB -23842.3 MiB       16460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.4 MiB -47690.8 MiB       32920               if temp_g_score < g_score[neighbor]:
    71     94.4 MiB  -6468.7 MiB        4520                   came_from[neighbor] = current
    72     94.4 MiB  -6468.7 MiB        4520                   g_score[neighbor] = temp_g_score
    73     94.4 MiB  -6468.7 MiB        4520                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.4 MiB  -6468.7 MiB        4520                   if neighbor not in open_set_hash:
    75     94.4 MiB  -6468.7 MiB        4520                       count += 1
    76     94.4 MiB  -6468.7 MiB        4520                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.4 MiB  -6468.7 MiB        4520                       open_set_hash.add(neighbor)
    78                                                             
    79     94.4 MiB  -5962.3 MiB        4115           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.4 MiB  -5962.3 MiB        4115           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.2 MiB     91.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.2 MiB    -20.2 MiB         257       for row in grid:
    30     91.2 MiB  -5162.8 MiB       65792           for spot in row:
    31     91.2 MiB  -5142.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.1 MiB     -0.2 MiB           1       count = 0
    34     91.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.1 MiB      0.0 MiB           1       came_from = {}
    37     91.4 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     91.4 MiB -1053259.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.3 MiB    -15.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.4 MiB -50781.6 MiB        8066       while not open_set.empty():
    47     76.4 MiB -50781.8 MiB        8066           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.4 MiB -50782.0 MiB        8066           current = open_set.get()[2]
    53     76.4 MiB -50782.1 MiB        8066           open_set_hash.remove(current)
    54                                         
    55     76.4 MiB -50782.2 MiB        8066           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.4 MiB -50782.4 MiB        8066           if current == end:
    60     67.8 MiB     -8.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.4 MiB -456987.8 MiB       72585           for neighbor in current.neighbors:
    65     76.4 MiB -406208.2 MiB       64520               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.4 MiB -203110.0 MiB       32260                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.4 MiB -203099.7 MiB       32260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.4 MiB -406211.2 MiB       64520               if temp_g_score < g_score[neighbor]:
    71     76.4 MiB -52960.7 MiB        8578                   came_from[neighbor] = current
    72     76.4 MiB -52960.9 MiB        8578                   g_score[neighbor] = temp_g_score
    73     76.4 MiB -52961.2 MiB        8578                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.4 MiB -52961.3 MiB        8578                   if neighbor not in open_set_hash:
    75     76.4 MiB -52961.5 MiB        8578                       count += 1
    76     76.4 MiB -52962.0 MiB        8578                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.4 MiB -52962.0 MiB        8578                       open_set_hash.add(neighbor)
    78                                                             
    79     76.4 MiB -50781.1 MiB        8065           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.4 MiB -50781.3 MiB        8065           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.9 MiB     67.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.9 MiB     -3.0 MiB         257       for row in grid:
    30     67.9 MiB   -781.0 MiB       65792           for spot in row:
    31     67.9 MiB   -778.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     67.8 MiB     -0.0 MiB           1       count = 0
    34     67.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.8 MiB      0.0 MiB           1       came_from = {}
    37     68.8 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     72.0 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.0 MiB -77930.5 MiB        5986       while not open_set.empty():
    47     72.0 MiB -77930.7 MiB        5986           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.0 MiB -77930.9 MiB        5986           current = open_set.get()[2]
    53     72.0 MiB -77930.9 MiB        5986           open_set_hash.remove(current)
    54                                         
    55     72.0 MiB -77930.9 MiB        5986           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.0 MiB -77931.0 MiB        5986           if current == end:
    60     55.6 MiB    -16.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.0 MiB -701280.8 MiB       53865           for neighbor in current.neighbors:
    65     72.0 MiB -623353.3 MiB       47880               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.0 MiB -311691.0 MiB       23940                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.0 MiB -311665.6 MiB       23940                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.0 MiB -623360.1 MiB       47880               if temp_g_score < g_score[neighbor]:
    71     72.0 MiB -85490.2 MiB        6650                   came_from[neighbor] = current
    72     72.0 MiB -85490.7 MiB        6650                   g_score[neighbor] = temp_g_score
    73     72.0 MiB -85489.8 MiB        6650                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.0 MiB -85490.0 MiB        6650                   if neighbor not in open_set_hash:
    75     72.0 MiB -85490.4 MiB        6650                       count += 1
    76     72.0 MiB -85490.8 MiB        6650                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.0 MiB -85491.1 MiB        6650                       open_set_hash.add(neighbor)
    78                                                             
    79     72.0 MiB -77928.9 MiB        5985           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.0 MiB -77929.6 MiB        5985           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.3 MiB     96.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.3 MiB   -433.4 MiB         257       for row in grid:
    30     96.3 MiB -110958.4 MiB       65792           for spot in row:
    31     96.3 MiB -110527.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.3 MiB     -3.0 MiB           1       count = 0
    34     93.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.3 MiB      0.0 MiB           1       came_from = {}
    37     96.9 MiB      3.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.1 MiB  -9424.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.6 MiB     -6.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.6 MiB -94116.1 MiB        3888       while not open_set.empty():
    47     93.6 MiB -94116.5 MiB        3888           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.6 MiB -94117.2 MiB        3888           current = open_set.get()[2]
    53     93.6 MiB -94117.5 MiB        3888           open_set_hash.remove(current)
    54                                         
    55     93.6 MiB -94118.1 MiB        3888           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.6 MiB -94118.6 MiB        3888           if current == end:
    60     68.0 MiB    -25.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.6 MiB -846949.3 MiB       34983           for neighbor in current.neighbors:
    65     93.6 MiB -752839.0 MiB       31096               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.6 MiB -376443.9 MiB       15548                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.6 MiB -376399.8 MiB       15548                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.6 MiB -752848.6 MiB       31096               if temp_g_score < g_score[neighbor]:
    71     93.6 MiB -101485.2 MiB        4246                   came_from[neighbor] = current
    72     93.6 MiB -101485.7 MiB        4246                   g_score[neighbor] = temp_g_score
    73     93.6 MiB -101486.0 MiB        4246                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.6 MiB -101486.4 MiB        4246                   if neighbor not in open_set_hash:
    75     93.6 MiB -101486.6 MiB        4246                       count += 1
    76     93.6 MiB -101487.1 MiB        4246                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.6 MiB -101487.5 MiB        4246                       open_set_hash.add(neighbor)
    78                                                             
    79     93.6 MiB -94114.5 MiB        3887           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.6 MiB -94115.5 MiB        3887           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.2 MiB     70.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     72.8 MiB  -5606.5 MiB         257       for row in grid:
    30     72.8 MiB -1435325.6 MiB       65792           for spot in row:
    31     72.8 MiB -1429723.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     54.2 MiB    -18.5 MiB           1       count = 0
    34     54.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     54.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     54.3 MiB      0.0 MiB           1       came_from = {}
    37     59.0 MiB  -6525.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     62.6 MiB  -9736.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.9 MiB    -20.4 MiB         520       while not open_set.empty():
    47     62.9 MiB    -20.4 MiB         520           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.9 MiB    -20.4 MiB         520           current = open_set.get()[2]
    53     62.9 MiB    -20.4 MiB         520           open_set_hash.remove(current)
    54                                         
    55     62.9 MiB    -20.4 MiB         520           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.9 MiB    -20.4 MiB         520           if current == end:
    60     62.8 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.9 MiB   -183.4 MiB        4671           for neighbor in current.neighbors:
    65     62.9 MiB   -163.0 MiB        4152               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.9 MiB    -81.6 MiB        2076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.9 MiB    -81.5 MiB        2076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.9 MiB   -163.1 MiB        4152               if temp_g_score < g_score[neighbor]:
    71     62.9 MiB    -24.7 MiB         662                   came_from[neighbor] = current
    72     62.9 MiB    -24.7 MiB         662                   g_score[neighbor] = temp_g_score
    73     62.9 MiB    -24.7 MiB         662                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.9 MiB    -24.7 MiB         662                   if neighbor not in open_set_hash:
    75     62.9 MiB    -24.7 MiB         662                       count += 1
    76     62.9 MiB    -24.7 MiB         662                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.9 MiB    -24.6 MiB         662                       open_set_hash.add(neighbor)
    78                                                             
    79     62.9 MiB    -20.4 MiB         519           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.9 MiB    -20.4 MiB         519           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.9 MiB     62.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.9 MiB  -1326.8 MiB         257       for row in grid:
    30     62.9 MiB -340239.2 MiB       65792           for spot in row:
    31     62.9 MiB -338919.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     53.8 MiB     -9.1 MiB           1       count = 0
    34     53.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     53.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     53.8 MiB      0.0 MiB           1       came_from = {}
    37     57.3 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.4 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.5 MiB   -309.4 MiB        2760       while not open_set.empty():
    47     60.5 MiB   -309.4 MiB        2760           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.5 MiB   -309.4 MiB        2760           current = open_set.get()[2]
    53     60.5 MiB   -309.4 MiB        2760           open_set_hash.remove(current)
    54                                         
    55     60.5 MiB   -309.4 MiB        2760           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.5 MiB   -309.4 MiB        2760           if current == end:
    60     59.9 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.5 MiB  -2781.1 MiB       24831           for neighbor in current.neighbors:
    65     60.5 MiB  -2471.8 MiB       22072               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.5 MiB  -1236.5 MiB       11036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.5 MiB  -1235.5 MiB       11036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.5 MiB  -2472.0 MiB       22072               if temp_g_score < g_score[neighbor]:
    71     60.5 MiB   -346.5 MiB        3084                   came_from[neighbor] = current
    72     60.5 MiB   -346.6 MiB        3084                   g_score[neighbor] = temp_g_score
    73     60.5 MiB   -346.7 MiB        3084                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.5 MiB   -346.7 MiB        3084                   if neighbor not in open_set_hash:
    75     60.5 MiB   -346.7 MiB        3084                       count += 1
    76     60.5 MiB   -346.7 MiB        3084                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.5 MiB   -346.7 MiB        3084                       open_set_hash.add(neighbor)
    78                                                             
    79     60.5 MiB   -309.3 MiB        2759           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.5 MiB   -309.4 MiB        2759           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.9 MiB     59.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.1 MiB  -1175.4 MiB         257       for row in grid:
    30     60.1 MiB -300975.8 MiB       65792           for spot in row:
    31     60.1 MiB -299814.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     49.1 MiB    -11.0 MiB           1       count = 0
    34     49.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     49.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     49.1 MiB      0.0 MiB           1       came_from = {}
    37     55.1 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     59.3 MiB   -105.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     59.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     59.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     59.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     59.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.4 MiB    -30.2 MiB         918       while not open_set.empty():
    47     59.4 MiB    -30.2 MiB         918           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.4 MiB    -30.2 MiB         918           current = open_set.get()[2]
    53     59.4 MiB    -30.2 MiB         918           open_set_hash.remove(current)
    54                                         
    55     59.4 MiB    -30.2 MiB         918           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.4 MiB    -30.2 MiB         918           if current == end:
    60     59.2 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.4 MiB   -270.7 MiB        8253           for neighbor in current.neighbors:
    65     59.4 MiB   -240.5 MiB        7336               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.4 MiB   -120.4 MiB        3668                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.4 MiB   -120.2 MiB        3668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.4 MiB   -240.6 MiB        7336               if temp_g_score < g_score[neighbor]:
    71     59.4 MiB    -35.4 MiB        1106                   came_from[neighbor] = current
    72     59.4 MiB    -35.5 MiB        1106                   g_score[neighbor] = temp_g_score
    73     59.4 MiB    -35.5 MiB        1106                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.4 MiB    -35.5 MiB        1106                   if neighbor not in open_set_hash:
    75     59.4 MiB    -35.5 MiB        1106                       count += 1
    76     59.4 MiB    -35.5 MiB        1106                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.4 MiB    -35.5 MiB        1106                       open_set_hash.add(neighbor)
    78                                                             
    79     59.4 MiB    -30.2 MiB         917           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.4 MiB    -30.2 MiB         917           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.6 MiB     61.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.8 MiB      0.0 MiB         257       for row in grid:
    30     61.8 MiB      0.0 MiB       65792           for spot in row:
    31     61.8 MiB      0.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.8 MiB      0.0 MiB           1       count = 0
    34     61.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.8 MiB      0.0 MiB           1       came_from = {}
    37     62.4 MiB      0.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.4 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.5 MiB      0.0 MiB        2478       while not open_set.empty():
    47     65.5 MiB      0.0 MiB        2478           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.5 MiB      0.0 MiB        2478           current = open_set.get()[2]
    53     65.5 MiB      0.0 MiB        2478           open_set_hash.remove(current)
    54                                         
    55     65.5 MiB      0.0 MiB        2478           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.5 MiB      0.0 MiB        2478           if current == end:
    60     65.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.5 MiB      0.0 MiB       22293           for neighbor in current.neighbors:
    65     65.5 MiB      0.0 MiB       19816               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.5 MiB      0.0 MiB        9908                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.5 MiB      0.0 MiB        9908                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.5 MiB      0.0 MiB       19816               if temp_g_score < g_score[neighbor]:
    71     65.5 MiB      0.1 MiB        2796                   came_from[neighbor] = current
    72     65.5 MiB      0.0 MiB        2796                   g_score[neighbor] = temp_g_score
    73     65.5 MiB      0.0 MiB        2796                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.5 MiB      0.0 MiB        2796                   if neighbor not in open_set_hash:
    75     65.5 MiB      0.0 MiB        2796                       count += 1
    76     65.5 MiB      0.0 MiB        2796                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.5 MiB      0.0 MiB        2796                       open_set_hash.add(neighbor)
    78                                                             
    79     65.5 MiB      0.0 MiB        2477           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.5 MiB      0.0 MiB        2477           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     65.5 MiB     65.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     65.5 MiB      0.0 MiB         257       for row in grid:
    30     65.5 MiB      0.0 MiB       65792           for spot in row:
    31     65.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     65.5 MiB      0.0 MiB           1       count = 0
    34     65.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     65.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     65.5 MiB      0.0 MiB           1       came_from = {}
    37     67.1 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.2 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.3 MiB      0.0 MiB        1526       while not open_set.empty():
    47     69.3 MiB      0.0 MiB        1526           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.3 MiB      0.0 MiB        1526           current = open_set.get()[2]
    53     69.3 MiB      0.0 MiB        1526           open_set_hash.remove(current)
    54                                         
    55     69.3 MiB      0.0 MiB        1526           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.3 MiB      0.0 MiB        1526           if current == end:
    60     69.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.3 MiB      0.0 MiB       13725           for neighbor in current.neighbors:
    65     69.3 MiB      0.0 MiB       12200               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.3 MiB      0.0 MiB        6100                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.3 MiB      0.0 MiB        6100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.3 MiB      0.0 MiB       12200               if temp_g_score < g_score[neighbor]:
    71     69.3 MiB      0.1 MiB        1988                   came_from[neighbor] = current
    72     69.3 MiB      0.0 MiB        1988                   g_score[neighbor] = temp_g_score
    73     69.3 MiB      0.0 MiB        1988                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.3 MiB      0.0 MiB        1988                   if neighbor not in open_set_hash:
    75     69.3 MiB      0.0 MiB        1988                       count += 1
    76     69.3 MiB      0.0 MiB        1988                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.3 MiB      0.0 MiB        1988                       open_set_hash.add(neighbor)
    78                                                             
    79     69.3 MiB      0.0 MiB        1525           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.3 MiB      0.0 MiB        1525           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.3 MiB     69.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.3 MiB      0.0 MiB         257       for row in grid:
    30     69.3 MiB      0.0 MiB       65792           for spot in row:
    31     69.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     69.3 MiB      0.0 MiB           1       count = 0
    34     69.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     69.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     69.3 MiB      0.0 MiB           1       came_from = {}
    37     69.4 MiB -51858.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.5 MiB     -0.9 MiB           1       g_score[start] = 0
    39     68.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.5 MiB -21403.8 MiB        6909       while not open_set.empty():
    47     68.5 MiB -21403.8 MiB        6909           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.5 MiB -21404.0 MiB        6909           current = open_set.get()[2]
    53     68.5 MiB -21404.0 MiB        6909           open_set_hash.remove(current)
    54                                         
    55     68.5 MiB -21404.0 MiB        6909           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.5 MiB -21404.0 MiB        6909           if current == end:
    60     62.5 MiB     -6.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.5 MiB -192617.7 MiB       62172           for neighbor in current.neighbors:
    65     68.5 MiB -171215.7 MiB       55264               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.5 MiB -85615.2 MiB       27632                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.5 MiB -85601.6 MiB       27632                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.5 MiB -171218.0 MiB       55264               if temp_g_score < g_score[neighbor]:
    71     68.5 MiB -22576.0 MiB        7389                   came_from[neighbor] = current
    72     68.5 MiB -22576.0 MiB        7389                   g_score[neighbor] = temp_g_score
    73     68.5 MiB -22576.0 MiB        7389                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.5 MiB -22576.0 MiB        7389                   if neighbor not in open_set_hash:
    75     68.5 MiB -22576.0 MiB        7389                       count += 1
    76     68.5 MiB -22576.0 MiB        7389                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.5 MiB -22576.0 MiB        7389                       open_set_hash.add(neighbor)
    78                                                             
    79     68.5 MiB -21403.7 MiB        6908           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.5 MiB -21403.8 MiB        6908           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.9 MiB     96.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.9 MiB    -31.9 MiB         257       for row in grid:
    30     96.9 MiB  -7776.2 MiB       65792           for spot in row:
    31     96.9 MiB  -7745.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.3 MiB     -2.7 MiB           1       count = 0
    34     94.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.3 MiB      0.0 MiB           1       came_from = {}
    37     96.7 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.1 MiB -12194.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.1 MiB  -2131.1 MiB        8991       while not open_set.empty():
    47    100.1 MiB  -2131.1 MiB        8991           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.1 MiB  -2131.1 MiB        8991           current = open_set.get()[2]
    53    100.1 MiB  -2131.1 MiB        8991           open_set_hash.remove(current)
    54                                         
    55    100.1 MiB  -2131.1 MiB        8991           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.1 MiB  -2131.1 MiB        8991           if current == end:
    60     99.0 MiB     -1.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.1 MiB -19174.7 MiB       80910           for neighbor in current.neighbors:
    65    100.1 MiB -17044.5 MiB       71920               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.1 MiB  -8524.7 MiB       35960                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.1 MiB  -8520.2 MiB       35960                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.1 MiB -17045.0 MiB       71920               if temp_g_score < g_score[neighbor]:
    71    100.1 MiB  -2265.2 MiB        9535                   came_from[neighbor] = current
    72    100.1 MiB  -2265.2 MiB        9535                   g_score[neighbor] = temp_g_score
    73    100.1 MiB  -2265.2 MiB        9535                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.1 MiB  -2265.2 MiB        9535                   if neighbor not in open_set_hash:
    75    100.1 MiB  -2265.2 MiB        9535                       count += 1
    76    100.1 MiB  -2265.2 MiB        9535                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.1 MiB  -2265.2 MiB        9535                       open_set_hash.add(neighbor)
    78                                                             
    79    100.1 MiB  -2131.1 MiB        8990           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.1 MiB  -2131.1 MiB        8990           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.0 MiB     99.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.0 MiB    -46.5 MiB         257       for row in grid:
    30     99.0 MiB -11861.0 MiB       65792           for spot in row:
    31     99.0 MiB -11814.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.6 MiB     -0.4 MiB           1       count = 0
    34     98.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.6 MiB      0.0 MiB           1       came_from = {}
    37     99.5 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.7 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.7 MiB  -5340.7 MiB        2948       while not open_set.empty():
    47    102.7 MiB  -5340.7 MiB        2948           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.7 MiB  -5340.7 MiB        2948           current = open_set.get()[2]
    53    102.7 MiB  -5340.7 MiB        2948           open_set_hash.remove(current)
    54                                         
    55    102.7 MiB  -5340.7 MiB        2948           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.7 MiB  -5340.7 MiB        2948           if current == end:
    60    100.2 MiB     -2.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.7 MiB -48045.2 MiB       26523           for neighbor in current.neighbors:
    65    102.7 MiB -42706.0 MiB       23576               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.7 MiB -21353.6 MiB       11788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.7 MiB -21352.6 MiB       11788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.7 MiB -42706.6 MiB       23576               if temp_g_score < g_score[neighbor]:
    71    102.7 MiB  -5700.4 MiB        3256                   came_from[neighbor] = current
    72    102.7 MiB  -5700.4 MiB        3256                   g_score[neighbor] = temp_g_score
    73    102.7 MiB  -5700.4 MiB        3256                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.7 MiB  -5700.4 MiB        3256                   if neighbor not in open_set_hash:
    75    102.7 MiB  -5700.4 MiB        3256                       count += 1
    76    102.7 MiB  -5700.4 MiB        3256                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.7 MiB  -5700.4 MiB        3256                       open_set_hash.add(neighbor)
    78                                                             
    79    102.7 MiB  -5339.8 MiB        2947           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.7 MiB  -5340.4 MiB        2947           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.2 MiB    100.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.2 MiB     -7.2 MiB         257       for row in grid:
    30    100.2 MiB  -1776.2 MiB       65792           for spot in row:
    31    100.2 MiB  -1771.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.6 MiB     -3.6 MiB           1       count = 0
    34     96.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.6 MiB      0.0 MiB           1       came_from = {}
    37     99.0 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.3 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.3 MiB      0.0 MiB         800       while not open_set.empty():
    47     99.3 MiB      0.0 MiB         800           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.3 MiB      0.0 MiB         800           current = open_set.get()[2]
    53     99.3 MiB      0.0 MiB         800           open_set_hash.remove(current)
    54                                         
    55     99.3 MiB      0.0 MiB         800           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.3 MiB      0.0 MiB         800           if current == end:
    60     99.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.3 MiB      0.0 MiB        7191           for neighbor in current.neighbors:
    65     99.3 MiB      0.0 MiB        6392               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.3 MiB      0.0 MiB        3196                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.3 MiB      0.0 MiB        3196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.3 MiB      0.0 MiB        6392               if temp_g_score < g_score[neighbor]:
    71     99.3 MiB      0.0 MiB        1214                   came_from[neighbor] = current
    72     99.3 MiB      0.0 MiB        1214                   g_score[neighbor] = temp_g_score
    73     99.3 MiB      0.0 MiB        1214                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.3 MiB      0.0 MiB        1214                   if neighbor not in open_set_hash:
    75     99.3 MiB      0.0 MiB        1214                       count += 1
    76     99.3 MiB      0.0 MiB        1214                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.3 MiB      0.0 MiB        1214                       open_set_hash.add(neighbor)
    78                                                             
    79     99.3 MiB      0.0 MiB         799           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.3 MiB      0.0 MiB         799           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.3 MiB     99.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.3 MiB   -523.8 MiB         257       for row in grid:
    30     99.3 MiB -134452.8 MiB       65792           for spot in row:
    31     99.3 MiB -133930.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.0 MiB     -2.3 MiB           1       count = 0
    34     97.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.0 MiB      0.0 MiB           1       came_from = {}
    37    100.0 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.9 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.9 MiB      0.0 MiB        1400       while not open_set.empty():
    47    100.9 MiB      0.0 MiB        1400           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.9 MiB      0.0 MiB        1400           current = open_set.get()[2]
    53    100.9 MiB      0.0 MiB        1400           open_set_hash.remove(current)
    54                                         
    55    100.9 MiB      0.0 MiB        1400           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.9 MiB      0.0 MiB        1400           if current == end:
    60    100.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.9 MiB      0.0 MiB       12591           for neighbor in current.neighbors:
    65    100.9 MiB      0.0 MiB       11192               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.9 MiB      0.0 MiB        5596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.9 MiB      0.0 MiB        5596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.9 MiB      0.0 MiB       11192               if temp_g_score < g_score[neighbor]:
    71    100.9 MiB      0.0 MiB        1618                   came_from[neighbor] = current
    72    100.9 MiB      0.0 MiB        1618                   g_score[neighbor] = temp_g_score
    73    100.9 MiB      0.0 MiB        1618                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.9 MiB      0.0 MiB        1618                   if neighbor not in open_set_hash:
    75    100.9 MiB      0.0 MiB        1618                       count += 1
    76    100.9 MiB      0.0 MiB        1618                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.9 MiB      0.0 MiB        1618                       open_set_hash.add(neighbor)
    78                                                             
    79    100.9 MiB      0.0 MiB        1399           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.9 MiB      0.0 MiB        1399           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.9 MiB    100.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.9 MiB   -921.4 MiB         257       for row in grid:
    30    100.9 MiB -236275.1 MiB       65792           for spot in row:
    31    100.9 MiB -235357.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.2 MiB     -5.7 MiB           1       count = 0
    34     95.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.2 MiB      0.0 MiB           1       came_from = {}
    37     96.5 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.6 MiB   -706.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.4 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.5 MiB  -2058.8 MiB         630       while not open_set.empty():
    47     97.5 MiB  -2058.8 MiB         630           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.5 MiB  -2058.8 MiB         630           current = open_set.get()[2]
    53     97.5 MiB  -2058.8 MiB         630           open_set_hash.remove(current)
    54                                         
    55     97.5 MiB  -2058.8 MiB         630           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.5 MiB  -2058.8 MiB         630           if current == end:
    60     92.2 MiB     -5.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.5 MiB -18521.1 MiB        5661           for neighbor in current.neighbors:
    65     97.5 MiB -16463.9 MiB        5032               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.5 MiB  -8234.1 MiB        2516                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.5 MiB  -8230.1 MiB        2516                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.5 MiB -16464.2 MiB        5032               if temp_g_score < g_score[neighbor]:
    71     97.5 MiB  -2406.8 MiB         774                   came_from[neighbor] = current
    72     97.5 MiB  -2406.8 MiB         774                   g_score[neighbor] = temp_g_score
    73     97.5 MiB  -2406.8 MiB         774                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.5 MiB  -2406.8 MiB         774                   if neighbor not in open_set_hash:
    75     97.5 MiB  -2406.8 MiB         774                       count += 1
    76     97.5 MiB  -2407.4 MiB         774                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.5 MiB  -2407.7 MiB         774                       open_set_hash.add(neighbor)
    78                                                             
    79     97.5 MiB  -2058.8 MiB         629           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.5 MiB  -2058.8 MiB         629           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.2 MiB     92.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.2 MiB  -1760.8 MiB         257       for row in grid:
    30     92.2 MiB -452135.3 MiB       65792           for spot in row:
    31     92.2 MiB -450378.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.9 MiB     -6.3 MiB           1       count = 0
    34     85.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     85.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     85.9 MiB      0.0 MiB           1       came_from = {}
    37     88.5 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     92.6 MiB  -2144.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     91.2 MiB     -1.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     91.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     91.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     91.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     91.2 MiB      0.0 MiB         108       while not open_set.empty():
    47     91.2 MiB      0.0 MiB         108           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     91.2 MiB      0.0 MiB         108           current = open_set.get()[2]
    53     91.2 MiB      0.0 MiB         108           open_set_hash.remove(current)
    54                                         
    55     91.2 MiB      0.0 MiB         108           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     91.2 MiB      0.0 MiB         108           if current == end:
    60     91.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     91.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     91.2 MiB      0.0 MiB         963           for neighbor in current.neighbors:
    65     91.2 MiB      0.0 MiB         856               if current.row != neighbor.row and current.col != neighbor.col:
    66     91.2 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     91.2 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     91.2 MiB      0.0 MiB         856               if temp_g_score < g_score[neighbor]:
    71     91.2 MiB      0.0 MiB         256                   came_from[neighbor] = current
    72     91.2 MiB      0.0 MiB         256                   g_score[neighbor] = temp_g_score
    73     91.2 MiB      0.0 MiB         256                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     91.2 MiB      0.0 MiB         256                   if neighbor not in open_set_hash:
    75     91.2 MiB      0.0 MiB         256                       count += 1
    76     91.2 MiB      0.0 MiB         256                       open_set.put((f_score[neighbor], count, neighbor))
    77     91.2 MiB      0.0 MiB         256                       open_set_hash.add(neighbor)
    78                                                             
    79     91.2 MiB      0.0 MiB         107           if draw is not None:
    80                                                     draw()
    81                                         
    82     91.2 MiB      0.0 MiB         107           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.2 MiB     91.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.2 MiB    -98.9 MiB         257       for row in grid:
    30     91.2 MiB -25270.5 MiB       65792           for spot in row:
    31     91.2 MiB -25172.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.9 MiB     -1.3 MiB           1       count = 0
    34     89.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     89.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     89.9 MiB      0.0 MiB           1       came_from = {}
    37     92.9 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     92.9 MiB -122820.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     92.0 MiB     -0.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     92.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     92.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     92.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     92.1 MiB      0.0 MiB         357       while not open_set.empty():
    47     92.1 MiB      0.0 MiB         357           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     92.1 MiB      0.0 MiB         357           current = open_set.get()[2]
    53     92.1 MiB      0.0 MiB         357           open_set_hash.remove(current)
    54                                         
    55     92.1 MiB      0.0 MiB         357           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     92.1 MiB      0.0 MiB         357           if current == end:
    60     92.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     92.1 MiB      0.0 MiB        3204           for neighbor in current.neighbors:
    65     92.1 MiB      0.0 MiB        2848               if current.row != neighbor.row and current.col != neighbor.col:
    66     92.1 MiB      0.0 MiB        1424                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     92.1 MiB      0.0 MiB        1424                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     92.1 MiB      0.0 MiB        2848               if temp_g_score < g_score[neighbor]:
    71     92.1 MiB      0.0 MiB         573                   came_from[neighbor] = current
    72     92.1 MiB      0.0 MiB         573                   g_score[neighbor] = temp_g_score
    73     92.1 MiB      0.0 MiB         573                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     92.1 MiB      0.0 MiB         573                   if neighbor not in open_set_hash:
    75     92.1 MiB      0.0 MiB         573                       count += 1
    76     92.1 MiB      0.0 MiB         573                       open_set.put((f_score[neighbor], count, neighbor))
    77     92.1 MiB      0.0 MiB         573                       open_set_hash.add(neighbor)
    78                                                             
    79     92.1 MiB      0.0 MiB         356           if draw is not None:
    80                                                     draw()
    81                                         
    82     92.1 MiB      0.0 MiB         356           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.2 MiB    107.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.2 MiB   -592.6 MiB         257       for row in grid:
    30    107.2 MiB -152096.8 MiB       65792           for spot in row:
    31    107.2 MiB -151506.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.0 MiB     -3.2 MiB           1       count = 0
    34    104.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.0 MiB      0.0 MiB           1       came_from = {}
    37    104.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.7 MiB  -5141.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.9 MiB      0.0 MiB        3311       while not open_set.empty():
    47    104.9 MiB      0.0 MiB        3311           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.9 MiB      0.0 MiB        3311           current = open_set.get()[2]
    53    104.9 MiB      0.0 MiB        3311           open_set_hash.remove(current)
    54                                         
    55    104.9 MiB      0.0 MiB        3311           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.9 MiB      0.0 MiB        3311           if current == end:
    60    104.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.9 MiB      0.0 MiB       29790           for neighbor in current.neighbors:
    65    104.9 MiB      0.0 MiB       26480               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.9 MiB      0.0 MiB       13240                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.9 MiB      0.0 MiB       13240                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.9 MiB      0.0 MiB       26480               if temp_g_score < g_score[neighbor]:
    71    104.9 MiB      0.2 MiB        3703                   came_from[neighbor] = current
    72    104.9 MiB      0.0 MiB        3703                   g_score[neighbor] = temp_g_score
    73    104.9 MiB      0.0 MiB        3703                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.9 MiB      0.0 MiB        3703                   if neighbor not in open_set_hash:
    75    104.9 MiB      0.0 MiB        3703                       count += 1
    76    104.9 MiB      0.0 MiB        3703                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.9 MiB      0.1 MiB        3703                       open_set_hash.add(neighbor)
    78                                                             
    79    104.9 MiB      0.0 MiB        3310           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.9 MiB      0.0 MiB        3310           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.9 MiB    104.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.9 MiB   -163.8 MiB         257       for row in grid:
    30    104.9 MiB -42067.6 MiB       65792           for spot in row:
    31    104.9 MiB -41904.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.2 MiB     -0.7 MiB           1       count = 0
    34    104.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.2 MiB      0.0 MiB           1       came_from = {}
    37    107.6 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.9 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.0 MiB      0.0 MiB         585       while not open_set.empty():
    47    108.0 MiB      0.0 MiB         585           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.0 MiB      0.0 MiB         585           current = open_set.get()[2]
    53    108.0 MiB      0.0 MiB         585           open_set_hash.remove(current)
    54                                         
    55    108.0 MiB      0.0 MiB         585           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.0 MiB      0.0 MiB         585           if current == end:
    60    108.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.0 MiB      0.0 MiB        5256           for neighbor in current.neighbors:
    65    108.0 MiB      0.0 MiB        4672               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.0 MiB      0.0 MiB        2336                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.0 MiB      0.0 MiB        2336                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.0 MiB      0.0 MiB        4672               if temp_g_score < g_score[neighbor]:
    71    108.0 MiB      0.0 MiB         749                   came_from[neighbor] = current
    72    108.0 MiB      0.0 MiB         749                   g_score[neighbor] = temp_g_score
    73    108.0 MiB      0.0 MiB         749                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.0 MiB      0.0 MiB         749                   if neighbor not in open_set_hash:
    75    108.0 MiB      0.0 MiB         749                       count += 1
    76    108.0 MiB      0.0 MiB         749                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.0 MiB      0.0 MiB         749                       open_set_hash.add(neighbor)
    78                                                             
    79    108.0 MiB      0.0 MiB         584           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.0 MiB      0.0 MiB         584           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.0 MiB    108.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.0 MiB     -3.7 MiB         257       for row in grid:
    30    108.0 MiB   -937.4 MiB       65792           for spot in row:
    31    108.0 MiB   -933.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.0 MiB     -0.0 MiB           1       count = 0
    34    108.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.0 MiB      0.0 MiB           1       came_from = {}
    37    111.8 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.8 MiB -18287.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.5 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.5 MiB      0.0 MiB         959       while not open_set.empty():
    47    111.5 MiB      0.0 MiB         959           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.5 MiB      0.0 MiB         959           current = open_set.get()[2]
    53    111.5 MiB      0.0 MiB         959           open_set_hash.remove(current)
    54                                         
    55    111.5 MiB      0.0 MiB         959           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.5 MiB      0.0 MiB         959           if current == end:
    60    111.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.5 MiB      0.0 MiB        8622           for neighbor in current.neighbors:
    65    111.5 MiB      0.0 MiB        7664               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.5 MiB      0.0 MiB        3832                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.5 MiB      0.0 MiB        3832                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.5 MiB      0.0 MiB        7664               if temp_g_score < g_score[neighbor]:
    71    111.5 MiB      0.0 MiB        1259                   came_from[neighbor] = current
    72    111.5 MiB      0.0 MiB        1259                   g_score[neighbor] = temp_g_score
    73    111.5 MiB      0.0 MiB        1259                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.5 MiB      0.0 MiB        1259                   if neighbor not in open_set_hash:
    75    111.5 MiB      0.0 MiB        1259                       count += 1
    76    111.5 MiB      0.0 MiB        1259                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.5 MiB      0.0 MiB        1259                       open_set_hash.add(neighbor)
    78                                                             
    79    111.5 MiB      0.0 MiB         958           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.5 MiB      0.0 MiB         958           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.5 MiB    111.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.5 MiB   -953.9 MiB         257       for row in grid:
    30    111.5 MiB -243998.7 MiB       65792           for spot in row:
    31    111.5 MiB -243048.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.7 MiB     -5.8 MiB           1       count = 0
    34    105.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.7 MiB      0.0 MiB           1       came_from = {}
    37    110.2 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.2 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.2 MiB  -1465.0 MiB        1440       while not open_set.empty():
    47    112.2 MiB  -1465.0 MiB        1440           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.2 MiB  -1465.0 MiB        1440           current = open_set.get()[2]
    53    112.2 MiB  -1465.0 MiB        1440           open_set_hash.remove(current)
    54                                         
    55    112.2 MiB  -1465.0 MiB        1440           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.2 MiB  -1465.0 MiB        1440           if current == end:
    60    110.2 MiB     -2.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.2 MiB -13175.8 MiB       12951           for neighbor in current.neighbors:
    65    112.2 MiB -11711.4 MiB       11512               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.2 MiB  -5859.3 MiB        5756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.2 MiB  -5853.0 MiB        5756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.2 MiB -11712.5 MiB       11512               if temp_g_score < g_score[neighbor]:
    71    112.2 MiB  -1657.8 MiB        1670                   came_from[neighbor] = current
    72    112.2 MiB  -1657.8 MiB        1670                   g_score[neighbor] = temp_g_score
    73    112.2 MiB  -1657.9 MiB        1670                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.2 MiB  -1657.9 MiB        1670                   if neighbor not in open_set_hash:
    75    112.2 MiB  -1657.9 MiB        1670                       count += 1
    76    112.2 MiB  -1657.9 MiB        1670                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.2 MiB  -1657.9 MiB        1670                       open_set_hash.add(neighbor)
    78                                                             
    79    112.2 MiB  -1465.0 MiB        1439           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.2 MiB  -1465.0 MiB        1439           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.2 MiB    110.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.2 MiB      0.0 MiB         257       for row in grid:
    30    110.2 MiB      0.0 MiB       65792           for spot in row:
    31    110.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.2 MiB      0.0 MiB           1       count = 0
    34    110.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.2 MiB      0.0 MiB           1       came_from = {}
    37    110.8 MiB  -7484.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.8 MiB     -1.0 MiB           1       g_score[start] = 0
    39    110.2 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.2 MiB      0.0 MiB        1720       while not open_set.empty():
    47    110.2 MiB      0.0 MiB        1720           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.2 MiB      0.0 MiB        1720           current = open_set.get()[2]
    53    110.2 MiB      0.0 MiB        1720           open_set_hash.remove(current)
    54                                         
    55    110.2 MiB      0.0 MiB        1720           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.2 MiB      0.0 MiB        1720           if current == end:
    60    110.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.2 MiB      0.0 MiB       15471           for neighbor in current.neighbors:
    65    110.2 MiB      0.0 MiB       13752               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.2 MiB      0.0 MiB        6876                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.2 MiB      0.0 MiB        6876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.2 MiB      0.0 MiB       13752               if temp_g_score < g_score[neighbor]:
    71    110.2 MiB      0.0 MiB        1970                   came_from[neighbor] = current
    72    110.2 MiB      0.0 MiB        1970                   g_score[neighbor] = temp_g_score
    73    110.2 MiB      0.0 MiB        1970                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.2 MiB      0.0 MiB        1970                   if neighbor not in open_set_hash:
    75    110.2 MiB      0.0 MiB        1970                       count += 1
    76    110.2 MiB      0.0 MiB        1970                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.2 MiB      0.0 MiB        1970                       open_set_hash.add(neighbor)
    78                                                             
    79    110.2 MiB      0.0 MiB        1719           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.2 MiB      0.0 MiB        1719           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.2 MiB    110.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.2 MiB    -89.7 MiB         257       for row in grid:
    30    110.2 MiB -22968.3 MiB       65792           for spot in row:
    31    110.2 MiB -22878.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    109.6 MiB     -0.6 MiB           1       count = 0
    34    109.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    109.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    109.6 MiB      0.0 MiB           1       came_from = {}
    37    109.9 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.7 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.7 MiB      0.0 MiB         272       while not open_set.empty():
    47    113.7 MiB      0.0 MiB         272           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.7 MiB      0.0 MiB         272           current = open_set.get()[2]
    53    113.7 MiB      0.0 MiB         272           open_set_hash.remove(current)
    54                                         
    55    113.7 MiB      0.0 MiB         272           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.7 MiB      0.0 MiB         272           if current == end:
    60    113.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.7 MiB      0.0 MiB        2439           for neighbor in current.neighbors:
    65    113.7 MiB      0.0 MiB        2168               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.7 MiB      0.0 MiB        1084                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.7 MiB      0.0 MiB        1084                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.7 MiB      0.0 MiB        2168               if temp_g_score < g_score[neighbor]:
    71    113.7 MiB      0.0 MiB         422                   came_from[neighbor] = current
    72    113.7 MiB      0.0 MiB         422                   g_score[neighbor] = temp_g_score
    73    113.7 MiB      0.0 MiB         422                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.7 MiB      0.0 MiB         422                   if neighbor not in open_set_hash:
    75    113.7 MiB      0.0 MiB         422                       count += 1
    76    113.7 MiB      0.0 MiB         422                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.7 MiB      0.0 MiB         422                       open_set_hash.add(neighbor)
    78                                                             
    79    113.7 MiB      0.0 MiB         271           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.7 MiB      0.0 MiB         271           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.7 MiB    113.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.7 MiB  -1006.2 MiB         257       for row in grid:
    30    113.7 MiB -257906.5 MiB       65792           for spot in row:
    31    113.7 MiB -256906.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.7 MiB     -9.0 MiB           1       count = 0
    34    104.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.7 MiB      0.0 MiB           1       came_from = {}
    37    106.2 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.3 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.3 MiB      0.0 MiB         225       while not open_set.empty():
    47    108.3 MiB      0.0 MiB         225           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.3 MiB      0.0 MiB         225           current = open_set.get()[2]
    53    108.3 MiB      0.0 MiB         225           open_set_hash.remove(current)
    54                                         
    55    108.3 MiB      0.0 MiB         225           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.3 MiB      0.0 MiB         225           if current == end:
    60    108.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.3 MiB      0.0 MiB        2016           for neighbor in current.neighbors:
    65    108.3 MiB      0.0 MiB        1792               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.3 MiB      0.0 MiB         896                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.3 MiB      0.0 MiB         896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.3 MiB      0.0 MiB        1792               if temp_g_score < g_score[neighbor]:
    71    108.3 MiB      0.0 MiB         529                   came_from[neighbor] = current
    72    108.3 MiB      0.0 MiB         529                   g_score[neighbor] = temp_g_score
    73    108.3 MiB      0.0 MiB         529                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.3 MiB      0.0 MiB         529                   if neighbor not in open_set_hash:
    75    108.3 MiB      0.0 MiB         529                       count += 1
    76    108.3 MiB      0.0 MiB         529                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.3 MiB      0.0 MiB         529                       open_set_hash.add(neighbor)
    78                                                             
    79    108.3 MiB      0.0 MiB         224           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.3 MiB      0.0 MiB         224           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.5 MiB    105.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.5 MiB  -1943.7 MiB         257       for row in grid:
    30    105.5 MiB -497002.8 MiB       65792           for spot in row:
    31    105.5 MiB -495066.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.6 MiB    -11.9 MiB           1       count = 0
    34     93.7 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     93.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.7 MiB      0.0 MiB           1       came_from = {}
    37     95.1 MiB -178031.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     82.1 MiB    -13.0 MiB           1       g_score[start] = 0
    39     85.8 MiB -423693.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     58.8 MiB    -27.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     58.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     58.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     58.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.3 MiB      0.0 MiB        2562       while not open_set.empty():
    47     61.3 MiB      0.0 MiB        2562           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.3 MiB      0.0 MiB        2562           current = open_set.get()[2]
    53     61.3 MiB      0.0 MiB        2562           open_set_hash.remove(current)
    54                                         
    55     61.3 MiB      0.0 MiB        2562           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.3 MiB      0.0 MiB        2562           if current == end:
    60     61.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.3 MiB      0.0 MiB       23049           for neighbor in current.neighbors:
    65     61.3 MiB      2.3 MiB       20488               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.3 MiB      0.0 MiB       10244                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.3 MiB      0.0 MiB       10244                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.3 MiB      0.0 MiB       20488               if temp_g_score < g_score[neighbor]:
    71     61.3 MiB      0.2 MiB        2888                   came_from[neighbor] = current
    72     61.3 MiB      0.0 MiB        2888                   g_score[neighbor] = temp_g_score
    73     61.3 MiB      0.0 MiB        2888                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.3 MiB      0.0 MiB        2888                   if neighbor not in open_set_hash:
    75     61.3 MiB      0.0 MiB        2888                       count += 1
    76     61.3 MiB      0.0 MiB        2888                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.3 MiB      0.0 MiB        2888                       open_set_hash.add(neighbor)
    78                                                             
    79     61.3 MiB      0.0 MiB        2561           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.3 MiB      0.0 MiB        2561           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.5 MiB     61.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     65.1 MiB     -0.1 MiB         257       for row in grid:
    30     65.1 MiB    -22.1 MiB       65792           for spot in row:
    31     65.1 MiB    -18.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     65.1 MiB     -0.0 MiB           1       count = 0
    34     65.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     65.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     65.1 MiB      0.0 MiB           1       came_from = {}
    37     69.5 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.0 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.0 MiB      0.0 MiB         548       while not open_set.empty():
    47     70.0 MiB      0.0 MiB         548           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.0 MiB      0.0 MiB         548           current = open_set.get()[2]
    53     70.0 MiB      0.0 MiB         548           open_set_hash.remove(current)
    54                                         
    55     70.0 MiB      0.0 MiB         548           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.0 MiB      0.0 MiB         548           if current == end:
    60     70.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.0 MiB      0.0 MiB        4923           for neighbor in current.neighbors:
    65     70.0 MiB      0.0 MiB        4376               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.0 MiB      0.0 MiB        2188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.0 MiB      0.0 MiB        2188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.0 MiB      0.0 MiB        4376               if temp_g_score < g_score[neighbor]:
    71     70.0 MiB      0.0 MiB         836                   came_from[neighbor] = current
    72     70.0 MiB      0.0 MiB         836                   g_score[neighbor] = temp_g_score
    73     70.0 MiB      0.0 MiB         836                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.0 MiB      0.0 MiB         836                   if neighbor not in open_set_hash:
    75     70.0 MiB      0.0 MiB         836                       count += 1
    76     70.0 MiB      0.0 MiB         836                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.0 MiB      0.0 MiB         836                       open_set_hash.add(neighbor)
    78                                                             
    79     70.0 MiB      0.0 MiB         547           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.0 MiB      0.0 MiB         547           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.0 MiB     70.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     70.0 MiB   -948.5 MiB         257       for row in grid:
    30     70.0 MiB -242636.9 MiB       65792           for spot in row:
    31     70.0 MiB -241696.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.8 MiB    -10.2 MiB           1       count = 0
    34     59.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.8 MiB      0.0 MiB           1       came_from = {}
    37     63.4 MiB  -7796.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.2 MiB     -1.2 MiB           1       g_score[start] = 0
    39     66.3 MiB -30786.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.6 MiB     -2.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.8 MiB      0.0 MiB        2232       while not open_set.empty():
    47     63.8 MiB      0.0 MiB        2232           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.8 MiB      0.0 MiB        2232           current = open_set.get()[2]
    53     63.8 MiB      0.0 MiB        2232           open_set_hash.remove(current)
    54                                         
    55     63.8 MiB      0.0 MiB        2232           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.8 MiB      0.0 MiB        2232           if current == end:
    60     63.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.8 MiB      0.0 MiB       20079           for neighbor in current.neighbors:
    65     63.8 MiB      0.1 MiB       17848               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.8 MiB      0.0 MiB        8924                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.8 MiB      0.0 MiB        8924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.8 MiB      0.0 MiB       17848               if temp_g_score < g_score[neighbor]:
    71     63.8 MiB      0.1 MiB        2498                   came_from[neighbor] = current
    72     63.8 MiB      0.0 MiB        2498                   g_score[neighbor] = temp_g_score
    73     63.8 MiB      0.0 MiB        2498                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.8 MiB      0.0 MiB        2498                   if neighbor not in open_set_hash:
    75     63.8 MiB      0.0 MiB        2498                       count += 1
    76     63.8 MiB      0.0 MiB        2498                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.8 MiB      0.0 MiB        2498                       open_set_hash.add(neighbor)
    78                                                             
    79     63.8 MiB      0.0 MiB        2231           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.8 MiB      0.0 MiB        2231           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.8 MiB     63.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.9 MiB   -122.5 MiB         257       for row in grid:
    30     63.9 MiB -31000.0 MiB       65792           for spot in row:
    31     63.9 MiB -30880.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.6 MiB     -4.3 MiB           1       count = 0
    34     59.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.6 MiB      0.0 MiB           1       came_from = {}
    37     62.0 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     63.7 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.7 MiB      0.0 MiB         574       while not open_set.empty():
    47     63.7 MiB      0.0 MiB         574           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.7 MiB      0.0 MiB         574           current = open_set.get()[2]
    53     63.7 MiB      0.0 MiB         574           open_set_hash.remove(current)
    54                                         
    55     63.7 MiB      0.0 MiB         574           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.7 MiB      0.0 MiB         574           if current == end:
    60     63.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.7 MiB      0.0 MiB        5157           for neighbor in current.neighbors:
    65     63.7 MiB      0.0 MiB        4584               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.7 MiB      0.0 MiB        2292                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.7 MiB      0.0 MiB        2292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.7 MiB      0.0 MiB        4584               if temp_g_score < g_score[neighbor]:
    71     63.7 MiB      0.0 MiB         710                   came_from[neighbor] = current
    72     63.7 MiB      0.0 MiB         710                   g_score[neighbor] = temp_g_score
    73     63.7 MiB      0.0 MiB         710                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.7 MiB      0.0 MiB         710                   if neighbor not in open_set_hash:
    75     63.7 MiB      0.0 MiB         710                       count += 1
    76     63.7 MiB      0.0 MiB         710                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.7 MiB      0.0 MiB         710                       open_set_hash.add(neighbor)
    78                                                             
    79     63.7 MiB      0.0 MiB         573           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.7 MiB      0.0 MiB         573           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.7 MiB     63.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.7 MiB   -728.4 MiB         257       for row in grid:
    30     63.7 MiB -186507.6 MiB       65792           for spot in row:
    31     63.7 MiB -185780.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.0 MiB     -3.7 MiB           1       count = 0
    34     60.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.0 MiB      0.0 MiB           1       came_from = {}
    37     63.8 MiB  -1833.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.1 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.1 MiB -28000.9 MiB        2990       while not open_set.empty():
    47     64.1 MiB -28001.3 MiB        2990           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.1 MiB -28002.4 MiB        2990           current = open_set.get()[2]
    53     64.1 MiB -28002.5 MiB        2990           open_set_hash.remove(current)
    54                                         
    55     64.1 MiB -28002.6 MiB        2990           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.1 MiB -28002.7 MiB        2990           if current == end:
    60     37.6 MiB    -26.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     37.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.1 MiB -251878.7 MiB       26901           for neighbor in current.neighbors:
    65     64.1 MiB -223882.4 MiB       23912               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.1 MiB -111972.0 MiB       11956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.1 MiB -111913.2 MiB       11956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.1 MiB -223886.9 MiB       23912               if temp_g_score < g_score[neighbor]:
    71     64.1 MiB -30919.5 MiB        3340                   came_from[neighbor] = current
    72     64.1 MiB -30926.1 MiB        3340                   g_score[neighbor] = temp_g_score
    73     64.1 MiB -30926.8 MiB        3340                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.1 MiB -30927.1 MiB        3340                   if neighbor not in open_set_hash:
    75     64.1 MiB -30927.4 MiB        3340                       count += 1
    76     64.1 MiB -30928.5 MiB        3340                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.1 MiB -30929.8 MiB        3340                       open_set_hash.add(neighbor)
    78                                                             
    79     64.1 MiB -28000.2 MiB        2989           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.1 MiB -28000.8 MiB        2989           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     44.0 MiB     44.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     53.6 MiB    -42.5 MiB         257       for row in grid:
    30     53.6 MiB -11018.9 MiB       65792           for spot in row:
    31     53.6 MiB -10966.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     53.6 MiB      0.0 MiB           1       count = 0
    34     53.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     53.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     53.6 MiB      0.0 MiB           1       came_from = {}
    37     54.8 MiB -302832.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     41.9 MiB    -12.8 MiB           1       g_score[start] = 0
    39     47.1 MiB -12665.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     46.8 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     46.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     46.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     46.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     47.3 MiB      0.0 MiB          30       while not open_set.empty():
    47     47.3 MiB      0.0 MiB          30           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     47.3 MiB      0.0 MiB          30           current = open_set.get()[2]
    53     47.3 MiB      0.0 MiB          30           open_set_hash.remove(current)
    54                                         
    55     47.3 MiB      0.0 MiB          30           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     47.3 MiB      0.0 MiB          30           if current == end:
    60     47.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     47.3 MiB      0.2 MiB         261           for neighbor in current.neighbors:
    65     47.3 MiB      0.2 MiB         232               if current.row != neighbor.row and current.col != neighbor.col:
    66     47.3 MiB      0.0 MiB         116                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     47.3 MiB      0.0 MiB         116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     47.3 MiB      0.0 MiB         232               if temp_g_score < g_score[neighbor]:
    71     47.3 MiB      0.0 MiB          60                   came_from[neighbor] = current
    72     47.3 MiB      0.0 MiB          60                   g_score[neighbor] = temp_g_score
    73     47.3 MiB      0.0 MiB          60                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     47.3 MiB      0.0 MiB          60                   if neighbor not in open_set_hash:
    75     47.3 MiB      0.0 MiB          60                       count += 1
    76     47.3 MiB      0.0 MiB          60                       open_set.put((f_score[neighbor], count, neighbor))
    77     47.3 MiB      0.0 MiB          60                       open_set_hash.add(neighbor)
    78                                                             
    79     47.3 MiB      0.0 MiB          29           if draw is not None:
    80                                                     draw()
    81                                         
    82     47.3 MiB      0.0 MiB          29           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     50.0 MiB     50.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     56.8 MiB   -146.1 MiB         257       for row in grid:
    30     56.8 MiB -37262.1 MiB       65792           for spot in row:
    31     56.8 MiB -37112.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     56.8 MiB      0.0 MiB           1       count = 0
    34     56.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     56.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     56.8 MiB      0.0 MiB           1       came_from = {}
    37     60.7 MiB    -75.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     63.0 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.0 MiB      0.0 MiB         104       while not open_set.empty():
    47     63.0 MiB      0.0 MiB         104           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.0 MiB      0.0 MiB         104           current = open_set.get()[2]
    53     63.0 MiB      0.0 MiB         104           open_set_hash.remove(current)
    54                                         
    55     63.0 MiB      0.0 MiB         104           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.0 MiB      0.0 MiB         104           if current == end:
    60     63.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.0 MiB      0.0 MiB         927           for neighbor in current.neighbors:
    65     63.0 MiB      0.0 MiB         824               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.0 MiB      0.0 MiB         412                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.0 MiB      0.0 MiB         412                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.0 MiB      0.0 MiB         824               if temp_g_score < g_score[neighbor]:
    71     63.0 MiB      0.0 MiB         214                   came_from[neighbor] = current
    72     63.0 MiB      0.0 MiB         214                   g_score[neighbor] = temp_g_score
    73     63.0 MiB      0.0 MiB         214                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.0 MiB      0.0 MiB         214                   if neighbor not in open_set_hash:
    75     63.0 MiB      0.0 MiB         214                       count += 1
    76     63.0 MiB      0.0 MiB         214                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.0 MiB      0.0 MiB         214                       open_set_hash.add(neighbor)
    78                                                             
    79     63.0 MiB      0.0 MiB         103           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.0 MiB      0.0 MiB         103           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.8 MiB    100.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.8 MiB   -704.5 MiB         257       for row in grid:
    30    100.8 MiB -180905.4 MiB       65792           for spot in row:
    31    100.8 MiB -180204.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.1 MiB     -3.7 MiB           1       count = 0
    34     97.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.1 MiB      0.0 MiB           1       came_from = {}
    37    101.2 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.6 MiB -13254.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.7 MiB     -2.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.8 MiB  -4711.8 MiB        6600       while not open_set.empty():
    47    100.8 MiB  -4711.8 MiB        6600           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.8 MiB  -4711.8 MiB        6600           current = open_set.get()[2]
    53    100.8 MiB  -4711.8 MiB        6600           open_set_hash.remove(current)
    54                                         
    55    100.8 MiB  -4711.8 MiB        6600           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.8 MiB  -4711.8 MiB        6600           if current == end:
    60     98.4 MiB     -2.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.8 MiB -42401.4 MiB       59391           for neighbor in current.neighbors:
    65    100.8 MiB -37690.0 MiB       52792               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.8 MiB -18846.4 MiB       26396                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.8 MiB -18844.3 MiB       26396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.8 MiB -37691.3 MiB       52792               if temp_g_score < g_score[neighbor]:
    71    100.8 MiB  -5007.5 MiB        7058                   came_from[neighbor] = current
    72    100.8 MiB  -5007.5 MiB        7058                   g_score[neighbor] = temp_g_score
    73    100.8 MiB  -5007.6 MiB        7058                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.8 MiB  -5007.6 MiB        7058                   if neighbor not in open_set_hash:
    75    100.8 MiB  -5007.6 MiB        7058                       count += 1
    76    100.8 MiB  -5007.7 MiB        7058                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.8 MiB  -5007.7 MiB        7058                       open_set_hash.add(neighbor)
    78                                                             
    79    100.8 MiB  -4711.8 MiB        6599           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.8 MiB  -4711.8 MiB        6599           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.4 MiB     98.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.4 MiB      0.0 MiB         257       for row in grid:
    30     98.4 MiB      0.0 MiB       65792           for spot in row:
    31     98.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.4 MiB      0.0 MiB           1       count = 0
    34     98.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.4 MiB      0.0 MiB           1       came_from = {}
    37     99.2 MiB -19270.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.3 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.3 MiB -33208.0 MiB        9170       while not open_set.empty():
    47    103.3 MiB -33208.0 MiB        9170           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.3 MiB -33208.4 MiB        9170           current = open_set.get()[2]
    53    103.3 MiB -33208.5 MiB        9170           open_set_hash.remove(current)
    54                                         
    55    103.3 MiB -33208.6 MiB        9170           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.3 MiB -33208.6 MiB        9170           if current == end:
    60     93.0 MiB    -10.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.3 MiB -298836.5 MiB       82521           for neighbor in current.neighbors:
    65    103.3 MiB -265631.7 MiB       73352               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.3 MiB -132826.3 MiB       36676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.3 MiB -132806.2 MiB       36676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.3 MiB -265635.5 MiB       73352               if temp_g_score < g_score[neighbor]:
    71    103.3 MiB -35151.2 MiB        9832                   came_from[neighbor] = current
    72    103.3 MiB -35151.4 MiB        9832                   g_score[neighbor] = temp_g_score
    73    103.3 MiB -35152.6 MiB        9832                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.3 MiB -35152.8 MiB        9832                   if neighbor not in open_set_hash:
    75    103.3 MiB -35152.9 MiB        9832                       count += 1
    76    103.3 MiB -35152.9 MiB        9832                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.3 MiB -35152.9 MiB        9832                       open_set_hash.add(neighbor)
    78                                                             
    79    103.3 MiB -33207.8 MiB        9169           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.3 MiB -33207.9 MiB        9169           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.8 MiB     93.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.8 MiB   -143.1 MiB         257       for row in grid:
    30     95.8 MiB -36606.8 MiB       65792           for spot in row:
    31     95.8 MiB -36462.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.9 MiB     -0.9 MiB           1       count = 0
    34     94.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.9 MiB      0.0 MiB           1       came_from = {}
    37     95.9 MiB -56646.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.9 MiB      1.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.0 MiB  -3742.9 MiB        1440       while not open_set.empty():
    47     97.0 MiB  -3743.1 MiB        1440           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.0 MiB  -3743.3 MiB        1440           current = open_set.get()[2]
    53     97.0 MiB  -3743.8 MiB        1440           open_set_hash.remove(current)
    54                                         
    55     97.0 MiB  -3744.5 MiB        1440           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.0 MiB  -3745.0 MiB        1440           if current == end:
    60     86.5 MiB    -10.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     86.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.0 MiB -33643.0 MiB       12951           for neighbor in current.neighbors:
    65     97.0 MiB -29902.7 MiB       11512               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.0 MiB -14958.2 MiB        5756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.0 MiB -14946.1 MiB        5756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.0 MiB -29905.6 MiB       11512               if temp_g_score < g_score[neighbor]:
    71     97.0 MiB  -4309.7 MiB        1670                   came_from[neighbor] = current
    72     97.0 MiB  -4309.8 MiB        1670                   g_score[neighbor] = temp_g_score
    73     97.0 MiB  -4310.0 MiB        1670                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.0 MiB  -4310.1 MiB        1670                   if neighbor not in open_set_hash:
    75     97.0 MiB  -4310.2 MiB        1670                       count += 1
    76     97.0 MiB  -4310.3 MiB        1670                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.0 MiB  -4310.4 MiB        1670                       open_set_hash.add(neighbor)
    78                                                             
    79     97.0 MiB  -3741.9 MiB        1439           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.0 MiB  -3742.3 MiB        1439           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     86.6 MiB     86.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     86.6 MiB  -4261.7 MiB         257       for row in grid:
    30     86.6 MiB -1091337.7 MiB       65792           for spot in row:
    31     86.6 MiB -1087095.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.1 MiB    -27.5 MiB           1       count = 0
    34     59.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.1 MiB      0.0 MiB           1       came_from = {}
    37     59.7 MiB -115387.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.7 MiB     -1.0 MiB           1       g_score[start] = 0
    39     60.1 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.2 MiB      0.0 MiB         640       while not open_set.empty():
    47     60.2 MiB      0.0 MiB         640           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.2 MiB      0.0 MiB         640           current = open_set.get()[2]
    53     60.2 MiB      0.0 MiB         640           open_set_hash.remove(current)
    54                                         
    55     60.2 MiB      0.0 MiB         640           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.2 MiB      0.0 MiB         640           if current == end:
    60     60.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.2 MiB      0.0 MiB        5751           for neighbor in current.neighbors:
    65     60.2 MiB      0.0 MiB        5112               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.2 MiB      0.0 MiB        2556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.2 MiB      0.0 MiB        2556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.2 MiB      0.0 MiB        5112               if temp_g_score < g_score[neighbor]:
    71     60.2 MiB      0.1 MiB         806                   came_from[neighbor] = current
    72     60.2 MiB      0.0 MiB         806                   g_score[neighbor] = temp_g_score
    73     60.2 MiB      0.0 MiB         806                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.2 MiB      0.0 MiB         806                   if neighbor not in open_set_hash:
    75     60.2 MiB      0.0 MiB         806                       count += 1
    76     60.2 MiB      0.0 MiB         806                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.2 MiB      0.0 MiB         806                       open_set_hash.add(neighbor)
    78                                                             
    79     60.2 MiB      0.0 MiB         639           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.2 MiB      0.0 MiB         639           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     60.3 MiB     60.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.4 MiB      0.0 MiB         257       for row in grid:
    30     60.4 MiB      0.0 MiB       65792           for spot in row:
    31     60.4 MiB      0.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.4 MiB      0.0 MiB           1       count = 0
    34     60.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.4 MiB      0.0 MiB           1       came_from = {}
    37     64.1 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.9 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.9 MiB      0.0 MiB         123       while not open_set.empty():
    47     64.9 MiB      0.0 MiB         123           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.9 MiB      0.0 MiB         123           current = open_set.get()[2]
    53     64.9 MiB      0.0 MiB         123           open_set_hash.remove(current)
    54                                         
    55     64.9 MiB      0.0 MiB         123           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.9 MiB      0.0 MiB         123           if current == end:
    60     64.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.9 MiB      0.0 MiB        1098           for neighbor in current.neighbors:
    65     64.9 MiB      0.0 MiB         976               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.9 MiB      0.0 MiB         488                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.9 MiB      0.0 MiB         488                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.9 MiB      0.0 MiB         976               if temp_g_score < g_score[neighbor]:
    71     64.9 MiB      0.0 MiB         291                   came_from[neighbor] = current
    72     64.9 MiB      0.0 MiB         291                   g_score[neighbor] = temp_g_score
    73     64.9 MiB      0.0 MiB         291                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.9 MiB      0.0 MiB         291                   if neighbor not in open_set_hash:
    75     64.9 MiB      0.0 MiB         291                       count += 1
    76     64.9 MiB      0.0 MiB         291                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.9 MiB      0.0 MiB         291                       open_set_hash.add(neighbor)
    78                                                             
    79     64.9 MiB      0.0 MiB         122           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.9 MiB      0.0 MiB         122           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.9 MiB     64.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.9 MiB   -422.4 MiB         257       for row in grid:
    30     64.9 MiB -107412.1 MiB       65792           for spot in row:
    31     64.9 MiB -106997.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     54.4 MiB    -10.4 MiB           1       count = 0
    34     54.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     54.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     54.4 MiB      0.0 MiB           1       came_from = {}
    37     55.9 MiB -12603.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.1 MiB      4.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.1 MiB  -2416.1 MiB        1548       while not open_set.empty():
    47     60.1 MiB  -2416.1 MiB        1548           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.1 MiB  -2416.2 MiB        1548           current = open_set.get()[2]
    53     60.1 MiB  -2416.6 MiB        1548           open_set_hash.remove(current)
    54                                         
    55     60.1 MiB  -2416.6 MiB        1548           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.1 MiB  -2416.6 MiB        1548           if current == end:
    60     52.7 MiB     -7.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     52.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.1 MiB -21716.6 MiB       13923           for neighbor in current.neighbors:
    65     60.1 MiB -19301.4 MiB       12376               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.1 MiB  -9657.4 MiB        6188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.1 MiB  -9644.9 MiB        6188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.1 MiB -19303.5 MiB       12376               if temp_g_score < g_score[neighbor]:
    71     60.1 MiB  -2880.7 MiB        1852                   came_from[neighbor] = current
    72     60.1 MiB  -2880.7 MiB        1852                   g_score[neighbor] = temp_g_score
    73     60.1 MiB  -2880.7 MiB        1852                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.1 MiB  -2880.8 MiB        1852                   if neighbor not in open_set_hash:
    75     60.1 MiB  -2880.9 MiB        1852                       count += 1
    76     60.1 MiB  -2880.9 MiB        1852                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.1 MiB  -2880.9 MiB        1852                       open_set_hash.add(neighbor)
    78                                                             
    79     60.1 MiB  -2416.1 MiB        1547           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.1 MiB  -2416.1 MiB        1547           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     55.5 MiB     55.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     55.5 MiB  -2215.1 MiB         257       for row in grid:
    30     56.6 MiB -569875.8 MiB       65792           for spot in row:
    31     56.6 MiB -566916.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     51.5 MiB     -4.0 MiB           1       count = 0
    34     51.7 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     51.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     51.7 MiB      0.0 MiB           1       came_from = {}
    37     55.6 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.1 MiB      5.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.2 MiB    -33.9 MiB        3569       while not open_set.empty():
    47     61.2 MiB    -33.9 MiB        3569           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.2 MiB    -33.9 MiB        3569           current = open_set.get()[2]
    53     61.2 MiB    -33.9 MiB        3569           open_set_hash.remove(current)
    54                                         
    55     61.2 MiB    -33.9 MiB        3569           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.2 MiB    -33.9 MiB        3569           if current == end:
    60     61.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.3 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.2 MiB   -305.0 MiB       32112           for neighbor in current.neighbors:
    65     61.2 MiB   -271.2 MiB       28544               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.2 MiB   -135.6 MiB       14272                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.2 MiB   -135.6 MiB       14272                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.2 MiB   -271.2 MiB       28544               if temp_g_score < g_score[neighbor]:
    71     61.2 MiB    -36.6 MiB        3905                   came_from[neighbor] = current
    72     61.2 MiB    -36.6 MiB        3905                   g_score[neighbor] = temp_g_score
    73     61.2 MiB    -36.6 MiB        3905                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.2 MiB    -36.6 MiB        3905                   if neighbor not in open_set_hash:
    75     61.2 MiB    -36.6 MiB        3905                       count += 1
    76     61.2 MiB    -36.5 MiB        3905                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.2 MiB    -36.5 MiB        3905                       open_set_hash.add(neighbor)
    78                                                             
    79     61.2 MiB    -33.9 MiB        3568           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.2 MiB    -33.9 MiB        3568           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.3 MiB   -542.8 MiB         257       for row in grid:
    30    100.3 MiB -138520.3 MiB       65792           for spot in row:
    31    100.3 MiB -137980.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.2 MiB     -5.0 MiB           1       count = 0
    34     95.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.2 MiB      0.0 MiB           1       came_from = {}
    37     99.0 MiB  -2345.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.0 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.0 MiB      0.0 MiB        1298       while not open_set.empty():
    47    101.0 MiB      0.0 MiB        1298           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.0 MiB      0.0 MiB        1298           current = open_set.get()[2]
    53    101.0 MiB      0.0 MiB        1298           open_set_hash.remove(current)
    54                                         
    55    101.0 MiB      0.0 MiB        1298           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.0 MiB      0.0 MiB        1298           if current == end:
    60    101.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.0 MiB      0.0 MiB       11673           for neighbor in current.neighbors:
    65    101.0 MiB      0.0 MiB       10376               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.0 MiB      0.0 MiB        5188                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.0 MiB      0.0 MiB        5188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.0 MiB      0.0 MiB       10376               if temp_g_score < g_score[neighbor]:
    71    101.0 MiB      0.0 MiB        1790                   came_from[neighbor] = current
    72    101.0 MiB      0.0 MiB        1790                   g_score[neighbor] = temp_g_score
    73    101.0 MiB      0.0 MiB        1790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.0 MiB      0.0 MiB        1790                   if neighbor not in open_set_hash:
    75    101.0 MiB      0.0 MiB        1790                       count += 1
    76    101.0 MiB      0.0 MiB        1790                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.0 MiB      0.0 MiB        1790                       open_set_hash.add(neighbor)
    78                                                             
    79    101.0 MiB      0.0 MiB        1297           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.0 MiB      0.0 MiB        1297           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.0 MiB    101.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.0 MiB      0.0 MiB         257       for row in grid:
    30    101.0 MiB      0.0 MiB       65792           for spot in row:
    31    101.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.0 MiB      0.0 MiB           1       count = 0
    34    101.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.0 MiB      0.0 MiB           1       came_from = {}
    37    101.5 MiB -58006.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.1 MiB     -2.5 MiB           1       g_score[start] = 0
    39    101.0 MiB  -2998.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.9 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.9 MiB -61684.6 MiB        3168       while not open_set.empty():
    47    100.9 MiB -61684.8 MiB        3168           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.9 MiB -61685.8 MiB        3168           current = open_set.get()[2]
    53    100.9 MiB -61686.5 MiB        3168           open_set_hash.remove(current)
    54                                         
    55    100.9 MiB -61686.8 MiB        3168           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.9 MiB -61687.1 MiB        3168           if current == end:
    60     66.8 MiB    -34.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.9 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.9 MiB -555011.9 MiB       28503           for neighbor in current.neighbors:
    65    100.9 MiB -493330.8 MiB       25336               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.9 MiB -246702.7 MiB       12668                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.9 MiB -246632.2 MiB       12668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.9 MiB -493340.6 MiB       25336               if temp_g_score < g_score[neighbor]:
    71    100.9 MiB -66210.9 MiB        3490                   came_from[neighbor] = current
    72    100.9 MiB -66212.6 MiB        3490                   g_score[neighbor] = temp_g_score
    73    100.9 MiB -66215.9 MiB        3490                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.9 MiB -66217.1 MiB        3490                   if neighbor not in open_set_hash:
    75    100.9 MiB -66219.1 MiB        3490                       count += 1
    76    100.9 MiB -66221.5 MiB        3490                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.9 MiB -66222.4 MiB        3490                       open_set_hash.add(neighbor)
    78                                                             
    79    100.9 MiB -61684.1 MiB        3167           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.9 MiB -61684.3 MiB        3167           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     71.4 MiB     71.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.5 MiB  -5716.2 MiB         257       for row in grid:
    30     74.5 MiB -1466603.3 MiB       65792           for spot in row:
    31     74.5 MiB -1460893.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     51.8 MiB    -22.6 MiB           1       count = 0
    34     51.9 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     52.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.0 MiB      0.0 MiB           1       came_from = {}
    37     58.5 MiB      6.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.2 MiB      2.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.3 MiB      0.0 MiB        1508       while not open_set.empty():
    47     61.3 MiB      0.0 MiB        1508           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.3 MiB      0.0 MiB        1508           current = open_set.get()[2]
    53     61.3 MiB      0.0 MiB        1508           open_set_hash.remove(current)
    54                                         
    55     61.3 MiB      0.0 MiB        1508           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.3 MiB      0.0 MiB        1508           if current == end:
    60     61.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.3 MiB      0.0 MiB       13563           for neighbor in current.neighbors:
    65     61.3 MiB      0.0 MiB       12056               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.3 MiB      0.0 MiB        6028                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.3 MiB      0.0 MiB        6028                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.3 MiB      0.0 MiB       12056               if temp_g_score < g_score[neighbor]:
    71     61.3 MiB      0.0 MiB        1726                   came_from[neighbor] = current
    72     61.3 MiB      0.0 MiB        1726                   g_score[neighbor] = temp_g_score
    73     61.3 MiB      0.0 MiB        1726                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.3 MiB      0.0 MiB        1726                   if neighbor not in open_set_hash:
    75     61.3 MiB      0.0 MiB        1726                       count += 1
    76     61.3 MiB      0.0 MiB        1726                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.3 MiB      0.0 MiB        1726                       open_set_hash.add(neighbor)
    78                                                             
    79     61.3 MiB      0.0 MiB        1507           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.3 MiB      0.0 MiB        1507           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.3 MiB     61.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.3 MiB  -1098.8 MiB         257       for row in grid:
    30     61.3 MiB -281526.2 MiB       65792           for spot in row:
    31     61.3 MiB -280431.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     53.0 MiB     -8.3 MiB           1       count = 0
    34     53.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     53.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     53.0 MiB      0.0 MiB           1       came_from = {}
    37     57.2 MiB   -942.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.9 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.1 MiB      0.0 MiB         444       while not open_set.empty():
    47     61.1 MiB      0.0 MiB         444           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.1 MiB      0.0 MiB         444           current = open_set.get()[2]
    53     61.1 MiB      0.0 MiB         444           open_set_hash.remove(current)
    54                                         
    55     61.1 MiB      0.0 MiB         444           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.1 MiB      0.0 MiB         444           if current == end:
    60     61.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.1 MiB      0.0 MiB        3987           for neighbor in current.neighbors:
    65     61.1 MiB      0.1 MiB        3544               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.1 MiB      0.0 MiB        1772                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.1 MiB      0.0 MiB        1772                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.1 MiB      0.0 MiB        3544               if temp_g_score < g_score[neighbor]:
    71     61.1 MiB      0.0 MiB         750                   came_from[neighbor] = current
    72     61.1 MiB      0.0 MiB         750                   g_score[neighbor] = temp_g_score
    73     61.1 MiB      0.0 MiB         750                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.1 MiB      0.0 MiB         750                   if neighbor not in open_set_hash:
    75     61.1 MiB      0.0 MiB         750                       count += 1
    76     61.1 MiB      0.1 MiB         750                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.1 MiB      0.0 MiB         750                       open_set_hash.add(neighbor)
    78                                                             
    79     61.1 MiB      0.0 MiB         443           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.1 MiB      0.0 MiB         443           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.1 MiB     61.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.6 MiB      0.0 MiB         257       for row in grid:
    30     61.6 MiB      0.0 MiB       65792           for spot in row:
    31     61.6 MiB      0.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.6 MiB      0.0 MiB           1       count = 0
    34     61.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.6 MiB      0.0 MiB           1       came_from = {}
    37     62.2 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.8 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.8 MiB -118751.2 MiB        6321       while not open_set.empty():
    47     64.8 MiB -118752.1 MiB        6321           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.8 MiB -118754.2 MiB        6321           current = open_set.get()[2]
    53     64.8 MiB -118754.9 MiB        6321           open_set_hash.remove(current)
    54                                         
    55     64.8 MiB -118755.6 MiB        6321           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.8 MiB -118756.3 MiB        6321           if current == end:
    60     27.8 MiB    -37.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     27.9 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.8 MiB -1068604.5 MiB       56880           for neighbor in current.neighbors:
    65     64.8 MiB -949859.8 MiB       50560               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.8 MiB -474968.1 MiB       25280                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.8 MiB -474899.5 MiB       25280                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.8 MiB -949872.8 MiB       50560               if temp_g_score < g_score[neighbor]:
    71     64.8 MiB -125663.5 MiB        6785                   came_from[neighbor] = current
    72     64.8 MiB -125664.1 MiB        6785                   g_score[neighbor] = temp_g_score
    73     64.8 MiB -125665.5 MiB        6785                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.8 MiB -125666.4 MiB        6785                   if neighbor not in open_set_hash:
    75     64.8 MiB -125667.6 MiB        6785                       count += 1
    76     64.8 MiB -125669.4 MiB        6785                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.8 MiB -125670.2 MiB        6785                       open_set_hash.add(neighbor)
    78                                                             
    79     64.8 MiB -118750.0 MiB        6320           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.8 MiB -118750.4 MiB        6320           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     37.5 MiB     37.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     51.9 MiB   -214.2 MiB         257       for row in grid:
    30     51.9 MiB -54712.6 MiB       65792           for spot in row:
    31     51.9 MiB -54482.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     51.9 MiB      0.0 MiB           1       count = 0
    34     52.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.0 MiB      0.0 MiB           1       came_from = {}
    37     54.9 MiB -30320.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     54.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     57.5 MiB -15946.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     57.6 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     57.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     57.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     57.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     58.3 MiB    -64.5 MiB         989       while not open_set.empty():
    47     58.3 MiB    -64.7 MiB         989           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     58.3 MiB    -64.4 MiB         989           current = open_set.get()[2]
    53     58.3 MiB    -64.7 MiB         989           open_set_hash.remove(current)
    54                                         
    55     58.3 MiB    -64.8 MiB         989           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     58.3 MiB    -64.8 MiB         989           if current == end:
    60     58.2 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     58.3 MiB   -581.7 MiB        8892           for neighbor in current.neighbors:
    65     58.3 MiB   -517.1 MiB        7904               if current.row != neighbor.row and current.col != neighbor.col:
    66     58.3 MiB   -258.6 MiB        3952                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     58.3 MiB   -258.5 MiB        3952                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     58.3 MiB   -517.1 MiB        7904               if temp_g_score < g_score[neighbor]:
    71     58.3 MiB    -75.5 MiB        1205                   came_from[neighbor] = current
    72     58.3 MiB    -75.6 MiB        1205                   g_score[neighbor] = temp_g_score
    73     58.3 MiB    -75.6 MiB        1205                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     58.3 MiB    -75.6 MiB        1205                   if neighbor not in open_set_hash:
    75     58.3 MiB    -75.6 MiB        1205                       count += 1
    76     58.3 MiB    -75.5 MiB        1205                       open_set.put((f_score[neighbor], count, neighbor))
    77     58.3 MiB    -75.6 MiB        1205                       open_set_hash.add(neighbor)
    78                                                             
    79     58.3 MiB    -64.7 MiB         988           if draw is not None:
    80                                                     draw()
    81                                         
    82     58.3 MiB    -64.7 MiB         988           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     58.2 MiB     58.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.7 MiB      0.0 MiB         257       for row in grid:
    30     58.7 MiB      0.0 MiB       65792           for spot in row:
    31     58.7 MiB      0.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.7 MiB      0.0 MiB           1       count = 0
    34     58.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.7 MiB      0.0 MiB           1       came_from = {}
    37     58.8 MiB  -4529.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.0 MiB -23397.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.4 MiB  -3869.6 MiB        9870       while not open_set.empty():
    47     60.4 MiB  -3869.8 MiB        9870           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.4 MiB  -3870.8 MiB        9870           current = open_set.get()[2]
    53     60.4 MiB  -3871.6 MiB        9870           open_set_hash.remove(current)
    54                                         
    55     60.4 MiB  -3872.6 MiB        9870           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.4 MiB  -3873.4 MiB        9870           if current == end:
    60     52.7 MiB     -7.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     52.8 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.4 MiB -34839.2 MiB       88821           for neighbor in current.neighbors:
    65     60.4 MiB -30973.0 MiB       78952               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.4 MiB -15493.9 MiB       39476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.4 MiB -15481.8 MiB       39476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.4 MiB -30980.0 MiB       78952               if temp_g_score < g_score[neighbor]:
    71     60.4 MiB  -4365.7 MiB       10476                   came_from[neighbor] = current
    72     60.4 MiB  -4366.4 MiB       10476                   g_score[neighbor] = temp_g_score
    73     60.4 MiB  -4366.9 MiB       10476                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.4 MiB  -4366.9 MiB       10476                   if neighbor not in open_set_hash:
    75     60.4 MiB  -4367.0 MiB       10476                       count += 1
    76     60.4 MiB  -4356.1 MiB       10476                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.4 MiB  -4356.5 MiB       10476                       open_set_hash.add(neighbor)
    78                                                             
    79     60.4 MiB  -3869.1 MiB        9869           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.4 MiB  -3869.3 MiB        9869           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.8 MiB     92.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.8 MiB    -12.2 MiB         257       for row in grid:
    30     92.8 MiB  -3138.0 MiB       65792           for spot in row:
    31     92.8 MiB  -3125.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.8 MiB     -0.1 MiB           1       count = 0
    34     92.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.8 MiB      0.0 MiB           1       came_from = {}
    37     97.2 MiB      4.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.2 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.2 MiB  -2793.0 MiB        2023       while not open_set.empty():
    47    100.2 MiB  -2793.0 MiB        2023           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.2 MiB  -2793.0 MiB        2023           current = open_set.get()[2]
    53    100.2 MiB  -2793.1 MiB        2023           open_set_hash.remove(current)
    54                                         
    55    100.2 MiB  -2793.1 MiB        2023           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.2 MiB  -2793.1 MiB        2023           if current == end:
    60     90.1 MiB    -10.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.2 MiB -25075.4 MiB       18198           for neighbor in current.neighbors:
    65    100.2 MiB -22286.1 MiB       16176               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.2 MiB -11152.2 MiB        8088                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.2 MiB -11135.0 MiB        8088                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.2 MiB -22288.4 MiB       16176               if temp_g_score < g_score[neighbor]:
    71    100.2 MiB  -3248.3 MiB        2327                   came_from[neighbor] = current
    72    100.2 MiB  -3248.4 MiB        2327                   g_score[neighbor] = temp_g_score
    73    100.2 MiB  -3248.9 MiB        2327                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.2 MiB  -3249.2 MiB        2327                   if neighbor not in open_set_hash:
    75    100.2 MiB  -3249.5 MiB        2327                       count += 1
    76    100.2 MiB  -3250.0 MiB        2327                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.2 MiB  -3250.6 MiB        2327                       open_set_hash.add(neighbor)
    78                                                             
    79    100.2 MiB  -2792.6 MiB        2022           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.2 MiB  -2792.8 MiB        2022           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.6 MiB     91.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.5 MiB  -9098.7 MiB         257       for row in grid:
    30     92.5 MiB -2333124.9 MiB       65792           for spot in row:
    31     92.5 MiB -2324047.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     47.2 MiB    -45.3 MiB           1       count = 0
    34     47.6 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     47.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     47.8 MiB      0.0 MiB           1       came_from = {}
    37     53.0 MiB      5.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     53.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     56.9 MiB  -1151.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     57.1 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     57.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     57.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     57.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     57.7 MiB      0.0 MiB        3944       while not open_set.empty():
    47     57.7 MiB      0.0 MiB        3944           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     57.7 MiB      0.0 MiB        3944           current = open_set.get()[2]
    53     57.7 MiB      0.0 MiB        3944           open_set_hash.remove(current)
    54                                         
    55     57.7 MiB      0.0 MiB        3944           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     57.7 MiB      0.0 MiB        3944           if current == end:
    60     57.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     57.7 MiB      0.2 MiB       35487           for neighbor in current.neighbors:
    65     57.7 MiB      0.1 MiB       31544               if current.row != neighbor.row and current.col != neighbor.col:
    66     57.7 MiB      0.0 MiB       15772                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     57.7 MiB      0.0 MiB       15772                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     57.7 MiB      0.0 MiB       31544               if temp_g_score < g_score[neighbor]:
    71     57.7 MiB      0.2 MiB        4310                   came_from[neighbor] = current
    72     57.7 MiB      0.0 MiB        4310                   g_score[neighbor] = temp_g_score
    73     57.7 MiB      0.0 MiB        4310                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     57.7 MiB      0.0 MiB        4310                   if neighbor not in open_set_hash:
    75     57.7 MiB      0.0 MiB        4310                       count += 1
    76     57.7 MiB      0.0 MiB        4310                       open_set.put((f_score[neighbor], count, neighbor))
    77     57.7 MiB      0.1 MiB        4310                       open_set_hash.add(neighbor)
    78                                                             
    79     57.7 MiB      0.0 MiB        3943           if draw is not None:
    80                                                     draw()
    81                                         
    82     57.7 MiB      0.0 MiB        3943           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     60.1 MiB     60.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.4 MiB     -6.6 MiB         257       for row in grid:
    30     60.4 MiB  -1401.9 MiB       65792           for spot in row:
    31     60.4 MiB  -1396.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.1 MiB     -1.3 MiB           1       count = 0
    34     59.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.1 MiB      0.0 MiB           1       came_from = {}
    37     63.4 MiB -110873.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.2 MiB     -8.1 MiB           1       g_score[start] = 0
    39     57.9 MiB -36899.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     57.3 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     57.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     57.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     57.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     57.2 MiB     -2.4 MiB         620       while not open_set.empty():
    47     57.2 MiB   -343.1 MiB         620           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     57.2 MiB   -333.4 MiB         620           current = open_set.get()[2]
    53     57.2 MiB   -323.7 MiB         620           open_set_hash.remove(current)
    54                                         
    55     57.2 MiB   -304.4 MiB         620           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     57.2 MiB   -304.4 MiB         620           if current == end:
    60     56.8 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     57.2 MiB  -2644.2 MiB        5571           for neighbor in current.neighbors:
    65     57.2 MiB  -2355.0 MiB        4952               if current.row != neighbor.row and current.col != neighbor.col:
    66     56.8 MiB  -1217.0 MiB        2476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     57.2 MiB  -1215.4 MiB        2476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     57.2 MiB  -1260.5 MiB        4952               if temp_g_score < g_score[neighbor]:
    71     57.2 MiB   -381.1 MiB         760                   came_from[neighbor] = current
    72     57.2 MiB   -381.2 MiB         760                   g_score[neighbor] = temp_g_score
    73     57.2 MiB   -369.5 MiB         760                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     57.2 MiB   -369.7 MiB         760                   if neighbor not in open_set_hash:
    75     57.2 MiB   -357.9 MiB         760                       count += 1
    76     57.1 MiB   -358.0 MiB         760                       open_set.put((f_score[neighbor], count, neighbor))
    77     57.1 MiB   -310.5 MiB         760                       open_set_hash.add(neighbor)
    78                                                             
    79     56.8 MiB   -294.6 MiB         619           if draw is not None:
    80                                                     draw()
    81                                         
    82     56.8 MiB     -2.3 MiB         619           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     57.0 MiB     57.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     59.5 MiB  -1239.3 MiB         257       for row in grid:
    30     59.5 MiB -318053.9 MiB       65792           for spot in row:
    31     59.5 MiB -316813.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.6 MiB     -6.9 MiB           1       count = 0
    34     52.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.6 MiB      0.0 MiB           1       came_from = {}
    37     56.8 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.0 MiB      4.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.2 MiB      0.0 MiB         639       while not open_set.empty():
    47     61.2 MiB      0.0 MiB         639           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.2 MiB      0.0 MiB         639           current = open_set.get()[2]
    53     61.2 MiB      0.0 MiB         639           open_set_hash.remove(current)
    54                                         
    55     61.2 MiB      0.0 MiB         639           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.2 MiB      0.0 MiB         639           if current == end:
    60     61.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.2 MiB      0.0 MiB        5742           for neighbor in current.neighbors:
    65     61.2 MiB      0.1 MiB        5104               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.2 MiB      0.0 MiB        2552                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.2 MiB      0.0 MiB        2552                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.2 MiB      0.0 MiB        5104               if temp_g_score < g_score[neighbor]:
    71     61.2 MiB      0.0 MiB         939                   came_from[neighbor] = current
    72     61.2 MiB      0.0 MiB         939                   g_score[neighbor] = temp_g_score
    73     61.2 MiB      0.0 MiB         939                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.2 MiB      0.0 MiB         939                   if neighbor not in open_set_hash:
    75     61.2 MiB      0.0 MiB         939                       count += 1
    76     61.2 MiB      0.1 MiB         939                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.2 MiB      0.0 MiB         939                       open_set_hash.add(neighbor)
    78                                                             
    79     61.2 MiB      0.0 MiB         638           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.2 MiB      0.0 MiB         638           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.2 MiB     61.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.2 MiB      0.0 MiB         257       for row in grid:
    30     61.2 MiB      0.0 MiB       65792           for spot in row:
    31     61.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.2 MiB      0.0 MiB           1       count = 0
    34     61.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.2 MiB      0.0 MiB           1       came_from = {}
    37     64.7 MiB      3.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.3 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.4 MiB    -21.6 MiB         492       while not open_set.empty():
    47     67.4 MiB    -21.6 MiB         492           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.4 MiB    -21.6 MiB         492           current = open_set.get()[2]
    53     67.4 MiB    -21.6 MiB         492           open_set_hash.remove(current)
    54                                         
    55     67.4 MiB    -21.6 MiB         492           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.4 MiB    -21.6 MiB         492           if current == end:
    60     67.0 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.4 MiB   -193.8 MiB        4419           for neighbor in current.neighbors:
    65     67.4 MiB   -172.3 MiB        3928               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.4 MiB    -86.3 MiB        1964                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.4 MiB    -86.0 MiB        1964                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.4 MiB   -172.3 MiB        3928               if temp_g_score < g_score[neighbor]:
    71     67.4 MiB    -42.4 MiB         990                   came_from[neighbor] = current
    72     67.4 MiB    -42.4 MiB         990                   g_score[neighbor] = temp_g_score
    73     67.4 MiB    -42.4 MiB         990                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.4 MiB    -42.5 MiB         990                   if neighbor not in open_set_hash:
    75     67.4 MiB    -42.5 MiB         990                       count += 1
    76     67.4 MiB    -42.5 MiB         990                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.4 MiB    -42.5 MiB         990                       open_set_hash.add(neighbor)
    78                                                             
    79     67.4 MiB    -21.6 MiB         491           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.4 MiB    -21.6 MiB         491           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.0 MiB     67.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.0 MiB  -2034.5 MiB         257       for row in grid:
    30     67.0 MiB -519790.1 MiB       65792           for spot in row:
    31     67.0 MiB -517769.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     45.2 MiB    -21.9 MiB           1       count = 0
    34     45.2 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     45.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     45.3 MiB      0.0 MiB           1       came_from = {}
    37     47.9 MiB -83358.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     47.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     51.9 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     52.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     52.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     52.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     52.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     56.3 MiB  -3020.1 MiB        5265       while not open_set.empty():
    47     56.3 MiB  -3020.1 MiB        5265           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     56.3 MiB  -3020.2 MiB        5265           current = open_set.get()[2]
    53     56.3 MiB  -3020.2 MiB        5265           open_set_hash.remove(current)
    54                                         
    55     56.3 MiB  -3020.3 MiB        5265           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     56.3 MiB  -3020.4 MiB        5265           if current == end:
    60     55.9 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     56.3 MiB -27174.1 MiB       47376           for neighbor in current.neighbors:
    65     56.3 MiB -24151.5 MiB       42112               if current.row != neighbor.row and current.col != neighbor.col:
    66     56.3 MiB -12081.0 MiB       21056                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     56.3 MiB -12073.2 MiB       21056                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     56.3 MiB -24156.4 MiB       42112               if temp_g_score < g_score[neighbor]:
    71     56.3 MiB  -3189.6 MiB        5685                   came_from[neighbor] = current
    72     56.3 MiB  -3189.9 MiB        5685                   g_score[neighbor] = temp_g_score
    73     56.3 MiB  -3189.9 MiB        5685                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     56.3 MiB  -3189.9 MiB        5685                   if neighbor not in open_set_hash:
    75     56.3 MiB  -3189.9 MiB        5685                       count += 1
    76     56.3 MiB  -3189.9 MiB        5685                       open_set.put((f_score[neighbor], count, neighbor))
    77     56.3 MiB  -3189.9 MiB        5685                       open_set_hash.add(neighbor)
    78                                                             
    79     56.3 MiB  -3020.0 MiB        5264           if draw is not None:
    80                                                     draw()
    81                                         
    82     56.3 MiB  -3020.0 MiB        5264           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     56.0 MiB     56.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.8 MiB      0.0 MiB         257       for row in grid:
    30     61.8 MiB      0.0 MiB       65792           for spot in row:
    31     61.8 MiB      5.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.8 MiB      0.0 MiB           1       count = 0
    34     61.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.8 MiB      0.0 MiB           1       came_from = {}
    37     65.1 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.5 MiB      1.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.6 MiB      0.0 MiB        1400       while not open_set.empty():
    47     66.6 MiB      0.0 MiB        1400           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.6 MiB      0.0 MiB        1400           current = open_set.get()[2]
    53     66.6 MiB      0.0 MiB        1400           open_set_hash.remove(current)
    54                                         
    55     66.6 MiB      0.0 MiB        1400           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.6 MiB      0.0 MiB        1400           if current == end:
    60     66.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.6 MiB      0.0 MiB       12591           for neighbor in current.neighbors:
    65     66.6 MiB      0.0 MiB       11192               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.6 MiB      0.0 MiB        5596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.6 MiB      0.0 MiB        5596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.6 MiB      0.0 MiB       11192               if temp_g_score < g_score[neighbor]:
    71     66.6 MiB      0.0 MiB        1826                   came_from[neighbor] = current
    72     66.6 MiB      0.0 MiB        1826                   g_score[neighbor] = temp_g_score
    73     66.6 MiB      0.0 MiB        1826                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.6 MiB      0.0 MiB        1826                   if neighbor not in open_set_hash:
    75     66.6 MiB      0.0 MiB        1826                       count += 1
    76     66.6 MiB      0.0 MiB        1826                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.6 MiB      0.0 MiB        1826                       open_set_hash.add(neighbor)
    78                                                             
    79     66.6 MiB      0.0 MiB        1399           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.6 MiB      0.0 MiB        1399           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.8 MiB    100.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.8 MiB  -2399.2 MiB         257       for row in grid:
    30    100.8 MiB -614999.2 MiB       65792           for spot in row:
    31    100.8 MiB -612609.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.4 MiB    -13.4 MiB           1       count = 0
    34     87.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     87.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     87.4 MiB      0.0 MiB           1       came_from = {}
    37     91.7 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.6 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.7 MiB      0.0 MiB        9991       while not open_set.empty():
    47     94.7 MiB      0.0 MiB        9991           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.7 MiB      0.0 MiB        9991           current = open_set.get()[2]
    53     94.7 MiB      0.0 MiB        9991           open_set_hash.remove(current)
    54                                         
    55     94.7 MiB      0.0 MiB        9991           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.7 MiB      0.0 MiB        9991           if current == end:
    60     94.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.7 MiB      0.0 MiB       89910           for neighbor in current.neighbors:
    65     94.7 MiB      0.0 MiB       79920               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.7 MiB      0.0 MiB       39960                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.7 MiB      0.0 MiB       39960                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.7 MiB      0.0 MiB       79920               if temp_g_score < g_score[neighbor]:
    71     94.7 MiB      0.0 MiB       10595                   came_from[neighbor] = current
    72     94.7 MiB      0.0 MiB       10595                   g_score[neighbor] = temp_g_score
    73     94.7 MiB      0.0 MiB       10595                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.7 MiB      0.0 MiB       10595                   if neighbor not in open_set_hash:
    75     94.7 MiB      0.0 MiB       10595                       count += 1
    76     94.7 MiB      0.0 MiB       10595                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.7 MiB      0.0 MiB       10595                       open_set_hash.add(neighbor)
    78                                                             
    79     94.7 MiB      0.0 MiB        9990           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.7 MiB      0.0 MiB        9990           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.7 MiB     94.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.7 MiB   -330.1 MiB         257       for row in grid:
    30     94.7 MiB -84402.7 MiB       65792           for spot in row:
    31     94.7 MiB -84076.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.5 MiB     -4.2 MiB           1       count = 0
    34     90.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     90.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     90.5 MiB      0.0 MiB           1       came_from = {}
    37     90.5 MiB -514168.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.0 MiB    -16.5 MiB           1       g_score[start] = 0
    39     74.0 MiB -2005005.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     39.0 MiB    -35.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     39.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     39.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     39.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     44.5 MiB -19938.1 MiB        8633       while not open_set.empty():
    47     44.5 MiB -19938.2 MiB        8633           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     44.5 MiB -19938.3 MiB        8633           current = open_set.get()[2]
    53     44.5 MiB -19938.4 MiB        8633           open_set_hash.remove(current)
    54                                         
    55     44.5 MiB -19938.4 MiB        8633           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     44.5 MiB -19938.6 MiB        8633           if current == end:
    60     44.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     44.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     44.5 MiB -179420.6 MiB       77688           for neighbor in current.neighbors:
    65     44.5 MiB -159481.3 MiB       69056               if current.row != neighbor.row and current.col != neighbor.col:
    66     44.5 MiB -79748.7 MiB       34528                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     44.5 MiB -79736.3 MiB       34528                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     44.5 MiB -159485.3 MiB       69056               if temp_g_score < g_score[neighbor]:
    71     44.5 MiB -20763.1 MiB        9181                   came_from[neighbor] = current
    72     44.5 MiB -20763.4 MiB        9181                   g_score[neighbor] = temp_g_score
    73     44.5 MiB -20763.6 MiB        9181                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     44.5 MiB -20763.6 MiB        9181                   if neighbor not in open_set_hash:
    75     44.5 MiB -20763.6 MiB        9181                       count += 1
    76     44.5 MiB -20763.9 MiB        9181                       open_set.put((f_score[neighbor], count, neighbor))
    77     44.5 MiB -20763.9 MiB        9181                       open_set_hash.add(neighbor)
    78                                                             
    79     44.5 MiB -19938.0 MiB        8632           if draw is not None:
    80                                                     draw()
    81                                         
    82     44.5 MiB -19938.0 MiB        8632           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     46.3 MiB     46.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     57.8 MiB     -7.5 MiB         257       for row in grid:
    30     57.8 MiB  -1873.1 MiB       65792           for spot in row:
    31     57.8 MiB  -1855.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.8 MiB      0.0 MiB           1       count = 0
    34     57.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.8 MiB      0.0 MiB           1       came_from = {}
    37     59.2 MiB -112211.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.8 MiB     -1.4 MiB           1       g_score[start] = 0
    39     60.5 MiB -949410.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     27.7 MiB    -32.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     27.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     27.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     27.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     34.8 MiB   -105.6 MiB         644       while not open_set.empty():
    47     34.8 MiB   -105.8 MiB         644           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     34.8 MiB   -105.5 MiB         644           current = open_set.get()[2]
    53     34.8 MiB   -105.8 MiB         644           open_set_hash.remove(current)
    54                                         
    55     34.8 MiB   -105.2 MiB         644           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     34.8 MiB   -105.2 MiB         644           if current == end:
    60     34.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     34.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     34.8 MiB   -999.1 MiB        5787           for neighbor in current.neighbors:
    65     34.8 MiB   -860.8 MiB        5144               if current.row != neighbor.row and current.col != neighbor.col:
    66     34.8 MiB   -446.7 MiB        2572                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     34.8 MiB   -445.1 MiB        2572                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     34.8 MiB   -868.3 MiB        5144               if temp_g_score < g_score[neighbor]:
    71     34.8 MiB   -167.2 MiB         980                   came_from[neighbor] = current
    72     34.8 MiB   -167.3 MiB         980                   g_score[neighbor] = temp_g_score
    73     34.8 MiB   -167.4 MiB         980                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     34.8 MiB   -167.5 MiB         980                   if neighbor not in open_set_hash:
    75     34.8 MiB   -162.7 MiB         980                       count += 1
    76     34.8 MiB   -157.9 MiB         980                       open_set.put((f_score[neighbor], count, neighbor))
    77     34.8 MiB   -158.1 MiB         980                       open_set_hash.add(neighbor)
    78                                                             
    79     34.8 MiB   -108.7 MiB         643           if draw is not None:
    80                                                     draw()
    81                                         
    82     34.8 MiB   -105.7 MiB         643           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     39.7 MiB     39.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     50.6 MiB   -304.8 MiB         257       for row in grid:
    30     50.6 MiB -78718.1 MiB       65792           for spot in row:
    31     50.6 MiB -78399.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     50.6 MiB      0.0 MiB           1       count = 0
    34     50.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     50.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     50.7 MiB      0.0 MiB           1       came_from = {}
    37     56.2 MiB      5.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.3 MiB      5.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.6 MiB   -455.0 MiB        3384       while not open_set.empty():
    47     61.6 MiB   -455.0 MiB        3384           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.6 MiB   -455.0 MiB        3384           current = open_set.get()[2]
    53     61.6 MiB   -455.0 MiB        3384           open_set_hash.remove(current)
    54                                         
    55     61.6 MiB   -455.0 MiB        3384           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.6 MiB   -455.0 MiB        3384           if current == end:
    60     60.6 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.6 MiB  -4087.2 MiB       30447           for neighbor in current.neighbors:
    65     61.6 MiB  -3632.3 MiB       27064               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.6 MiB  -1817.7 MiB       13532                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.6 MiB  -1815.6 MiB       13532                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.6 MiB  -3633.4 MiB       27064               if temp_g_score < g_score[neighbor]:
    71     61.6 MiB   -509.7 MiB        3714                   came_from[neighbor] = current
    72     61.6 MiB   -510.0 MiB        3714                   g_score[neighbor] = temp_g_score
    73     61.6 MiB   -510.0 MiB        3714                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.6 MiB   -510.0 MiB        3714                   if neighbor not in open_set_hash:
    75     61.6 MiB   -510.0 MiB        3714                       count += 1
    76     61.6 MiB   -510.0 MiB        3714                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.6 MiB   -509.9 MiB        3714                       open_set_hash.add(neighbor)
    78                                                             
    79     61.6 MiB   -455.0 MiB        3383           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.6 MiB   -455.0 MiB        3383           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     60.7 MiB     60.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.7 MiB    -12.7 MiB         257       for row in grid:
    30     60.7 MiB  -3254.2 MiB       65792           for spot in row:
    31     60.7 MiB  -3241.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.7 MiB      0.0 MiB           1       count = 0
    34     60.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.7 MiB      0.0 MiB           1       came_from = {}
    37     64.9 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.1 MiB -60802.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.3 MiB     -3.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.3 MiB   -703.3 MiB         594       while not open_set.empty():
    47     65.3 MiB   -703.6 MiB         594           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.3 MiB   -704.0 MiB         594           current = open_set.get()[2]
    53     65.3 MiB   -704.0 MiB         594           open_set_hash.remove(current)
    54                                         
    55     65.3 MiB   -704.0 MiB         594           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.3 MiB   -704.0 MiB         594           if current == end:
    60     63.8 MiB     -1.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.3 MiB  -6322.4 MiB        5337           for neighbor in current.neighbors:
    65     65.3 MiB  -5619.8 MiB        4744               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.3 MiB  -2810.1 MiB        2372                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.3 MiB  -2809.8 MiB        2372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.3 MiB  -5619.9 MiB        4744               if temp_g_score < g_score[neighbor]:
    71     65.3 MiB   -953.4 MiB         830                   came_from[neighbor] = current
    72     65.3 MiB   -953.5 MiB         830                   g_score[neighbor] = temp_g_score
    73     65.3 MiB   -953.5 MiB         830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.3 MiB   -953.5 MiB         830                   if neighbor not in open_set_hash:
    75     65.3 MiB   -953.5 MiB         830                       count += 1
    76     65.3 MiB   -953.5 MiB         830                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.3 MiB   -953.5 MiB         830                       open_set_hash.add(neighbor)
    78                                                             
    79     65.3 MiB   -702.7 MiB         593           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.3 MiB   -702.9 MiB         593           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.8 MiB     63.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.8 MiB   -715.2 MiB         257       for row in grid:
    30     63.8 MiB -182750.8 MiB       65792           for spot in row:
    31     63.8 MiB -182038.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.3 MiB     -5.5 MiB           1       count = 0
    34     58.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.3 MiB      0.0 MiB           1       came_from = {}
    37     59.7 MiB -64869.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.0 MiB -58597.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.0 MiB      0.0 MiB         702       while not open_set.empty():
    47     61.0 MiB      0.0 MiB         702           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.0 MiB      0.0 MiB         702           current = open_set.get()[2]
    53     61.0 MiB      0.0 MiB         702           open_set_hash.remove(current)
    54                                         
    55     61.0 MiB      0.0 MiB         702           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.0 MiB      0.0 MiB         702           if current == end:
    60     61.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.0 MiB      0.0 MiB        6309           for neighbor in current.neighbors:
    65     61.0 MiB      0.0 MiB        5608               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.0 MiB      0.0 MiB        2804                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.0 MiB      0.0 MiB        2804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.0 MiB      0.0 MiB        5608               if temp_g_score < g_score[neighbor]:
    71     61.0 MiB      0.0 MiB         860                   came_from[neighbor] = current
    72     61.0 MiB      0.0 MiB         860                   g_score[neighbor] = temp_g_score
    73     61.0 MiB      0.0 MiB         860                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.0 MiB      0.0 MiB         860                   if neighbor not in open_set_hash:
    75     61.0 MiB      0.0 MiB         860                       count += 1
    76     61.0 MiB      0.0 MiB         860                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.0 MiB      0.0 MiB         860                       open_set_hash.add(neighbor)
    78                                                             
    79     61.0 MiB      0.0 MiB         701           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.0 MiB      0.0 MiB         701           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.0 MiB     61.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.0 MiB  -1688.5 MiB         257       for row in grid:
    30     61.0 MiB -432844.5 MiB       65792           for spot in row:
    31     61.0 MiB -431159.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     51.0 MiB    -10.0 MiB           1       count = 0
    34     51.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     51.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     51.5 MiB      0.0 MiB           1       came_from = {}
    37     52.2 MiB -143669.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     51.9 MiB     -0.3 MiB           1       g_score[start] = 0
    39     52.4 MiB -306506.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     49.5 MiB     -2.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     49.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     49.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     49.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     49.9 MiB   -222.1 MiB         306       while not open_set.empty():
    47     49.9 MiB   -222.2 MiB         306           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     49.9 MiB   -222.2 MiB         306           current = open_set.get()[2]
    53     49.9 MiB   -222.3 MiB         306           open_set_hash.remove(current)
    54                                         
    55     49.9 MiB   -222.3 MiB         306           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     49.9 MiB   -222.3 MiB         306           if current == end:
    60     48.6 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     49.9 MiB  -1994.1 MiB        2745           for neighbor in current.neighbors:
    65     49.9 MiB  -1772.1 MiB        2440               if current.row != neighbor.row and current.col != neighbor.col:
    66     49.9 MiB   -887.6 MiB        1220                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     49.9 MiB   -884.7 MiB        1220                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     49.9 MiB  -1772.6 MiB        2440               if temp_g_score < g_score[neighbor]:
    71     49.9 MiB   -369.3 MiB         520                   came_from[neighbor] = current
    72     49.9 MiB   -369.4 MiB         520                   g_score[neighbor] = temp_g_score
    73     49.9 MiB   -369.5 MiB         520                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     49.9 MiB   -369.6 MiB         520                   if neighbor not in open_set_hash:
    75     49.9 MiB   -369.6 MiB         520                       count += 1
    76     49.9 MiB   -369.6 MiB         520                       open_set.put((f_score[neighbor], count, neighbor))
    77     49.9 MiB   -369.8 MiB         520                       open_set_hash.add(neighbor)
    78                                                             
    79     49.9 MiB   -222.2 MiB         305           if draw is not None:
    80                                                     draw()
    81                                         
    82     49.9 MiB   -222.2 MiB         305           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.1 MiB     95.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.1 MiB      0.0 MiB         257       for row in grid:
    30     95.1 MiB      0.0 MiB       65792           for spot in row:
    31     95.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.1 MiB      0.0 MiB           1       count = 0
    34     95.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.1 MiB      0.0 MiB           1       came_from = {}
    37     95.8 MiB      0.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.2 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.3 MiB -27832.6 MiB        9310       while not open_set.empty():
    47     98.3 MiB -27833.0 MiB        9310           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.3 MiB -27833.5 MiB        9310           current = open_set.get()[2]
    53     98.3 MiB -27833.6 MiB        9310           open_set_hash.remove(current)
    54                                         
    55     98.3 MiB -27833.7 MiB        9310           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.3 MiB -27834.0 MiB        9310           if current == end:
    60     79.7 MiB    -18.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     79.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.3 MiB -250405.1 MiB       83781           for neighbor in current.neighbors:
    65     98.3 MiB -222576.0 MiB       74472               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.3 MiB -111309.4 MiB       37236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.3 MiB -111270.5 MiB       37236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.3 MiB -222582.9 MiB       74472               if temp_g_score < g_score[neighbor]:
    71     98.3 MiB -30361.1 MiB       10166                   came_from[neighbor] = current
    72     98.3 MiB -30362.2 MiB       10166                   g_score[neighbor] = temp_g_score
    73     98.3 MiB -30362.8 MiB       10166                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.3 MiB -30362.9 MiB       10166                   if neighbor not in open_set_hash:
    75     98.3 MiB -30363.2 MiB       10166                       count += 1
    76     98.3 MiB -30363.5 MiB       10166                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.3 MiB -30363.7 MiB       10166                       open_set_hash.add(neighbor)
    78                                                             
    79     98.3 MiB -27832.2 MiB        9309           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.3 MiB -27832.4 MiB        9309           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     79.9 MiB     79.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     81.3 MiB  -2021.5 MiB         257       for row in grid:
    30     81.3 MiB -514765.2 MiB       65792           for spot in row:
    31     81.3 MiB -512758.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     55.2 MiB    -26.1 MiB           1       count = 0
    34     55.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     55.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     55.2 MiB      0.0 MiB           1       came_from = {}
    37     59.0 MiB      3.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     62.3 MiB -20723.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     58.0 MiB     -4.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     58.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     58.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     58.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     58.1 MiB -42080.5 MiB       13696       while not open_set.empty():
    47     58.1 MiB -42080.5 MiB       13696           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     58.1 MiB -42080.5 MiB       13696           current = open_set.get()[2]
    53     58.1 MiB -42080.5 MiB       13696           open_set_hash.remove(current)
    54                                         
    55     58.1 MiB -42080.5 MiB       13696           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     58.1 MiB -42080.5 MiB       13696           if current == end:
    60     56.1 MiB     -2.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     58.1 MiB -378702.4 MiB      123255           for neighbor in current.neighbors:
    65     58.1 MiB -336622.1 MiB      109560               if current.row != neighbor.row and current.col != neighbor.col:
    66     58.1 MiB -168311.9 MiB       54780                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     58.1 MiB -168310.8 MiB       54780                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     58.1 MiB -336623.1 MiB      109560               if temp_g_score < g_score[neighbor]:
    71     58.1 MiB -43890.7 MiB       14420                   came_from[neighbor] = current
    72     58.1 MiB -43890.8 MiB       14420                   g_score[neighbor] = temp_g_score
    73     58.1 MiB -43890.9 MiB       14420                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     58.1 MiB -43891.1 MiB       14420                   if neighbor not in open_set_hash:
    75     58.1 MiB -43891.8 MiB       14420                       count += 1
    76     58.1 MiB -43892.2 MiB       14420                       open_set.put((f_score[neighbor], count, neighbor))
    77     58.1 MiB -43892.1 MiB       14420                       open_set_hash.add(neighbor)
    78                                                             
    79     58.1 MiB -42080.3 MiB       13695           if draw is not None:
    80                                                     draw()
    81                                         
    82     58.1 MiB -42080.3 MiB       13695           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     56.2 MiB     56.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     58.2 MiB      0.0 MiB         257       for row in grid:
    30     58.2 MiB     -1.6 MiB       65792           for spot in row:
    31     58.2 MiB      0.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.2 MiB      0.0 MiB           1       count = 0
    34     58.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.2 MiB      0.0 MiB           1       came_from = {}
    37     62.2 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.3 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.3 MiB -38311.3 MiB        4876       while not open_set.empty():
    47     66.3 MiB -38311.5 MiB        4876           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.3 MiB -38312.4 MiB        4876           current = open_set.get()[2]
    53     66.3 MiB -38312.5 MiB        4876           open_set_hash.remove(current)
    54                                         
    55     66.3 MiB -38312.9 MiB        4876           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.3 MiB -38313.2 MiB        4876           if current == end:
    60     47.3 MiB    -19.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.4 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.3 MiB -344703.2 MiB       43875           for neighbor in current.neighbors:
    65     66.3 MiB -306394.4 MiB       39000               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.3 MiB -153215.9 MiB       19500                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.3 MiB -153184.4 MiB       19500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.3 MiB -306401.8 MiB       39000               if temp_g_score < g_score[neighbor]:
    71     66.3 MiB -42018.6 MiB        5390                   came_from[neighbor] = current
    72     66.3 MiB -42019.3 MiB        5390                   g_score[neighbor] = temp_g_score
    73     66.3 MiB -42020.4 MiB        5390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.3 MiB -42020.8 MiB        5390                   if neighbor not in open_set_hash:
    75     66.3 MiB -42021.3 MiB        5390                       count += 1
    76     66.3 MiB -42022.3 MiB        5390                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.3 MiB -42023.0 MiB        5390                       open_set_hash.add(neighbor)
    78                                                             
    79     66.3 MiB -38310.4 MiB        4875           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.3 MiB -38310.9 MiB        4875           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     50.3 MiB     50.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     55.4 MiB   -384.8 MiB         257       for row in grid:
    30     55.4 MiB -98902.2 MiB       65792           for spot in row:
    31     55.4 MiB -98511.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     55.4 MiB      0.0 MiB           1       count = 0
    34     55.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     55.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     55.5 MiB      0.0 MiB           1       came_from = {}
    37     59.8 MiB  -1051.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     59.6 MiB     -0.2 MiB           1       g_score[start] = 0
    39     63.6 MiB  -3790.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.8 MiB -38539.5 MiB        7372       while not open_set.empty():
    47     63.8 MiB -38539.5 MiB        7372           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.8 MiB -38540.7 MiB        7372           current = open_set.get()[2]
    53     63.8 MiB -38540.7 MiB        7372           open_set_hash.remove(current)
    54                                         
    55     63.8 MiB -38540.8 MiB        7372           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.8 MiB -38542.2 MiB        7372           if current == end:
    60     56.4 MiB     -7.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.8 MiB -346830.6 MiB       66339           for neighbor in current.neighbors:
    65     63.8 MiB -308291.9 MiB       58968               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.8 MiB -154152.3 MiB       29484                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.8 MiB -154141.6 MiB       29484                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.8 MiB -308294.7 MiB       58968               if temp_g_score < g_score[neighbor]:
    71     63.8 MiB -40224.3 MiB        7868                   came_from[neighbor] = current
    72     63.8 MiB -40224.6 MiB        7868                   g_score[neighbor] = temp_g_score
    73     63.8 MiB -40224.6 MiB        7868                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.8 MiB -40224.6 MiB        7868                   if neighbor not in open_set_hash:
    75     63.8 MiB -40224.8 MiB        7868                       count += 1
    76     63.8 MiB -40224.8 MiB        7868                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.8 MiB -40225.1 MiB        7868                       open_set_hash.add(neighbor)
    78                                                             
    79     63.8 MiB -38539.4 MiB        7371           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.8 MiB -38539.4 MiB        7371           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     57.0 MiB     57.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.1 MiB    -99.8 MiB         257       for row in grid:
    30     60.1 MiB -25749.7 MiB       65792           for spot in row:
    31     60.1 MiB -25645.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.1 MiB      0.0 MiB           1       count = 0
    34     60.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.1 MiB      0.0 MiB           1       came_from = {}
    37     64.1 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.5 MiB -30998.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.1 MiB     -1.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.2 MiB -10694.6 MiB        3266       while not open_set.empty():
    47     66.2 MiB -10694.6 MiB        3266           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.2 MiB -10694.9 MiB        3266           current = open_set.get()[2]
    53     66.2 MiB -10695.0 MiB        3266           open_set_hash.remove(current)
    54                                         
    55     66.2 MiB -10695.0 MiB        3266           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.2 MiB -10695.0 MiB        3266           if current == end:
    60     56.7 MiB     -9.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.8 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.2 MiB -96217.0 MiB       29385           for neighbor in current.neighbors:
    65     66.2 MiB -85523.5 MiB       26120               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.2 MiB -42773.0 MiB       13060                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.2 MiB -42752.7 MiB       13060                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.2 MiB -85530.3 MiB       26120               if temp_g_score < g_score[neighbor]:
    71     66.2 MiB -12529.3 MiB        3878                   came_from[neighbor] = current
    72     66.2 MiB -12529.6 MiB        3878                   g_score[neighbor] = temp_g_score
    73     66.2 MiB -12529.7 MiB        3878                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.2 MiB -12529.8 MiB        3878                   if neighbor not in open_set_hash:
    75     66.2 MiB -12529.8 MiB        3878                       count += 1
    76     66.2 MiB -12529.8 MiB        3878                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.2 MiB -12529.9 MiB        3878                       open_set_hash.add(neighbor)
    78                                                             
    79     66.2 MiB -10694.6 MiB        3265           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.2 MiB -10694.6 MiB        3265           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.8 MiB     59.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.0 MiB   -350.8 MiB         257       for row in grid:
    30     63.0 MiB -89652.0 MiB       65792           for spot in row:
    31     63.0 MiB -89299.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.4 MiB     -2.6 MiB           1       count = 0
    34     60.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.4 MiB     -0.0 MiB           1       came_from = {}
    37     61.6 MiB -436752.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     50.5 MiB    -11.1 MiB           1       g_score[start] = 0
    39     51.8 MiB -18334.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     51.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     51.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     51.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     51.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     53.0 MiB   -562.5 MiB        1190       while not open_set.empty():
    47     53.0 MiB   -562.7 MiB        1190           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     53.0 MiB   -562.4 MiB        1190           current = open_set.get()[2]
    53     53.0 MiB   -562.7 MiB        1190           open_set_hash.remove(current)
    54                                         
    55     53.0 MiB   -562.7 MiB        1190           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     53.0 MiB   -562.7 MiB        1190           if current == end:
    60     52.8 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     52.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     53.0 MiB  -5054.1 MiB       10701           for neighbor in current.neighbors:
    65     53.0 MiB  -4491.2 MiB        9512               if current.row != neighbor.row and current.col != neighbor.col:
    66     53.0 MiB  -2246.9 MiB        4756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     53.0 MiB  -2245.1 MiB        4756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     53.0 MiB  -4492.5 MiB        9512               if temp_g_score < g_score[neighbor]:
    71     53.0 MiB   -672.7 MiB        1466                   came_from[neighbor] = current
    72     53.0 MiB   -672.7 MiB        1466                   g_score[neighbor] = temp_g_score
    73     53.0 MiB   -672.7 MiB        1466                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     53.0 MiB   -672.7 MiB        1466                   if neighbor not in open_set_hash:
    75     53.0 MiB   -672.7 MiB        1466                       count += 1
    76     53.0 MiB   -672.5 MiB        1466                       open_set.put((f_score[neighbor], count, neighbor))
    77     53.0 MiB   -672.5 MiB        1466                       open_set_hash.add(neighbor)
    78                                                             
    79     53.0 MiB   -562.5 MiB        1189           if draw is not None:
    80                                                     draw()
    81                                         
    82     53.0 MiB   -562.6 MiB        1189           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     53.5 MiB     53.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     55.7 MiB  -1115.5 MiB         257       for row in grid:
    30     55.7 MiB -286642.6 MiB       65792           for spot in row:
    31     55.7 MiB -285526.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.0 MiB     -3.8 MiB           1       count = 0
    34     52.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.0 MiB      0.0 MiB           1       came_from = {}
    37     57.0 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     57.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.6 MiB  -2409.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.4 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.5 MiB -12384.8 MiB        3080       while not open_set.empty():
    47     60.5 MiB -12384.8 MiB        3080           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.5 MiB -12385.2 MiB        3080           current = open_set.get()[2]
    53     60.5 MiB -12385.4 MiB        3080           open_set_hash.remove(current)
    54                                         
    55     60.5 MiB -12385.7 MiB        3080           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.5 MiB -12385.8 MiB        3080           if current == end:
    60     51.0 MiB     -9.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     51.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.5 MiB -111429.2 MiB       27711           for neighbor in current.neighbors:
    65     60.5 MiB -99045.9 MiB       24632               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.5 MiB -49530.7 MiB       12316                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.5 MiB -49516.7 MiB       12316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.5 MiB -99050.6 MiB       24632               if temp_g_score < g_score[neighbor]:
    71     60.5 MiB -13522.1 MiB        3392                   came_from[neighbor] = current
    72     60.5 MiB -13522.2 MiB        3392                   g_score[neighbor] = temp_g_score
    73     60.5 MiB -13522.3 MiB        3392                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.5 MiB -13522.5 MiB        3392                   if neighbor not in open_set_hash:
    75     60.5 MiB -13523.0 MiB        3392                       count += 1
    76     60.5 MiB -13523.0 MiB        3392                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.5 MiB -13522.9 MiB        3392                       open_set_hash.add(neighbor)
    78                                                             
    79     60.5 MiB -12384.5 MiB        3079           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.5 MiB -12384.6 MiB        3079           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.1 MiB     89.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     89.1 MiB   -224.2 MiB         257       for row in grid:
    30     89.1 MiB -57224.0 MiB       65792           for spot in row:
    31     89.1 MiB -57002.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.8 MiB     -3.3 MiB           1       count = 0
    34     85.8 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     85.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     85.8 MiB      0.0 MiB           1       came_from = {}
    37     90.7 MiB  -1779.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     90.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.5 MiB      5.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.6 MiB      0.0 MiB         690       while not open_set.empty():
    47     96.6 MiB      0.0 MiB         690           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.6 MiB      0.0 MiB         690           current = open_set.get()[2]
    53     96.6 MiB      0.0 MiB         690           open_set_hash.remove(current)
    54                                         
    55     96.6 MiB      0.0 MiB         690           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.6 MiB      0.0 MiB         690           if current == end:
    60     96.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.6 MiB      0.0 MiB        6201           for neighbor in current.neighbors:
    65     96.6 MiB      0.0 MiB        5512               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.6 MiB      0.0 MiB        2756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.6 MiB      0.0 MiB        2756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.6 MiB      0.0 MiB        5512               if temp_g_score < g_score[neighbor]:
    71     96.6 MiB      0.1 MiB         902                   came_from[neighbor] = current
    72     96.6 MiB      0.0 MiB         902                   g_score[neighbor] = temp_g_score
    73     96.6 MiB      0.0 MiB         902                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.6 MiB      0.0 MiB         902                   if neighbor not in open_set_hash:
    75     96.6 MiB      0.0 MiB         902                       count += 1
    76     96.6 MiB      0.0 MiB         902                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.6 MiB      0.0 MiB         902                       open_set_hash.add(neighbor)
    78                                                             
    79     96.6 MiB      0.0 MiB         689           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.6 MiB      0.0 MiB         689           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.6 MiB     96.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.7 MiB      0.0 MiB         257       for row in grid:
    30     96.7 MiB      0.0 MiB       65792           for spot in row:
    31     96.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.7 MiB      0.0 MiB           1       count = 0
    34     96.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.7 MiB      0.0 MiB           1       came_from = {}
    37     98.2 MiB   -502.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.6 MiB      4.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.7 MiB      0.0 MiB        2304       while not open_set.empty():
    47    102.7 MiB      0.0 MiB        2304           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.7 MiB      0.0 MiB        2304           current = open_set.get()[2]
    53    102.7 MiB      0.0 MiB        2304           open_set_hash.remove(current)
    54                                         
    55    102.7 MiB      0.0 MiB        2304           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.7 MiB      0.0 MiB        2304           if current == end:
    60    102.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.7 MiB      0.0 MiB       20727           for neighbor in current.neighbors:
    65    102.7 MiB      0.0 MiB       18424               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.7 MiB      0.0 MiB        9212                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.7 MiB      0.0 MiB        9212                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.7 MiB      0.0 MiB       18424               if temp_g_score < g_score[neighbor]:
    71    102.7 MiB      0.1 MiB        2574                   came_from[neighbor] = current
    72    102.7 MiB      0.0 MiB        2574                   g_score[neighbor] = temp_g_score
    73    102.7 MiB      0.0 MiB        2574                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.7 MiB      0.0 MiB        2574                   if neighbor not in open_set_hash:
    75    102.7 MiB      0.0 MiB        2574                       count += 1
    76    102.7 MiB      0.0 MiB        2574                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.7 MiB      0.0 MiB        2574                       open_set_hash.add(neighbor)
    78                                                             
    79    102.7 MiB      0.0 MiB        2303           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.7 MiB      0.0 MiB        2303           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.7 MiB    102.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.7 MiB  -5540.5 MiB         257       for row in grid:
    30    102.7 MiB -1418643.0 MiB       65792           for spot in row:
    31    102.7 MiB -1413129.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.5 MiB    -41.2 MiB           1       count = 0
    34     61.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.5 MiB      0.0 MiB           1       came_from = {}
    37     65.8 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.2 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.3 MiB -69377.8 MiB       11322       while not open_set.empty():
    47     70.3 MiB -69377.8 MiB       11322           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.3 MiB -69377.9 MiB       11322           current = open_set.get()[2]
    53     70.3 MiB -69377.9 MiB       11322           open_set_hash.remove(current)
    54                                         
    55     70.3 MiB -69378.0 MiB       11322           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.3 MiB -69378.0 MiB       11322           if current == end:
    60     61.1 MiB     -9.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.3 MiB -624355.6 MiB      101889           for neighbor in current.neighbors:
    65     70.3 MiB -554978.5 MiB       90568               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.3 MiB -277503.9 MiB       45284                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.3 MiB -277480.2 MiB       45284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.3 MiB -554986.3 MiB       90568               if temp_g_score < g_score[neighbor]:
    71     70.3 MiB -72204.0 MiB       11968                   came_from[neighbor] = current
    72     70.3 MiB -72204.1 MiB       11968                   g_score[neighbor] = temp_g_score
    73     70.3 MiB -72204.3 MiB       11968                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.3 MiB -72204.3 MiB       11968                   if neighbor not in open_set_hash:
    75     70.3 MiB -72204.7 MiB       11968                       count += 1
    76     70.3 MiB -72203.4 MiB       11968                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.3 MiB -72203.4 MiB       11968                       open_set_hash.add(neighbor)
    78                                                             
    79     70.3 MiB -69377.7 MiB       11321           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.3 MiB -69377.8 MiB       11321           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     61.1 MiB     61.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.2 MiB    -25.3 MiB         257       for row in grid:
    30     61.2 MiB  -6469.4 MiB       65792           for spot in row:
    31     61.2 MiB  -6444.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.1 MiB     -1.1 MiB           1       count = 0
    34     60.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.1 MiB      0.0 MiB           1       came_from = {}
    37     63.9 MiB  -6555.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.8 MiB -26522.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     65.8 MiB -62461.2 MiB        4370       while not open_set.empty():
    47     65.8 MiB -62461.9 MiB        4370           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     65.8 MiB -62463.4 MiB        4370           current = open_set.get()[2]
    53     65.8 MiB -62464.4 MiB        4370           open_set_hash.remove(current)
    54                                         
    55     65.8 MiB -62465.1 MiB        4370           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     65.8 MiB -62466.0 MiB        4370           if current == end:
    60     39.8 MiB    -26.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     39.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     65.8 MiB -562057.3 MiB       39321           for neighbor in current.neighbors:
    65     65.8 MiB -499600.9 MiB       34952               if current.row != neighbor.row and current.col != neighbor.col:
    66     65.8 MiB -249828.0 MiB       17476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     65.8 MiB -249780.2 MiB       17476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     65.8 MiB -499613.2 MiB       34952               if temp_g_score < g_score[neighbor]:
    71     65.8 MiB -69096.7 MiB        4904                   came_from[neighbor] = current
    72     65.8 MiB -69096.7 MiB        4904                   g_score[neighbor] = temp_g_score
    73     65.8 MiB -69096.8 MiB        4904                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     65.8 MiB -69096.8 MiB        4904                   if neighbor not in open_set_hash:
    75     65.8 MiB -69096.9 MiB        4904                       count += 1
    76     65.8 MiB -69096.9 MiB        4904                       open_set.put((f_score[neighbor], count, neighbor))
    77     65.8 MiB -69097.1 MiB        4904                       open_set_hash.add(neighbor)
    78                                                             
    79     65.8 MiB -62459.6 MiB        4369           if draw is not None:
    80                                                     draw()
    81                                         
    82     65.8 MiB -62460.4 MiB        4369           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     45.7 MiB     45.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     61.4 MiB    -23.4 MiB         257       for row in grid:
    30     61.4 MiB  -6112.4 MiB       65792           for spot in row:
    31     61.4 MiB  -6072.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.4 MiB      0.0 MiB           1       count = 0
    34     61.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     61.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.4 MiB      0.0 MiB           1       came_from = {}
    37     65.4 MiB      4.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.0 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.2 MiB -19077.1 MiB        5989       while not open_set.empty():
    47     68.2 MiB -19077.1 MiB        5989           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.2 MiB -19077.1 MiB        5989           current = open_set.get()[2]
    53     68.2 MiB -19077.1 MiB        5989           open_set_hash.remove(current)
    54                                         
    55     68.2 MiB -19077.1 MiB        5989           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.2 MiB -19077.1 MiB        5989           if current == end:
    60     64.1 MiB     -4.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.2 MiB -171661.3 MiB       53892           for neighbor in current.neighbors:
    65     68.2 MiB -152584.2 MiB       47904               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.2 MiB -76292.1 MiB       23952                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.2 MiB -76292.1 MiB       23952                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.2 MiB -152584.2 MiB       47904               if temp_g_score < g_score[neighbor]:
    71     68.2 MiB -20017.1 MiB        6425                   came_from[neighbor] = current
    72     68.2 MiB -20017.2 MiB        6425                   g_score[neighbor] = temp_g_score
    73     68.2 MiB -20017.2 MiB        6425                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.2 MiB -20017.2 MiB        6425                   if neighbor not in open_set_hash:
    75     68.2 MiB -20017.2 MiB        6425                       count += 1
    76     68.2 MiB -20021.3 MiB        6425                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.2 MiB -20021.2 MiB        6425                       open_set_hash.add(neighbor)
    78                                                             
    79     68.2 MiB -19077.1 MiB        5988           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.2 MiB -19077.1 MiB        5988           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.2 MiB     64.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.2 MiB      0.0 MiB         257       for row in grid:
    30     64.2 MiB      0.0 MiB       65792           for spot in row:
    31     64.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.2 MiB      0.0 MiB           1       count = 0
    34     64.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     64.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     64.2 MiB      0.0 MiB           1       came_from = {}
    37     66.2 MiB -42295.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.8 MiB     -3.4 MiB           1       g_score[start] = 0
    39     63.6 MiB -97128.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.0 MiB      0.0 MiB        6786       while not open_set.empty():
    47     64.0 MiB      0.0 MiB        6786           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.0 MiB      0.0 MiB        6786           current = open_set.get()[2]
    53     64.0 MiB      0.0 MiB        6786           open_set_hash.remove(current)
    54                                         
    55     64.0 MiB      0.0 MiB        6786           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.0 MiB      0.0 MiB        6786           if current == end:
    60     64.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.0 MiB      0.0 MiB       61065           for neighbor in current.neighbors:
    65     64.0 MiB      0.0 MiB       54280               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.0 MiB      0.0 MiB       27140                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.0 MiB      0.0 MiB       27140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.0 MiB      0.0 MiB       54280               if temp_g_score < g_score[neighbor]:
    71     64.0 MiB      0.2 MiB        7558                   came_from[neighbor] = current
    72     64.0 MiB      0.0 MiB        7558                   g_score[neighbor] = temp_g_score
    73     64.0 MiB      0.0 MiB        7558                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.0 MiB      0.0 MiB        7558                   if neighbor not in open_set_hash:
    75     64.0 MiB      0.0 MiB        7558                       count += 1
    76     64.0 MiB      0.0 MiB        7558                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.0 MiB      0.1 MiB        7558                       open_set_hash.add(neighbor)
    78                                                             
    79     64.0 MiB      0.0 MiB        6785           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.0 MiB      0.0 MiB        6785           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.0 MiB     64.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.0 MiB     -1.6 MiB         257       for row in grid:
    30     64.0 MiB   -406.1 MiB       65792           for spot in row:
    31     64.0 MiB   -404.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.0 MiB     -0.0 MiB           1       count = 0
    34     64.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     64.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     64.0 MiB      0.0 MiB           1       came_from = {}
    37     66.8 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.6 MiB      4.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.7 MiB -23635.7 MiB        2805       while not open_set.empty():
    47     71.7 MiB -23635.7 MiB        2805           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.7 MiB -23635.8 MiB        2805           current = open_set.get()[2]
    53     71.7 MiB -23635.8 MiB        2805           open_set_hash.remove(current)
    54                                         
    55     71.7 MiB -23635.8 MiB        2805           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.7 MiB -23636.2 MiB        2805           if current == end:
    60     56.7 MiB    -14.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.7 MiB -212634.8 MiB       25236           for neighbor in current.neighbors:
    65     71.7 MiB -189001.4 MiB       22432               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.7 MiB -94514.9 MiB       11216                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.7 MiB -94492.6 MiB       11216                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.7 MiB -189008.5 MiB       22432               if temp_g_score < g_score[neighbor]:
    71     71.7 MiB -26613.9 MiB        3201                   came_from[neighbor] = current
    72     71.7 MiB -26614.2 MiB        3201                   g_score[neighbor] = temp_g_score
    73     71.7 MiB -26615.1 MiB        3201                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.7 MiB -26615.7 MiB        3201                   if neighbor not in open_set_hash:
    75     71.7 MiB -26615.9 MiB        3201                       count += 1
    76     71.7 MiB -26616.1 MiB        3201                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.7 MiB -26616.6 MiB        3201                       open_set_hash.add(neighbor)
    78                                                             
    79     71.7 MiB -23635.4 MiB        2804           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.7 MiB -23635.7 MiB        2804           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.4 MiB     91.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.4 MiB   -321.4 MiB         257       for row in grid:
    30     91.4 MiB -82590.7 MiB       65792           for spot in row:
    31     91.4 MiB -82270.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.1 MiB     -1.3 MiB           1       count = 0
    34     90.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     90.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     90.1 MiB      0.0 MiB           1       came_from = {}
    37     93.6 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.1 MiB      4.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.1 MiB      0.0 MiB         220       while not open_set.empty():
    47     98.1 MiB      0.0 MiB         220           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.1 MiB      0.0 MiB         220           current = open_set.get()[2]
    53     98.1 MiB      0.0 MiB         220           open_set_hash.remove(current)
    54                                         
    55     98.1 MiB      0.0 MiB         220           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.1 MiB      0.0 MiB         220           if current == end:
    60     98.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.1 MiB      0.0 MiB        1971           for neighbor in current.neighbors:
    65     98.1 MiB      0.0 MiB        1752               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.1 MiB      0.0 MiB         876                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.1 MiB      0.0 MiB         876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.1 MiB      0.0 MiB        1752               if temp_g_score < g_score[neighbor]:
    71     98.1 MiB      0.0 MiB         326                   came_from[neighbor] = current
    72     98.1 MiB      0.0 MiB         326                   g_score[neighbor] = temp_g_score
    73     98.1 MiB      0.0 MiB         326                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.1 MiB      0.0 MiB         326                   if neighbor not in open_set_hash:
    75     98.1 MiB      0.0 MiB         326                       count += 1
    76     98.1 MiB      0.0 MiB         326                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.1 MiB      0.0 MiB         326                       open_set_hash.add(neighbor)
    78                                                             
    79     98.1 MiB      0.0 MiB         219           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.1 MiB      0.0 MiB         219           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.1 MiB     98.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.1 MiB      0.0 MiB         257       for row in grid:
    30     98.1 MiB      0.0 MiB       65792           for spot in row:
    31     98.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.1 MiB      0.0 MiB           1       count = 0
    34     98.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.1 MiB      0.0 MiB           1       came_from = {}
    37    100.0 MiB  -3220.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.5 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.5 MiB      0.0 MiB         765       while not open_set.empty():
    47    103.5 MiB      0.0 MiB         765           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.5 MiB      0.0 MiB         765           current = open_set.get()[2]
    53    103.5 MiB      0.0 MiB         765           open_set_hash.remove(current)
    54                                         
    55    103.5 MiB      0.0 MiB         765           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.5 MiB      0.0 MiB         765           if current == end:
    60    103.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.5 MiB      0.0 MiB        6876           for neighbor in current.neighbors:
    65    103.5 MiB      0.0 MiB        6112               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.5 MiB      0.0 MiB        3056                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.5 MiB      0.0 MiB        3056                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.5 MiB      0.0 MiB        6112               if temp_g_score < g_score[neighbor]:
    71    103.5 MiB      0.0 MiB         921                   came_from[neighbor] = current
    72    103.5 MiB      0.0 MiB         921                   g_score[neighbor] = temp_g_score
    73    103.5 MiB      0.0 MiB         921                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.5 MiB      0.0 MiB         921                   if neighbor not in open_set_hash:
    75    103.5 MiB      0.0 MiB         921                       count += 1
    76    103.5 MiB      0.0 MiB         921                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.5 MiB      0.0 MiB         921                       open_set_hash.add(neighbor)
    78                                                             
    79    103.5 MiB      0.0 MiB         764           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.5 MiB      0.0 MiB         764           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.5 MiB    103.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.5 MiB   -755.3 MiB         257       for row in grid:
    30    103.5 MiB -191719.8 MiB       65792           for spot in row:
    31    103.5 MiB -190973.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.9 MiB    -12.6 MiB           1       count = 0
    34     91.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.0 MiB      0.0 MiB           1       came_from = {}
    37     91.3 MiB -2862455.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     27.7 MiB    -63.6 MiB           1       g_score[start] = 0
    39     33.8 MiB -13135.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     34.0 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     34.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     34.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     34.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     35.6 MiB      0.1 MiB         108       while not open_set.empty():
    47     35.6 MiB      0.0 MiB         108           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     35.6 MiB      0.0 MiB         108           current = open_set.get()[2]
    53     35.6 MiB      0.0 MiB         108           open_set_hash.remove(current)
    54                                         
    55     35.6 MiB      0.0 MiB         108           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     35.6 MiB      0.0 MiB         108           if current == end:
    60     35.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     35.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     35.6 MiB      0.4 MiB         963           for neighbor in current.neighbors:
    65     35.6 MiB      0.9 MiB         856               if current.row != neighbor.row and current.col != neighbor.col:
    66     35.6 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     35.6 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     35.6 MiB      0.0 MiB         856               if temp_g_score < g_score[neighbor]:
    71     35.6 MiB      0.0 MiB         222                   came_from[neighbor] = current
    72     35.6 MiB      0.0 MiB         222                   g_score[neighbor] = temp_g_score
    73     35.6 MiB      0.0 MiB         222                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     35.6 MiB      0.0 MiB         222                   if neighbor not in open_set_hash:
    75     35.6 MiB      0.0 MiB         222                       count += 1
    76     35.6 MiB      0.2 MiB         222                       open_set.put((f_score[neighbor], count, neighbor))
    77     35.6 MiB      0.0 MiB         222                       open_set_hash.add(neighbor)
    78                                                             
    79     35.6 MiB      0.0 MiB         107           if draw is not None:
    80                                                     draw()
    81                                         
    82     35.6 MiB      0.0 MiB         107           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     38.4 MiB     38.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     59.7 MiB     -0.0 MiB         257       for row in grid:
    30     59.7 MiB     -7.7 MiB       65792           for spot in row:
    31     59.7 MiB     13.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     59.7 MiB      0.0 MiB           1       count = 0
    34     59.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     59.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     59.7 MiB      0.0 MiB           1       came_from = {}
    37     60.7 MiB -159362.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.8 MiB     -1.9 MiB           1       g_score[start] = 0
    39     62.4 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.5 MiB      0.0 MiB        2015       while not open_set.empty():
    47     62.5 MiB      0.0 MiB        2015           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.5 MiB      0.0 MiB        2015           current = open_set.get()[2]
    53     62.5 MiB      0.0 MiB        2015           open_set_hash.remove(current)
    54                                         
    55     62.5 MiB      0.0 MiB        2015           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.5 MiB      0.0 MiB        2015           if current == end:
    60     62.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.5 MiB      0.0 MiB       18126           for neighbor in current.neighbors:
    65     62.5 MiB      0.0 MiB       16112               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.5 MiB      0.0 MiB        8056                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.5 MiB      0.0 MiB        8056                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.5 MiB      0.0 MiB       16112               if temp_g_score < g_score[neighbor]:
    71     62.5 MiB      0.0 MiB        2267                   came_from[neighbor] = current
    72     62.5 MiB      0.0 MiB        2267                   g_score[neighbor] = temp_g_score
    73     62.5 MiB      0.0 MiB        2267                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.5 MiB      0.0 MiB        2267                   if neighbor not in open_set_hash:
    75     62.5 MiB      0.0 MiB        2267                       count += 1
    76     62.5 MiB      0.0 MiB        2267                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.5 MiB      0.0 MiB        2267                       open_set_hash.add(neighbor)
    78                                                             
    79     62.5 MiB      0.0 MiB        2014           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.5 MiB      0.0 MiB        2014           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     62.5 MiB     62.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     62.5 MiB    -12.1 MiB         257       for row in grid:
    30     62.5 MiB  -3071.5 MiB       65792           for spot in row:
    31     62.5 MiB  -3059.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     62.2 MiB     -0.4 MiB           1       count = 0
    34     62.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     62.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     62.2 MiB      0.0 MiB           1       came_from = {}
    37     66.4 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.6 MiB   -776.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.5 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.5 MiB -15706.2 MiB        3040       while not open_set.empty():
    47     70.5 MiB -15706.8 MiB        3040           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.5 MiB -15706.8 MiB        3040           current = open_set.get()[2]
    53     70.5 MiB -15706.8 MiB        3040           open_set_hash.remove(current)
    54                                         
    55     70.5 MiB -15706.8 MiB        3040           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.5 MiB -15707.6 MiB        3040           if current == end:
    60     65.0 MiB     -5.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.5 MiB -141336.6 MiB       27351           for neighbor in current.neighbors:
    65     70.5 MiB -125631.7 MiB       24312               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.5 MiB -62816.8 MiB       12156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.5 MiB -62815.0 MiB       12156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.5 MiB -125631.9 MiB       24312               if temp_g_score < g_score[neighbor]:
    71     70.5 MiB -16997.3 MiB        3350                   came_from[neighbor] = current
    72     70.5 MiB -16997.3 MiB        3350                   g_score[neighbor] = temp_g_score
    73     70.5 MiB -16997.7 MiB        3350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.5 MiB -16998.3 MiB        3350                   if neighbor not in open_set_hash:
    75     70.5 MiB -16999.0 MiB        3350                       count += 1
    76     70.5 MiB -16999.8 MiB        3350                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.5 MiB -16999.7 MiB        3350                       open_set_hash.add(neighbor)
    78                                                             
    79     70.5 MiB -15706.2 MiB        3039           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.5 MiB -15706.2 MiB        3039           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     65.0 MiB     65.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     65.0 MiB      0.0 MiB         257       for row in grid:
    30     65.0 MiB      0.0 MiB       65792           for spot in row:
    31     65.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     65.0 MiB      0.0 MiB           1       count = 0
    34     65.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     65.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     65.1 MiB      0.0 MiB           1       came_from = {}
    37     67.3 MiB      2.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.9 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.9 MiB      0.0 MiB        4160       while not open_set.empty():
    47     69.9 MiB      0.0 MiB        4160           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.9 MiB      0.0 MiB        4160           current = open_set.get()[2]
    53     69.9 MiB      0.0 MiB        4160           open_set_hash.remove(current)
    54                                         
    55     69.9 MiB      0.0 MiB        4160           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.9 MiB      0.0 MiB        4160           if current == end:
    60     69.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.9 MiB      0.0 MiB       37431           for neighbor in current.neighbors:
    65     69.9 MiB      0.0 MiB       33272               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.9 MiB      0.0 MiB       16636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.9 MiB      0.0 MiB       16636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.9 MiB      0.0 MiB       33272               if temp_g_score < g_score[neighbor]:
    71     69.9 MiB      0.0 MiB        4526                   came_from[neighbor] = current
    72     69.9 MiB      0.0 MiB        4526                   g_score[neighbor] = temp_g_score
    73     69.9 MiB      0.0 MiB        4526                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.9 MiB      0.0 MiB        4526                   if neighbor not in open_set_hash:
    75     69.9 MiB      0.0 MiB        4526                       count += 1
    76     69.9 MiB      0.0 MiB        4526                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.9 MiB      0.0 MiB        4526                       open_set_hash.add(neighbor)
    78                                                             
    79     69.9 MiB      0.0 MiB        4159           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.9 MiB      0.0 MiB        4159           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.9 MiB     69.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.9 MiB      0.0 MiB         257       for row in grid:
    30     69.9 MiB      0.0 MiB       65792           for spot in row:
    31     69.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     69.9 MiB      0.0 MiB           1       count = 0
    34     69.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     69.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     69.9 MiB      0.0 MiB           1       came_from = {}
    37     71.6 MiB  -6273.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     72.3 MiB      0.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.4 MiB      0.0 MiB        4095       while not open_set.empty():
    47     72.4 MiB      0.0 MiB        4095           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.4 MiB      0.0 MiB        4095           current = open_set.get()[2]
    53     72.4 MiB      0.0 MiB        4095           open_set_hash.remove(current)
    54                                         
    55     72.4 MiB      0.0 MiB        4095           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.4 MiB      0.0 MiB        4095           if current == end:
    60     72.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.4 MiB      0.0 MiB       36846           for neighbor in current.neighbors:
    65     72.4 MiB      0.0 MiB       32752               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.4 MiB      0.0 MiB       16376                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.4 MiB      0.0 MiB       16376                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.4 MiB      0.0 MiB       32752               if temp_g_score < g_score[neighbor]:
    71     72.4 MiB      0.0 MiB        4467                   came_from[neighbor] = current
    72     72.4 MiB      0.0 MiB        4467                   g_score[neighbor] = temp_g_score
    73     72.4 MiB      0.0 MiB        4467                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.4 MiB      0.0 MiB        4467                   if neighbor not in open_set_hash:
    75     72.4 MiB      0.0 MiB        4467                       count += 1
    76     72.4 MiB      0.0 MiB        4467                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.4 MiB      0.0 MiB        4467                       open_set_hash.add(neighbor)
    78                                                             
    79     72.4 MiB      0.0 MiB        4094           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.4 MiB      0.0 MiB        4094           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.4 MiB    110.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.4 MiB      0.0 MiB         257       for row in grid:
    30    110.4 MiB      0.0 MiB       65792           for spot in row:
    31    110.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.4 MiB      0.0 MiB           1       count = 0
    34    110.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.4 MiB      0.0 MiB           1       came_from = {}
    37    110.4 MiB -1598093.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     83.4 MiB    -27.0 MiB           1       g_score[start] = 0
    39     87.5 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     87.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     87.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     87.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     87.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.5 MiB    -33.9 MiB        9200       while not open_set.empty():
    47     94.5 MiB    -33.9 MiB        9200           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.5 MiB    -33.9 MiB        9200           current = open_set.get()[2]
    53     94.5 MiB    -33.9 MiB        9200           open_set_hash.remove(current)
    54                                         
    55     94.5 MiB    -33.9 MiB        9200           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.5 MiB    -33.9 MiB        9200           if current == end:
    60     94.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.5 MiB   -302.2 MiB       82791           for neighbor in current.neighbors:
    65     94.5 MiB   -269.5 MiB       73592               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.5 MiB   -135.3 MiB       36796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.5 MiB   -135.0 MiB       36796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.5 MiB   -270.4 MiB       73592               if temp_g_score < g_score[neighbor]:
    71     94.5 MiB    -38.0 MiB        9766                   came_from[neighbor] = current
    72     94.5 MiB    -38.0 MiB        9766                   g_score[neighbor] = temp_g_score
    73     94.5 MiB    -38.0 MiB        9766                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.5 MiB    -38.1 MiB        9766                   if neighbor not in open_set_hash:
    75     94.5 MiB    -38.1 MiB        9766                       count += 1
    76     94.5 MiB    -34.2 MiB        9766                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.5 MiB    -38.1 MiB        9766                       open_set_hash.add(neighbor)
    78                                                             
    79     94.5 MiB    -33.9 MiB        9199           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.5 MiB    -33.9 MiB        9199           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.5 MiB     94.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.7 MiB      0.0 MiB         257       for row in grid:
    30     94.7 MiB      0.0 MiB       65792           for spot in row:
    31     94.7 MiB      0.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.7 MiB      0.0 MiB           1       count = 0
    34     94.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.7 MiB      0.0 MiB           1       came_from = {}
    37     96.2 MiB  -5953.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.3 MiB      0.0 MiB        9135       while not open_set.empty():
    47     96.3 MiB      0.0 MiB        9135           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.3 MiB      0.0 MiB        9135           current = open_set.get()[2]
    53     96.3 MiB      0.0 MiB        9135           open_set_hash.remove(current)
    54                                         
    55     96.3 MiB      0.0 MiB        9135           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.3 MiB      0.0 MiB        9135           if current == end:
    60     96.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.3 MiB      0.0 MiB       82206           for neighbor in current.neighbors:
    65     96.3 MiB      0.0 MiB       73072               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.3 MiB      0.0 MiB       36536                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.3 MiB      0.0 MiB       36536                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.3 MiB      0.0 MiB       73072               if temp_g_score < g_score[neighbor]:
    71     96.3 MiB      0.0 MiB        9691                   came_from[neighbor] = current
    72     96.3 MiB      0.0 MiB        9691                   g_score[neighbor] = temp_g_score
    73     96.3 MiB      0.0 MiB        9691                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.3 MiB      0.0 MiB        9691                   if neighbor not in open_set_hash:
    75     96.3 MiB      0.0 MiB        9691                       count += 1
    76     96.3 MiB      0.0 MiB        9691                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.3 MiB      0.0 MiB        9691                       open_set_hash.add(neighbor)
    78                                                             
    79     96.3 MiB      0.0 MiB        9134           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.3 MiB      0.0 MiB        9134           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.3 MiB     96.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.3 MiB      0.0 MiB         257       for row in grid:
    30     96.3 MiB      0.0 MiB       65792           for spot in row:
    31     96.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.3 MiB      0.0 MiB           1       count = 0
    34     96.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.3 MiB      0.0 MiB           1       came_from = {}
    37     96.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.3 MiB -191969.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     87.2 MiB     -9.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     87.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     87.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     87.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     87.4 MiB  -1074.9 MiB        5546       while not open_set.empty():
    47     87.4 MiB  -1074.9 MiB        5546           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     87.4 MiB  -1074.9 MiB        5546           current = open_set.get()[2]
    53     87.4 MiB  -1074.9 MiB        5546           open_set_hash.remove(current)
    54                                         
    55     87.4 MiB  -1074.9 MiB        5546           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     87.4 MiB  -1074.9 MiB        5546           if current == end:
    60     86.0 MiB     -1.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     86.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     87.4 MiB  -9667.9 MiB       49905           for neighbor in current.neighbors:
    65     87.4 MiB  -8593.0 MiB       44360               if current.row != neighbor.row and current.col != neighbor.col:
    66     87.4 MiB  -4298.7 MiB       22180                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     87.4 MiB  -4294.5 MiB       22180                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     87.4 MiB  -8593.4 MiB       44360               if temp_g_score < g_score[neighbor]:
    71     87.4 MiB  -1175.3 MiB        5968                   came_from[neighbor] = current
    72     87.4 MiB  -1175.6 MiB        5968                   g_score[neighbor] = temp_g_score
    73     87.4 MiB  -1175.9 MiB        5968                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     87.4 MiB  -1176.0 MiB        5968                   if neighbor not in open_set_hash:
    75     87.4 MiB  -1176.0 MiB        5968                       count += 1
    76     87.4 MiB  -1176.0 MiB        5968                       open_set.put((f_score[neighbor], count, neighbor))
    77     87.4 MiB  -1176.0 MiB        5968                       open_set_hash.add(neighbor)
    78                                                             
    79     87.4 MiB  -1074.9 MiB        5545           if draw is not None:
    80                                                     draw()
    81                                         
    82     87.4 MiB  -1074.9 MiB        5545           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     86.4 MiB     86.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     87.8 MiB  -2293.8 MiB         257       for row in grid:
    30     87.8 MiB -585102.7 MiB       65792           for spot in row:
    31     87.8 MiB -582822.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     66.7 MiB    -21.2 MiB           1       count = 0
    34     66.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.7 MiB      0.0 MiB           1       came_from = {}
    37     67.7 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.9 MiB -50994.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.0 MiB     -4.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.0 MiB      0.0 MiB         930       while not open_set.empty():
    47     67.0 MiB      0.0 MiB         930           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.0 MiB      0.0 MiB         930           current = open_set.get()[2]
    53     67.0 MiB      0.0 MiB         930           open_set_hash.remove(current)
    54                                         
    55     67.0 MiB      0.0 MiB         930           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.0 MiB      0.0 MiB         930           if current == end:
    60     67.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.0 MiB      0.0 MiB        8361           for neighbor in current.neighbors:
    65     67.0 MiB      0.0 MiB        7432               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.0 MiB      0.0 MiB        3716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.0 MiB      0.0 MiB        3716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.0 MiB      0.0 MiB        7432               if temp_g_score < g_score[neighbor]:
    71     67.0 MiB      0.0 MiB        1112                   came_from[neighbor] = current
    72     67.0 MiB      0.0 MiB        1112                   g_score[neighbor] = temp_g_score
    73     67.0 MiB      0.0 MiB        1112                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.0 MiB      0.0 MiB        1112                   if neighbor not in open_set_hash:
    75     67.0 MiB      0.0 MiB        1112                       count += 1
    76     67.0 MiB      0.0 MiB        1112                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.0 MiB      0.0 MiB        1112                       open_set_hash.add(neighbor)
    78                                                             
    79     67.0 MiB      0.0 MiB         929           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.0 MiB      0.0 MiB         929           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.0 MiB     67.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.0 MiB      0.0 MiB         257       for row in grid:
    30     67.0 MiB      0.0 MiB       65792           for spot in row:
    31     67.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     67.0 MiB      0.0 MiB           1       count = 0
    34     67.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.0 MiB      0.0 MiB           1       came_from = {}
    37     68.1 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.3 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.3 MiB      0.0 MiB         264       while not open_set.empty():
    47     70.3 MiB      0.0 MiB         264           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.3 MiB      0.0 MiB         264           current = open_set.get()[2]
    53     70.3 MiB      0.0 MiB         264           open_set_hash.remove(current)
    54                                         
    55     70.3 MiB      0.0 MiB         264           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.3 MiB      0.0 MiB         264           if current == end:
    60     70.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.3 MiB      0.0 MiB        2367           for neighbor in current.neighbors:
    65     70.3 MiB      0.0 MiB        2104               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.3 MiB      0.0 MiB        1052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.3 MiB      0.0 MiB        1052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.3 MiB      0.0 MiB        2104               if temp_g_score < g_score[neighbor]:
    71     70.3 MiB      0.0 MiB         374                   came_from[neighbor] = current
    72     70.3 MiB      0.0 MiB         374                   g_score[neighbor] = temp_g_score
    73     70.3 MiB      0.0 MiB         374                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.3 MiB      0.0 MiB         374                   if neighbor not in open_set_hash:
    75     70.3 MiB      0.0 MiB         374                       count += 1
    76     70.3 MiB      0.0 MiB         374                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.3 MiB      0.0 MiB         374                       open_set_hash.add(neighbor)
    78                                                             
    79     70.3 MiB      0.0 MiB         263           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.3 MiB      0.0 MiB         263           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.3 MiB     70.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     70.3 MiB      0.0 MiB         257       for row in grid:
    30     70.3 MiB      0.0 MiB       65792           for spot in row:
    31     70.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     70.3 MiB      0.0 MiB           1       count = 0
    34     70.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     70.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     70.3 MiB      0.0 MiB           1       came_from = {}
    37     73.2 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     73.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     73.4 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     73.4 MiB      0.0 MiB        1404       while not open_set.empty():
    47     73.4 MiB      0.0 MiB        1404           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     73.4 MiB      0.0 MiB        1404           current = open_set.get()[2]
    53     73.4 MiB      0.0 MiB        1404           open_set_hash.remove(current)
    54                                         
    55     73.4 MiB      0.0 MiB        1404           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     73.4 MiB      0.0 MiB        1404           if current == end:
    60     73.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     73.4 MiB      0.0 MiB       12627           for neighbor in current.neighbors:
    65     73.4 MiB      0.0 MiB       11224               if current.row != neighbor.row and current.col != neighbor.col:
    66     73.4 MiB      0.0 MiB        5612                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     73.4 MiB      0.0 MiB        5612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     73.4 MiB      0.0 MiB       11224               if temp_g_score < g_score[neighbor]:
    71     73.4 MiB      0.0 MiB        1614                   came_from[neighbor] = current
    72     73.4 MiB      0.0 MiB        1614                   g_score[neighbor] = temp_g_score
    73     73.4 MiB      0.0 MiB        1614                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     73.4 MiB      0.0 MiB        1614                   if neighbor not in open_set_hash:
    75     73.4 MiB      0.0 MiB        1614                       count += 1
    76     73.4 MiB      0.0 MiB        1614                       open_set.put((f_score[neighbor], count, neighbor))
    77     73.4 MiB      0.0 MiB        1614                       open_set_hash.add(neighbor)
    78                                                             
    79     73.4 MiB      0.0 MiB        1403           if draw is not None:
    80                                                     draw()
    81                                         
    82     73.4 MiB      0.0 MiB        1403           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     73.4 MiB   -237.2 MiB         257       for row in grid:
    30     73.4 MiB -60872.9 MiB       65792           for spot in row:
    31     73.4 MiB -60636.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     72.3 MiB     -1.1 MiB           1       count = 0
    34     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     72.3 MiB      0.0 MiB           1       came_from = {}
    37     72.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     72.8 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.8 MiB      0.0 MiB        3335       while not open_set.empty():
    47     72.8 MiB      0.0 MiB        3335           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.8 MiB      0.0 MiB        3335           current = open_set.get()[2]
    53     72.8 MiB      0.0 MiB        3335           open_set_hash.remove(current)
    54                                         
    55     72.8 MiB      0.0 MiB        3335           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.8 MiB      0.0 MiB        3335           if current == end:
    60     72.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.8 MiB      0.0 MiB       30006           for neighbor in current.neighbors:
    65     72.8 MiB      0.0 MiB       26672               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.8 MiB      0.0 MiB       13336                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.8 MiB      0.0 MiB       13336                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.8 MiB      0.0 MiB       26672               if temp_g_score < g_score[neighbor]:
    71     72.8 MiB      0.0 MiB        3679                   came_from[neighbor] = current
    72     72.8 MiB      0.0 MiB        3679                   g_score[neighbor] = temp_g_score
    73     72.8 MiB      0.0 MiB        3679                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.8 MiB      0.0 MiB        3679                   if neighbor not in open_set_hash:
    75     72.8 MiB      0.0 MiB        3679                       count += 1
    76     72.8 MiB      0.0 MiB        3679                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.8 MiB      0.0 MiB        3679                       open_set_hash.add(neighbor)
    78                                                             
    79     72.8 MiB      0.0 MiB        3334           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.8 MiB      0.0 MiB        3334           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.8 MiB    107.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.8 MiB      0.0 MiB         257       for row in grid:
    30    107.8 MiB      0.0 MiB       65792           for spot in row:
    31    107.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.8 MiB      0.0 MiB           1       count = 0
    34    107.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.8 MiB      0.0 MiB           1       came_from = {}
    37    108.2 MiB      0.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.1 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.6 MiB      0.0 MiB       10971       while not open_set.empty():
    47    111.6 MiB      0.0 MiB       10971           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.6 MiB      0.0 MiB       10971           current = open_set.get()[2]
    53    111.6 MiB      0.0 MiB       10971           open_set_hash.remove(current)
    54                                         
    55    111.6 MiB      0.0 MiB       10971           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.6 MiB      0.0 MiB       10971           if current == end:
    60    111.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.6 MiB      0.0 MiB       98730           for neighbor in current.neighbors:
    65    111.6 MiB      0.0 MiB       87760               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.6 MiB      0.0 MiB       43880                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.6 MiB      0.0 MiB       43880                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.6 MiB      0.0 MiB       87760               if temp_g_score < g_score[neighbor]:
    71    111.6 MiB      0.5 MiB       11563                   came_from[neighbor] = current
    72    111.6 MiB      0.0 MiB       11563                   g_score[neighbor] = temp_g_score
    73    111.6 MiB      0.0 MiB       11563                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.6 MiB      0.0 MiB       11563                   if neighbor not in open_set_hash:
    75    111.6 MiB      0.0 MiB       11563                       count += 1
    76    111.6 MiB      0.0 MiB       11563                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.6 MiB      0.0 MiB       11563                       open_set_hash.add(neighbor)
    78                                                             
    79    111.6 MiB      0.0 MiB       10970           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.6 MiB      0.0 MiB       10970           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.6 MiB    111.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.6 MiB      0.0 MiB         257       for row in grid:
    30    111.6 MiB      0.0 MiB       65792           for spot in row:
    31    111.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.6 MiB      0.0 MiB           1       count = 0
    34    111.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.6 MiB      0.0 MiB           1       came_from = {}
    37    111.7 MiB -20484.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.3 MiB     -0.4 MiB           1       g_score[start] = 0
    39    111.6 MiB   -140.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.6 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.6 MiB  -6586.4 MiB        1696       while not open_set.empty():
    47    111.6 MiB  -6586.4 MiB        1696           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.6 MiB  -6586.4 MiB        1696           current = open_set.get()[2]
    53    111.6 MiB  -6586.4 MiB        1696           open_set_hash.remove(current)
    54                                         
    55    111.6 MiB  -6586.4 MiB        1696           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.6 MiB  -6586.4 MiB        1696           if current == end:
    60    106.8 MiB     -4.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.6 MiB -59260.6 MiB       15255           for neighbor in current.neighbors:
    65    111.6 MiB -52675.2 MiB       13560               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.6 MiB -26345.0 MiB        6780                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.6 MiB -26331.0 MiB        6780                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.6 MiB -52676.9 MiB       13560               if temp_g_score < g_score[neighbor]:
    71    111.6 MiB  -8254.2 MiB        2150                   came_from[neighbor] = current
    72    111.6 MiB  -8254.2 MiB        2150                   g_score[neighbor] = temp_g_score
    73    111.6 MiB  -8254.2 MiB        2150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.6 MiB  -8254.2 MiB        2150                   if neighbor not in open_set_hash:
    75    111.6 MiB  -8254.3 MiB        2150                       count += 1
    76    111.6 MiB  -8254.9 MiB        2150                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.6 MiB  -8255.0 MiB        2150                       open_set_hash.add(neighbor)
    78                                                             
    79    111.6 MiB  -6586.4 MiB        1695           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.6 MiB  -6586.4 MiB        1695           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.8 MiB    106.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.8 MiB      0.0 MiB         257       for row in grid:
    30    106.8 MiB      0.0 MiB       65792           for spot in row:
    31    106.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.8 MiB      0.0 MiB           1       count = 0
    34    106.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.8 MiB      0.0 MiB           1       came_from = {}
    37    108.1 MiB -249142.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.3 MiB     -4.8 MiB           1       g_score[start] = 0
    39    103.5 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.5 MiB      0.0 MiB        1233       while not open_set.empty():
    47    103.5 MiB      0.0 MiB        1233           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.5 MiB      0.0 MiB        1233           current = open_set.get()[2]
    53    103.5 MiB      0.0 MiB        1233           open_set_hash.remove(current)
    54                                         
    55    103.5 MiB      0.0 MiB        1233           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.5 MiB      0.0 MiB        1233           if current == end:
    60    103.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.5 MiB      0.0 MiB       11088           for neighbor in current.neighbors:
    65    103.5 MiB      0.0 MiB        9856               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.5 MiB      0.0 MiB        4928                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.5 MiB      0.0 MiB        4928                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.5 MiB      0.0 MiB        9856               if temp_g_score < g_score[neighbor]:
    71    103.5 MiB      0.0 MiB        1797                   came_from[neighbor] = current
    72    103.5 MiB      0.0 MiB        1797                   g_score[neighbor] = temp_g_score
    73    103.5 MiB      0.0 MiB        1797                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.5 MiB      0.0 MiB        1797                   if neighbor not in open_set_hash:
    75    103.5 MiB      0.0 MiB        1797                       count += 1
    76    103.5 MiB      0.0 MiB        1797                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.5 MiB      0.0 MiB        1797                       open_set_hash.add(neighbor)
    78                                                             
    79    103.5 MiB      0.0 MiB        1232           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.5 MiB      0.0 MiB        1232           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.5 MiB    103.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.5 MiB      0.0 MiB         257       for row in grid:
    30    103.5 MiB      0.0 MiB       65792           for spot in row:
    31    103.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.5 MiB      0.0 MiB           1       count = 0
    34    103.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.5 MiB      0.0 MiB           1       came_from = {}
    37    106.1 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.2 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.2 MiB      0.0 MiB        1414       while not open_set.empty():
    47    106.2 MiB      0.0 MiB        1414           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.2 MiB      0.0 MiB        1414           current = open_set.get()[2]
    53    106.2 MiB      0.0 MiB        1414           open_set_hash.remove(current)
    54                                         
    55    106.2 MiB      0.0 MiB        1414           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.2 MiB      0.0 MiB        1414           if current == end:
    60    106.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.2 MiB      0.0 MiB       12717           for neighbor in current.neighbors:
    65    106.2 MiB      0.0 MiB       11304               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.2 MiB      0.0 MiB        5652                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.2 MiB      0.0 MiB        5652                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.2 MiB      0.0 MiB       11304               if temp_g_score < g_score[neighbor]:
    71    106.2 MiB      0.0 MiB        1670                   came_from[neighbor] = current
    72    106.2 MiB      0.0 MiB        1670                   g_score[neighbor] = temp_g_score
    73    106.2 MiB      0.0 MiB        1670                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.2 MiB      0.0 MiB        1670                   if neighbor not in open_set_hash:
    75    106.2 MiB      0.0 MiB        1670                       count += 1
    76    106.2 MiB      0.0 MiB        1670                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.2 MiB      0.0 MiB        1670                       open_set_hash.add(neighbor)
    78                                                             
    79    106.2 MiB      0.0 MiB        1413           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.2 MiB      0.0 MiB        1413           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB   -218.6 MiB         257       for row in grid:
    30    106.2 MiB -55755.4 MiB       65792           for spot in row:
    31    106.2 MiB -55538.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.7 MiB     -2.5 MiB           1       count = 0
    34    103.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.7 MiB      0.0 MiB           1       came_from = {}
    37    103.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.8 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.8 MiB      0.0 MiB        2379       while not open_set.empty():
    47    103.8 MiB      0.0 MiB        2379           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.8 MiB      0.0 MiB        2379           current = open_set.get()[2]
    53    103.8 MiB      0.0 MiB        2379           open_set_hash.remove(current)
    54                                         
    55    103.8 MiB      0.0 MiB        2379           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.8 MiB      0.0 MiB        2379           if current == end:
    60    103.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.8 MiB      0.0 MiB       21402           for neighbor in current.neighbors:
    65    103.8 MiB      0.0 MiB       19024               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.8 MiB      0.0 MiB        9512                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.8 MiB      0.0 MiB        9512                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.8 MiB      0.0 MiB       19024               if temp_g_score < g_score[neighbor]:
    71    103.8 MiB      0.0 MiB        2699                   came_from[neighbor] = current
    72    103.8 MiB      0.0 MiB        2699                   g_score[neighbor] = temp_g_score
    73    103.8 MiB      0.0 MiB        2699                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.8 MiB      0.0 MiB        2699                   if neighbor not in open_set_hash:
    75    103.8 MiB      0.0 MiB        2699                       count += 1
    76    103.8 MiB      0.0 MiB        2699                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.8 MiB      0.0 MiB        2699                       open_set_hash.add(neighbor)
    78                                                             
    79    103.8 MiB      0.0 MiB        2378           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.8 MiB      0.0 MiB        2378           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.8 MiB    103.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.8 MiB      0.0 MiB         257       for row in grid:
    30    103.8 MiB      0.0 MiB       65792           for spot in row:
    31    103.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.8 MiB      0.0 MiB           1       count = 0
    34    103.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.8 MiB      0.0 MiB           1       came_from = {}
    37    103.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.6 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.6 MiB      0.0 MiB        1426       while not open_set.empty():
    47    104.6 MiB      0.0 MiB        1426           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.6 MiB      0.0 MiB        1426           current = open_set.get()[2]
    53    104.6 MiB      0.0 MiB        1426           open_set_hash.remove(current)
    54                                         
    55    104.6 MiB      0.0 MiB        1426           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.6 MiB      0.0 MiB        1426           if current == end:
    60    104.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.6 MiB      0.0 MiB       12825           for neighbor in current.neighbors:
    65    104.6 MiB      0.0 MiB       11400               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.6 MiB      0.0 MiB        5700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.6 MiB      0.0 MiB        5700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.6 MiB      0.0 MiB       11400               if temp_g_score < g_score[neighbor]:
    71    104.6 MiB      0.0 MiB        1718                   came_from[neighbor] = current
    72    104.6 MiB      0.0 MiB        1718                   g_score[neighbor] = temp_g_score
    73    104.6 MiB      0.0 MiB        1718                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.6 MiB      0.0 MiB        1718                   if neighbor not in open_set_hash:
    75    104.6 MiB      0.0 MiB        1718                       count += 1
    76    104.6 MiB      0.0 MiB        1718                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.6 MiB      0.0 MiB        1718                       open_set_hash.add(neighbor)
    78                                                             
    79    104.6 MiB      0.0 MiB        1425           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.6 MiB      0.0 MiB        1425           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.6 MiB    104.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.6 MiB      0.0 MiB         257       for row in grid:
    30    104.6 MiB      0.0 MiB       65792           for spot in row:
    31    104.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.6 MiB      0.0 MiB           1       count = 0
    34    104.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.6 MiB      0.0 MiB           1       came_from = {}
    37    105.3 MiB  -2058.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.2 MiB     -0.2 MiB           1       g_score[start] = 0
    39    106.4 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.4 MiB      0.0 MiB          96       while not open_set.empty():
    47    106.4 MiB      0.0 MiB          96           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.4 MiB      0.0 MiB          96           current = open_set.get()[2]
    53    106.4 MiB      0.0 MiB          96           open_set_hash.remove(current)
    54                                         
    55    106.4 MiB      0.0 MiB          96           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.4 MiB      0.0 MiB          96           if current == end:
    60    106.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.4 MiB      0.0 MiB         855           for neighbor in current.neighbors:
    65    106.4 MiB      0.0 MiB         760               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.4 MiB      0.0 MiB         380                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.4 MiB      0.0 MiB         380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.4 MiB      0.0 MiB         760               if temp_g_score < g_score[neighbor]:
    71    106.4 MiB      0.0 MiB         158                   came_from[neighbor] = current
    72    106.4 MiB      0.0 MiB         158                   g_score[neighbor] = temp_g_score
    73    106.4 MiB      0.0 MiB         158                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.4 MiB      0.0 MiB         158                   if neighbor not in open_set_hash:
    75    106.4 MiB      0.0 MiB         158                       count += 1
    76    106.4 MiB      0.0 MiB         158                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.4 MiB      0.0 MiB         158                       open_set_hash.add(neighbor)
    78                                                             
    79    106.4 MiB      0.0 MiB          95           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.4 MiB      0.0 MiB          95           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.5 MiB    106.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.5 MiB   -851.0 MiB         257       for row in grid:
    30    106.5 MiB -218386.6 MiB       65792           for spot in row:
    31    106.5 MiB -217537.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.0 MiB     -3.5 MiB           1       count = 0
    34    103.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.0 MiB      0.0 MiB           1       came_from = {}
    37    105.7 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.4 MiB      0.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.4 MiB      0.0 MiB        3636       while not open_set.empty():
    47    106.4 MiB      0.0 MiB        3636           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.4 MiB      0.0 MiB        3636           current = open_set.get()[2]
    53    106.4 MiB      0.0 MiB        3636           open_set_hash.remove(current)
    54                                         
    55    106.4 MiB      0.0 MiB        3636           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.4 MiB      0.0 MiB        3636           if current == end:
    60    106.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.4 MiB      0.0 MiB       32715           for neighbor in current.neighbors:
    65    106.4 MiB      0.0 MiB       29080               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.4 MiB      0.0 MiB       14540                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.4 MiB      0.0 MiB       14540                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.4 MiB      0.0 MiB       29080               if temp_g_score < g_score[neighbor]:
    71    106.4 MiB      0.0 MiB        3980                   came_from[neighbor] = current
    72    106.4 MiB      0.0 MiB        3980                   g_score[neighbor] = temp_g_score
    73    106.4 MiB      0.0 MiB        3980                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.4 MiB      0.0 MiB        3980                   if neighbor not in open_set_hash:
    75    106.4 MiB      0.0 MiB        3980                       count += 1
    76    106.4 MiB      0.0 MiB        3980                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.4 MiB      0.0 MiB        3980                       open_set_hash.add(neighbor)
    78                                                             
    79    106.4 MiB      0.0 MiB        3635           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.4 MiB      0.0 MiB        3635           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.4 MiB    106.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.4 MiB      0.0 MiB         257       for row in grid:
    30    106.4 MiB      0.0 MiB       65792           for spot in row:
    31    106.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.4 MiB      0.0 MiB           1       count = 0
    34    106.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.4 MiB      0.0 MiB           1       came_from = {}
    37    106.5 MiB -99011.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.7 MiB     -1.8 MiB           1       g_score[start] = 0
    39    106.0 MiB -50954.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.0 MiB      0.0 MiB         484       while not open_set.empty():
    47    106.0 MiB      0.0 MiB         484           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.0 MiB      0.0 MiB         484           current = open_set.get()[2]
    53    106.0 MiB      0.0 MiB         484           open_set_hash.remove(current)
    54                                         
    55    106.0 MiB      0.0 MiB         484           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.0 MiB      0.0 MiB         484           if current == end:
    60    106.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.0 MiB      0.0 MiB        4347           for neighbor in current.neighbors:
    65    106.0 MiB      0.0 MiB        3864               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.0 MiB      0.0 MiB        1932                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.0 MiB      0.0 MiB        1932                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.0 MiB      0.0 MiB        3864               if temp_g_score < g_score[neighbor]:
    71    106.0 MiB      0.0 MiB         974                   came_from[neighbor] = current
    72    106.0 MiB      0.0 MiB         974                   g_score[neighbor] = temp_g_score
    73    106.0 MiB      0.0 MiB         974                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.0 MiB      0.0 MiB         974                   if neighbor not in open_set_hash:
    75    106.0 MiB      0.0 MiB         974                       count += 1
    76    106.0 MiB      0.0 MiB         974                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.0 MiB      0.0 MiB         974                       open_set_hash.add(neighbor)
    78                                                             
    79    106.0 MiB      0.0 MiB         483           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.0 MiB      0.0 MiB         483           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.0 MiB    106.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.0 MiB      0.0 MiB         257       for row in grid:
    30    106.0 MiB      0.0 MiB       65792           for spot in row:
    31    106.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.0 MiB      0.0 MiB           1       count = 0
    34    106.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.0 MiB      0.0 MiB           1       came_from = {}
    37    107.4 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.1 MiB      0.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.1 MiB      0.0 MiB         584       while not open_set.empty():
    47    108.1 MiB      0.0 MiB         584           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.1 MiB      0.0 MiB         584           current = open_set.get()[2]
    53    108.1 MiB      0.0 MiB         584           open_set_hash.remove(current)
    54                                         
    55    108.1 MiB      0.0 MiB         584           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.1 MiB      0.0 MiB         584           if current == end:
    60    108.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.1 MiB      0.0 MiB        5247           for neighbor in current.neighbors:
    65    108.1 MiB      0.0 MiB        4664               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.1 MiB      0.0 MiB        2332                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.1 MiB      0.0 MiB        2332                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.1 MiB      0.0 MiB        4664               if temp_g_score < g_score[neighbor]:
    71    108.1 MiB      0.0 MiB         890                   came_from[neighbor] = current
    72    108.1 MiB      0.0 MiB         890                   g_score[neighbor] = temp_g_score
    73    108.1 MiB      0.0 MiB         890                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.1 MiB      0.0 MiB         890                   if neighbor not in open_set_hash:
    75    108.1 MiB      0.0 MiB         890                       count += 1
    76    108.1 MiB      0.0 MiB         890                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.1 MiB      0.0 MiB         890                       open_set_hash.add(neighbor)
    78                                                             
    79    108.1 MiB      0.0 MiB         583           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.1 MiB      0.0 MiB         583           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.1 MiB    108.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.1 MiB      0.0 MiB         257       for row in grid:
    30    108.1 MiB      0.0 MiB       65792           for spot in row:
    31    108.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.1 MiB      0.0 MiB           1       count = 0
    34    108.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.1 MiB      0.0 MiB           1       came_from = {}
    37    108.7 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.2 MiB      3.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.2 MiB   -994.4 MiB        2565       while not open_set.empty():
    47    112.2 MiB   -994.4 MiB        2565           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.2 MiB   -994.4 MiB        2565           current = open_set.get()[2]
    53    112.2 MiB   -994.4 MiB        2565           open_set_hash.remove(current)
    54                                         
    55    112.2 MiB   -994.4 MiB        2565           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.2 MiB   -994.4 MiB        2565           if current == end:
    60    111.6 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.2 MiB  -8946.0 MiB       23076           for neighbor in current.neighbors:
    65    112.2 MiB  -7951.8 MiB       20512               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.2 MiB  -3976.8 MiB       10256                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.2 MiB  -3975.2 MiB       10256                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.2 MiB  -7952.1 MiB       20512               if temp_g_score < g_score[neighbor]:
    71    112.2 MiB  -1081.7 MiB        2881                   came_from[neighbor] = current
    72    112.2 MiB  -1081.7 MiB        2881                   g_score[neighbor] = temp_g_score
    73    112.2 MiB  -1081.7 MiB        2881                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.2 MiB  -1081.7 MiB        2881                   if neighbor not in open_set_hash:
    75    112.2 MiB  -1081.7 MiB        2881                       count += 1
    76    112.2 MiB  -1081.7 MiB        2881                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.2 MiB  -1081.7 MiB        2881                       open_set_hash.add(neighbor)
    78                                                             
    79    112.2 MiB   -994.4 MiB        2564           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.2 MiB   -994.4 MiB        2564           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.6 MiB    111.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.6 MiB      0.0 MiB         257       for row in grid:
    30    111.6 MiB      0.0 MiB       65792           for spot in row:
    31    111.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.6 MiB      0.0 MiB           1       count = 0
    34    111.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.6 MiB      0.0 MiB           1       came_from = {}
    37    114.5 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.0 MiB      1.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.0 MiB      0.0 MiB         376       while not open_set.empty():
    47    116.0 MiB      0.0 MiB         376           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.0 MiB      0.0 MiB         376           current = open_set.get()[2]
    53    116.0 MiB      0.0 MiB         376           open_set_hash.remove(current)
    54                                         
    55    116.0 MiB      0.0 MiB         376           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.0 MiB      0.0 MiB         376           if current == end:
    60    116.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.0 MiB      0.0 MiB        3375           for neighbor in current.neighbors:
    65    116.0 MiB      0.0 MiB        3000               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.0 MiB      0.0 MiB        1500                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.0 MiB      0.0 MiB        1500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.0 MiB      0.0 MiB        3000               if temp_g_score < g_score[neighbor]:
    71    116.0 MiB      0.0 MiB         578                   came_from[neighbor] = current
    72    116.0 MiB      0.0 MiB         578                   g_score[neighbor] = temp_g_score
    73    116.0 MiB      0.0 MiB         578                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.0 MiB      0.0 MiB         578                   if neighbor not in open_set_hash:
    75    116.0 MiB      0.0 MiB         578                       count += 1
    76    116.0 MiB      0.0 MiB         578                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.0 MiB      0.0 MiB         578                       open_set_hash.add(neighbor)
    78                                                             
    79    116.0 MiB      0.0 MiB         375           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.0 MiB      0.0 MiB         375           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.0 MiB    116.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.0 MiB      0.0 MiB         257       for row in grid:
    30    116.0 MiB      0.0 MiB       65792           for spot in row:
    31    116.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    116.0 MiB      0.0 MiB           1       count = 0
    34    116.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    116.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    116.0 MiB      0.0 MiB           1       came_from = {}
    37    116.3 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.5 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.5 MiB      0.0 MiB        3072       while not open_set.empty():
    47    117.5 MiB      0.0 MiB        3072           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.5 MiB      0.0 MiB        3072           current = open_set.get()[2]
    53    117.5 MiB      0.0 MiB        3072           open_set_hash.remove(current)
    54                                         
    55    117.5 MiB      0.0 MiB        3072           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.5 MiB      0.0 MiB        3072           if current == end:
    60    117.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    117.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.5 MiB      0.0 MiB       27639           for neighbor in current.neighbors:
    65    117.5 MiB      0.0 MiB       24568               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.5 MiB      0.0 MiB       12284                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.5 MiB      0.0 MiB       12284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.5 MiB      0.0 MiB       24568               if temp_g_score < g_score[neighbor]:
    71    117.5 MiB      0.0 MiB        3422                   came_from[neighbor] = current
    72    117.5 MiB      0.0 MiB        3422                   g_score[neighbor] = temp_g_score
    73    117.5 MiB      0.0 MiB        3422                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.5 MiB      0.0 MiB        3422                   if neighbor not in open_set_hash:
    75    117.5 MiB      0.0 MiB        3422                       count += 1
    76    117.5 MiB      0.0 MiB        3422                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.5 MiB      0.0 MiB        3422                       open_set_hash.add(neighbor)
    78                                                             
    79    117.5 MiB      0.0 MiB        3071           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.5 MiB      0.0 MiB        3071           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    117.5 MiB    117.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    117.5 MiB      0.0 MiB         257       for row in grid:
    30    117.5 MiB      0.0 MiB       65792           for spot in row:
    31    117.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    117.5 MiB      0.0 MiB           1       count = 0
    34    117.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    117.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    117.5 MiB      0.0 MiB           1       came_from = {}
    37    117.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    117.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.5 MiB -63288.1 MiB        3888       while not open_set.empty():
    47    117.5 MiB -63289.4 MiB        3888           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.5 MiB -63292.0 MiB        3888           current = open_set.get()[2]
    53    117.5 MiB -63292.9 MiB        3888           open_set_hash.remove(current)
    54                                         
    55    117.5 MiB -63294.0 MiB        3888           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.5 MiB -63295.4 MiB        3888           if current == end:
    60     61.2 MiB    -56.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.4 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.5 MiB -569340.3 MiB       34983           for neighbor in current.neighbors:
    65    117.5 MiB -506064.4 MiB       31096               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.5 MiB -253076.8 MiB       15548                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.5 MiB -252995.6 MiB       15548                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.5 MiB -506080.2 MiB       31096               if temp_g_score < g_score[neighbor]:
    71    117.5 MiB -70350.3 MiB        4390                   came_from[neighbor] = current
    72    117.5 MiB -70351.1 MiB        4390                   g_score[neighbor] = temp_g_score
    73    117.5 MiB -70353.0 MiB        4390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.5 MiB -70354.2 MiB        4390                   if neighbor not in open_set_hash:
    75    117.5 MiB -70355.5 MiB        4390                       count += 1
    76    117.5 MiB -70358.4 MiB        4390                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.5 MiB -70359.6 MiB        4390                       open_set_hash.add(neighbor)
    78                                                             
    79    117.5 MiB -63285.0 MiB        3887           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.5 MiB -63286.4 MiB        3887           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.2 MiB    100.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.5 MiB     -2.0 MiB         257       for row in grid:
    30    100.5 MiB   -502.2 MiB       65792           for spot in row:
    31    100.5 MiB   -500.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.5 MiB      0.0 MiB           1       count = 0
    34    100.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.5 MiB      0.0 MiB           1       came_from = {}
    37    102.6 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.6 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.6 MiB    -42.6 MiB        7700       while not open_set.empty():
    47    106.6 MiB    -42.6 MiB        7700           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.6 MiB    -42.6 MiB        7700           current = open_set.get()[2]
    53    106.6 MiB    -42.6 MiB        7700           open_set_hash.remove(current)
    54                                         
    55    106.6 MiB    -42.6 MiB        7700           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.6 MiB    -42.6 MiB        7700           if current == end:
    60    106.6 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.6 MiB   -383.5 MiB       69291           for neighbor in current.neighbors:
    65    106.6 MiB   -340.9 MiB       61592               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.6 MiB   -170.5 MiB       30796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.6 MiB   -170.4 MiB       30796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.6 MiB   -340.9 MiB       61592               if temp_g_score < g_score[neighbor]:
    71    106.6 MiB    -45.0 MiB        8278                   came_from[neighbor] = current
    72    106.6 MiB    -45.0 MiB        8278                   g_score[neighbor] = temp_g_score
    73    106.6 MiB    -45.0 MiB        8278                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.6 MiB    -45.0 MiB        8278                   if neighbor not in open_set_hash:
    75    106.6 MiB    -45.0 MiB        8278                       count += 1
    76    106.6 MiB    -45.0 MiB        8278                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.6 MiB    -45.0 MiB        8278                       open_set_hash.add(neighbor)
    78                                                             
    79    106.6 MiB    -42.6 MiB        7699           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.6 MiB    -42.6 MiB        7699           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.6 MiB    106.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.6 MiB      0.0 MiB         257       for row in grid:
    30    106.6 MiB      0.0 MiB       65792           for spot in row:
    31    106.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.6 MiB      0.0 MiB           1       count = 0
    34    106.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.6 MiB      0.0 MiB           1       came_from = {}
    37    106.8 MiB      0.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.4 MiB      1.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.5 MiB    -12.2 MiB        2430       while not open_set.empty():
    47    108.5 MiB    -12.2 MiB        2430           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.5 MiB    -12.2 MiB        2430           current = open_set.get()[2]
    53    108.5 MiB    -12.2 MiB        2430           open_set_hash.remove(current)
    54                                         
    55    108.5 MiB    -12.2 MiB        2430           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.5 MiB    -12.2 MiB        2430           if current == end:
    60    108.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.5 MiB   -110.2 MiB       21861           for neighbor in current.neighbors:
    65    108.5 MiB    -98.0 MiB       19432               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.5 MiB    -49.0 MiB        9716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.5 MiB    -49.0 MiB        9716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.5 MiB    -98.0 MiB       19432               if temp_g_score < g_score[neighbor]:
    71    108.5 MiB    -13.1 MiB        2716                   came_from[neighbor] = current
    72    108.5 MiB    -13.2 MiB        2716                   g_score[neighbor] = temp_g_score
    73    108.5 MiB    -13.2 MiB        2716                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.5 MiB    -13.2 MiB        2716                   if neighbor not in open_set_hash:
    75    108.5 MiB    -13.2 MiB        2716                       count += 1
    76    108.5 MiB    -13.2 MiB        2716                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.5 MiB    -13.2 MiB        2716                       open_set_hash.add(neighbor)
    78                                                             
    79    108.5 MiB    -12.2 MiB        2429           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.5 MiB    -12.2 MiB        2429           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.5 MiB    108.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.5 MiB      0.0 MiB         257       for row in grid:
    30    108.5 MiB      0.0 MiB       65792           for spot in row:
    31    108.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.5 MiB      0.0 MiB           1       count = 0
    34    108.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.5 MiB      0.0 MiB           1       came_from = {}
    37    110.6 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.6 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.7 MiB      0.0 MiB        1029       while not open_set.empty():
    47    112.7 MiB      0.0 MiB        1029           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.7 MiB      0.0 MiB        1029           current = open_set.get()[2]
    53    112.7 MiB      0.0 MiB        1029           open_set_hash.remove(current)
    54                                         
    55    112.7 MiB      0.0 MiB        1029           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.7 MiB      0.0 MiB        1029           if current == end:
    60    112.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.7 MiB      0.0 MiB        9252           for neighbor in current.neighbors:
    65    112.7 MiB      0.0 MiB        8224               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.7 MiB      0.0 MiB        4112                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.7 MiB      0.0 MiB        4112                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.7 MiB      0.0 MiB        8224               if temp_g_score < g_score[neighbor]:
    71    112.7 MiB      0.1 MiB        1209                   came_from[neighbor] = current
    72    112.7 MiB      0.0 MiB        1209                   g_score[neighbor] = temp_g_score
    73    112.7 MiB      0.0 MiB        1209                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.7 MiB      0.0 MiB        1209                   if neighbor not in open_set_hash:
    75    112.7 MiB      0.0 MiB        1209                       count += 1
    76    112.7 MiB      0.0 MiB        1209                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.7 MiB      0.0 MiB        1209                       open_set_hash.add(neighbor)
    78                                                             
    79    112.7 MiB      0.0 MiB        1028           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.7 MiB      0.0 MiB        1028           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.7 MiB    112.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.7 MiB   -147.0 MiB         257       for row in grid:
    30    112.7 MiB -37403.4 MiB       65792           for spot in row:
    31    112.7 MiB -37257.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.2 MiB     -1.5 MiB           1       count = 0
    34    111.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.2 MiB      0.0 MiB           1       came_from = {}
    37    112.3 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.2 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.2 MiB      0.0 MiB          55       while not open_set.empty():
    47    113.2 MiB      0.0 MiB          55           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.2 MiB      0.0 MiB          55           current = open_set.get()[2]
    53    113.2 MiB      0.0 MiB          55           open_set_hash.remove(current)
    54                                         
    55    113.2 MiB      0.0 MiB          55           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.2 MiB      0.0 MiB          55           if current == end:
    60    113.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.2 MiB      0.0 MiB         486           for neighbor in current.neighbors:
    65    113.2 MiB      0.0 MiB         432               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.2 MiB      0.0 MiB         216                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.2 MiB      0.0 MiB         216                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.2 MiB      0.0 MiB         432               if temp_g_score < g_score[neighbor]:
    71    113.2 MiB      0.0 MiB          95                   came_from[neighbor] = current
    72    113.2 MiB      0.0 MiB          95                   g_score[neighbor] = temp_g_score
    73    113.2 MiB      0.0 MiB          95                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.2 MiB      0.0 MiB          95                   if neighbor not in open_set_hash:
    75    113.2 MiB      0.0 MiB          95                       count += 1
    76    113.2 MiB      0.0 MiB          95                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.2 MiB      0.0 MiB          95                       open_set_hash.add(neighbor)
    78                                                             
    79    113.2 MiB      0.0 MiB          54           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.2 MiB      0.0 MiB          54           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.2 MiB    113.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.2 MiB      0.0 MiB         257       for row in grid:
    30    113.2 MiB      0.0 MiB       65792           for spot in row:
    31    113.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    113.2 MiB      0.0 MiB           1       count = 0
    34    113.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    113.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    113.2 MiB      0.0 MiB           1       came_from = {}
    37    113.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.1 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.1 MiB      0.0 MiB        2635       while not open_set.empty():
    47    114.1 MiB      0.0 MiB        2635           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.1 MiB      0.0 MiB        2635           current = open_set.get()[2]
    53    114.1 MiB      0.0 MiB        2635           open_set_hash.remove(current)
    54                                         
    55    114.1 MiB      0.0 MiB        2635           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.1 MiB      0.0 MiB        2635           if current == end:
    60    114.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.1 MiB      0.0 MiB       23706           for neighbor in current.neighbors:
    65    114.1 MiB      0.0 MiB       21072               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.1 MiB      0.0 MiB       10536                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.1 MiB      0.0 MiB       10536                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.1 MiB      0.0 MiB       21072               if temp_g_score < g_score[neighbor]:
    71    114.1 MiB      0.0 MiB        3011                   came_from[neighbor] = current
    72    114.1 MiB      0.0 MiB        3011                   g_score[neighbor] = temp_g_score
    73    114.1 MiB      0.0 MiB        3011                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.1 MiB      0.0 MiB        3011                   if neighbor not in open_set_hash:
    75    114.1 MiB      0.0 MiB        3011                       count += 1
    76    114.1 MiB      0.0 MiB        3011                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.1 MiB      0.0 MiB        3011                       open_set_hash.add(neighbor)
    78                                                             
    79    114.1 MiB      0.0 MiB        2634           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.1 MiB      0.0 MiB        2634           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.1 MiB    114.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.1 MiB      0.0 MiB         257       for row in grid:
    30    114.1 MiB      0.0 MiB       65792           for spot in row:
    31    114.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.1 MiB      0.0 MiB           1       count = 0
    34    114.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.1 MiB      0.0 MiB           1       came_from = {}
    37    114.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.2 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.2 MiB      0.0 MiB        1560       while not open_set.empty():
    47    114.2 MiB      0.0 MiB        1560           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.2 MiB      0.0 MiB        1560           current = open_set.get()[2]
    53    114.2 MiB      0.0 MiB        1560           open_set_hash.remove(current)
    54                                         
    55    114.2 MiB      0.0 MiB        1560           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.2 MiB      0.0 MiB        1560           if current == end:
    60    114.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.2 MiB      0.0 MiB       14031           for neighbor in current.neighbors:
    65    114.2 MiB      0.0 MiB       12472               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.2 MiB      0.0 MiB        6236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.2 MiB      0.0 MiB        6236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.2 MiB      0.0 MiB       12472               if temp_g_score < g_score[neighbor]:
    71    114.2 MiB      0.0 MiB        1796                   came_from[neighbor] = current
    72    114.2 MiB      0.0 MiB        1796                   g_score[neighbor] = temp_g_score
    73    114.2 MiB      0.0 MiB        1796                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.2 MiB      0.0 MiB        1796                   if neighbor not in open_set_hash:
    75    114.2 MiB      0.0 MiB        1796                       count += 1
    76    114.2 MiB      0.0 MiB        1796                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.2 MiB      0.0 MiB        1796                       open_set_hash.add(neighbor)
    78                                                             
    79    114.2 MiB      0.0 MiB        1559           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.2 MiB      0.0 MiB        1559           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.2 MiB    114.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.2 MiB      0.0 MiB         257       for row in grid:
    30    114.2 MiB      0.0 MiB       65792           for spot in row:
    31    114.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.2 MiB      0.0 MiB           1       count = 0
    34    114.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.2 MiB      0.0 MiB           1       came_from = {}
    37    115.5 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.7 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.7 MiB -98341.2 MiB        8829       while not open_set.empty():
    47    116.7 MiB -98341.2 MiB        8829           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.7 MiB -98341.7 MiB        8829           current = open_set.get()[2]
    53    116.7 MiB -98342.0 MiB        8829           open_set_hash.remove(current)
    54                                         
    55    116.7 MiB -98342.3 MiB        8829           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.7 MiB -98342.7 MiB        8829           if current == end:
    60     94.1 MiB    -22.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.7 MiB -884964.3 MiB       79452           for neighbor in current.neighbors:
    65    116.7 MiB -786628.0 MiB       70624               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.7 MiB -393334.1 MiB       35312                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.7 MiB -393297.5 MiB       35312                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.7 MiB -786635.5 MiB       70624               if temp_g_score < g_score[neighbor]:
    71    116.7 MiB -102508.9 MiB        9369                   came_from[neighbor] = current
    72    116.7 MiB -102509.3 MiB        9369                   g_score[neighbor] = temp_g_score
    73    116.7 MiB -102509.9 MiB        9369                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.7 MiB -102510.3 MiB        9369                   if neighbor not in open_set_hash:
    75    116.7 MiB -102510.5 MiB        9369                       count += 1
    76    116.7 MiB -102511.1 MiB        9369                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.7 MiB -102511.5 MiB        9369                       open_set_hash.add(neighbor)
    78                                                             
    79    116.7 MiB -98340.0 MiB        8828           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.7 MiB -98340.6 MiB        8828           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.3 MiB     97.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.3 MiB      0.0 MiB         257       for row in grid:
    30     97.3 MiB      0.0 MiB       65792           for spot in row:
    31     97.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.3 MiB      0.0 MiB           1       count = 0
    34     97.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.3 MiB      0.0 MiB           1       came_from = {}
    37    101.8 MiB   -546.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.3 MiB     -0.4 MiB           1       g_score[start] = 0
    39    106.9 MiB      5.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.0 MiB      0.0 MiB        2640       while not open_set.empty():
    47    107.0 MiB      0.0 MiB        2640           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.0 MiB      0.0 MiB        2640           current = open_set.get()[2]
    53    107.0 MiB      0.0 MiB        2640           open_set_hash.remove(current)
    54                                         
    55    107.0 MiB      0.0 MiB        2640           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.0 MiB      0.0 MiB        2640           if current == end:
    60    107.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.0 MiB      0.0 MiB       23751           for neighbor in current.neighbors:
    65    107.0 MiB      0.0 MiB       21112               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.0 MiB      0.0 MiB       10556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.0 MiB      0.0 MiB       10556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.0 MiB      0.0 MiB       21112               if temp_g_score < g_score[neighbor]:
    71    107.0 MiB      0.0 MiB        2954                   came_from[neighbor] = current
    72    107.0 MiB      0.0 MiB        2954                   g_score[neighbor] = temp_g_score
    73    107.0 MiB      0.0 MiB        2954                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.0 MiB      0.0 MiB        2954                   if neighbor not in open_set_hash:
    75    107.0 MiB      0.0 MiB        2954                       count += 1
    76    107.0 MiB      0.0 MiB        2954                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.0 MiB      0.0 MiB        2954                       open_set_hash.add(neighbor)
    78                                                             
    79    107.0 MiB      0.0 MiB        2639           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.0 MiB      0.0 MiB        2639           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.0 MiB    107.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.0 MiB      0.0 MiB         257       for row in grid:
    30    107.0 MiB      0.0 MiB       65792           for spot in row:
    31    107.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.0 MiB      0.0 MiB           1       count = 0
    34    107.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.0 MiB      0.0 MiB           1       came_from = {}
    37    107.2 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.2 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.2 MiB      0.0 MiB        1152       while not open_set.empty():
    47    108.2 MiB      0.0 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.2 MiB      0.0 MiB        1152           current = open_set.get()[2]
    53    108.2 MiB      0.0 MiB        1152           open_set_hash.remove(current)
    54                                         
    55    108.2 MiB      0.0 MiB        1152           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.2 MiB      0.0 MiB        1152           if current == end:
    60    108.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.2 MiB      0.0 MiB       10359           for neighbor in current.neighbors:
    65    108.2 MiB      0.0 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.2 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.2 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.2 MiB      0.0 MiB        9208               if temp_g_score < g_score[neighbor]:
    71    108.2 MiB      0.0 MiB        1390                   came_from[neighbor] = current
    72    108.2 MiB      0.0 MiB        1390                   g_score[neighbor] = temp_g_score
    73    108.2 MiB      0.0 MiB        1390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.2 MiB      0.0 MiB        1390                   if neighbor not in open_set_hash:
    75    108.2 MiB      0.0 MiB        1390                       count += 1
    76    108.2 MiB      0.0 MiB        1390                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.2 MiB      0.0 MiB        1390                       open_set_hash.add(neighbor)
    78                                                             
    79    108.2 MiB      0.0 MiB        1151           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.2 MiB      0.0 MiB        1151           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.2 MiB    108.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.2 MiB      0.0 MiB         257       for row in grid:
    30    108.2 MiB      0.0 MiB       65792           for spot in row:
    31    108.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.2 MiB      0.0 MiB           1       count = 0
    34    108.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.2 MiB      0.0 MiB           1       came_from = {}
    37    108.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.3 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.3 MiB      0.0 MiB         268       while not open_set.empty():
    47    110.3 MiB      0.0 MiB         268           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.3 MiB      0.0 MiB         268           current = open_set.get()[2]
    53    110.3 MiB      0.0 MiB         268           open_set_hash.remove(current)
    54                                         
    55    110.3 MiB      0.0 MiB         268           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.3 MiB      0.0 MiB         268           if current == end:
    60    110.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    110.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.3 MiB      0.0 MiB        2403           for neighbor in current.neighbors:
    65    110.3 MiB      0.0 MiB        2136               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.3 MiB      0.0 MiB        1068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.3 MiB      0.0 MiB        1068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.3 MiB      0.0 MiB        2136               if temp_g_score < g_score[neighbor]:
    71    110.3 MiB      0.0 MiB         416                   came_from[neighbor] = current
    72    110.3 MiB      0.0 MiB         416                   g_score[neighbor] = temp_g_score
    73    110.3 MiB      0.0 MiB         416                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.3 MiB      0.0 MiB         416                   if neighbor not in open_set_hash:
    75    110.3 MiB      0.0 MiB         416                       count += 1
    76    110.3 MiB      0.0 MiB         416                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.3 MiB      0.0 MiB         416                       open_set_hash.add(neighbor)
    78                                                             
    79    110.3 MiB      0.0 MiB         267           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.3 MiB      0.0 MiB         267           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.3 MiB    110.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.3 MiB     -1.2 MiB         257       for row in grid:
    30    110.3 MiB   -299.7 MiB       65792           for spot in row:
    31    110.3 MiB   -298.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.2 MiB     -0.0 MiB           1       count = 0
    34    110.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.2 MiB      0.0 MiB           1       came_from = {}
    37    110.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    110.4 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    110.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    110.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    110.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    110.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    110.4 MiB  -1076.4 MiB        1804       while not open_set.empty():
    47    110.4 MiB  -1076.4 MiB        1804           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    110.4 MiB  -1076.4 MiB        1804           current = open_set.get()[2]
    53    110.4 MiB  -1076.4 MiB        1804           open_set_hash.remove(current)
    54                                         
    55    110.4 MiB  -1076.4 MiB        1804           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    110.4 MiB  -1076.4 MiB        1804           if current == end:
    60    109.8 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    110.4 MiB  -9685.9 MiB       16227           for neighbor in current.neighbors:
    65    110.4 MiB  -8609.6 MiB       14424               if current.row != neighbor.row and current.col != neighbor.col:
    66    110.4 MiB  -4305.6 MiB        7212                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    110.4 MiB  -4304.2 MiB        7212                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    110.4 MiB  -8610.0 MiB       14424               if temp_g_score < g_score[neighbor]:
    71    110.4 MiB  -1204.0 MiB        2060                   came_from[neighbor] = current
    72    110.4 MiB  -1204.0 MiB        2060                   g_score[neighbor] = temp_g_score
    73    110.4 MiB  -1204.0 MiB        2060                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    110.4 MiB  -1204.0 MiB        2060                   if neighbor not in open_set_hash:
    75    110.4 MiB  -1204.0 MiB        2060                       count += 1
    76    110.4 MiB  -1204.0 MiB        2060                       open_set.put((f_score[neighbor], count, neighbor))
    77    110.4 MiB  -1204.0 MiB        2060                       open_set_hash.add(neighbor)
    78                                                             
    79    110.4 MiB  -1076.4 MiB        1803           if draw is not None:
    80                                                     draw()
    81                                         
    82    110.4 MiB  -1076.4 MiB        1803           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.8 MiB    109.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.8 MiB   -173.9 MiB         257       for row in grid:
    30    109.8 MiB -44363.1 MiB       65792           for spot in row:
    31    109.8 MiB -44192.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.7 MiB     -4.0 MiB           1       count = 0
    34    105.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.7 MiB      0.0 MiB           1       came_from = {}
    37    105.9 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.3 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.3 MiB      0.0 MiB         826       while not open_set.empty():
    47    108.3 MiB      0.0 MiB         826           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.3 MiB      0.0 MiB         826           current = open_set.get()[2]
    53    108.3 MiB      0.0 MiB         826           open_set_hash.remove(current)
    54                                         
    55    108.3 MiB      0.0 MiB         826           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.3 MiB      0.0 MiB         826           if current == end:
    60    108.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.3 MiB      0.0 MiB        7425           for neighbor in current.neighbors:
    65    108.3 MiB      0.0 MiB        6600               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.3 MiB      0.0 MiB        3300                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.3 MiB      0.0 MiB        3300                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.3 MiB      0.0 MiB        6600               if temp_g_score < g_score[neighbor]:
    71    108.3 MiB      0.0 MiB        1088                   came_from[neighbor] = current
    72    108.3 MiB      0.0 MiB        1088                   g_score[neighbor] = temp_g_score
    73    108.3 MiB      0.0 MiB        1088                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.3 MiB      0.0 MiB        1088                   if neighbor not in open_set_hash:
    75    108.3 MiB      0.0 MiB        1088                       count += 1
    76    108.3 MiB      0.0 MiB        1088                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.3 MiB      0.0 MiB        1088                       open_set_hash.add(neighbor)
    78                                                             
    79    108.3 MiB      0.0 MiB         825           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.3 MiB      0.0 MiB         825           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.3 MiB    108.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.3 MiB  -1076.1 MiB         257       for row in grid:
    30    108.3 MiB -272912.0 MiB       65792           for spot in row:
    31    108.3 MiB -271869.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     60.0 MiB    -48.3 MiB           1       count = 0
    34     60.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.0 MiB      0.0 MiB           1       came_from = {}
    37     63.5 MiB   -323.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     65.7 MiB -18076.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     65.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     65.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     65.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     65.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     66.9 MiB      0.0 MiB        2209       while not open_set.empty():
    47     66.9 MiB      0.0 MiB        2209           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     66.9 MiB      0.0 MiB        2209           current = open_set.get()[2]
    53     66.9 MiB      0.0 MiB        2209           open_set_hash.remove(current)
    54                                         
    55     66.9 MiB      0.0 MiB        2209           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     66.9 MiB      0.0 MiB        2209           if current == end:
    60     66.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     66.9 MiB      0.6 MiB       19872           for neighbor in current.neighbors:
    65     66.9 MiB      0.6 MiB       17664               if current.row != neighbor.row and current.col != neighbor.col:
    66     66.9 MiB      0.0 MiB        8832                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     66.9 MiB      0.0 MiB        8832                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     66.9 MiB      0.0 MiB       17664               if temp_g_score < g_score[neighbor]:
    71     66.9 MiB      0.0 MiB        2489                   came_from[neighbor] = current
    72     66.9 MiB      0.0 MiB        2489                   g_score[neighbor] = temp_g_score
    73     66.9 MiB      0.0 MiB        2489                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     66.9 MiB      0.0 MiB        2489                   if neighbor not in open_set_hash:
    75     66.9 MiB      0.0 MiB        2489                       count += 1
    76     66.9 MiB      0.0 MiB        2489                       open_set.put((f_score[neighbor], count, neighbor))
    77     66.9 MiB      0.0 MiB        2489                       open_set_hash.add(neighbor)
    78                                                             
    79     66.9 MiB      0.0 MiB        2208           if draw is not None:
    80                                                     draw()
    81                                         
    82     66.9 MiB      0.0 MiB        2208           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     66.9 MiB     66.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.8 MiB      0.0 MiB         257       for row in grid:
    30     68.8 MiB      0.0 MiB       65792           for spot in row:
    31     68.8 MiB      1.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     68.8 MiB      0.0 MiB           1       count = 0
    34     68.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     68.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     68.8 MiB      0.0 MiB           1       came_from = {}
    37     71.0 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.4 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.4 MiB      0.0 MiB        1032       while not open_set.empty():
    47     71.4 MiB      0.0 MiB        1032           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.4 MiB      0.0 MiB        1032           current = open_set.get()[2]
    53     71.4 MiB      0.0 MiB        1032           open_set_hash.remove(current)
    54                                         
    55     71.4 MiB      0.0 MiB        1032           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.4 MiB      0.0 MiB        1032           if current == end:
    60     71.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.4 MiB      0.0 MiB        9279           for neighbor in current.neighbors:
    65     71.4 MiB      0.0 MiB        8248               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.4 MiB      0.0 MiB        4124                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.4 MiB      0.0 MiB        4124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.4 MiB      0.0 MiB        8248               if temp_g_score < g_score[neighbor]:
    71     71.4 MiB      0.0 MiB        1250                   came_from[neighbor] = current
    72     71.4 MiB      0.0 MiB        1250                   g_score[neighbor] = temp_g_score
    73     71.4 MiB      0.0 MiB        1250                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.4 MiB      0.0 MiB        1250                   if neighbor not in open_set_hash:
    75     71.4 MiB      0.0 MiB        1250                       count += 1
    76     71.4 MiB      0.0 MiB        1250                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.4 MiB      0.0 MiB        1250                       open_set_hash.add(neighbor)
    78                                                             
    79     71.4 MiB      0.0 MiB        1031           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.4 MiB      0.0 MiB        1031           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.3 MiB    103.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.3 MiB      0.0 MiB         257       for row in grid:
    30    103.3 MiB      0.0 MiB       65792           for spot in row:
    31    103.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    103.3 MiB      0.0 MiB           1       count = 0
    34    103.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    103.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    103.3 MiB      0.0 MiB           1       came_from = {}
    37    104.5 MiB    -70.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.5 MiB     -0.0 MiB           1       g_score[start] = 0
    39    105.8 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.8 MiB -110217.2 MiB       14344       while not open_set.empty():
    47    105.8 MiB -110217.3 MiB       14344           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.8 MiB -110217.7 MiB       14344           current = open_set.get()[2]
    53    105.8 MiB -110217.9 MiB       14344           open_set_hash.remove(current)
    54                                         
    55    105.8 MiB -110218.2 MiB       14344           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.8 MiB -110218.3 MiB       14344           if current == end:
    60     93.3 MiB    -12.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.8 MiB -991900.5 MiB      129084           for neighbor in current.neighbors:
    65    105.8 MiB -881685.6 MiB      114741               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.8 MiB -440854.4 MiB       57370                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.8 MiB -440833.0 MiB       57371                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.8 MiB -881690.9 MiB      114741               if temp_g_score < g_score[neighbor]:
    71    105.8 MiB -115203.8 MiB       15167                   came_from[neighbor] = current
    72    105.8 MiB -115204.0 MiB       15167                   g_score[neighbor] = temp_g_score
    73    105.8 MiB -115204.1 MiB       15167                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.8 MiB -115204.3 MiB       15167                   if neighbor not in open_set_hash:
    75    105.8 MiB -115204.6 MiB       15167                       count += 1
    76    105.8 MiB -115204.7 MiB       15167                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.8 MiB -115205.1 MiB       15167                       open_set_hash.add(neighbor)
    78                                                             
    79    105.8 MiB -110216.6 MiB       14343           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.8 MiB -110216.9 MiB       14343           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.4 MiB     93.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.7 MiB      0.0 MiB         257       for row in grid:
    30     93.7 MiB      0.0 MiB       65792           for spot in row:
    31     93.7 MiB      0.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.7 MiB      0.0 MiB           1       count = 0
    34     93.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.7 MiB      0.0 MiB           1       came_from = {}
    37     96.6 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.1 MiB  -1115.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.8 MiB      0.0 MiB       12669       while not open_set.empty():
    47     99.8 MiB      0.0 MiB       12669           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.8 MiB      0.0 MiB       12669           current = open_set.get()[2]
    53     99.8 MiB      0.0 MiB       12669           open_set_hash.remove(current)
    54                                         
    55     99.8 MiB      0.0 MiB       12669           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.8 MiB      0.0 MiB       12669           if current == end:
    60     99.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.8 MiB      0.0 MiB      114009           for neighbor in current.neighbors:
    65     99.8 MiB      0.0 MiB      101341               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.8 MiB      0.0 MiB       50670                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.8 MiB      0.0 MiB       50671                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.8 MiB      0.0 MiB      101341               if temp_g_score < g_score[neighbor]:
    71     99.8 MiB      0.6 MiB       13322                   came_from[neighbor] = current
    72     99.8 MiB      0.0 MiB       13322                   g_score[neighbor] = temp_g_score
    73     99.8 MiB      0.0 MiB       13322                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.8 MiB      0.0 MiB       13322                   if neighbor not in open_set_hash:
    75     99.8 MiB      0.0 MiB       13322                       count += 1
    76     99.8 MiB      0.0 MiB       13322                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.8 MiB      0.1 MiB       13322                       open_set_hash.add(neighbor)
    78                                                             
    79     99.8 MiB      0.0 MiB       12668           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.8 MiB      0.0 MiB       12668           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.8 MiB     99.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.8 MiB   -205.4 MiB         257       for row in grid:
    30     99.8 MiB -52398.6 MiB       65792           for spot in row:
    31     99.8 MiB -52194.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.0 MiB     -2.7 MiB           1       count = 0
    34     97.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.0 MiB      0.0 MiB           1       came_from = {}
    37     99.2 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.3 MiB     -0.6 MiB        4347       while not open_set.empty():
    47     99.3 MiB     -0.6 MiB        4347           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.3 MiB     -0.6 MiB        4347           current = open_set.get()[2]
    53     99.3 MiB     -0.6 MiB        4347           open_set_hash.remove(current)
    54                                         
    55     99.3 MiB     -0.6 MiB        4347           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.3 MiB     -0.6 MiB        4347           if current == end:
    60     99.3 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.3 MiB     -5.3 MiB       39111           for neighbor in current.neighbors:
    65     99.3 MiB     -4.7 MiB       34765               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.3 MiB     -2.4 MiB       17382                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.3 MiB     -2.3 MiB       17383                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.3 MiB     -4.7 MiB       34765               if temp_g_score < g_score[neighbor]:
    71     99.3 MiB     -0.8 MiB        4812                   came_from[neighbor] = current
    72     99.3 MiB     -0.8 MiB        4812                   g_score[neighbor] = temp_g_score
    73     99.3 MiB     -0.8 MiB        4812                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.3 MiB     -0.8 MiB        4812                   if neighbor not in open_set_hash:
    75     99.3 MiB     -0.8 MiB        4812                       count += 1
    76     99.3 MiB     -0.8 MiB        4812                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.3 MiB     -0.8 MiB        4812                       open_set_hash.add(neighbor)
    78                                                             
    79     99.3 MiB     -0.6 MiB        4346           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.3 MiB     -0.6 MiB        4346           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.3 MiB     99.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.3 MiB   -229.5 MiB         257       for row in grid:
    30     99.3 MiB -58413.7 MiB       65792           for spot in row:
    31     99.3 MiB -58186.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.1 MiB     -4.2 MiB           1       count = 0
    34     95.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.1 MiB      0.0 MiB           1       came_from = {}
    37     97.3 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.7 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.1 MiB      0.0 MiB        6194       while not open_set.empty():
    47     99.1 MiB      0.0 MiB        6194           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.1 MiB      0.0 MiB        6194           current = open_set.get()[2]
    53     99.1 MiB      0.0 MiB        6194           open_set_hash.remove(current)
    54                                         
    55     99.1 MiB      0.0 MiB        6194           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.1 MiB      0.0 MiB        6194           if current == end:
    60     99.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.1 MiB      0.0 MiB       55734           for neighbor in current.neighbors:
    65     99.1 MiB      0.0 MiB       49541               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.1 MiB      0.0 MiB       24770                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.1 MiB      0.0 MiB       24771                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.1 MiB      0.0 MiB       49541               if temp_g_score < g_score[neighbor]:
    71     99.1 MiB      0.4 MiB        6667                   came_from[neighbor] = current
    72     99.1 MiB      0.0 MiB        6667                   g_score[neighbor] = temp_g_score
    73     99.1 MiB      0.0 MiB        6667                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.1 MiB      0.0 MiB        6667                   if neighbor not in open_set_hash:
    75     99.1 MiB      0.0 MiB        6667                       count += 1
    76     99.1 MiB      0.0 MiB        6667                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.1 MiB      0.0 MiB        6667                       open_set_hash.add(neighbor)
    78                                                             
    79     99.1 MiB      0.0 MiB        6193           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.1 MiB      0.0 MiB        6193           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.1 MiB     99.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.1 MiB   -315.4 MiB         257       for row in grid:
    30     99.1 MiB -80924.0 MiB       65792           for spot in row:
    31     99.1 MiB -80609.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.5 MiB     -1.7 MiB           1       count = 0
    34     97.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.5 MiB      0.0 MiB           1       came_from = {}
    37     99.3 MiB      1.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.6 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.6 MiB -50280.0 MiB        9153       while not open_set.empty():
    47    100.6 MiB -50280.0 MiB        9153           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.6 MiB -50280.1 MiB        9153           current = open_set.get()[2]
    53    100.6 MiB -50280.1 MiB        9153           open_set_hash.remove(current)
    54                                         
    55    100.6 MiB -50280.3 MiB        9153           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.6 MiB -50280.5 MiB        9153           if current == end:
    60     93.9 MiB     -6.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     93.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.6 MiB -452500.2 MiB       82365           for neighbor in current.neighbors:
    65    100.6 MiB -402221.3 MiB       73213               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.6 MiB -201116.1 MiB       36606                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.6 MiB -201105.9 MiB       36607                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.6 MiB -402222.6 MiB       73213               if temp_g_score < g_score[neighbor]:
    71    100.6 MiB -53165.2 MiB        9762                   came_from[neighbor] = current
    72    100.6 MiB -53165.7 MiB        9762                   g_score[neighbor] = temp_g_score
    73    100.6 MiB -53166.4 MiB        9762                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.6 MiB -53166.5 MiB        9762                   if neighbor not in open_set_hash:
    75    100.6 MiB -53166.8 MiB        9762                       count += 1
    76    100.6 MiB -53167.6 MiB        9762                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.6 MiB -53167.9 MiB        9762                       open_set_hash.add(neighbor)
    78                                                             
    79    100.6 MiB -50279.8 MiB        9152           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.6 MiB -50279.8 MiB        9152           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.9 MiB     93.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.9 MiB     -2.1 MiB         257       for row in grid:
    30     93.9 MiB   -546.5 MiB       65792           for spot in row:
    31     93.9 MiB   -544.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.8 MiB     -0.0 MiB           1       count = 0
    34     93.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.8 MiB      0.0 MiB           1       came_from = {}
    37     93.9 MiB -336018.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.7 MiB     -5.2 MiB           1       g_score[start] = 0
    39     90.9 MiB -10412.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.7 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     91.0 MiB -65760.2 MiB        7089       while not open_set.empty():
    47     91.0 MiB -65760.7 MiB        7089           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     91.0 MiB -65761.8 MiB        7089           current = open_set.get()[2]
    53     91.0 MiB -65762.4 MiB        7089           open_set_hash.remove(current)
    54                                         
    55     91.0 MiB -65762.8 MiB        7089           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     91.0 MiB -65763.3 MiB        7089           if current == end:
    60     64.8 MiB    -26.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     91.0 MiB -589831.1 MiB       63375           for neighbor in current.neighbors:
    65     91.0 MiB -524076.3 MiB       56287               if current.row != neighbor.row and current.col != neighbor.col:
    66     91.0 MiB -261746.4 MiB       28074                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     91.0 MiB -262333.1 MiB       28213                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     91.0 MiB -524083.6 MiB       56287               if temp_g_score < g_score[neighbor]:
    71     91.0 MiB -68942.8 MiB        7428                   came_from[neighbor] = current
    72     91.0 MiB -68943.9 MiB        7428                   g_score[neighbor] = temp_g_score
    73     91.0 MiB -68945.1 MiB        7428                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     91.0 MiB -68945.9 MiB        7428                   if neighbor not in open_set_hash:
    75     91.0 MiB -68946.7 MiB        7428                       count += 1
    76     91.0 MiB -68948.0 MiB        7428                       open_set.put((f_score[neighbor], count, neighbor))
    77     91.0 MiB -68948.6 MiB        7428                       open_set_hash.add(neighbor)
    78                                                             
    79     91.0 MiB -65758.9 MiB        7088           if draw is not None:
    80                                                     draw()
    81                                         
    82     91.0 MiB -65759.6 MiB        7088           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.8 MiB     64.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.8 MiB      0.0 MiB         257       for row in grid:
    30     64.8 MiB      0.0 MiB       65792           for spot in row:
    31     64.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.8 MiB      0.0 MiB           1       count = 0
    34     64.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     64.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     64.8 MiB      0.0 MiB           1       came_from = {}
    37     64.8 MiB   -394.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.0 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.0 MiB      0.0 MiB         775       while not open_set.empty():
    47     68.0 MiB      0.0 MiB         775           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.0 MiB      0.0 MiB         775           current = open_set.get()[2]
    53     68.0 MiB      0.0 MiB         775           open_set_hash.remove(current)
    54                                         
    55     68.0 MiB      0.0 MiB         775           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.0 MiB      0.0 MiB         775           if current == end:
    60     68.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.0 MiB      0.0 MiB        6501           for neighbor in current.neighbors:
    65     68.0 MiB      0.0 MiB        5727               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.0 MiB      0.0 MiB        2786                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.0 MiB      0.0 MiB        2941                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.0 MiB      0.0 MiB        5727               if temp_g_score < g_score[neighbor]:
    71     68.0 MiB      0.0 MiB         946                   came_from[neighbor] = current
    72     68.0 MiB      0.0 MiB         946                   g_score[neighbor] = temp_g_score
    73     68.0 MiB      0.0 MiB         946                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.0 MiB      0.0 MiB         946                   if neighbor not in open_set_hash:
    75     68.0 MiB      0.0 MiB         946                       count += 1
    76     68.0 MiB      0.0 MiB         946                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.0 MiB      0.0 MiB         946                       open_set_hash.add(neighbor)
    78                                                             
    79     68.0 MiB      0.0 MiB         774           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.0 MiB      0.0 MiB         774           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.8 MiB    100.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.8 MiB     -2.5 MiB         257       for row in grid:
    30    100.8 MiB   -651.8 MiB       65792           for spot in row:
    31    100.8 MiB   -649.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.7 MiB     -0.0 MiB           1       count = 0
    34    100.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.7 MiB      0.0 MiB           1       came_from = {}
    37    101.4 MiB      0.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.4 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.4 MiB  -3465.5 MiB        5120       while not open_set.empty():
    47    105.4 MiB  -3465.5 MiB        5120           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.4 MiB  -3465.5 MiB        5120           current = open_set.get()[2]
    53    105.4 MiB  -3465.5 MiB        5120           open_set_hash.remove(current)
    54                                         
    55    105.4 MiB  -3465.5 MiB        5120           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.4 MiB  -3465.5 MiB        5120           if current == end:
    60    104.5 MiB     -0.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.4 MiB -31184.2 MiB       46071           for neighbor in current.neighbors:
    65    105.4 MiB -27718.7 MiB       40952               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.4 MiB -13860.3 MiB       20476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.4 MiB -13858.6 MiB       20476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.4 MiB -27719.1 MiB       40952               if temp_g_score < g_score[neighbor]:
    71    105.4 MiB  -3706.6 MiB        5566                   came_from[neighbor] = current
    72    105.4 MiB  -3706.8 MiB        5566                   g_score[neighbor] = temp_g_score
    73    105.4 MiB  -3706.9 MiB        5566                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.4 MiB  -3706.9 MiB        5566                   if neighbor not in open_set_hash:
    75    105.4 MiB  -3706.9 MiB        5566                       count += 1
    76    105.4 MiB  -3706.9 MiB        5566                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.4 MiB  -3706.9 MiB        5566                       open_set_hash.add(neighbor)
    78                                                             
    79    105.4 MiB  -3465.5 MiB        5119           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.4 MiB  -3465.5 MiB        5119           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.5 MiB    104.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.5 MiB      0.0 MiB         257       for row in grid:
    30    104.5 MiB      0.0 MiB       65792           for spot in row:
    31    104.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.5 MiB      0.0 MiB           1       count = 0
    34    104.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.5 MiB      0.0 MiB           1       came_from = {}
    37    107.4 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    107.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.0 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.1 MiB      0.0 MiB        1140       while not open_set.empty():
    47    109.1 MiB      0.0 MiB        1140           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.1 MiB      0.0 MiB        1140           current = open_set.get()[2]
    53    109.1 MiB      0.0 MiB        1140           open_set_hash.remove(current)
    54                                         
    55    109.1 MiB      0.0 MiB        1140           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.1 MiB      0.0 MiB        1140           if current == end:
    60    109.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.1 MiB      0.0 MiB       10251           for neighbor in current.neighbors:
    65    109.1 MiB      0.0 MiB        9112               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.1 MiB      0.0 MiB        4556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.1 MiB      0.0 MiB        4556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.1 MiB      0.0 MiB        9112               if temp_g_score < g_score[neighbor]:
    71    109.1 MiB      0.0 MiB        1334                   came_from[neighbor] = current
    72    109.1 MiB      0.0 MiB        1334                   g_score[neighbor] = temp_g_score
    73    109.1 MiB      0.0 MiB        1334                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.1 MiB      0.0 MiB        1334                   if neighbor not in open_set_hash:
    75    109.1 MiB      0.0 MiB        1334                       count += 1
    76    109.1 MiB      0.0 MiB        1334                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.1 MiB      0.0 MiB        1334                       open_set_hash.add(neighbor)
    78                                                             
    79    109.1 MiB      0.0 MiB        1139           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.1 MiB      0.0 MiB        1139           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.1 MiB    109.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.1 MiB   -154.9 MiB         257       for row in grid:
    30    109.1 MiB -39747.3 MiB       65792           for spot in row:
    31    109.1 MiB -39593.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.9 MiB     -1.2 MiB           1       count = 0
    34    107.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.9 MiB      0.0 MiB           1       came_from = {}
    37    108.6 MiB -79470.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.9 MiB     -1.7 MiB           1       g_score[start] = 0
    39    108.0 MiB -208121.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     91.0 MiB    -17.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     91.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     91.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     91.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     91.3 MiB     -8.1 MiB        2001       while not open_set.empty():
    47     91.3 MiB     -8.1 MiB        2001           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     91.3 MiB     -8.2 MiB        2001           current = open_set.get()[2]
    53     91.3 MiB     -8.2 MiB        2001           open_set_hash.remove(current)
    54                                         
    55     91.3 MiB     -8.2 MiB        2001           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     91.3 MiB     -8.2 MiB        2001           if current == end:
    60     91.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     91.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     91.3 MiB    -73.2 MiB       18000           for neighbor in current.neighbors:
    65     91.3 MiB    -64.9 MiB       16000               if current.row != neighbor.row and current.col != neighbor.col:
    66     91.3 MiB    -32.5 MiB        8000                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     91.3 MiB    -32.6 MiB        8000                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     91.3 MiB    -65.1 MiB       16000               if temp_g_score < g_score[neighbor]:
    71     91.3 MiB     -9.2 MiB        2333                   came_from[neighbor] = current
    72     91.3 MiB     -9.2 MiB        2333                   g_score[neighbor] = temp_g_score
    73     91.3 MiB     -9.2 MiB        2333                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     91.3 MiB     -9.2 MiB        2333                   if neighbor not in open_set_hash:
    75     91.3 MiB     -9.2 MiB        2333                       count += 1
    76     91.3 MiB     -9.2 MiB        2333                       open_set.put((f_score[neighbor], count, neighbor))
    77     91.3 MiB     -9.2 MiB        2333                       open_set_hash.add(neighbor)
    78                                                             
    79     91.3 MiB     -8.1 MiB        2000           if draw is not None:
    80                                                     draw()
    81                                         
    82     91.3 MiB     -8.1 MiB        2000           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.5 MiB     91.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.7 MiB      0.0 MiB         257       for row in grid:
    30     92.7 MiB      0.0 MiB       65792           for spot in row:
    31     92.7 MiB      1.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.7 MiB      0.0 MiB           1       count = 0
    34     92.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.7 MiB      0.0 MiB           1       came_from = {}
    37     96.0 MiB   -519.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.0 MiB     -0.0 MiB           1       g_score[start] = 0
    39     98.4 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.4 MiB      0.0 MiB         215       while not open_set.empty():
    47     98.4 MiB      0.0 MiB         215           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.4 MiB      0.0 MiB         215           current = open_set.get()[2]
    53     98.4 MiB      0.0 MiB         215           open_set_hash.remove(current)
    54                                         
    55     98.4 MiB      0.0 MiB         215           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.4 MiB      0.0 MiB         215           if current == end:
    60     98.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.4 MiB      0.0 MiB        1926           for neighbor in current.neighbors:
    65     98.4 MiB      0.0 MiB        1712               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.4 MiB      0.0 MiB         856                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.4 MiB      0.0 MiB         856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.4 MiB      0.0 MiB        1712               if temp_g_score < g_score[neighbor]:
    71     98.4 MiB      0.0 MiB         395                   came_from[neighbor] = current
    72     98.4 MiB      0.0 MiB         395                   g_score[neighbor] = temp_g_score
    73     98.4 MiB      0.0 MiB         395                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.4 MiB      0.0 MiB         395                   if neighbor not in open_set_hash:
    75     98.4 MiB      0.0 MiB         395                       count += 1
    76     98.4 MiB      0.0 MiB         395                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.4 MiB      0.0 MiB         395                       open_set_hash.add(neighbor)
    78                                                             
    79     98.4 MiB      0.0 MiB         214           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.4 MiB      0.0 MiB         214           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.4 MiB     98.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.4 MiB      0.0 MiB         257       for row in grid:
    30     98.4 MiB      0.0 MiB       65792           for spot in row:
    31     98.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.4 MiB      0.0 MiB           1       count = 0
    34     98.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.4 MiB      0.0 MiB           1       came_from = {}
    37     99.0 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.3 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.5 MiB      0.0 MiB        4633       while not open_set.empty():
    47    101.5 MiB      0.0 MiB        4633           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.5 MiB      0.0 MiB        4633           current = open_set.get()[2]
    53    101.5 MiB      0.0 MiB        4633           open_set_hash.remove(current)
    54                                         
    55    101.5 MiB      0.0 MiB        4633           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.5 MiB      0.0 MiB        4633           if current == end:
    60    101.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.5 MiB      0.0 MiB       41688           for neighbor in current.neighbors:
    65    101.5 MiB      0.0 MiB       37056               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.5 MiB      0.0 MiB       18528                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.5 MiB      0.0 MiB       18528                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.5 MiB      0.0 MiB       37056               if temp_g_score < g_score[neighbor]:
    71    101.5 MiB      0.2 MiB        5021                   came_from[neighbor] = current
    72    101.5 MiB      0.0 MiB        5021                   g_score[neighbor] = temp_g_score
    73    101.5 MiB      0.0 MiB        5021                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.5 MiB      0.0 MiB        5021                   if neighbor not in open_set_hash:
    75    101.5 MiB      0.0 MiB        5021                       count += 1
    76    101.5 MiB      0.0 MiB        5021                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.5 MiB      0.0 MiB        5021                       open_set_hash.add(neighbor)
    78                                                             
    79    101.5 MiB      0.0 MiB        4632           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.5 MiB      0.0 MiB        4632           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.5 MiB    101.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.5 MiB    -88.6 MiB         257       for row in grid:
    30    101.5 MiB -22608.0 MiB       65792           for spot in row:
    31    101.5 MiB -22519.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.8 MiB     -0.7 MiB           1       count = 0
    34    100.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.8 MiB      0.0 MiB           1       came_from = {}
    37    101.6 MiB      0.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.9 MiB -12789.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.0 MiB      0.0 MiB        1170       while not open_set.empty():
    47    104.0 MiB      0.0 MiB        1170           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.0 MiB      0.0 MiB        1170           current = open_set.get()[2]
    53    104.0 MiB      0.0 MiB        1170           open_set_hash.remove(current)
    54                                         
    55    104.0 MiB      0.0 MiB        1170           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.0 MiB      0.0 MiB        1170           if current == end:
    60    104.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.0 MiB      0.0 MiB       10521           for neighbor in current.neighbors:
    65    104.0 MiB      0.0 MiB        9352               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.0 MiB      0.0 MiB        4676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.0 MiB      0.0 MiB        4676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.0 MiB      0.0 MiB        9352               if temp_g_score < g_score[neighbor]:
    71    104.0 MiB      0.1 MiB        1442                   came_from[neighbor] = current
    72    104.0 MiB      0.0 MiB        1442                   g_score[neighbor] = temp_g_score
    73    104.0 MiB      0.0 MiB        1442                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.0 MiB      0.0 MiB        1442                   if neighbor not in open_set_hash:
    75    104.0 MiB      0.0 MiB        1442                       count += 1
    76    104.0 MiB      0.0 MiB        1442                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.0 MiB      0.0 MiB        1442                       open_set_hash.add(neighbor)
    78                                                             
    79    104.0 MiB      0.0 MiB        1169           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.0 MiB      0.0 MiB        1169           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.0 MiB    104.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.0 MiB      0.0 MiB         257       for row in grid:
    30    104.0 MiB      0.0 MiB       65792           for spot in row:
    31    104.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.0 MiB      0.0 MiB           1       count = 0
    34    104.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.0 MiB      0.0 MiB           1       came_from = {}
    37    104.3 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.8 MiB  -1056.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.7 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.7 MiB      0.0 MiB        1526       while not open_set.empty():
    47    104.7 MiB      0.0 MiB        1526           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.7 MiB      0.0 MiB        1526           current = open_set.get()[2]
    53    104.7 MiB      0.0 MiB        1526           open_set_hash.remove(current)
    54                                         
    55    104.7 MiB      0.0 MiB        1526           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.7 MiB      0.0 MiB        1526           if current == end:
    60    104.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.7 MiB      0.0 MiB       13725           for neighbor in current.neighbors:
    65    104.7 MiB      0.0 MiB       12200               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.7 MiB      0.0 MiB        6100                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.7 MiB      0.0 MiB        6100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.7 MiB      0.0 MiB       12200               if temp_g_score < g_score[neighbor]:
    71    104.7 MiB      0.0 MiB        1798                   came_from[neighbor] = current
    72    104.7 MiB      0.0 MiB        1798                   g_score[neighbor] = temp_g_score
    73    104.7 MiB      0.0 MiB        1798                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.7 MiB      0.0 MiB        1798                   if neighbor not in open_set_hash:
    75    104.7 MiB      0.0 MiB        1798                       count += 1
    76    104.7 MiB      0.0 MiB        1798                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.7 MiB      0.0 MiB        1798                       open_set_hash.add(neighbor)
    78                                                             
    79    104.7 MiB      0.0 MiB        1525           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.7 MiB      0.0 MiB        1525           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.6 MiB    106.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.6 MiB  -7711.0 MiB         257       for row in grid:
    30    106.6 MiB -1976290.9 MiB       65792           for spot in row:
    31    106.6 MiB -1968614.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     48.3 MiB    -58.2 MiB           1       count = 0
    34     48.6 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     48.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     48.8 MiB      0.0 MiB           1       came_from = {}
    37     53.7 MiB -24049.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     52.9 MiB     -0.8 MiB           1       g_score[start] = 0
    39     57.3 MiB     -0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     57.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     57.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     57.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     57.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     92.4 MiB     -9.7 MiB        1712       while not open_set.empty():
    47     92.4 MiB     -9.7 MiB        1712           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     92.4 MiB     -9.7 MiB        1712           current = open_set.get()[2]
    53     92.4 MiB     -9.7 MiB        1712           open_set_hash.remove(current)
    54                                         
    55     92.4 MiB     -9.7 MiB        1712           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     92.4 MiB     -9.7 MiB        1712           if current == end:
    60     92.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     92.4 MiB    -87.5 MiB       15399           for neighbor in current.neighbors:
    65     92.4 MiB    -77.7 MiB       13688               if current.row != neighbor.row and current.col != neighbor.col:
    66     92.4 MiB    -38.9 MiB        6844                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     92.4 MiB    -38.9 MiB        6844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     92.4 MiB    -77.9 MiB       13688               if temp_g_score < g_score[neighbor]:
    71     92.4 MiB    -12.1 MiB        2170                   came_from[neighbor] = current
    72     92.4 MiB    -12.2 MiB        2170                   g_score[neighbor] = temp_g_score
    73     92.4 MiB    -12.2 MiB        2170                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     92.4 MiB    -12.2 MiB        2170                   if neighbor not in open_set_hash:
    75     92.4 MiB    -12.2 MiB        2170                       count += 1
    76     92.4 MiB     22.5 MiB        2170                       open_set.put((f_score[neighbor], count, neighbor))
    77     92.4 MiB    -12.1 MiB        2170                       open_set_hash.add(neighbor)
    78                                                             
    79     92.4 MiB     -9.7 MiB        1711           if draw is not None:
    80                                                     draw()
    81                                         
    82     92.4 MiB     -9.7 MiB        1711           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.4 MiB     92.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.4 MiB      0.0 MiB         257       for row in grid:
    30     92.4 MiB      0.0 MiB       65792           for spot in row:
    31     92.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.4 MiB      0.0 MiB           1       count = 0
    34     92.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.4 MiB      0.0 MiB           1       came_from = {}
    37     95.7 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.6 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.6 MiB -12524.6 MiB        8602       while not open_set.empty():
    47     98.6 MiB -12524.7 MiB        8602           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.6 MiB -12525.0 MiB        8602           current = open_set.get()[2]
    53     98.6 MiB -12525.2 MiB        8602           open_set_hash.remove(current)
    54                                         
    55     98.6 MiB -12525.4 MiB        8602           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.6 MiB -12525.5 MiB        8602           if current == end:
    60     95.4 MiB     -3.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.6 MiB -112706.7 MiB       77409           for neighbor in current.neighbors:
    65     98.6 MiB -100182.9 MiB       68808               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.6 MiB -50092.3 MiB       34404                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.6 MiB -50090.8 MiB       34404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.6 MiB -100183.4 MiB       68808               if temp_g_score < g_score[neighbor]:
    71     98.6 MiB -13202.1 MiB        9158                   came_from[neighbor] = current
    72     98.6 MiB -13202.2 MiB        9158                   g_score[neighbor] = temp_g_score
    73     98.6 MiB -13202.2 MiB        9158                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.6 MiB -13202.2 MiB        9158                   if neighbor not in open_set_hash:
    75     98.6 MiB -13202.6 MiB        9158                       count += 1
    76     98.6 MiB -13202.7 MiB        9158                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.6 MiB -13202.8 MiB        9158                       open_set_hash.add(neighbor)
    78                                                             
    79     98.6 MiB -12524.3 MiB        8601           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.6 MiB -12524.5 MiB        8601           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.4 MiB     95.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.4 MiB      0.0 MiB         257       for row in grid:
    30     95.4 MiB      0.0 MiB       65792           for spot in row:
    31     95.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.4 MiB      0.0 MiB           1       count = 0
    34     95.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.4 MiB      0.0 MiB           1       came_from = {}
    37     99.1 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.5 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.6 MiB      0.0 MiB        1296       while not open_set.empty():
    47    101.6 MiB      0.0 MiB        1296           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.6 MiB      0.0 MiB        1296           current = open_set.get()[2]
    53    101.6 MiB      0.0 MiB        1296           open_set_hash.remove(current)
    54                                         
    55    101.6 MiB      0.0 MiB        1296           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.6 MiB      0.0 MiB        1296           if current == end:
    60    101.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.6 MiB      0.0 MiB       11655           for neighbor in current.neighbors:
    65    101.6 MiB      0.0 MiB       10360               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.6 MiB      0.0 MiB        5180                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.6 MiB      0.0 MiB        5180                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.6 MiB      0.0 MiB       10360               if temp_g_score < g_score[neighbor]:
    71    101.6 MiB      0.0 MiB        1558                   came_from[neighbor] = current
    72    101.6 MiB      0.0 MiB        1558                   g_score[neighbor] = temp_g_score
    73    101.6 MiB      0.0 MiB        1558                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.6 MiB      0.0 MiB        1558                   if neighbor not in open_set_hash:
    75    101.6 MiB      0.0 MiB        1558                       count += 1
    76    101.6 MiB      0.0 MiB        1558                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.6 MiB      0.0 MiB        1558                       open_set_hash.add(neighbor)
    78                                                             
    79    101.6 MiB      0.0 MiB        1295           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.6 MiB      0.0 MiB        1295           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.6 MiB    101.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.6 MiB  -1244.3 MiB         257       for row in grid:
    30    101.6 MiB -319201.5 MiB       65792           for spot in row:
    31    101.6 MiB -317961.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.0 MiB     -5.6 MiB           1       count = 0
    34     96.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.0 MiB      0.0 MiB           1       came_from = {}
    37     96.0 MiB -90211.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.2 MiB     -0.8 MiB           1       g_score[start] = 0
    39     99.3 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.3 MiB -34052.2 MiB       12649       while not open_set.empty():
    47     99.3 MiB -34052.7 MiB       12649           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.3 MiB -34053.0 MiB       12649           current = open_set.get()[2]
    53     99.3 MiB -34053.4 MiB       12649           open_set_hash.remove(current)
    54                                         
    55     99.3 MiB -34053.7 MiB       12649           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.3 MiB -34053.7 MiB       12649           if current == end:
    60     92.6 MiB     -6.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.3 MiB -306436.3 MiB      113832           for neighbor in current.neighbors:
    65     99.3 MiB -272385.6 MiB      101184               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.3 MiB -136196.6 MiB       50592                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.3 MiB -136189.8 MiB       50592                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.3 MiB -272387.0 MiB      101184               if temp_g_score < g_score[neighbor]:
    71     99.3 MiB -35389.5 MiB       13289                   came_from[neighbor] = current
    72     99.3 MiB -35389.7 MiB       13289                   g_score[neighbor] = temp_g_score
    73     99.3 MiB -35389.9 MiB       13289                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.3 MiB -35390.2 MiB       13289                   if neighbor not in open_set_hash:
    75     99.3 MiB -35390.4 MiB       13289                       count += 1
    76     99.3 MiB -35390.9 MiB       13289                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.3 MiB -35391.4 MiB       13289                       open_set_hash.add(neighbor)
    78                                                             
    79     99.3 MiB -34051.9 MiB       12648           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.3 MiB -34052.0 MiB       12648           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.6 MiB     92.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.3 MiB    -82.5 MiB         257       for row in grid:
    30     93.3 MiB -20955.0 MiB       65792           for spot in row:
    31     93.3 MiB -20872.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.8 MiB     -1.4 MiB           1       count = 0
    34     91.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.9 MiB      0.0 MiB           1       came_from = {}
    37     94.6 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.2 MiB   -543.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.6 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.6 MiB      0.0 MiB        2553       while not open_set.empty():
    47     96.6 MiB      0.0 MiB        2553           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.6 MiB      0.0 MiB        2553           current = open_set.get()[2]
    53     96.6 MiB      0.0 MiB        2553           open_set_hash.remove(current)
    54                                         
    55     96.6 MiB      0.0 MiB        2553           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.6 MiB      0.0 MiB        2553           if current == end:
    60     96.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.6 MiB      0.0 MiB       22968           for neighbor in current.neighbors:
    65     96.6 MiB      0.0 MiB       20416               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.6 MiB      0.0 MiB       10208                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.6 MiB      0.0 MiB       10208                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.6 MiB      0.0 MiB       20416               if temp_g_score < g_score[neighbor]:
    71     96.6 MiB      0.0 MiB        3041                   came_from[neighbor] = current
    72     96.6 MiB      0.0 MiB        3041                   g_score[neighbor] = temp_g_score
    73     96.6 MiB      0.0 MiB        3041                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.6 MiB      0.0 MiB        3041                   if neighbor not in open_set_hash:
    75     96.6 MiB      0.0 MiB        3041                       count += 1
    76     96.6 MiB      0.0 MiB        3041                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.6 MiB      0.0 MiB        3041                       open_set_hash.add(neighbor)
    78                                                             
    79     96.6 MiB      0.0 MiB        2552           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.6 MiB      0.0 MiB        2552           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.6 MiB     96.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.6 MiB   -455.8 MiB         257       for row in grid:
    30     96.6 MiB -116873.6 MiB       65792           for spot in row:
    31     96.6 MiB -116419.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.4 MiB     -2.2 MiB           1       count = 0
    34     94.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.4 MiB      0.0 MiB           1       came_from = {}
    37     95.2 MiB      0.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.5 MiB  -1732.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.7 MiB      0.0 MiB        3920       while not open_set.empty():
    47     96.7 MiB      0.0 MiB        3920           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.7 MiB      0.0 MiB        3920           current = open_set.get()[2]
    53     96.7 MiB      0.0 MiB        3920           open_set_hash.remove(current)
    54                                         
    55     96.7 MiB      0.0 MiB        3920           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.7 MiB      0.0 MiB        3920           if current == end:
    60     96.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     96.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.7 MiB      0.0 MiB       35271           for neighbor in current.neighbors:
    65     96.7 MiB      0.0 MiB       31352               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.7 MiB      0.0 MiB       15676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.7 MiB      0.0 MiB       15676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.7 MiB      0.0 MiB       31352               if temp_g_score < g_score[neighbor]:
    71     96.7 MiB      0.2 MiB        4310                   came_from[neighbor] = current
    72     96.7 MiB      0.0 MiB        4310                   g_score[neighbor] = temp_g_score
    73     96.7 MiB      0.0 MiB        4310                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.7 MiB      0.0 MiB        4310                   if neighbor not in open_set_hash:
    75     96.7 MiB      0.0 MiB        4310                       count += 1
    76     96.7 MiB      0.0 MiB        4310                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.7 MiB      0.0 MiB        4310                       open_set_hash.add(neighbor)
    78                                                             
    79     96.7 MiB      0.0 MiB        3919           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.7 MiB      0.0 MiB        3919           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.7 MiB     96.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.7 MiB    -54.3 MiB         257       for row in grid:
    30     96.7 MiB -13389.9 MiB       65792           for spot in row:
    31     96.7 MiB -13337.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.3 MiB     -2.3 MiB           1       count = 0
    34     94.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.3 MiB      0.0 MiB           1       came_from = {}
    37     98.8 MiB -11101.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.4 MiB     -4.5 MiB           1       g_score[start] = 0
    39     94.4 MiB -131535.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.1 MiB     -1.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.2 MiB  -2521.2 MiB        2240       while not open_set.empty():
    47     93.2 MiB  -2521.2 MiB        2240           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.2 MiB  -2521.2 MiB        2240           current = open_set.get()[2]
    53     93.2 MiB  -2521.3 MiB        2240           open_set_hash.remove(current)
    54                                         
    55     93.2 MiB  -2521.3 MiB        2240           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.2 MiB  -2521.4 MiB        2240           if current == end:
    60     92.0 MiB     -1.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.2 MiB -22686.6 MiB       20151           for neighbor in current.neighbors:
    65     93.2 MiB -20165.6 MiB       17912               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.2 MiB -10084.1 MiB        8956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.2 MiB -10081.8 MiB        8956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.2 MiB -20166.2 MiB       17912               if temp_g_score < g_score[neighbor]:
    71     93.2 MiB  -2893.4 MiB        2614                   came_from[neighbor] = current
    72     93.2 MiB  -2893.5 MiB        2614                   g_score[neighbor] = temp_g_score
    73     93.2 MiB  -2893.5 MiB        2614                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.2 MiB  -2893.5 MiB        2614                   if neighbor not in open_set_hash:
    75     93.2 MiB  -2893.6 MiB        2614                       count += 1
    76     93.2 MiB  -2893.6 MiB        2614                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.2 MiB  -2893.6 MiB        2614                       open_set_hash.add(neighbor)
    78                                                             
    79     93.2 MiB  -2521.1 MiB        2239           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.2 MiB  -2521.1 MiB        2239           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.5 MiB     94.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.7 MiB     -0.3 MiB         257       for row in grid:
    30     95.7 MiB    -77.6 MiB       65792           for spot in row:
    31     95.7 MiB    -76.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.7 MiB      0.0 MiB           1       count = 0
    34     95.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.7 MiB      0.0 MiB           1       came_from = {}
    37     97.4 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.7 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.7 MiB   -102.3 MiB         430       while not open_set.empty():
    47     99.7 MiB   -102.3 MiB         430           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.7 MiB   -102.3 MiB         430           current = open_set.get()[2]
    53     99.7 MiB   -102.3 MiB         430           open_set_hash.remove(current)
    54                                         
    55     99.7 MiB   -102.3 MiB         430           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.7 MiB   -102.3 MiB         430           if current == end:
    60     99.4 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.7 MiB   -919.5 MiB        3861           for neighbor in current.neighbors:
    65     99.7 MiB   -817.2 MiB        3432               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.7 MiB   -409.0 MiB        1716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.7 MiB   -408.3 MiB        1716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.7 MiB   -817.4 MiB        3432               if temp_g_score < g_score[neighbor]:
    71     99.7 MiB   -143.7 MiB         620                   came_from[neighbor] = current
    72     99.7 MiB   -143.7 MiB         620                   g_score[neighbor] = temp_g_score
    73     99.7 MiB   -143.7 MiB         620                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.7 MiB   -143.7 MiB         620                   if neighbor not in open_set_hash:
    75     99.7 MiB   -143.7 MiB         620                       count += 1
    76     99.7 MiB   -143.7 MiB         620                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.7 MiB   -143.7 MiB         620                       open_set_hash.add(neighbor)
    78                                                             
    79     99.7 MiB   -102.3 MiB         429           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.7 MiB   -102.3 MiB         429           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.4 MiB     99.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.4 MiB   -271.5 MiB         257       for row in grid:
    30     99.4 MiB -68822.5 MiB       65792           for spot in row:
    31     99.4 MiB -68555.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.2 MiB     -6.2 MiB           1       count = 0
    34     93.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.2 MiB      0.0 MiB           1       came_from = {}
    37     94.0 MiB      0.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.4 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.4 MiB   -712.5 MiB        3584       while not open_set.empty():
    47     97.4 MiB   -712.5 MiB        3584           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.4 MiB   -712.5 MiB        3584           current = open_set.get()[2]
    53     97.4 MiB   -712.5 MiB        3584           open_set_hash.remove(current)
    54                                         
    55     97.4 MiB   -712.5 MiB        3584           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.4 MiB   -712.5 MiB        3584           if current == end:
    60     97.2 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.4 MiB  -6411.0 MiB       32247           for neighbor in current.neighbors:
    65     97.4 MiB  -5698.7 MiB       28664               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.4 MiB  -2849.4 MiB       14332                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.4 MiB  -2849.3 MiB       14332                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.4 MiB  -5698.7 MiB       28664               if temp_g_score < g_score[neighbor]:
    71     97.4 MiB   -768.5 MiB        3950                   came_from[neighbor] = current
    72     97.4 MiB   -768.6 MiB        3950                   g_score[neighbor] = temp_g_score
    73     97.4 MiB   -768.6 MiB        3950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.4 MiB   -768.6 MiB        3950                   if neighbor not in open_set_hash:
    75     97.4 MiB   -768.6 MiB        3950                       count += 1
    76     97.4 MiB   -768.6 MiB        3950                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.4 MiB   -768.6 MiB        3950                       open_set_hash.add(neighbor)
    78                                                             
    79     97.4 MiB   -712.3 MiB        3583           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.4 MiB   -712.3 MiB        3583           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.2 MiB     97.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.2 MiB      0.0 MiB         257       for row in grid:
    30     97.2 MiB      0.0 MiB       65792           for spot in row:
    31     97.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.2 MiB      0.0 MiB           1       count = 0
    34     97.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.2 MiB      0.0 MiB           1       came_from = {}
    37     97.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.1 MiB -61257.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.1 MiB      0.0 MiB        5440       while not open_set.empty():
    47     98.1 MiB      0.0 MiB        5440           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.1 MiB      0.0 MiB        5440           current = open_set.get()[2]
    53     98.1 MiB      0.0 MiB        5440           open_set_hash.remove(current)
    54                                         
    55     98.1 MiB      0.0 MiB        5440           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.1 MiB      0.0 MiB        5440           if current == end:
    60     98.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.1 MiB      0.0 MiB       48951           for neighbor in current.neighbors:
    65     98.1 MiB      0.0 MiB       43512               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.1 MiB      0.0 MiB       21756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.1 MiB      0.0 MiB       21756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.1 MiB      0.0 MiB       43512               if temp_g_score < g_score[neighbor]:
    71     98.1 MiB      0.0 MiB        5870                   came_from[neighbor] = current
    72     98.1 MiB      0.0 MiB        5870                   g_score[neighbor] = temp_g_score
    73     98.1 MiB      0.0 MiB        5870                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.1 MiB      0.0 MiB        5870                   if neighbor not in open_set_hash:
    75     98.1 MiB      0.0 MiB        5870                       count += 1
    76     98.1 MiB      0.0 MiB        5870                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.1 MiB      0.0 MiB        5870                       open_set_hash.add(neighbor)
    78                                                             
    79     98.1 MiB      0.0 MiB        5439           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.1 MiB      0.0 MiB        5439           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.1 MiB     98.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.1 MiB     -0.4 MiB         257       for row in grid:
    30     98.1 MiB    -97.2 MiB       65792           for spot in row:
    31     98.1 MiB    -96.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.1 MiB     -0.0 MiB           1       count = 0
    34     98.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.1 MiB      0.0 MiB           1       came_from = {}
    37     99.3 MiB      1.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.2 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.3 MiB  -5255.0 MiB        3397       while not open_set.empty():
    47    102.3 MiB  -5255.0 MiB        3397           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.3 MiB  -5255.0 MiB        3397           current = open_set.get()[2]
    53    102.3 MiB  -5255.0 MiB        3397           open_set_hash.remove(current)
    54                                         
    55    102.3 MiB  -5255.0 MiB        3397           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.3 MiB  -5255.0 MiB        3397           if current == end:
    60    100.3 MiB     -2.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.3 MiB -47281.1 MiB       30564           for neighbor in current.neighbors:
    65    102.3 MiB -42026.7 MiB       27168               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.3 MiB -21014.5 MiB       13584                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.3 MiB -21012.4 MiB       13584                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.3 MiB -42027.0 MiB       27168               if temp_g_score < g_score[neighbor]:
    71    102.3 MiB  -5743.5 MiB        3797                   came_from[neighbor] = current
    72    102.3 MiB  -5743.5 MiB        3797                   g_score[neighbor] = temp_g_score
    73    102.3 MiB  -5743.5 MiB        3797                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.3 MiB  -5743.7 MiB        3797                   if neighbor not in open_set_hash:
    75    102.3 MiB  -5744.0 MiB        3797                       count += 1
    76    102.3 MiB  -5744.0 MiB        3797                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.3 MiB  -5744.1 MiB        3797                       open_set_hash.add(neighbor)
    78                                                             
    79    102.3 MiB  -5254.8 MiB        3396           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.3 MiB  -5254.9 MiB        3396           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.3 MiB    -25.1 MiB         257       for row in grid:
    30    100.3 MiB  -6433.8 MiB       65792           for spot in row:
    31    100.3 MiB  -6408.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.1 MiB     -0.1 MiB           1       count = 0
    34    100.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.1 MiB      0.0 MiB           1       came_from = {}
    37    100.1 MiB -68283.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.3 MiB     -0.8 MiB           1       g_score[start] = 0
    39     99.8 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.9 MiB      0.0 MiB        2730       while not open_set.empty():
    47     99.9 MiB      0.0 MiB        2730           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.9 MiB      0.0 MiB        2730           current = open_set.get()[2]
    53     99.9 MiB      0.0 MiB        2730           open_set_hash.remove(current)
    54                                         
    55     99.9 MiB      0.0 MiB        2730           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.9 MiB      0.0 MiB        2730           if current == end:
    60     99.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.9 MiB      0.0 MiB       24561           for neighbor in current.neighbors:
    65     99.9 MiB      0.0 MiB       21832               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.9 MiB      0.0 MiB       10916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.9 MiB      0.0 MiB       10916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.9 MiB      0.0 MiB       21832               if temp_g_score < g_score[neighbor]:
    71     99.9 MiB      0.0 MiB        3072                   came_from[neighbor] = current
    72     99.9 MiB      0.0 MiB        3072                   g_score[neighbor] = temp_g_score
    73     99.9 MiB      0.0 MiB        3072                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.9 MiB      0.0 MiB        3072                   if neighbor not in open_set_hash:
    75     99.9 MiB      0.0 MiB        3072                       count += 1
    76     99.9 MiB      0.0 MiB        3072                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.9 MiB      0.0 MiB        3072                       open_set_hash.add(neighbor)
    78                                                             
    79     99.9 MiB      0.0 MiB        2729           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.9 MiB      0.0 MiB        2729           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.9 MiB     99.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.9 MiB      0.0 MiB         257       for row in grid:
    30     99.9 MiB      0.0 MiB       65792           for spot in row:
    31     99.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.9 MiB      0.0 MiB           1       count = 0
    34     99.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.9 MiB      0.0 MiB           1       came_from = {}
    37    102.5 MiB      2.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.6 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.6 MiB      0.0 MiB        2541       while not open_set.empty():
    47    105.6 MiB      0.0 MiB        2541           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.6 MiB      0.0 MiB        2541           current = open_set.get()[2]
    53    105.6 MiB      0.0 MiB        2541           open_set_hash.remove(current)
    54                                         
    55    105.6 MiB      0.0 MiB        2541           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.6 MiB      0.0 MiB        2541           if current == end:
    60    105.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.6 MiB      0.0 MiB       22860           for neighbor in current.neighbors:
    65    105.6 MiB      0.0 MiB       20320               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.6 MiB      0.0 MiB       10160                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.6 MiB      0.0 MiB       10160                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.6 MiB      0.0 MiB       20320               if temp_g_score < g_score[neighbor]:
    71    105.6 MiB      0.0 MiB        2913                   came_from[neighbor] = current
    72    105.6 MiB      0.0 MiB        2913                   g_score[neighbor] = temp_g_score
    73    105.6 MiB      0.0 MiB        2913                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.6 MiB      0.0 MiB        2913                   if neighbor not in open_set_hash:
    75    105.6 MiB      0.0 MiB        2913                       count += 1
    76    105.6 MiB      0.0 MiB        2913                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.6 MiB      0.0 MiB        2913                       open_set_hash.add(neighbor)
    78                                                             
    79    105.6 MiB      0.0 MiB        2540           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.6 MiB      0.0 MiB        2540           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.6 MiB    105.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.6 MiB   -573.8 MiB         257       for row in grid:
    30    105.6 MiB -147155.4 MiB       65792           for spot in row:
    31    105.6 MiB -146583.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.5 MiB     -3.2 MiB           1       count = 0
    34    102.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.5 MiB      0.0 MiB           1       came_from = {}
    37    102.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.5 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.5 MiB      0.0 MiB        2540       while not open_set.empty():
    47    105.5 MiB      0.0 MiB        2540           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.5 MiB      0.0 MiB        2540           current = open_set.get()[2]
    53    105.5 MiB      0.0 MiB        2540           open_set_hash.remove(current)
    54                                         
    55    105.5 MiB      0.0 MiB        2540           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.5 MiB      0.0 MiB        2540           if current == end:
    60    105.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.5 MiB      0.0 MiB       22851           for neighbor in current.neighbors:
    65    105.5 MiB      0.0 MiB       20312               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.5 MiB      0.0 MiB       10156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.5 MiB      0.0 MiB       10156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.5 MiB      0.0 MiB       20312               if temp_g_score < g_score[neighbor]:
    71    105.5 MiB      0.0 MiB        2872                   came_from[neighbor] = current
    72    105.5 MiB      0.0 MiB        2872                   g_score[neighbor] = temp_g_score
    73    105.5 MiB      0.0 MiB        2872                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.5 MiB      0.0 MiB        2872                   if neighbor not in open_set_hash:
    75    105.5 MiB      0.0 MiB        2872                       count += 1
    76    105.5 MiB      0.0 MiB        2872                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.5 MiB      0.0 MiB        2872                       open_set_hash.add(neighbor)
    78                                                             
    79    105.5 MiB      0.0 MiB        2539           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.5 MiB      0.0 MiB        2539           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.3 MiB    112.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.3 MiB    -14.5 MiB         257       for row in grid:
    30    112.3 MiB  -3719.0 MiB       65792           for spot in row:
    31    112.3 MiB  -3704.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.3 MiB     -0.1 MiB           1       count = 0
    34    112.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.3 MiB      0.0 MiB           1       came_from = {}
    37    112.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.3 MiB -58229.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.3 MiB     -4.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.3 MiB      0.0 MiB        1386       while not open_set.empty():
    47    108.3 MiB      0.0 MiB        1386           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.3 MiB      0.0 MiB        1386           current = open_set.get()[2]
    53    108.3 MiB      0.0 MiB        1386           open_set_hash.remove(current)
    54                                         
    55    108.3 MiB      0.0 MiB        1386           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.3 MiB      0.0 MiB        1386           if current == end:
    60    108.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.3 MiB      0.0 MiB       12465           for neighbor in current.neighbors:
    65    108.3 MiB      0.0 MiB       11080               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.3 MiB      0.0 MiB        5540                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.3 MiB      0.0 MiB        5540                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.3 MiB      0.0 MiB       11080               if temp_g_score < g_score[neighbor]:
    71    108.3 MiB      0.0 MiB        1680                   came_from[neighbor] = current
    72    108.3 MiB      0.0 MiB        1680                   g_score[neighbor] = temp_g_score
    73    108.3 MiB      0.0 MiB        1680                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.3 MiB      0.0 MiB        1680                   if neighbor not in open_set_hash:
    75    108.3 MiB      0.0 MiB        1680                       count += 1
    76    108.3 MiB      0.0 MiB        1680                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.3 MiB      0.0 MiB        1680                       open_set_hash.add(neighbor)
    78                                                             
    79    108.3 MiB      0.0 MiB        1385           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.3 MiB      0.0 MiB        1385           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.3 MiB    108.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.3 MiB     -3.2 MiB         257       for row in grid:
    30    108.3 MiB   -818.7 MiB       65792           for spot in row:
    31    108.3 MiB   -815.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.3 MiB     -0.1 MiB           1       count = 0
    34    108.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.3 MiB      0.0 MiB           1       came_from = {}
    37    108.6 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.7 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.7 MiB      0.0 MiB         648       while not open_set.empty():
    47    108.7 MiB      0.0 MiB         648           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.7 MiB      0.0 MiB         648           current = open_set.get()[2]
    53    108.7 MiB      0.0 MiB         648           open_set_hash.remove(current)
    54                                         
    55    108.7 MiB      0.0 MiB         648           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.7 MiB      0.0 MiB         648           if current == end:
    60    108.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.7 MiB      0.0 MiB        5823           for neighbor in current.neighbors:
    65    108.7 MiB      0.0 MiB        5176               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.7 MiB      0.0 MiB        2588                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.7 MiB      0.0 MiB        2588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.7 MiB      0.0 MiB        5176               if temp_g_score < g_score[neighbor]:
    71    108.7 MiB      0.0 MiB         986                   came_from[neighbor] = current
    72    108.7 MiB      0.0 MiB         986                   g_score[neighbor] = temp_g_score
    73    108.7 MiB      0.0 MiB         986                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.7 MiB      0.0 MiB         986                   if neighbor not in open_set_hash:
    75    108.7 MiB      0.0 MiB         986                       count += 1
    76    108.7 MiB      0.0 MiB         986                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.7 MiB      0.0 MiB         986                       open_set_hash.add(neighbor)
    78                                                             
    79    108.7 MiB      0.0 MiB         647           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.7 MiB      0.0 MiB         647           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.7 MiB    108.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.7 MiB      0.0 MiB         257       for row in grid:
    30    108.7 MiB      0.0 MiB       65792           for spot in row:
    31    108.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.7 MiB      0.0 MiB           1       count = 0
    34    108.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.7 MiB      0.0 MiB           1       came_from = {}
    37    111.7 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.5 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.6 MiB      0.0 MiB        8437       while not open_set.empty():
    47    113.6 MiB      0.0 MiB        8437           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.6 MiB      0.0 MiB        8437           current = open_set.get()[2]
    53    113.6 MiB      0.0 MiB        8437           open_set_hash.remove(current)
    54                                         
    55    113.6 MiB      0.0 MiB        8437           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.6 MiB      0.0 MiB        8437           if current == end:
    60    113.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.6 MiB      0.0 MiB       75924           for neighbor in current.neighbors:
    65    113.6 MiB      0.0 MiB       67488               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.6 MiB      0.0 MiB       33744                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.6 MiB      0.0 MiB       33744                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.6 MiB      0.0 MiB       67488               if temp_g_score < g_score[neighbor]:
    71    113.6 MiB      0.0 MiB        8957                   came_from[neighbor] = current
    72    113.6 MiB      0.0 MiB        8957                   g_score[neighbor] = temp_g_score
    73    113.6 MiB      0.0 MiB        8957                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.6 MiB      0.0 MiB        8957                   if neighbor not in open_set_hash:
    75    113.6 MiB      0.0 MiB        8957                       count += 1
    76    113.6 MiB      0.0 MiB        8957                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.6 MiB      0.0 MiB        8957                       open_set_hash.add(neighbor)
    78                                                             
    79    113.6 MiB      0.0 MiB        8436           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.6 MiB      0.0 MiB        8436           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    113.6 MiB    113.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    113.6 MiB     -6.4 MiB         257       for row in grid:
    30    113.6 MiB  -1438.2 MiB       65792           for spot in row:
    31    113.6 MiB  -1432.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.5 MiB     -1.1 MiB           1       count = 0
    34    112.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.5 MiB      0.0 MiB           1       came_from = {}
    37    112.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.1 MiB      1.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.2 MiB      0.0 MiB         931       while not open_set.empty():
    47    114.2 MiB      0.0 MiB         931           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.2 MiB      0.0 MiB         931           current = open_set.get()[2]
    53    114.2 MiB      0.0 MiB         931           open_set_hash.remove(current)
    54                                         
    55    114.2 MiB      0.0 MiB         931           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.2 MiB      0.0 MiB         931           if current == end:
    60    114.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.2 MiB      0.0 MiB        8370           for neighbor in current.neighbors:
    65    114.2 MiB      0.0 MiB        7440               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.2 MiB      0.0 MiB        3720                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.2 MiB      0.0 MiB        3720                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.2 MiB      0.0 MiB        7440               if temp_g_score < g_score[neighbor]:
    71    114.2 MiB      0.0 MiB        1103                   came_from[neighbor] = current
    72    114.2 MiB      0.0 MiB        1103                   g_score[neighbor] = temp_g_score
    73    114.2 MiB      0.0 MiB        1103                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.2 MiB      0.0 MiB        1103                   if neighbor not in open_set_hash:
    75    114.2 MiB      0.0 MiB        1103                       count += 1
    76    114.2 MiB      0.0 MiB        1103                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.2 MiB      0.0 MiB        1103                       open_set_hash.add(neighbor)
    78                                                             
    79    114.2 MiB      0.0 MiB         930           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.2 MiB      0.0 MiB         930           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.2 MiB    114.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.2 MiB  -1362.0 MiB         257       for row in grid:
    30    114.2 MiB -349191.9 MiB       65792           for spot in row:
    31    114.2 MiB -347834.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.2 MiB     -5.9 MiB           1       count = 0
    34    108.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.2 MiB      0.0 MiB           1       came_from = {}
    37    111.8 MiB      3.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.1 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.1 MiB  -6858.5 MiB        4485       while not open_set.empty():
    47    113.1 MiB  -6858.5 MiB        4485           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.1 MiB  -6858.5 MiB        4485           current = open_set.get()[2]
    53    113.1 MiB  -6858.5 MiB        4485           open_set_hash.remove(current)
    54                                         
    55    113.1 MiB  -6858.5 MiB        4485           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.1 MiB  -6858.5 MiB        4485           if current == end:
    60    111.5 MiB     -1.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.1 MiB -61718.3 MiB       40356           for neighbor in current.neighbors:
    65    113.1 MiB -54860.2 MiB       35872               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.1 MiB -27432.2 MiB       17936                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.1 MiB -27428.4 MiB       17936                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.1 MiB -54861.0 MiB       35872               if temp_g_score < g_score[neighbor]:
    71    113.1 MiB  -7388.6 MiB        4889                   came_from[neighbor] = current
    72    113.1 MiB  -7388.8 MiB        4889                   g_score[neighbor] = temp_g_score
    73    113.1 MiB  -7388.8 MiB        4889                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.1 MiB  -7388.8 MiB        4889                   if neighbor not in open_set_hash:
    75    113.1 MiB  -7388.8 MiB        4889                       count += 1
    76    113.1 MiB  -7388.8 MiB        4889                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.1 MiB  -7388.8 MiB        4889                       open_set_hash.add(neighbor)
    78                                                             
    79    113.1 MiB  -6858.5 MiB        4484           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.1 MiB  -6858.5 MiB        4484           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.5 MiB    111.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.5 MiB      0.0 MiB         257       for row in grid:
    30    111.5 MiB      0.0 MiB       65792           for spot in row:
    31    111.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.5 MiB      0.0 MiB           1       count = 0
    34    111.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.5 MiB      0.0 MiB           1       came_from = {}
    37    112.1 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    112.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.6 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.6 MiB      0.0 MiB        3268       while not open_set.empty():
    47    114.6 MiB      0.0 MiB        3268           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.6 MiB      0.0 MiB        3268           current = open_set.get()[2]
    53    114.6 MiB      0.0 MiB        3268           open_set_hash.remove(current)
    54                                         
    55    114.6 MiB      0.0 MiB        3268           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.6 MiB      0.0 MiB        3268           if current == end:
    60    114.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.6 MiB      0.0 MiB       29403           for neighbor in current.neighbors:
    65    114.6 MiB      0.0 MiB       26136               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.6 MiB      0.0 MiB       13068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.6 MiB      0.0 MiB       13068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.6 MiB      0.0 MiB       26136               if temp_g_score < g_score[neighbor]:
    71    114.6 MiB      0.0 MiB        3656                   came_from[neighbor] = current
    72    114.6 MiB      0.0 MiB        3656                   g_score[neighbor] = temp_g_score
    73    114.6 MiB      0.0 MiB        3656                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.6 MiB      0.0 MiB        3656                   if neighbor not in open_set_hash:
    75    114.6 MiB      0.0 MiB        3656                       count += 1
    76    114.6 MiB      0.0 MiB        3656                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.6 MiB      0.0 MiB        3656                       open_set_hash.add(neighbor)
    78                                                             
    79    114.6 MiB      0.0 MiB        3267           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.6 MiB      0.0 MiB        3267           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.6 MiB    114.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.6 MiB      0.0 MiB         257       for row in grid:
    30    114.6 MiB      0.0 MiB       65792           for spot in row:
    31    114.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.6 MiB      0.0 MiB           1       count = 0
    34    114.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.6 MiB      0.0 MiB           1       came_from = {}
    37    114.6 MiB -16277.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.4 MiB     -0.3 MiB           1       g_score[start] = 0
    39    114.8 MiB -114767.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.5 MiB    -15.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.9 MiB  -8451.1 MiB        1254       while not open_set.empty():
    47     99.9 MiB  -8451.8 MiB        1254           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.9 MiB  -8453.2 MiB        1254           current = open_set.get()[2]
    53     99.9 MiB  -8454.1 MiB        1254           open_set_hash.remove(current)
    54                                         
    55     99.9 MiB  -8454.8 MiB        1254           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.9 MiB  -8455.5 MiB        1254           if current == end:
    60     57.8 MiB    -42.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.9 MiB -75865.4 MiB       11277           for neighbor in current.neighbors:
    65     99.9 MiB -67422.8 MiB       10024               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.9 MiB -33747.0 MiB        5012                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.9 MiB -33682.3 MiB        5012                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.9 MiB -67436.0 MiB       10024               if temp_g_score < g_score[neighbor]:
    71     99.9 MiB  -9962.4 MiB        1460                   came_from[neighbor] = current
    72     99.9 MiB  -9963.2 MiB        1460                   g_score[neighbor] = temp_g_score
    73     99.9 MiB  -9964.8 MiB        1460                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.9 MiB  -9965.7 MiB        1460                   if neighbor not in open_set_hash:
    75     99.9 MiB  -9966.6 MiB        1460                       count += 1
    76     99.9 MiB  -9968.5 MiB        1460                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.9 MiB  -9969.4 MiB        1460                       open_set_hash.add(neighbor)
    78                                                             
    79     99.9 MiB  -8449.5 MiB        1253           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.9 MiB  -8450.3 MiB        1253           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.3 MiB    100.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.3 MiB   -179.7 MiB         257       for row in grid:
    30    100.3 MiB -45509.6 MiB       65792           for spot in row:
    31    100.3 MiB -45332.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.3 MiB     -4.1 MiB           1       count = 0
    34     96.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.3 MiB      0.0 MiB           1       came_from = {}
    37     96.3 MiB -387877.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.4 MiB     -4.9 MiB           1       g_score[start] = 0
    39     91.9 MiB -86312.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.6 MiB     -1.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     90.7 MiB  -2555.6 MiB        4756       while not open_set.empty():
    47     90.7 MiB  -2555.6 MiB        4756           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     90.7 MiB  -2555.7 MiB        4756           current = open_set.get()[2]
    53     90.7 MiB  -2555.7 MiB        4756           open_set_hash.remove(current)
    54                                         
    55     90.7 MiB  -2555.7 MiB        4756           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     90.7 MiB  -2555.7 MiB        4756           if current == end:
    60     89.9 MiB     -0.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     90.7 MiB -22995.4 MiB       42795           for neighbor in current.neighbors:
    65     90.7 MiB -20440.0 MiB       38040               if current.row != neighbor.row and current.col != neighbor.col:
    66     90.7 MiB -10220.9 MiB       19020                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     90.7 MiB -10219.1 MiB       19020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     90.7 MiB -20440.3 MiB       38040               if temp_g_score < g_score[neighbor]:
    71     90.7 MiB  -2756.6 MiB        5150                   came_from[neighbor] = current
    72     90.7 MiB  -2757.0 MiB        5150                   g_score[neighbor] = temp_g_score
    73     90.7 MiB  -2757.0 MiB        5150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     90.7 MiB  -2757.0 MiB        5150                   if neighbor not in open_set_hash:
    75     90.7 MiB  -2757.0 MiB        5150                       count += 1
    76     90.7 MiB  -2757.1 MiB        5150                       open_set.put((f_score[neighbor], count, neighbor))
    77     90.7 MiB  -2757.0 MiB        5150                       open_set_hash.add(neighbor)
    78                                                             
    79     90.7 MiB  -2555.5 MiB        4755           if draw is not None:
    80                                                     draw()
    81                                         
    82     90.7 MiB  -2555.6 MiB        4755           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.3 MiB     92.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.7 MiB      0.0 MiB         257       for row in grid:
    30     95.7 MiB      0.0 MiB       65792           for spot in row:
    31     95.7 MiB      3.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.7 MiB      0.0 MiB           1       count = 0
    34     95.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.7 MiB      0.0 MiB           1       came_from = {}
    37     97.9 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.1 MiB  -1879.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.8 MiB     -1.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.9 MiB      0.0 MiB        5244       while not open_set.empty():
    47     97.9 MiB      0.0 MiB        5244           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.9 MiB      0.0 MiB        5244           current = open_set.get()[2]
    53     97.9 MiB      0.0 MiB        5244           open_set_hash.remove(current)
    54                                         
    55     97.9 MiB      0.0 MiB        5244           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.9 MiB      0.0 MiB        5244           if current == end:
    60     97.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.9 MiB      0.0 MiB       47187           for neighbor in current.neighbors:
    65     97.9 MiB      0.0 MiB       41944               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.9 MiB      0.0 MiB       20972                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.9 MiB      0.0 MiB       20972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.9 MiB      0.0 MiB       41944               if temp_g_score < g_score[neighbor]:
    71     97.9 MiB      0.1 MiB        5654                   came_from[neighbor] = current
    72     97.9 MiB      0.0 MiB        5654                   g_score[neighbor] = temp_g_score
    73     97.9 MiB      0.0 MiB        5654                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.9 MiB      0.0 MiB        5654                   if neighbor not in open_set_hash:
    75     97.9 MiB      0.0 MiB        5654                       count += 1
    76     97.9 MiB      0.0 MiB        5654                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.9 MiB      0.0 MiB        5654                       open_set_hash.add(neighbor)
    78                                                             
    79     97.9 MiB      0.0 MiB        5243           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.9 MiB      0.0 MiB        5243           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.9 MiB     97.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.9 MiB   -118.2 MiB         257       for row in grid:
    30     97.9 MiB -30060.2 MiB       65792           for spot in row:
    31     97.9 MiB -29943.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.9 MiB     -2.0 MiB           1       count = 0
    34     95.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.9 MiB      0.0 MiB           1       came_from = {}
    37     96.4 MiB      0.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.9 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.9 MiB      0.0 MiB        1870       while not open_set.empty():
    47     98.9 MiB      0.0 MiB        1870           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.9 MiB      0.0 MiB        1870           current = open_set.get()[2]
    53     98.9 MiB      0.0 MiB        1870           open_set_hash.remove(current)
    54                                         
    55     98.9 MiB      0.0 MiB        1870           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.9 MiB      0.0 MiB        1870           if current == end:
    60     98.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.9 MiB      0.0 MiB       16821           for neighbor in current.neighbors:
    65     98.9 MiB      0.0 MiB       14952               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.9 MiB      0.0 MiB        7476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.9 MiB      0.0 MiB        7476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.9 MiB      0.0 MiB       14952               if temp_g_score < g_score[neighbor]:
    71     98.9 MiB      0.0 MiB        2252                   came_from[neighbor] = current
    72     98.9 MiB      0.0 MiB        2252                   g_score[neighbor] = temp_g_score
    73     98.9 MiB      0.0 MiB        2252                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.9 MiB      0.0 MiB        2252                   if neighbor not in open_set_hash:
    75     98.9 MiB      0.0 MiB        2252                       count += 1
    76     98.9 MiB      0.0 MiB        2252                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.9 MiB      0.0 MiB        2252                       open_set_hash.add(neighbor)
    78                                                             
    79     98.9 MiB      0.0 MiB        1869           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.9 MiB      0.0 MiB        1869           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.9 MiB     98.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.9 MiB   -372.8 MiB         257       for row in grid:
    30     98.9 MiB -95242.4 MiB       65792           for spot in row:
    31     98.9 MiB -94871.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.6 MiB     -3.3 MiB           1       count = 0
    34     95.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.6 MiB      0.0 MiB           1       came_from = {}
    37     96.3 MiB      0.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.4 MiB  -8624.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.4 MiB      0.0 MiB        1628       while not open_set.empty():
    47     98.4 MiB      0.0 MiB        1628           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.4 MiB      0.0 MiB        1628           current = open_set.get()[2]
    53     98.4 MiB      0.0 MiB        1628           open_set_hash.remove(current)
    54                                         
    55     98.4 MiB      0.0 MiB        1628           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.4 MiB      0.0 MiB        1628           if current == end:
    60     98.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.4 MiB      0.0 MiB       14643           for neighbor in current.neighbors:
    65     98.4 MiB      0.0 MiB       13016               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.4 MiB      0.0 MiB        6508                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.4 MiB      0.0 MiB        6508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.4 MiB      0.0 MiB       13016               if temp_g_score < g_score[neighbor]:
    71     98.4 MiB      0.0 MiB        1876                   came_from[neighbor] = current
    72     98.4 MiB      0.0 MiB        1876                   g_score[neighbor] = temp_g_score
    73     98.4 MiB      0.0 MiB        1876                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.4 MiB      0.0 MiB        1876                   if neighbor not in open_set_hash:
    75     98.4 MiB      0.0 MiB        1876                       count += 1
    76     98.4 MiB      0.0 MiB        1876                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.4 MiB      0.0 MiB        1876                       open_set_hash.add(neighbor)
    78                                                             
    79     98.4 MiB      0.0 MiB        1627           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.4 MiB      0.0 MiB        1627           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.4 MiB     98.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.4 MiB   -707.9 MiB         257       for row in grid:
    30     98.4 MiB -181564.9 MiB       65792           for spot in row:
    31     98.4 MiB -180861.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     92.7 MiB     -5.8 MiB           1       count = 0
    34     92.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     92.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     92.7 MiB      0.0 MiB           1       came_from = {}
    37     93.2 MiB -133115.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.4 MiB     -0.8 MiB           1       g_score[start] = 0
    39     95.8 MiB   -295.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     95.8 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     95.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     95.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     95.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.8 MiB      0.0 MiB        1829       while not open_set.empty():
    47     95.8 MiB      0.0 MiB        1829           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.8 MiB      0.0 MiB        1829           current = open_set.get()[2]
    53     95.8 MiB      0.0 MiB        1829           open_set_hash.remove(current)
    54                                         
    55     95.8 MiB      0.0 MiB        1829           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.8 MiB      0.0 MiB        1829           if current == end:
    60     95.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.8 MiB      0.0 MiB       16452           for neighbor in current.neighbors:
    65     95.8 MiB      0.0 MiB       14624               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.8 MiB      0.0 MiB        7312                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.8 MiB      0.0 MiB        7312                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.8 MiB      0.0 MiB       14624               if temp_g_score < g_score[neighbor]:
    71     95.8 MiB      0.0 MiB        2069                   came_from[neighbor] = current
    72     95.8 MiB      0.0 MiB        2069                   g_score[neighbor] = temp_g_score
    73     95.8 MiB      0.0 MiB        2069                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.8 MiB      0.0 MiB        2069                   if neighbor not in open_set_hash:
    75     95.8 MiB      0.0 MiB        2069                       count += 1
    76     95.8 MiB      0.0 MiB        2069                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.8 MiB      0.0 MiB        2069                       open_set_hash.add(neighbor)
    78                                                             
    79     95.8 MiB      0.0 MiB        1828           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.8 MiB      0.0 MiB        1828           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.8 MiB     95.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.8 MiB   -325.3 MiB         257       for row in grid:
    30     95.8 MiB -83098.2 MiB       65792           for spot in row:
    31     95.8 MiB -82774.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     93.2 MiB     -2.5 MiB           1       count = 0
    34     93.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     93.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     93.2 MiB      0.0 MiB           1       came_from = {}
    37     94.9 MiB      1.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.5 MiB   -243.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.6 MiB      0.0 MiB        1160       while not open_set.empty():
    47     97.6 MiB      0.0 MiB        1160           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.6 MiB      0.0 MiB        1160           current = open_set.get()[2]
    53     97.6 MiB      0.0 MiB        1160           open_set_hash.remove(current)
    54                                         
    55     97.6 MiB      0.0 MiB        1160           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.6 MiB      0.0 MiB        1160           if current == end:
    60     97.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.6 MiB      0.0 MiB       10431           for neighbor in current.neighbors:
    65     97.6 MiB      0.0 MiB        9272               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.6 MiB      0.0 MiB        4636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.6 MiB      0.0 MiB        4636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.6 MiB      0.0 MiB        9272               if temp_g_score < g_score[neighbor]:
    71     97.6 MiB      0.1 MiB        1642                   came_from[neighbor] = current
    72     97.6 MiB      0.0 MiB        1642                   g_score[neighbor] = temp_g_score
    73     97.6 MiB      0.0 MiB        1642                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.6 MiB      0.0 MiB        1642                   if neighbor not in open_set_hash:
    75     97.6 MiB      0.0 MiB        1642                       count += 1
    76     97.6 MiB      0.0 MiB        1642                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.6 MiB      0.0 MiB        1642                       open_set_hash.add(neighbor)
    78                                                             
    79     97.6 MiB      0.0 MiB        1159           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.6 MiB      0.0 MiB        1159           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.6 MiB     97.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.6 MiB    -68.1 MiB         257       for row in grid:
    30     97.6 MiB -17475.3 MiB       65792           for spot in row:
    31     97.6 MiB -17407.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.9 MiB     -0.7 MiB           1       count = 0
    34     96.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.9 MiB      0.0 MiB           1       came_from = {}
    37     99.6 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.2 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.2 MiB  -3739.6 MiB        8848       while not open_set.empty():
    47    102.2 MiB  -3739.6 MiB        8848           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.2 MiB  -3739.6 MiB        8848           current = open_set.get()[2]
    53    102.2 MiB  -3739.6 MiB        8848           open_set_hash.remove(current)
    54                                         
    55    102.2 MiB  -3739.6 MiB        8848           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.2 MiB  -3739.6 MiB        8848           if current == end:
    60    100.8 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.2 MiB -33645.9 MiB       79623           for neighbor in current.neighbors:
    65    102.2 MiB -29906.2 MiB       70776               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.2 MiB -14953.1 MiB       35388                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.2 MiB -14953.1 MiB       35388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.2 MiB -29906.2 MiB       70776               if temp_g_score < g_score[neighbor]:
    71    102.2 MiB  -4002.0 MiB        9590                   came_from[neighbor] = current
    72    102.2 MiB  -4002.0 MiB        9590                   g_score[neighbor] = temp_g_score
    73    102.2 MiB  -4002.0 MiB        9590                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.2 MiB  -4002.0 MiB        9590                   if neighbor not in open_set_hash:
    75    102.2 MiB  -4002.0 MiB        9590                       count += 1
    76    102.2 MiB  -4003.4 MiB        9590                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.2 MiB  -4003.4 MiB        9590                       open_set_hash.add(neighbor)
    78                                                             
    79    102.2 MiB  -3739.6 MiB        8847           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.2 MiB  -3739.6 MiB        8847           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.9 MiB    107.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.9 MiB   -413.4 MiB         257       for row in grid:
    30    107.9 MiB -106134.3 MiB       65792           for spot in row:
    31    107.9 MiB -105723.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.1 MiB     -3.8 MiB           1       count = 0
    34    104.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.1 MiB      0.0 MiB           1       came_from = {}
    37    105.2 MiB -44219.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.2 MiB      1.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.2 MiB      0.0 MiB        1764       while not open_set.empty():
    47    106.2 MiB      0.0 MiB        1764           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.2 MiB      0.0 MiB        1764           current = open_set.get()[2]
    53    106.2 MiB      0.0 MiB        1764           open_set_hash.remove(current)
    54                                         
    55    106.2 MiB      0.0 MiB        1764           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.2 MiB      0.0 MiB        1764           if current == end:
    60    106.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.2 MiB      0.0 MiB       15867           for neighbor in current.neighbors:
    65    106.2 MiB      0.0 MiB       14104               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.2 MiB      0.0 MiB        7052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.2 MiB      0.0 MiB        7052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.2 MiB      0.0 MiB       14104               if temp_g_score < g_score[neighbor]:
    71    106.2 MiB      0.0 MiB        2104                   came_from[neighbor] = current
    72    106.2 MiB      0.0 MiB        2104                   g_score[neighbor] = temp_g_score
    73    106.2 MiB      0.0 MiB        2104                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.2 MiB      0.0 MiB        2104                   if neighbor not in open_set_hash:
    75    106.2 MiB      0.0 MiB        2104                       count += 1
    76    106.2 MiB      0.0 MiB        2104                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.2 MiB      0.0 MiB        2104                       open_set_hash.add(neighbor)
    78                                                             
    79    106.2 MiB      0.0 MiB        1763           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.2 MiB      0.0 MiB        1763           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB    -73.3 MiB         257       for row in grid:
    30    106.2 MiB -18735.4 MiB       65792           for spot in row:
    31    106.2 MiB -18662.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.7 MiB     -0.5 MiB           1       count = 0
    34    105.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.7 MiB      0.0 MiB           1       came_from = {}
    37    106.4 MiB      0.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.4 MiB -234471.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.7 MiB     -3.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.7 MiB  -4504.5 MiB        2538       while not open_set.empty():
    47    102.7 MiB  -4504.5 MiB        2538           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.7 MiB  -4504.5 MiB        2538           current = open_set.get()[2]
    53    102.7 MiB  -4504.5 MiB        2538           open_set_hash.remove(current)
    54                                         
    55    102.7 MiB  -4504.5 MiB        2538           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.7 MiB  -4504.5 MiB        2538           if current == end:
    60    100.5 MiB     -2.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.7 MiB -40520.2 MiB       22833           for neighbor in current.neighbors:
    65    102.7 MiB -36018.0 MiB       20296               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.7 MiB -18009.0 MiB       10148                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.7 MiB -18009.0 MiB       10148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.7 MiB -36018.0 MiB       20296               if temp_g_score < g_score[neighbor]:
    71    102.7 MiB  -5168.2 MiB        2966                   came_from[neighbor] = current
    72    102.7 MiB  -5168.2 MiB        2966                   g_score[neighbor] = temp_g_score
    73    102.7 MiB  -5168.2 MiB        2966                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.7 MiB  -5168.2 MiB        2966                   if neighbor not in open_set_hash:
    75    102.7 MiB  -5168.2 MiB        2966                       count += 1
    76    102.7 MiB  -5168.2 MiB        2966                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.7 MiB  -5168.2 MiB        2966                       open_set_hash.add(neighbor)
    78                                                             
    79    102.7 MiB  -4504.5 MiB        2537           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.7 MiB  -4504.5 MiB        2537           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.5 MiB    100.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.5 MiB    -86.3 MiB         257       for row in grid:
    30    100.5 MiB -22096.5 MiB       65792           for spot in row:
    31    100.5 MiB -22010.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.1 MiB     -0.4 MiB           1       count = 0
    34    100.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.1 MiB      0.0 MiB           1       came_from = {}
    37    102.5 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.5 MiB  -1015.6 MiB        4747       while not open_set.empty():
    47    102.5 MiB  -1015.6 MiB        4747           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.5 MiB  -1015.6 MiB        4747           current = open_set.get()[2]
    53    102.5 MiB  -1015.6 MiB        4747           open_set_hash.remove(current)
    54                                         
    55    102.5 MiB  -1015.6 MiB        4747           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.5 MiB  -1015.6 MiB        4747           if current == end:
    60    102.4 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.5 MiB  -9139.0 MiB       42714           for neighbor in current.neighbors:
    65    102.5 MiB  -8123.6 MiB       37968               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.5 MiB  -4062.0 MiB       18984                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.5 MiB  -4061.6 MiB       18984                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.5 MiB  -8123.6 MiB       37968               if temp_g_score < g_score[neighbor]:
    71    102.5 MiB  -1107.0 MiB        5243                   came_from[neighbor] = current
    72    102.5 MiB  -1107.0 MiB        5243                   g_score[neighbor] = temp_g_score
    73    102.5 MiB  -1107.0 MiB        5243                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.5 MiB  -1107.0 MiB        5243                   if neighbor not in open_set_hash:
    75    102.5 MiB  -1107.0 MiB        5243                       count += 1
    76    102.5 MiB  -1107.0 MiB        5243                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.5 MiB  -1107.0 MiB        5243                       open_set_hash.add(neighbor)
    78                                                             
    79    102.5 MiB  -1015.6 MiB        4746           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.5 MiB  -1015.6 MiB        4746           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.4 MiB    102.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.4 MiB   -869.1 MiB         257       for row in grid:
    30    102.4 MiB -222589.5 MiB       65792           for spot in row:
    31    102.4 MiB -221723.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.1 MiB     -4.3 MiB           1       count = 0
    34     98.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.1 MiB      0.0 MiB           1       came_from = {}
    37     99.1 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.5 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.5 MiB -105003.6 MiB        7920       while not open_set.empty():
    47    100.5 MiB -105003.9 MiB        7920           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.5 MiB -105005.1 MiB        7920           current = open_set.get()[2]
    53    100.5 MiB -105005.6 MiB        7920           open_set_hash.remove(current)
    54                                         
    55    100.5 MiB -105006.3 MiB        7920           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.5 MiB -105006.8 MiB        7920           if current == end:
    60     81.8 MiB    -18.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     81.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.5 MiB -944943.9 MiB       71271           for neighbor in current.neighbors:
    65    100.5 MiB -839943.2 MiB       63352               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.5 MiB -419985.1 MiB       31676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.5 MiB -419960.6 MiB       31676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.5 MiB -839949.1 MiB       63352               if temp_g_score < g_score[neighbor]:
    71    100.5 MiB -109936.2 MiB        8454                   came_from[neighbor] = current
    72    100.5 MiB -109936.9 MiB        8454                   g_score[neighbor] = temp_g_score
    73    100.5 MiB -109937.8 MiB        8454                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.5 MiB -109938.1 MiB        8454                   if neighbor not in open_set_hash:
    75    100.5 MiB -109938.5 MiB        8454                       count += 1
    76    100.5 MiB -109939.3 MiB        8454                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.5 MiB -109940.0 MiB        8454                       open_set_hash.add(neighbor)
    78                                                             
    79    100.5 MiB -105002.9 MiB        7919           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.5 MiB -105003.3 MiB        7919           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     84.4 MiB     84.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.4 MiB      0.0 MiB         257       for row in grid:
    30     90.4 MiB      0.0 MiB       65792           for spot in row:
    31     90.4 MiB      6.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     90.4 MiB      0.0 MiB           1       count = 0
    34     90.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     90.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     90.4 MiB      0.0 MiB           1       came_from = {}
    37     93.4 MiB      3.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.4 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.5 MiB  -3941.4 MiB        2583       while not open_set.empty():
    47     94.5 MiB  -3941.6 MiB        2583           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.5 MiB  -3941.9 MiB        2583           current = open_set.get()[2]
    53     94.5 MiB  -3941.9 MiB        2583           open_set_hash.remove(current)
    54                                         
    55     94.5 MiB  -3942.0 MiB        2583           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.5 MiB  -3942.0 MiB        2583           if current == end:
    60     91.3 MiB     -3.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     91.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.5 MiB -35460.4 MiB       23238           for neighbor in current.neighbors:
    65     94.5 MiB -31519.9 MiB       20656               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.5 MiB -15761.1 MiB       10328                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.5 MiB -15759.1 MiB       10328                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.5 MiB -31520.8 MiB       20656               if temp_g_score < g_score[neighbor]:
    71     94.5 MiB  -4315.4 MiB        2915                   came_from[neighbor] = current
    72     94.5 MiB  -4315.5 MiB        2915                   g_score[neighbor] = temp_g_score
    73     94.5 MiB  -4315.5 MiB        2915                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.5 MiB  -4315.5 MiB        2915                   if neighbor not in open_set_hash:
    75     94.5 MiB  -4315.5 MiB        2915                       count += 1
    76     94.5 MiB  -4315.7 MiB        2915                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.5 MiB  -4315.7 MiB        2915                       open_set_hash.add(neighbor)
    78                                                             
    79     94.5 MiB  -3941.3 MiB        2582           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.5 MiB  -3941.3 MiB        2582           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.3 MiB     91.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.3 MiB  -4102.3 MiB         257       for row in grid:
    30     91.3 MiB -1049939.3 MiB       65792           for spot in row:
    31     91.3 MiB -1045856.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.2 MiB    -33.2 MiB           1       count = 0
    34     58.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.2 MiB      0.0 MiB           1       came_from = {}
    37     62.4 MiB      4.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     62.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.0 MiB -16471.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.0 MiB      0.0 MiB          99       while not open_set.empty():
    47     64.0 MiB      0.0 MiB          99           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.0 MiB      0.0 MiB          99           current = open_set.get()[2]
    53     64.0 MiB      0.0 MiB          99           open_set_hash.remove(current)
    54                                         
    55     64.0 MiB      0.0 MiB          99           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.0 MiB      0.0 MiB          99           if current == end:
    60     64.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.0 MiB      0.0 MiB         882           for neighbor in current.neighbors:
    65     64.0 MiB      0.0 MiB         784               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.0 MiB      0.0 MiB         392                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.0 MiB      0.0 MiB         392                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.0 MiB      0.0 MiB         784               if temp_g_score < g_score[neighbor]:
    71     64.0 MiB      0.0 MiB         155                   came_from[neighbor] = current
    72     64.0 MiB      0.0 MiB         155                   g_score[neighbor] = temp_g_score
    73     64.0 MiB      0.0 MiB         155                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.0 MiB      0.0 MiB         155                   if neighbor not in open_set_hash:
    75     64.0 MiB      0.0 MiB         155                       count += 1
    76     64.0 MiB      0.0 MiB         155                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.0 MiB      0.0 MiB         155                       open_set_hash.add(neighbor)
    78                                                             
    79     64.0 MiB      0.0 MiB          98           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.0 MiB      0.0 MiB          98           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     64.0 MiB     64.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     64.0 MiB  -2353.3 MiB         257       for row in grid:
    30     64.0 MiB -603294.7 MiB       65792           for spot in row:
    31     64.0 MiB -600947.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     52.7 MiB    -11.3 MiB           1       count = 0
    34     52.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     52.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     52.7 MiB      0.0 MiB           1       came_from = {}
    37     56.4 MiB      3.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     56.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     60.5 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.6 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.7 MiB      0.0 MiB          66       while not open_set.empty():
    47     60.7 MiB      0.0 MiB          66           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.7 MiB      0.0 MiB          66           current = open_set.get()[2]
    53     60.7 MiB      0.0 MiB          66           open_set_hash.remove(current)
    54                                         
    55     60.7 MiB      0.0 MiB          66           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.7 MiB      0.0 MiB          66           if current == end:
    60     60.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.7 MiB      0.0 MiB         585           for neighbor in current.neighbors:
    65     60.7 MiB      0.0 MiB         520               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.7 MiB      0.0 MiB         260                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.7 MiB      0.0 MiB         260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.7 MiB      0.0 MiB         520               if temp_g_score < g_score[neighbor]:
    71     60.7 MiB      0.0 MiB         120                   came_from[neighbor] = current
    72     60.7 MiB      0.0 MiB         120                   g_score[neighbor] = temp_g_score
    73     60.7 MiB      0.0 MiB         120                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.7 MiB      0.0 MiB         120                   if neighbor not in open_set_hash:
    75     60.7 MiB      0.0 MiB         120                       count += 1
    76     60.7 MiB      0.0 MiB         120                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.7 MiB      0.0 MiB         120                       open_set_hash.add(neighbor)
    78                                                             
    79     60.7 MiB      0.0 MiB          65           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.7 MiB      0.0 MiB          65           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.5 MiB     95.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.5 MiB      0.0 MiB         257       for row in grid:
    30     95.5 MiB      0.0 MiB       65792           for spot in row:
    31     95.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.5 MiB      0.0 MiB           1       count = 0
    34     95.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.5 MiB      0.0 MiB           1       came_from = {}
    37     95.8 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.7 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.1 MiB      0.0 MiB        9825       while not open_set.empty():
    47    100.1 MiB      0.0 MiB        9825           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.1 MiB      0.0 MiB        9825           current = open_set.get()[2]
    53    100.1 MiB      0.0 MiB        9825           open_set_hash.remove(current)
    54                                         
    55    100.1 MiB      0.0 MiB        9825           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.1 MiB      0.0 MiB        9825           if current == end:
    60    100.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.1 MiB      0.0 MiB       88416           for neighbor in current.neighbors:
    65    100.1 MiB      0.0 MiB       78592               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.1 MiB      0.0 MiB       39296                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.1 MiB      0.0 MiB       39296                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.1 MiB      0.0 MiB       78592               if temp_g_score < g_score[neighbor]:
    71    100.1 MiB      0.3 MiB       10385                   came_from[neighbor] = current
    72    100.1 MiB      0.0 MiB       10385                   g_score[neighbor] = temp_g_score
    73    100.1 MiB      0.0 MiB       10385                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.1 MiB      0.0 MiB       10385                   if neighbor not in open_set_hash:
    75    100.1 MiB      0.0 MiB       10385                       count += 1
    76    100.1 MiB      0.0 MiB       10385                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.1 MiB      0.0 MiB       10385                       open_set_hash.add(neighbor)
    78                                                             
    79    100.1 MiB      0.0 MiB        9824           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.1 MiB      0.0 MiB        9824           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.1 MiB    100.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.1 MiB      0.0 MiB         257       for row in grid:
    30    100.1 MiB      0.0 MiB       65792           for spot in row:
    31    100.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.1 MiB      0.0 MiB           1       count = 0
    34    100.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.1 MiB      0.0 MiB           1       came_from = {}
    37    100.3 MiB      0.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.5 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.5 MiB      0.0 MiB         616       while not open_set.empty():
    47    101.5 MiB      0.0 MiB         616           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.5 MiB      0.0 MiB         616           current = open_set.get()[2]
    53    101.5 MiB      0.0 MiB         616           open_set_hash.remove(current)
    54                                         
    55    101.5 MiB      0.0 MiB         616           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.5 MiB      0.0 MiB         616           if current == end:
    60    101.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.5 MiB      0.0 MiB        5535           for neighbor in current.neighbors:
    65    101.5 MiB      0.0 MiB        4920               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.5 MiB      0.0 MiB        2460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.5 MiB      0.0 MiB        2460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.5 MiB      0.0 MiB        4920               if temp_g_score < g_score[neighbor]:
    71    101.5 MiB      0.0 MiB         800                   came_from[neighbor] = current
    72    101.5 MiB      0.0 MiB         800                   g_score[neighbor] = temp_g_score
    73    101.5 MiB      0.0 MiB         800                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.5 MiB      0.0 MiB         800                   if neighbor not in open_set_hash:
    75    101.5 MiB      0.0 MiB         800                       count += 1
    76    101.5 MiB      0.0 MiB         800                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.5 MiB      0.0 MiB         800                       open_set_hash.add(neighbor)
    78                                                             
    79    101.5 MiB      0.0 MiB         615           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.5 MiB      0.0 MiB         615           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.5 MiB    101.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.5 MiB   -566.2 MiB         257       for row in grid:
    30    101.5 MiB -144610.8 MiB       65792           for spot in row:
    31    101.5 MiB -144051.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.7 MiB     -9.9 MiB           1       count = 0
    34     91.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.7 MiB      0.0 MiB           1       came_from = {}
    37     94.4 MiB -21465.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.2 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.2 MiB   -252.1 MiB        1920       while not open_set.empty():
    47     98.2 MiB   -252.1 MiB        1920           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.2 MiB   -252.1 MiB        1920           current = open_set.get()[2]
    53     98.2 MiB   -252.1 MiB        1920           open_set_hash.remove(current)
    54                                         
    55     98.2 MiB   -252.1 MiB        1920           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.2 MiB   -252.1 MiB        1920           if current == end:
    60     98.0 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.2 MiB  -2268.0 MiB       17271           for neighbor in current.neighbors:
    65     98.2 MiB  -2015.9 MiB       15352               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.2 MiB  -1008.2 MiB        7676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.2 MiB  -1007.8 MiB        7676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.2 MiB  -2016.0 MiB       15352               if temp_g_score < g_score[neighbor]:
    71     98.2 MiB   -283.4 MiB        2222                   came_from[neighbor] = current
    72     98.2 MiB   -283.4 MiB        2222                   g_score[neighbor] = temp_g_score
    73     98.2 MiB   -283.4 MiB        2222                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.2 MiB   -283.4 MiB        2222                   if neighbor not in open_set_hash:
    75     98.2 MiB   -283.4 MiB        2222                       count += 1
    76     98.2 MiB   -283.4 MiB        2222                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.2 MiB   -283.4 MiB        2222                       open_set_hash.add(neighbor)
    78                                                             
    79     98.2 MiB   -252.1 MiB        1919           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.2 MiB   -252.1 MiB        1919           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.0 MiB     98.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.0 MiB      0.0 MiB         257       for row in grid:
    30     98.0 MiB      0.0 MiB       65792           for spot in row:
    31     98.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.0 MiB      0.0 MiB           1       count = 0
    34     98.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.0 MiB      0.0 MiB           1       came_from = {}
    37    100.8 MiB   -416.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.4 MiB -17430.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.5 MiB     -0.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.6 MiB  -2783.0 MiB        3124       while not open_set.empty():
    47    102.6 MiB  -2783.0 MiB        3124           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.6 MiB  -2783.0 MiB        3124           current = open_set.get()[2]
    53    102.6 MiB  -2783.0 MiB        3124           open_set_hash.remove(current)
    54                                         
    55    102.6 MiB  -2783.0 MiB        3124           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.6 MiB  -2783.0 MiB        3124           if current == end:
    60     99.1 MiB     -3.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     99.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.6 MiB -25027.8 MiB       28107           for neighbor in current.neighbors:
    65    102.6 MiB -22245.7 MiB       24984               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.6 MiB -11127.2 MiB       12492                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.6 MiB -11119.3 MiB       12492                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.6 MiB -22247.0 MiB       24984               if temp_g_score < g_score[neighbor]:
    71    102.6 MiB  -3284.0 MiB        3734                   came_from[neighbor] = current
    72    102.6 MiB  -3284.1 MiB        3734                   g_score[neighbor] = temp_g_score
    73    102.6 MiB  -3284.1 MiB        3734                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.6 MiB  -3284.1 MiB        3734                   if neighbor not in open_set_hash:
    75    102.6 MiB  -3284.2 MiB        3734                       count += 1
    76    102.6 MiB  -3284.5 MiB        3734                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.6 MiB  -3284.5 MiB        3734                       open_set_hash.add(neighbor)
    78                                                             
    79    102.6 MiB  -2782.9 MiB        3123           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.6 MiB  -2782.9 MiB        3123           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.1 MiB     99.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.1 MiB  -4141.5 MiB         257       for row in grid:
    30     99.1 MiB -1060848.0 MiB       65792           for spot in row:
    31     99.1 MiB -1056720.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     78.9 MiB    -20.2 MiB           1       count = 0
    34     78.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     78.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     78.9 MiB      0.0 MiB           1       came_from = {}
    37     82.2 MiB      3.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     82.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     84.8 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     84.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     84.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     84.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     84.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     84.9 MiB      0.0 MiB         810       while not open_set.empty():
    47     84.9 MiB      0.0 MiB         810           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     84.9 MiB      0.0 MiB         810           current = open_set.get()[2]
    53     84.9 MiB      0.0 MiB         810           open_set_hash.remove(current)
    54                                         
    55     84.9 MiB      0.0 MiB         810           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     84.9 MiB      0.0 MiB         810           if current == end:
    60     84.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     84.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     84.9 MiB      0.0 MiB        7281           for neighbor in current.neighbors:
    65     84.9 MiB      0.0 MiB        6472               if current.row != neighbor.row and current.col != neighbor.col:
    66     84.9 MiB      0.0 MiB        3236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     84.9 MiB      0.0 MiB        3236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     84.9 MiB      0.0 MiB        6472               if temp_g_score < g_score[neighbor]:
    71     84.9 MiB      0.0 MiB        1466                   came_from[neighbor] = current
    72     84.9 MiB      0.0 MiB        1466                   g_score[neighbor] = temp_g_score
    73     84.9 MiB      0.0 MiB        1466                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     84.9 MiB      0.0 MiB        1466                   if neighbor not in open_set_hash:
    75     84.9 MiB      0.0 MiB        1466                       count += 1
    76     84.9 MiB      0.0 MiB        1466                       open_set.put((f_score[neighbor], count, neighbor))
    77     84.9 MiB      0.0 MiB        1466                       open_set_hash.add(neighbor)
    78                                                             
    79     84.9 MiB      0.0 MiB         809           if draw is not None:
    80                                                     draw()
    81                                         
    82     84.9 MiB      0.0 MiB         809           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     84.9 MiB     84.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     84.9 MiB      0.0 MiB         257       for row in grid:
    30     84.9 MiB      0.0 MiB       65792           for spot in row:
    31     84.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     84.9 MiB      0.0 MiB           1       count = 0
    34     84.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     84.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     84.9 MiB      0.0 MiB           1       came_from = {}
    37     87.2 MiB   -598.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     87.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     88.5 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     88.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     88.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     88.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     88.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     88.5 MiB  -4146.4 MiB        4401       while not open_set.empty():
    47     88.5 MiB  -4146.4 MiB        4401           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     88.5 MiB  -4146.4 MiB        4401           current = open_set.get()[2]
    53     88.5 MiB  -4146.4 MiB        4401           open_set_hash.remove(current)
    54                                         
    55     88.5 MiB  -4146.4 MiB        4401           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     88.5 MiB  -4146.4 MiB        4401           if current == end:
    60     84.0 MiB     -4.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     84.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     88.5 MiB -37297.2 MiB       39600           for neighbor in current.neighbors:
    65     88.5 MiB -33151.5 MiB       35200               if current.row != neighbor.row and current.col != neighbor.col:
    66     88.5 MiB -16579.8 MiB       17600                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     88.5 MiB -16572.4 MiB       17600                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     88.5 MiB -33152.9 MiB       35200               if temp_g_score < g_score[neighbor]:
    71     88.5 MiB  -4557.7 MiB        4833                   came_from[neighbor] = current
    72     88.5 MiB  -4558.1 MiB        4833                   g_score[neighbor] = temp_g_score
    73     88.5 MiB  -4558.7 MiB        4833                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     88.5 MiB  -4559.0 MiB        4833                   if neighbor not in open_set_hash:
    75     88.5 MiB  -4559.0 MiB        4833                       count += 1
    76     88.5 MiB  -4559.0 MiB        4833                       open_set.put((f_score[neighbor], count, neighbor))
    77     88.5 MiB  -4559.0 MiB        4833                       open_set_hash.add(neighbor)
    78                                                             
    79     88.5 MiB  -4146.3 MiB        4400           if draw is not None:
    80                                                     draw()
    81                                         
    82     88.5 MiB  -4146.4 MiB        4400           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     84.1 MiB     84.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     84.1 MiB   -185.6 MiB         257       for row in grid:
    30     84.1 MiB -47750.2 MiB       65792           for spot in row:
    31     84.1 MiB -47564.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     83.5 MiB     -0.6 MiB           1       count = 0
    34     83.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     83.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     83.5 MiB      0.0 MiB           1       came_from = {}
    37     87.4 MiB      3.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     87.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     89.6 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     89.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     89.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     89.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     89.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     89.6 MiB -58846.5 MiB        8858       while not open_set.empty():
    47     89.6 MiB -58847.2 MiB        8858           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     89.6 MiB -58848.3 MiB        8858           current = open_set.get()[2]
    53     89.6 MiB -58848.7 MiB        8858           open_set_hash.remove(current)
    54                                         
    55     89.6 MiB -58849.0 MiB        8858           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     89.6 MiB -58849.5 MiB        8858           if current == end:
    60     65.5 MiB    -24.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     65.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     89.6 MiB -529504.7 MiB       79713           for neighbor in current.neighbors:
    65     89.6 MiB -470663.7 MiB       70856               if current.row != neighbor.row and current.col != neighbor.col:
    66     89.6 MiB -235347.7 MiB       35428                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     89.6 MiB -235319.4 MiB       35428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     89.6 MiB -470670.3 MiB       70856               if temp_g_score < g_score[neighbor]:
    71     89.6 MiB -62504.2 MiB        9440                   came_from[neighbor] = current
    72     89.6 MiB -62504.6 MiB        9440                   g_score[neighbor] = temp_g_score
    73     89.6 MiB -62505.4 MiB        9440                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     89.6 MiB -62506.0 MiB        9440                   if neighbor not in open_set_hash:
    75     89.6 MiB -62506.5 MiB        9440                       count += 1
    76     89.6 MiB -62507.9 MiB        9440                       open_set.put((f_score[neighbor], count, neighbor))
    77     89.6 MiB -62508.8 MiB        9440                       open_set_hash.add(neighbor)
    78                                                             
    79     89.6 MiB -58845.1 MiB        8857           if draw is not None:
    80                                                     draw()
    81                                         
    82     89.6 MiB -58845.8 MiB        8857           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


