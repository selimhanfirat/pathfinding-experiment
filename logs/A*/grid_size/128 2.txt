Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28  51.8594 MiB  51.8594 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31  51.9531 MiB   0.0000 MiB         129       for row in grid:
    32  51.9531 MiB   0.0000 MiB       16512           for spot in row:
    33  51.9531 MiB   0.0938 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35  51.9531 MiB   0.0000 MiB           1       count = 0
    36  51.9531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37  51.9531 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38  51.9531 MiB   0.0000 MiB           1       came_from = {}
    39  52.7656 MiB   0.8125 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40  52.7656 MiB   0.0000 MiB           1       g_score[start] = 0
    41  54.2500 MiB   1.4844 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42  54.2500 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43  54.2500 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45  54.2500 MiB   0.0000 MiB           1       cost_diagonal = 14
    46  54.2500 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48  54.3438 MiB   0.0000 MiB        1500       while not open_set.empty():
    49  54.3438 MiB   0.0000 MiB        1500           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54  54.3438 MiB   0.0000 MiB        1500           current = open_set.get()[2]
    55  54.3438 MiB   0.0000 MiB        1500           open_set_hash.remove(current)
    56                                         
    57  54.3438 MiB   0.0000 MiB        1500           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61  54.3438 MiB   0.0000 MiB        1500           if current == end:
    62  54.3438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64  54.3438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66  54.3438 MiB   0.0000 MiB       13491           for neighbor in current.neighbors:
    67  54.3438 MiB   0.0000 MiB       11992               if current.row != neighbor.row and current.col != neighbor.col:
    68  54.3438 MiB   0.0000 MiB        5996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70  54.3438 MiB   0.0000 MiB        5996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72  54.3438 MiB   0.0000 MiB       11992               if temp_g_score < g_score[neighbor]:
    73  54.3438 MiB   0.0625 MiB        1718                   came_from[neighbor] = current
    74  54.3438 MiB   0.0000 MiB        1718                   g_score[neighbor] = temp_g_score
    75  54.3438 MiB   0.0000 MiB        1718                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76  54.3438 MiB   0.0000 MiB        1718                   if neighbor not in open_set_hash:
    77  54.3438 MiB   0.0000 MiB        1718                       count += 1
    78  54.3438 MiB   0.0000 MiB        1718                       open_set.put((f_score[neighbor], count, neighbor))
    79  54.3438 MiB   0.0312 MiB        1718                       open_set_hash.add(neighbor)
    80                                                             
    81  54.3438 MiB   0.0000 MiB        1499           if draw is not None:
    82                                                     draw()
    83                                         
    84  54.3438 MiB   0.0000 MiB        1499           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28  59.2656 MiB  59.2656 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31  59.2656 MiB   0.0000 MiB         129       for row in grid:
    32  59.2656 MiB   0.0000 MiB       16512           for spot in row:
    33  59.2656 MiB   0.0000 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35  59.2656 MiB   0.0000 MiB           1       count = 0
    36  59.2969 MiB   0.0312 MiB           1       open_set = PriorityQueue()
    37  59.2969 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38  59.2969 MiB   0.0000 MiB           1       came_from = {}
    39  59.8438 MiB   0.5469 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40  59.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    41  61.0938 MiB   1.2500 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42  61.0938 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43  61.0938 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45  61.0938 MiB   0.0000 MiB           1       cost_diagonal = 14
    46  61.0938 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48  61.0938 MiB   0.0000 MiB          85       while not open_set.empty():
    49  61.0938 MiB   0.0000 MiB          85           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54  61.0938 MiB   0.0000 MiB          85           current = open_set.get()[2]
    55  61.0938 MiB   0.0000 MiB          85           open_set_hash.remove(current)
    56                                         
    57  61.0938 MiB   0.0000 MiB          85           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61  61.0938 MiB   0.0000 MiB          85           if current == end:
    62  61.0938 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 111.4062 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 111.4062 MiB   0.0000 MiB       71811           for neighbor in current.neighbors:
    67 111.4062 MiB   0.0000 MiB       63832               if current.row != neighbor.row and current.col != neighbor.col:
    68 111.4062 MiB   0.0000 MiB       31916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 111.4062 MiB   0.0000 MiB       31916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 111.4062 MiB   0.0000 MiB       63832               if temp_g_score < g_score[neighbor]:
    73 111.4062 MiB   0.0312 MiB        8492                   came_from[neighbor] = current
    74 111.4062 MiB   0.0000 MiB        8492                   g_score[neighbor] = temp_g_score
    75 111.4062 MiB   0.0000 MiB        8492                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 111.4062 MiB   0.0000 MiB        8492                   if neighbor not in open_set_hash:
    77 111.4062 MiB   0.0000 MiB        8492                       count += 1
    78 111.4062 MiB   0.0469 MiB        8492                       open_set.put((f_score[neighbor], count, neighbor))
    79 111.4062 MiB   0.0469 MiB        8492                       open_set_hash.add(neighbor)
    80                                                             
    81 111.4062 MiB   0.0000 MiB        7979           if draw is not None:
    82                                                     draw()
    83                                         
    84 111.4062 MiB   0.0000 MiB        7979           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 109.4375 MiB 109.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 109.4375 MiB   0.0000 MiB         257       for row in grid:
    32 109.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 109.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 109.4375 MiB   0.0000 MiB           1       count = 0
    36 109.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 109.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 109.4375 MiB   0.0000 MiB           1       came_from = {}
    39 112.7500 MiB   3.3125 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 112.7500 MiB   0.0000 MiB           1       g_score[start] = 0
    41 116.0312 MiB   3.2812 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 116.0312 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 116.0312 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 116.0312 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 116.0312 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 116.0938 MiB   0.0000 MiB        6032       while not open_set.empty():
    49 116.0938 MiB   0.0000 MiB        6032           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 116.0938 MiB   0.0000 MiB        6032           current = open_set.get()[2]
    55 116.0938 MiB   0.0000 MiB        6032           open_set_hash.remove(current)
    56                                         
    57 116.0938 MiB   0.0000 MiB        6032           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 116.0938 MiB   0.0000 MiB        6032           if current == end:
    62 116.0938 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 116.0938 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 116.0938 MiB   0.0000 MiB       54279           for neighbor in current.neighbors:
    67 116.0938 MiB   0.0000 MiB       48248               if current.row != neighbor.row and current.col != neighbor.col:
    68 116.0938 MiB   0.0000 MiB       24124                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 116.0938 MiB   0.0000 MiB       24124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 116.0938 MiB   0.0000 MiB       48248               if temp_g_score < g_score[neighbor]:
    73 116.0938 MiB   0.0156 MiB        6470                   came_from[neighbor] = current
    74 116.0938 MiB   0.0000 MiB        6470                   g_score[neighbor] = temp_g_score
    75 116.0938 MiB   0.0000 MiB        6470                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 116.0938 MiB   0.0000 MiB        6470                   if neighbor not in open_set_hash:
    77 116.0938 MiB   0.0000 MiB        6470                       count += 1
    78 116.0938 MiB   0.0312 MiB        6470                       open_set.put((f_score[neighbor], count, neighbor))
    79 116.0938 MiB   0.0156 MiB        6470                       open_set_hash.add(neighbor)
    80                                                             
    81 116.0938 MiB   0.0000 MiB        6031           if draw is not None:
    82                                                     draw()
    83                                         
    84 116.0938 MiB   0.0000 MiB        6031           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.8125 MiB 118.8125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.8125 MiB   0.0000 MiB         257       for row in grid:
    32 118.8125 MiB   0.0000 MiB       65792           for spot in row:
    33 118.8125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.8125 MiB   0.0000 MiB           1       count = 0
    36 118.8125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.8125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.8125 MiB   0.0000 MiB           1       came_from = {}
    39 118.8281 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 118.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.8438 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.8438 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.8438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.8438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.8438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.8438 MiB   0.0000 MiB         105       while not open_set.empty():
    49 118.8438 MiB   0.0000 MiB         105           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.8438 MiB   0.0000 MiB         105           current = open_set.get()[2]
    55 118.8438 MiB   0.0000 MiB         105           open_set_hash.remove(current)
    56                                         
    57 118.8438 MiB   0.0000 MiB         105           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.8438 MiB   0.0000 MiB         105           if current == end:
    62 118.8438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.8438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.8438 MiB   0.0000 MiB         936           for neighbor in current.neighbors:
    67 118.8438 MiB   0.0000 MiB         832               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.8438 MiB   0.0000 MiB         416                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.8438 MiB   0.0000 MiB         416                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.8438 MiB   0.0000 MiB         832               if temp_g_score < g_score[neighbor]:
    73 118.8438 MiB   0.0000 MiB         197                   came_from[neighbor] = current
    74 118.8438 MiB   0.0000 MiB         197                   g_score[neighbor] = temp_g_score
    75 118.8438 MiB   0.0000 MiB         197                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.8438 MiB   0.0000 MiB         197                   if neighbor not in open_set_hash:
    77 118.8438 MiB   0.0000 MiB         197                       count += 1
    78 118.8438 MiB   0.0000 MiB         197                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.8438 MiB   0.0000 MiB         197                       open_set_hash.add(neighbor)
    80                                                             
    81 118.8438 MiB   0.0000 MiB         104           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.8438 MiB   0.0000 MiB         104           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 119.8594 MiB 119.8594 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 119.8594 MiB   0.0000 MiB         257       for row in grid:
    32 119.8594 MiB   0.0000 MiB       65792           for spot in row:
    33 119.8594 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 119.8594 MiB   0.0000 MiB           1       count = 0
    36 119.8594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 119.8594 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 119.8594 MiB   0.0000 MiB           1       came_from = {}
    39 123.6406 MiB   3.7812 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 123.6406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.6406 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.6406 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.6406 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.6406 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.6406 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.6406 MiB   0.0000 MiB         712       while not open_set.empty():
    49 123.6406 MiB   0.0000 MiB         712           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.6406 MiB   0.0000 MiB         712           current = open_set.get()[2]
    55 123.6406 MiB   0.0000 MiB         712           open_set_hash.remove(current)
    56                                         
    57 123.6406 MiB   0.0000 MiB         712           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.6406 MiB   0.0000 MiB         712           if current == end:
    62 123.6406 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 123.6406 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.6406 MiB   0.0000 MiB        6399           for neighbor in current.neighbors:
    67 123.6406 MiB   0.0000 MiB        5688               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.6406 MiB   0.0000 MiB        2844                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.6406 MiB   0.0000 MiB        2844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.6406 MiB   0.0000 MiB        5688               if temp_g_score < g_score[neighbor]:
    73 123.6406 MiB   0.0000 MiB        1082                   came_from[neighbor] = current
    74 123.6406 MiB   0.0000 MiB        1082                   g_score[neighbor] = temp_g_score
    75 123.6406 MiB   0.0000 MiB        1082                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.6406 MiB   0.0000 MiB        1082                   if neighbor not in open_set_hash:
    77 123.6406 MiB   0.0000 MiB        1082                       count += 1
    78 123.6406 MiB   0.0000 MiB        1082                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.6406 MiB   0.0000 MiB        1082                       open_set_hash.add(neighbor)
    80                                                             
    81 123.6406 MiB   0.0000 MiB         711           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.6406 MiB   0.0000 MiB         711           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 124.0938 MiB 124.0938 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 124.0938 MiB   0.0000 MiB         257       for row in grid:
    32 124.0938 MiB   0.0000 MiB       65792           for spot in row:
    33 124.0938 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 124.0938 MiB   0.0000 MiB           1       count = 0
    36 124.0938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 124.0938 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 124.0938 MiB   0.0000 MiB           1       came_from = {}
    39 124.1250 MiB   0.0312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 124.1250 MiB   0.0000 MiB           1       g_score[start] = 0
    41 124.1250 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 124.1250 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 124.1250 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 124.1250 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 124.1250 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 124.1250 MiB   0.0000 MiB         648       while not open_set.empty():
    49 124.1250 MiB   0.0000 MiB         648           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 124.1250 MiB   0.0000 MiB         648           current = open_set.get()[2]
    55 124.1250 MiB   0.0000 MiB         648           open_set_hash.remove(current)
    56                                         
    57 124.1250 MiB   0.0000 MiB         648           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 124.1250 MiB   0.0000 MiB         648           if current == end:
    62 124.1250 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 124.1250 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 124.1250 MiB   0.0000 MiB        5823           for neighbor in current.neighbors:
    67 124.1250 MiB   0.0000 MiB        5176               if current.row != neighbor.row and current.col != neighbor.col:
    68 124.1250 MiB   0.0000 MiB        2588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 124.1250 MiB   0.0000 MiB        2588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 124.1250 MiB   0.0000 MiB        5176               if temp_g_score < g_score[neighbor]:
    73 124.1250 MiB   0.0000 MiB         790                   came_from[neighbor] = current
    74 124.1250 MiB   0.0000 MiB         790                   g_score[neighbor] = temp_g_score
    75 124.1250 MiB   0.0000 MiB         790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 124.1250 MiB   0.0000 MiB         790                   if neighbor not in open_set_hash:
    77 124.1250 MiB   0.0000 MiB         790                       count += 1
    78 124.1250 MiB   0.0000 MiB         790                       open_set.put((f_score[neighbor], count, neighbor))
    79 124.1250 MiB   0.0000 MiB         790                       open_set_hash.add(neighbor)
    80                                                             
    81 124.1250 MiB   0.0000 MiB         647           if draw is not None:
    82                                                     draw()
    83                                         
    84 124.1250 MiB   0.0000 MiB         647           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 124.1250 MiB 124.1250 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 124.1250 MiB   0.0000 MiB         257       for row in grid:
    32 124.1250 MiB   0.0000 MiB       65792           for spot in row:
    33 124.1250 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 124.1250 MiB   0.0000 MiB           1       count = 0
    36 124.1250 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 124.1250 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 124.1250 MiB   0.0000 MiB           1       came_from = {}
    39 124.1406 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 124.1406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 126.6719 MiB   2.5312 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 126.6719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 126.6719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 126.6719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 126.6719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 126.7031 MiB   0.0000 MiB        3726       while not open_set.empty():
    49 126.7031 MiB   0.0000 MiB        3726           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 126.7031 MiB   0.0000 MiB        3726           current = open_set.get()[2]
    55 126.7031 MiB   0.0000 MiB        3726           open_set_hash.remove(current)
    56                                         
    57 126.7031 MiB   0.0000 MiB        3726           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 126.7031 MiB   0.0000 MiB        3726           if current == end:
    62 126.7031 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 126.7031 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 126.7031 MiB   0.0000 MiB       33525           for neighbor in current.neighbors:
    67 126.7031 MiB   0.0000 MiB       29800               if current.row != neighbor.row and current.col != neighbor.col:
    68 126.7031 MiB   0.0000 MiB       14900                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 126.7031 MiB   0.0000 MiB       14900                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 126.7031 MiB   0.0000 MiB       29800               if temp_g_score < g_score[neighbor]:
    73 126.7031 MiB   0.0312 MiB        4210                   came_from[neighbor] = current
    74 126.7031 MiB   0.0000 MiB        4210                   g_score[neighbor] = temp_g_score
    75 126.7031 MiB   0.0000 MiB        4210                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 126.7031 MiB   0.0000 MiB        4210                   if neighbor not in open_set_hash:
    77 126.7031 MiB   0.0000 MiB        4210                       count += 1
    78 126.7031 MiB   0.0000 MiB        4210                       open_set.put((f_score[neighbor], count, neighbor))
    79 126.7031 MiB   0.0000 MiB        4210                       open_set_hash.add(neighbor)
    80                                                             
    81 126.7031 MiB   0.0000 MiB        3725           if draw is not None:
    82                                                     draw()
    83                                         
    84 126.7031 MiB   0.0000 MiB        3725           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 127.4688 MiB 127.4688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 127.4688 MiB   0.0000 MiB         257       for row in grid:
    32 127.4688 MiB   0.0000 MiB       65792           for spot in row:
    33 127.4688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.4688 MiB   0.0000 MiB           1       count = 0
    36 127.4688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.4688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.4688 MiB   0.0000 MiB           1       came_from = {}
    39 127.4688 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 127.4688 MiB   0.0000 MiB           1       g_score[start] = 0
    41 127.4844 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 127.4844 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 127.4844 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 127.4844 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 127.4844 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 127.5000 MiB   0.0000 MiB        1890       while not open_set.empty():
    49 127.5000 MiB   0.0000 MiB        1890           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 127.5000 MiB   0.0000 MiB        1890           current = open_set.get()[2]
    55 127.5000 MiB   0.0000 MiB        1890           open_set_hash.remove(current)
    56                                         
    57 127.5000 MiB   0.0000 MiB        1890           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 127.5000 MiB   0.0000 MiB        1890           if current == end:
    62 127.5000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 127.5000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 127.5000 MiB   0.0000 MiB       17001           for neighbor in current.neighbors:
    67 127.5000 MiB   0.0000 MiB       15112               if current.row != neighbor.row and current.col != neighbor.col:
    68 127.5000 MiB   0.0000 MiB        7556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 127.5000 MiB   0.0000 MiB        7556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 127.5000 MiB   0.0000 MiB       15112               if temp_g_score < g_score[neighbor]:
    73 127.5000 MiB   0.0000 MiB        2152                   came_from[neighbor] = current
    74 127.5000 MiB   0.0000 MiB        2152                   g_score[neighbor] = temp_g_score
    75 127.5000 MiB   0.0000 MiB        2152                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 127.5000 MiB   0.0000 MiB        2152                   if neighbor not in open_set_hash:
    77 127.5000 MiB   0.0000 MiB        2152                       count += 1
    78 127.5000 MiB   0.0000 MiB        2152                       open_set.put((f_score[neighbor], count, neighbor))
    79 127.5000 MiB   0.0156 MiB        2152                       open_set_hash.add(neighbor)
    80                                                             
    81 127.5000 MiB   0.0000 MiB        1889           if draw is not None:
    82                                                     draw()
    83                                         
    84 127.5000 MiB   0.0000 MiB        1889           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 127.5000 MiB 127.5000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 127.5000 MiB   0.0000 MiB         257       for row in grid:
    32 127.5000 MiB   0.0000 MiB       65792           for spot in row:
    33 127.5000 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.5000 MiB   0.0000 MiB           1       count = 0
    36 127.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.5000 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.5000 MiB   0.0000 MiB           1       came_from = {}
    39 127.5156 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 127.5156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 127.5156 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 127.5156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 127.5156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 127.5156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 127.5156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 127.5156 MiB   0.0000 MiB        8184       while not open_set.empty():
    49 127.5156 MiB   0.0000 MiB        8184           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 127.5156 MiB   0.0000 MiB        8184           current = open_set.get()[2]
    55 127.5156 MiB   0.0000 MiB        8184           open_set_hash.remove(current)
    56                                         
    57 127.5156 MiB   0.0000 MiB        8184           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 127.5156 MiB   0.0000 MiB        8184           if current == end:
    62 127.5156 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 127.5156 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 127.5156 MiB   0.0000 MiB       73647           for neighbor in current.neighbors:
    67 127.5156 MiB   0.0000 MiB       65464               if current.row != neighbor.row and current.col != neighbor.col:
    68 127.5156 MiB   0.0000 MiB       32732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 127.5156 MiB   0.0000 MiB       32732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 127.5156 MiB   0.0000 MiB       65464               if temp_g_score < g_score[neighbor]:
    73 127.5156 MiB   0.0000 MiB        8720                   came_from[neighbor] = current
    74 127.5156 MiB   0.0000 MiB        8720                   g_score[neighbor] = temp_g_score
    75 127.5156 MiB   0.0000 MiB        8720                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 127.5156 MiB   0.0000 MiB        8720                   if neighbor not in open_set_hash:
    77 127.5156 MiB   0.0000 MiB        8720                       count += 1
    78 127.5156 MiB   0.0000 MiB        8720                       open_set.put((f_score[neighbor], count, neighbor))
    79 127.5156 MiB   0.0000 MiB        8720                       open_set_hash.add(neighbor)
    80                                                             
    81 127.5156 MiB   0.0000 MiB        8183           if draw is not None:
    82                                                     draw()
    83                                         
    84 127.5156 MiB   0.0000 MiB        8183           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 127.5156 MiB 127.5156 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 127.5156 MiB   0.0000 MiB         257       for row in grid:
    32 127.5156 MiB   0.0000 MiB       65792           for spot in row:
    33 127.5156 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.5156 MiB   0.0000 MiB           1       count = 0
    36 127.5156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.5156 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.5156 MiB   0.0000 MiB           1       came_from = {}
    39 127.5156 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 127.5156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 127.5312 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 127.5312 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 127.5312 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 127.5312 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 127.5312 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 127.5312 MiB   0.0000 MiB         376       while not open_set.empty():
    49 127.5312 MiB   0.0000 MiB         376           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 127.5312 MiB   0.0000 MiB         376           current = open_set.get()[2]
    55 127.5312 MiB   0.0000 MiB         376           open_set_hash.remove(current)
    56                                         
    57 127.5312 MiB   0.0000 MiB         376           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 127.5312 MiB   0.0000 MiB         376           if current == end:
    62 127.5312 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 127.5312 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 127.5312 MiB   0.0000 MiB        3375           for neighbor in current.neighbors:
    67 127.5312 MiB   0.0000 MiB        3000               if current.row != neighbor.row and current.col != neighbor.col:
    68 127.5312 MiB   0.0000 MiB        1500                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 127.5312 MiB   0.0000 MiB        1500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 127.5312 MiB   0.0000 MiB        3000               if temp_g_score < g_score[neighbor]:
    73 127.5312 MiB   0.0000 MiB         758                   came_from[neighbor] = current
    74 127.5312 MiB   0.0000 MiB         758                   g_score[neighbor] = temp_g_score
    75 127.5312 MiB   0.0000 MiB         758                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 127.5312 MiB   0.0000 MiB         758                   if neighbor not in open_set_hash:
    77 127.5312 MiB   0.0000 MiB         758                       count += 1
    78 127.5312 MiB   0.0000 MiB         758                       open_set.put((f_score[neighbor], count, neighbor))
    79 127.5312 MiB   0.0000 MiB         758                       open_set_hash.add(neighbor)
    80                                                             
    81 127.5312 MiB   0.0000 MiB         375           if draw is not None:
    82                                                     draw()
    83                                         
    84 127.5312 MiB   0.0000 MiB         375           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.1094 MiB 128.1094 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.1094 MiB   0.0000 MiB         257       for row in grid:
    32 128.1094 MiB   0.0000 MiB       65792           for spot in row:
    33 128.1094 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.1094 MiB   0.0000 MiB           1       count = 0
    36 128.1094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.1094 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.1094 MiB   0.0000 MiB           1       came_from = {}
    39 128.1562 MiB   0.0469 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.1562 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1562 MiB   0.0000 MiB        2074       while not open_set.empty():
    49 128.1562 MiB   0.0000 MiB        2074           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1562 MiB   0.0000 MiB        2074           current = open_set.get()[2]
    55 128.1562 MiB   0.0000 MiB        2074           open_set_hash.remove(current)
    56                                         
    57 128.1562 MiB   0.0000 MiB        2074           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1562 MiB   0.0000 MiB        2074           if current == end:
    62 128.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1562 MiB   0.0000 MiB       18657           for neighbor in current.neighbors:
    67 128.1562 MiB   0.0000 MiB       16584               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1562 MiB   0.0000 MiB        8292                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1562 MiB   0.0000 MiB        8292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1562 MiB   0.0000 MiB       16584               if temp_g_score < g_score[neighbor]:
    73 128.1562 MiB   0.0000 MiB        2330                   came_from[neighbor] = current
    74 128.1562 MiB   0.0000 MiB        2330                   g_score[neighbor] = temp_g_score
    75 128.1562 MiB   0.0000 MiB        2330                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1562 MiB   0.0000 MiB        2330                   if neighbor not in open_set_hash:
    77 128.1562 MiB   0.0000 MiB        2330                       count += 1
    78 128.1562 MiB   0.0000 MiB        2330                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1562 MiB   0.0000 MiB        2330                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1562 MiB   0.0000 MiB        2073           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1562 MiB   0.0000 MiB        2073           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.3125 MiB 129.3125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.3125 MiB   0.0000 MiB         257       for row in grid:
    32 129.3125 MiB   0.0000 MiB       65792           for spot in row:
    33 129.3125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.3125 MiB   0.0000 MiB           1       count = 0
    36 129.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.3125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.3125 MiB   0.0000 MiB           1       came_from = {}
    39 129.3125 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.3125 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.3125 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.3125 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.3125 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.3125 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.3125 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.3125 MiB   0.0000 MiB        5820       while not open_set.empty():
    49 129.3125 MiB   0.0000 MiB        5820           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.3125 MiB   0.0000 MiB        5820           current = open_set.get()[2]
    55 129.3125 MiB   0.0000 MiB        5820           open_set_hash.remove(current)
    56                                         
    57 129.3125 MiB   0.0000 MiB        5820           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.3125 MiB   0.0000 MiB        5820           if current == end:
    62 129.3125 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.3125 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.3125 MiB   0.0000 MiB       52371           for neighbor in current.neighbors:
    67 129.3125 MiB   0.0000 MiB       46552               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.3125 MiB   0.0000 MiB       23276                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.3125 MiB   0.0000 MiB       23276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.3125 MiB   0.0000 MiB       46552               if temp_g_score < g_score[neighbor]:
    73 129.3125 MiB   0.0000 MiB        6326                   came_from[neighbor] = current
    74 129.3125 MiB   0.0000 MiB        6326                   g_score[neighbor] = temp_g_score
    75 129.3125 MiB   0.0000 MiB        6326                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.3125 MiB   0.0000 MiB        6326                   if neighbor not in open_set_hash:
    77 129.3125 MiB   0.0000 MiB        6326                       count += 1
    78 129.3125 MiB   0.0000 MiB        6326                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.3125 MiB   0.0000 MiB        6326                       open_set_hash.add(neighbor)
    80                                                             
    81 129.3125 MiB   0.0000 MiB        5819           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.3125 MiB   0.0000 MiB        5819           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.3125 MiB 129.3125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.3125 MiB   0.0000 MiB         257       for row in grid:
    32 129.3125 MiB   0.0000 MiB       65792           for spot in row:
    33 129.3125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.3125 MiB   0.0000 MiB           1       count = 0
    36 129.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.3125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.3125 MiB   0.0000 MiB           1       came_from = {}
    39 129.3125 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.3125 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.3125 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.3125 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.3125 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.3125 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.3125 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.3125 MiB   0.0000 MiB        1260       while not open_set.empty():
    49 129.3125 MiB   0.0000 MiB        1260           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.3125 MiB   0.0000 MiB        1260           current = open_set.get()[2]
    55 129.3125 MiB   0.0000 MiB        1260           open_set_hash.remove(current)
    56                                         
    57 129.3125 MiB   0.0000 MiB        1260           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.3125 MiB   0.0000 MiB        1260           if current == end:
    62 129.3125 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.3125 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.3125 MiB   0.0000 MiB       11331           for neighbor in current.neighbors:
    67 129.3125 MiB   0.0000 MiB       10072               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.3125 MiB   0.0000 MiB        5036                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.3125 MiB   0.0000 MiB        5036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.3125 MiB   0.0000 MiB       10072               if temp_g_score < g_score[neighbor]:
    73 129.3125 MiB   0.0000 MiB        1646                   came_from[neighbor] = current
    74 129.3125 MiB   0.0000 MiB        1646                   g_score[neighbor] = temp_g_score
    75 129.3125 MiB   0.0000 MiB        1646                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.3125 MiB   0.0000 MiB        1646                   if neighbor not in open_set_hash:
    77 129.3125 MiB   0.0000 MiB        1646                       count += 1
    78 129.3125 MiB   0.0000 MiB        1646                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.3125 MiB   0.0000 MiB        1646                       open_set_hash.add(neighbor)
    80                                                             
    81 129.3125 MiB   0.0000 MiB        1259           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.3125 MiB   0.0000 MiB        1259           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.3125 MiB 129.3125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.3125 MiB   0.0000 MiB         257       for row in grid:
    32 129.3125 MiB   0.0000 MiB       65792           for spot in row:
    33 129.3125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.3125 MiB   0.0000 MiB           1       count = 0
    36 129.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.3125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.3125 MiB   0.0000 MiB           1       came_from = {}
    39 129.3281 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.3281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 131.8438 MiB   2.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 131.8438 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 131.8438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 131.8438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 131.8438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 131.8438 MiB   0.0000 MiB        9027       while not open_set.empty():
    49 131.8438 MiB   0.0000 MiB        9027           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 131.8438 MiB   0.0000 MiB        9027           current = open_set.get()[2]
    55 131.8438 MiB   0.0000 MiB        9027           open_set_hash.remove(current)
    56                                         
    57 131.8438 MiB   0.0000 MiB        9027           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 131.8438 MiB   0.0000 MiB        9027           if current == end:
    62 131.8438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 131.8438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 131.8438 MiB   0.0000 MiB       81234           for neighbor in current.neighbors:
    67 131.8438 MiB   0.0000 MiB       72208               if current.row != neighbor.row and current.col != neighbor.col:
    68 131.8438 MiB   0.0000 MiB       36104                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 131.8438 MiB   0.0000 MiB       36104                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 131.8438 MiB   0.0000 MiB       72208               if temp_g_score < g_score[neighbor]:
    73 131.8438 MiB   0.0000 MiB        9755                   came_from[neighbor] = current
    74 131.8438 MiB   0.0000 MiB        9755                   g_score[neighbor] = temp_g_score
    75 131.8438 MiB   0.0000 MiB        9755                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 131.8438 MiB   0.0000 MiB        9755                   if neighbor not in open_set_hash:
    77 131.8438 MiB   0.0000 MiB        9755                       count += 1
    78 131.8438 MiB   0.0000 MiB        9755                       open_set.put((f_score[neighbor], count, neighbor))
    79 131.8438 MiB   0.0000 MiB        9755                       open_set_hash.add(neighbor)
    80                                                             
    81 131.8438 MiB   0.0000 MiB        9026           if draw is not None:
    82                                                     draw()
    83                                         
    84 131.8438 MiB   0.0000 MiB        9026           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 131.8438 MiB 131.8438 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 131.8438 MiB   0.0000 MiB         257       for row in grid:
    32 131.8438 MiB   0.0000 MiB       65792           for spot in row:
    33 131.8438 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 131.8438 MiB   0.0000 MiB           1       count = 0
    36 131.8438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 131.8438 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 131.8438 MiB   0.0000 MiB           1       came_from = {}
    39 131.8438 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 131.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 131.8438 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 131.8438 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 131.8438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 131.8438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 131.8438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 131.8438 MiB   0.0000 MiB         174       while not open_set.empty():
    49 131.8438 MiB   0.0000 MiB         174           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 131.8438 MiB   0.0000 MiB         174           current = open_set.get()[2]
    55 131.8438 MiB   0.0000 MiB         174           open_set_hash.remove(current)
    56                                         
    57 131.8438 MiB   0.0000 MiB         174           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 131.8438 MiB   0.0000 MiB         174           if current == end:
    62 131.8438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 131.8438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 131.8438 MiB   0.0000 MiB        1557           for neighbor in current.neighbors:
    67 131.8438 MiB   0.0000 MiB        1384               if current.row != neighbor.row and current.col != neighbor.col:
    68 131.8438 MiB   0.0000 MiB         692                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 131.8438 MiB   0.0000 MiB         692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 131.8438 MiB   0.0000 MiB        1384               if temp_g_score < g_score[neighbor]:
    73 131.8438 MiB   0.0000 MiB         300                   came_from[neighbor] = current
    74 131.8438 MiB   0.0000 MiB         300                   g_score[neighbor] = temp_g_score
    75 131.8438 MiB   0.0000 MiB         300                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 131.8438 MiB   0.0000 MiB         300                   if neighbor not in open_set_hash:
    77 131.8438 MiB   0.0000 MiB         300                       count += 1
    78 131.8438 MiB   0.0000 MiB         300                       open_set.put((f_score[neighbor], count, neighbor))
    79 131.8438 MiB   0.0000 MiB         300                       open_set_hash.add(neighbor)
    80                                                             
    81 131.8438 MiB   0.0000 MiB         173           if draw is not None:
    82                                                     draw()
    83                                         
    84 131.8438 MiB   0.0000 MiB         173           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 131.9688 MiB 131.9688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 131.9688 MiB   0.0000 MiB         257       for row in grid:
    32 131.9688 MiB   0.0000 MiB       65792           for spot in row:
    33 131.9688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 131.9688 MiB   0.0000 MiB           1       count = 0
    36 131.9688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 131.9688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 131.9688 MiB   0.0000 MiB           1       came_from = {}
    39 132.0000 MiB   0.0312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 132.0000 MiB   0.0000 MiB           1       g_score[start] = 0
    41 132.0156 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 132.0156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 132.0156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 132.0156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 132.0156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 132.0312 MiB   0.0000 MiB         986       while not open_set.empty():
    49 132.0312 MiB   0.0000 MiB         986           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 132.0312 MiB   0.0000 MiB         986           current = open_set.get()[2]
    55 132.0312 MiB   0.0000 MiB         986           open_set_hash.remove(current)
    56                                         
    57 132.0312 MiB   0.0000 MiB         986           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 132.0312 MiB   0.0000 MiB         986           if current == end:
    62 132.0312 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 132.0312 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 132.0312 MiB   0.0000 MiB        8865           for neighbor in current.neighbors:
    67 132.0312 MiB   0.0000 MiB        7880               if current.row != neighbor.row and current.col != neighbor.col:
    68 132.0312 MiB   0.0000 MiB        3940                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 132.0312 MiB   0.0000 MiB        3940                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 132.0312 MiB   0.0000 MiB        7880               if temp_g_score < g_score[neighbor]:
    73 132.0312 MiB   0.0156 MiB        1168                   came_from[neighbor] = current
    74 132.0312 MiB   0.0000 MiB        1168                   g_score[neighbor] = temp_g_score
    75 132.0312 MiB   0.0000 MiB        1168                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 132.0312 MiB   0.0000 MiB        1168                   if neighbor not in open_set_hash:
    77 132.0312 MiB   0.0000 MiB        1168                       count += 1
    78 132.0312 MiB   0.0000 MiB        1168                       open_set.put((f_score[neighbor], count, neighbor))
    79 132.0312 MiB   0.0000 MiB        1168                       open_set_hash.add(neighbor)
    80                                                             
    81 132.0312 MiB   0.0000 MiB         985           if draw is not None:
    82                                                     draw()
    83                                         
    84 132.0312 MiB   0.0000 MiB         985           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 132.4375 MiB 132.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 132.4375 MiB   0.0000 MiB         257       for row in grid:
    32 132.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 132.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 132.4375 MiB   0.0000 MiB           1       count = 0
    36 132.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 132.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 132.4375 MiB   0.0000 MiB           1       came_from = {}
    39 132.4375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 132.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 132.4375 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 132.4375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 132.4375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 132.4375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 132.4375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 132.4375 MiB   0.0000 MiB         756       while not open_set.empty():
    49 132.4375 MiB   0.0000 MiB         756           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 132.4375 MiB   0.0000 MiB         756           current = open_set.get()[2]
    55 132.4375 MiB   0.0000 MiB         756           open_set_hash.remove(current)
    56                                         
    57 132.4375 MiB   0.0000 MiB         756           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 132.4375 MiB   0.0000 MiB         756           if current == end:
    62 132.4375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 132.4375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 132.4375 MiB   0.0000 MiB        6795           for neighbor in current.neighbors:
    67 132.4375 MiB   0.0000 MiB        6040               if current.row != neighbor.row and current.col != neighbor.col:
    68 132.4375 MiB   0.0000 MiB        3020                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 132.4375 MiB   0.0000 MiB        3020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 132.4375 MiB   0.0000 MiB        6040               if temp_g_score < g_score[neighbor]:
    73 132.4375 MiB   0.0000 MiB        1148                   came_from[neighbor] = current
    74 132.4375 MiB   0.0000 MiB        1148                   g_score[neighbor] = temp_g_score
    75 132.4375 MiB   0.0000 MiB        1148                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 132.4375 MiB   0.0000 MiB        1148                   if neighbor not in open_set_hash:
    77 132.4375 MiB   0.0000 MiB        1148                       count += 1
    78 132.4375 MiB   0.0000 MiB        1148                       open_set.put((f_score[neighbor], count, neighbor))
    79 132.4375 MiB   0.0000 MiB        1148                       open_set_hash.add(neighbor)
    80                                                             
    81 132.4375 MiB   0.0000 MiB         755           if draw is not None:
    82                                                     draw()
    83                                         
    84 132.4375 MiB   0.0000 MiB         755           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 132.4375 MiB 132.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 132.4375 MiB   0.0000 MiB         257       for row in grid:
    32 132.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 132.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 132.4375 MiB   0.0000 MiB           1       count = 0
    36 132.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 132.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 132.4375 MiB   0.0000 MiB           1       came_from = {}
    39 132.4375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 132.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 132.4375 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 132.4375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 132.4375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 132.4375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 132.4375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 132.4375 MiB   0.0000 MiB        2600       while not open_set.empty():
    49 132.4375 MiB   0.0000 MiB        2600           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 132.4375 MiB   0.0000 MiB        2600           current = open_set.get()[2]
    55 132.4375 MiB   0.0000 MiB        2600           open_set_hash.remove(current)
    56                                         
    57 132.4375 MiB   0.0000 MiB        2600           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 132.4375 MiB   0.0000 MiB        2600           if current == end:
    62 132.4375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 132.4375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 132.4375 MiB   0.0000 MiB       23391           for neighbor in current.neighbors:
    67 132.4375 MiB   0.0000 MiB       20792               if current.row != neighbor.row and current.col != neighbor.col:
    68 132.4375 MiB   0.0000 MiB       10396                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 132.4375 MiB   0.0000 MiB       10396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 132.4375 MiB   0.0000 MiB       20792               if temp_g_score < g_score[neighbor]:
    73 132.4375 MiB   0.0000 MiB        2902                   came_from[neighbor] = current
    74 132.4375 MiB   0.0000 MiB        2902                   g_score[neighbor] = temp_g_score
    75 132.4375 MiB   0.0000 MiB        2902                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 132.4375 MiB   0.0000 MiB        2902                   if neighbor not in open_set_hash:
    77 132.4375 MiB   0.0000 MiB        2902                       count += 1
    78 132.4375 MiB   0.0000 MiB        2902                       open_set.put((f_score[neighbor], count, neighbor))
    79 132.4375 MiB   0.0000 MiB        2902                       open_set_hash.add(neighbor)
    80                                                             
    81 132.4375 MiB   0.0000 MiB        2599           if draw is not None:
    82                                                     draw()
    83                                         
    84 132.4375 MiB   0.0000 MiB        2599           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 132.4375 MiB 132.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 132.4375 MiB   0.0000 MiB         257       for row in grid:
    32 132.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 132.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 132.4375 MiB   0.0000 MiB           1       count = 0
    36 132.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 132.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 132.4375 MiB   0.0000 MiB           1       came_from = {}
    39 132.4375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 132.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 132.4375 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 132.4375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 132.4375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 132.4375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 132.4375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 132.4375 MiB   0.0000 MiB         864       while not open_set.empty():
    49 132.4375 MiB   0.0000 MiB         864           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 132.4375 MiB   0.0000 MiB         864           current = open_set.get()[2]
    55 132.4375 MiB   0.0000 MiB         864           open_set_hash.remove(current)
    56                                         
    57 132.4375 MiB   0.0000 MiB         864           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 132.4375 MiB   0.0000 MiB         864           if current == end:
    62 132.4375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 132.4375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 132.4375 MiB   0.0000 MiB        7767           for neighbor in current.neighbors:
    67 132.4375 MiB   0.0000 MiB        6904               if current.row != neighbor.row and current.col != neighbor.col:
    68 132.4375 MiB   0.0000 MiB        3452                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 132.4375 MiB   0.0000 MiB        3452                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 132.4375 MiB   0.0000 MiB        6904               if temp_g_score < g_score[neighbor]:
    73 132.4375 MiB   0.0000 MiB        1030                   came_from[neighbor] = current
    74 132.4375 MiB   0.0000 MiB        1030                   g_score[neighbor] = temp_g_score
    75 132.4375 MiB   0.0000 MiB        1030                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 132.4375 MiB   0.0000 MiB        1030                   if neighbor not in open_set_hash:
    77 132.4375 MiB   0.0000 MiB        1030                       count += 1
    78 132.4375 MiB   0.0000 MiB        1030                       open_set.put((f_score[neighbor], count, neighbor))
    79 132.4375 MiB   0.0000 MiB        1030                       open_set_hash.add(neighbor)
    80                                                             
    81 132.4375 MiB   0.0000 MiB         863           if draw is not None:
    82                                                     draw()
    83                                         
    84 132.4375 MiB   0.0000 MiB         863           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 132.4375 MiB 132.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 132.4375 MiB   0.0000 MiB         257       for row in grid:
    32 132.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 132.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 132.4375 MiB   0.0000 MiB           1       count = 0
    36 132.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 132.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 132.4375 MiB   0.0000 MiB           1       came_from = {}
    39 132.4375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 132.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 132.4375 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 132.4375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 132.4375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 132.4375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 132.4375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 132.4375 MiB   0.0000 MiB         950       while not open_set.empty():
    49 132.4375 MiB   0.0000 MiB         950           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 132.4375 MiB   0.0000 MiB         950           current = open_set.get()[2]
    55 132.4375 MiB   0.0000 MiB         950           open_set_hash.remove(current)
    56                                         
    57 132.4375 MiB   0.0000 MiB         950           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 132.4375 MiB   0.0000 MiB         950           if current == end:
    62 132.4375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 132.4375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 132.4375 MiB   0.0000 MiB        8541           for neighbor in current.neighbors:
    67 132.4375 MiB   0.0000 MiB        7592               if current.row != neighbor.row and current.col != neighbor.col:
    68 132.4375 MiB   0.0000 MiB        3796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 132.4375 MiB   0.0000 MiB        3796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 132.4375 MiB   0.0000 MiB        7592               if temp_g_score < g_score[neighbor]:
    73 132.4375 MiB   0.0000 MiB        1124                   came_from[neighbor] = current
    74 132.4375 MiB   0.0000 MiB        1124                   g_score[neighbor] = temp_g_score
    75 132.4375 MiB   0.0000 MiB        1124                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 132.4375 MiB   0.0000 MiB        1124                   if neighbor not in open_set_hash:
    77 132.4375 MiB   0.0000 MiB        1124                       count += 1
    78 132.4375 MiB   0.0000 MiB        1124                       open_set.put((f_score[neighbor], count, neighbor))
    79 132.4375 MiB   0.0000 MiB        1124                       open_set_hash.add(neighbor)
    80                                                             
    81 132.4375 MiB   0.0000 MiB         949           if draw is not None:
    82                                                     draw()
    83                                         
    84 132.4375 MiB   0.0000 MiB         949           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 132.4375 MiB 132.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 132.4375 MiB   0.0000 MiB         257       for row in grid:
    32 132.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 132.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 132.4375 MiB   0.0000 MiB           1       count = 0
    36 132.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 132.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 132.4375 MiB   0.0000 MiB           1       came_from = {}
    39 132.4375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 132.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 132.4375 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 132.4375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 132.4375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 132.4375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 132.4375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 132.4375 MiB   0.0000 MiB        1890       while not open_set.empty():
    49 132.4375 MiB   0.0000 MiB        1890           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 132.4375 MiB   0.0000 MiB        1890           current = open_set.get()[2]
    55 132.4375 MiB   0.0000 MiB        1890           open_set_hash.remove(current)
    56                                         
    57 132.4375 MiB   0.0000 MiB        1890           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 132.4375 MiB   0.0000 MiB        1890           if current == end:
    62 132.4375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 132.4375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 132.4375 MiB   0.0000 MiB       17001           for neighbor in current.neighbors:
    67 132.4375 MiB   0.0000 MiB       15112               if current.row != neighbor.row and current.col != neighbor.col:
    68 132.4375 MiB   0.0000 MiB        7556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 132.4375 MiB   0.0000 MiB        7556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 132.4375 MiB   0.0000 MiB       15112               if temp_g_score < g_score[neighbor]:
    73 132.4375 MiB   0.0000 MiB        2136                   came_from[neighbor] = current
    74 132.4375 MiB   0.0000 MiB        2136                   g_score[neighbor] = temp_g_score
    75 132.4375 MiB   0.0000 MiB        2136                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 132.4375 MiB   0.0000 MiB        2136                   if neighbor not in open_set_hash:
    77 132.4375 MiB   0.0000 MiB        2136                       count += 1
    78 132.4375 MiB   0.0000 MiB        2136                       open_set.put((f_score[neighbor], count, neighbor))
    79 132.4375 MiB   0.0000 MiB        2136                       open_set_hash.add(neighbor)
    80                                                             
    81 132.4375 MiB   0.0000 MiB        1889           if draw is not None:
    82                                                     draw()
    83                                         
    84 132.4375 MiB   0.0000 MiB        1889           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 132.4375 MiB 132.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 132.4375 MiB -1198.0781 MiB         257       for row in grid:
    32 132.4375 MiB -307038.9531 MiB       65792           for spot in row:
    33 132.4375 MiB -305844.1406 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.5625 MiB  -4.8750 MiB           1       count = 0
    36 127.5625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.5625 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.5625 MiB   0.0000 MiB           1       came_from = {}
    39 128.0000 MiB   0.4375 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.0000 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.7812 MiB   0.7812 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.7812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.7812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.7812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.7812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.7812 MiB   0.0000 MiB         360       while not open_set.empty():
    49 128.7812 MiB   0.0000 MiB         360           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.7812 MiB   0.0000 MiB         360           current = open_set.get()[2]
    55 128.7812 MiB   0.0000 MiB         360           open_set_hash.remove(current)
    56                                         
    57 128.7812 MiB   0.0000 MiB         360           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.7812 MiB   0.0000 MiB         360           if current == end:
    62 128.7812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.7812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.7812 MiB   0.0000 MiB        3231           for neighbor in current.neighbors:
    67 128.7812 MiB   0.0000 MiB        2872               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.7812 MiB   0.0000 MiB        1436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.7812 MiB   0.0000 MiB        1436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.7812 MiB   0.0000 MiB        2872               if temp_g_score < g_score[neighbor]:
    73 128.7812 MiB   0.0000 MiB         502                   came_from[neighbor] = current
    74 128.7812 MiB   0.0000 MiB         502                   g_score[neighbor] = temp_g_score
    75 128.7812 MiB   0.0000 MiB         502                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.7812 MiB   0.0000 MiB         502                   if neighbor not in open_set_hash:
    77 128.7812 MiB   0.0000 MiB         502                       count += 1
    78 128.7812 MiB   0.0000 MiB         502                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.7812 MiB   0.0000 MiB         502                       open_set_hash.add(neighbor)
    80                                                             
    81 128.7812 MiB   0.0000 MiB         359           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.7812 MiB   0.0000 MiB         359           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 116.2344 MiB 116.2344 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 116.2344 MiB -61.0000 MiB         257       for row in grid:
    32 116.2344 MiB -14948.2344 MiB       65792           for spot in row:
    33 116.2344 MiB -14889.8906 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 112.4219 MiB  -3.8125 MiB           1       count = 0
    36 112.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 112.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 112.4219 MiB   0.0000 MiB           1       came_from = {}
    39 115.6250 MiB -297.3125 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 115.5156 MiB  -0.1094 MiB           1       g_score[start] = 0
    41 118.6875 MiB   3.1719 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.6875 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.6875 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.6875 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.6875 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.6875 MiB   0.0000 MiB        1975       while not open_set.empty():
    49 118.6875 MiB   0.0000 MiB        1975           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.6875 MiB   0.0000 MiB        1975           current = open_set.get()[2]
    55 118.6875 MiB   0.0000 MiB        1975           open_set_hash.remove(current)
    56                                         
    57 118.6875 MiB   0.0000 MiB        1975           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.6875 MiB   0.0000 MiB        1975           if current == end:
    62 118.6875 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.6875 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.6875 MiB   0.0000 MiB       17766           for neighbor in current.neighbors:
    67 118.6875 MiB   0.0000 MiB       15792               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.6875 MiB   0.0000 MiB        7896                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.6875 MiB   0.0000 MiB        7896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.6875 MiB   0.0000 MiB       15792               if temp_g_score < g_score[neighbor]:
    73 118.6875 MiB   0.0000 MiB        2231                   came_from[neighbor] = current
    74 118.6875 MiB   0.0000 MiB        2231                   g_score[neighbor] = temp_g_score
    75 118.6875 MiB   0.0000 MiB        2231                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.6875 MiB   0.0000 MiB        2231                   if neighbor not in open_set_hash:
    77 118.6875 MiB   0.0000 MiB        2231                       count += 1
    78 118.6875 MiB   0.0000 MiB        2231                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.6875 MiB   0.0000 MiB        2231                       open_set_hash.add(neighbor)
    80                                                             
    81 118.6875 MiB   0.0000 MiB        1974           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.6875 MiB   0.0000 MiB        1974           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.8125 MiB 118.8125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.8125 MiB   0.0000 MiB         257       for row in grid:
    32 118.8125 MiB   0.0000 MiB       65792           for spot in row:
    33 118.8125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.8125 MiB   0.0000 MiB           1       count = 0
    36 118.8125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.8125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.8125 MiB   0.0000 MiB           1       came_from = {}
    39 121.3438 MiB   2.5312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 121.3438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 125.6719 MiB   4.3281 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 125.6719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 125.6719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 125.6719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 125.6719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 125.6875 MiB   0.0000 MiB        1494       while not open_set.empty():
    49 125.6875 MiB   0.0000 MiB        1494           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 125.6875 MiB   0.0000 MiB        1494           current = open_set.get()[2]
    55 125.6875 MiB   0.0000 MiB        1494           open_set_hash.remove(current)
    56                                         
    57 125.6875 MiB   0.0000 MiB        1494           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 125.6875 MiB   0.0000 MiB        1494           if current == end:
    62 125.6875 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 125.6875 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 125.6875 MiB   0.0000 MiB       13437           for neighbor in current.neighbors:
    67 125.6875 MiB   0.0000 MiB       11944               if current.row != neighbor.row and current.col != neighbor.col:
    68 125.6875 MiB   0.0000 MiB        5972                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 125.6875 MiB   0.0000 MiB        5972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 125.6875 MiB   0.0000 MiB       11944               if temp_g_score < g_score[neighbor]:
    73 125.6875 MiB   0.0000 MiB        1730                   came_from[neighbor] = current
    74 125.6875 MiB   0.0000 MiB        1730                   g_score[neighbor] = temp_g_score
    75 125.6875 MiB   0.0000 MiB        1730                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 125.6875 MiB   0.0000 MiB        1730                   if neighbor not in open_set_hash:
    77 125.6875 MiB   0.0000 MiB        1730                       count += 1
    78 125.6875 MiB   0.0000 MiB        1730                       open_set.put((f_score[neighbor], count, neighbor))
    79 125.6875 MiB   0.0156 MiB        1730                       open_set_hash.add(neighbor)
    80                                                             
    81 125.6875 MiB   0.0000 MiB        1493           if draw is not None:
    82                                                     draw()
    83                                         
    84 125.6875 MiB   0.0000 MiB        1493           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 125.6875 MiB 125.6875 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 125.6875 MiB -515.0625 MiB         257       for row in grid:
    32 125.6875 MiB -132324.0000 MiB       65792           for spot in row:
    33 125.6875 MiB -131810.7812 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 123.1250 MiB  -2.5625 MiB           1       count = 0
    36 123.1250 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 123.1250 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 123.1250 MiB   0.0000 MiB           1       came_from = {}
    39 123.1406 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 123.1406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.6562 MiB   0.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.6562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.6562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.6562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.6562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.6562 MiB   0.0000 MiB         360       while not open_set.empty():
    49 123.6562 MiB   0.0000 MiB         360           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.6562 MiB   0.0000 MiB         360           current = open_set.get()[2]
    55 123.6562 MiB   0.0000 MiB         360           open_set_hash.remove(current)
    56                                         
    57 123.6562 MiB   0.0000 MiB         360           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.6562 MiB   0.0000 MiB         360           if current == end:
    62 123.6562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 123.6562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.6562 MiB   0.0000 MiB        3231           for neighbor in current.neighbors:
    67 123.6562 MiB   0.0000 MiB        2872               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.6562 MiB   0.0000 MiB        1436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.6562 MiB   0.0000 MiB        1436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.6562 MiB   0.0000 MiB        2872               if temp_g_score < g_score[neighbor]:
    73 123.6562 MiB   0.0000 MiB         656                   came_from[neighbor] = current
    74 123.6562 MiB   0.0000 MiB         656                   g_score[neighbor] = temp_g_score
    75 123.6562 MiB   0.0000 MiB         656                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.6562 MiB   0.0000 MiB         656                   if neighbor not in open_set_hash:
    77 123.6562 MiB   0.0000 MiB         656                       count += 1
    78 123.6562 MiB   0.0000 MiB         656                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.6562 MiB   0.0000 MiB         656                       open_set_hash.add(neighbor)
    80                                                             
    81 123.6562 MiB   0.0000 MiB         359           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.6562 MiB   0.0000 MiB         359           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 123.6562 MiB 123.6562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 123.6562 MiB -1255.3594 MiB         257       for row in grid:
    32 123.6562 MiB -322144.4062 MiB       65792           for spot in row:
    33 123.6562 MiB -320892.9219 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.3594 MiB  -5.2969 MiB           1       count = 0
    36 118.3594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.3594 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.3594 MiB   0.0000 MiB           1       came_from = {}
    39 118.3750 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 118.3750 MiB   0.0000 MiB           1       g_score[start] = 0
    41 119.6562 MiB   1.2812 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 119.6562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 119.6562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 119.6562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 119.6562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 119.6562 MiB   0.0000 MiB         975       while not open_set.empty():
    49 119.6562 MiB   0.0000 MiB         975           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 119.6562 MiB   0.0000 MiB         975           current = open_set.get()[2]
    55 119.6562 MiB   0.0000 MiB         975           open_set_hash.remove(current)
    56                                         
    57 119.6562 MiB   0.0000 MiB         975           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 119.6562 MiB   0.0000 MiB         975           if current == end:
    62 119.6562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 119.6562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 119.6562 MiB   0.0000 MiB        8766           for neighbor in current.neighbors:
    67 119.6562 MiB   0.0000 MiB        7792               if current.row != neighbor.row and current.col != neighbor.col:
    68 119.6562 MiB   0.0000 MiB        3896                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 119.6562 MiB   0.0000 MiB        3896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 119.6562 MiB   0.0000 MiB        7792               if temp_g_score < g_score[neighbor]:
    73 119.6562 MiB   0.0000 MiB        1175                   came_from[neighbor] = current
    74 119.6562 MiB   0.0000 MiB        1175                   g_score[neighbor] = temp_g_score
    75 119.6562 MiB   0.0000 MiB        1175                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 119.6562 MiB   0.0000 MiB        1175                   if neighbor not in open_set_hash:
    77 119.6562 MiB   0.0000 MiB        1175                       count += 1
    78 119.6562 MiB   0.0000 MiB        1175                       open_set.put((f_score[neighbor], count, neighbor))
    79 119.6562 MiB   0.0000 MiB        1175                       open_set_hash.add(neighbor)
    80                                                             
    81 119.6562 MiB   0.0000 MiB         974           if draw is not None:
    82                                                     draw()
    83                                         
    84 119.6562 MiB   0.0000 MiB         974           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 119.6562 MiB 119.6562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 119.6562 MiB  -3.1875 MiB         257       for row in grid:
    32 119.6562 MiB -810.5469 MiB       65792           for spot in row:
    33 119.6562 MiB -807.3750 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 119.5938 MiB  -0.0625 MiB           1       count = 0
    36 119.5938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 119.5938 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 119.5938 MiB   0.0000 MiB           1       came_from = {}
    39 119.6250 MiB   0.0312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 119.6250 MiB   0.0000 MiB           1       g_score[start] = 0
    41 122.5469 MiB   2.9219 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 122.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 122.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 122.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 122.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 122.5469 MiB   0.0000 MiB        1160       while not open_set.empty():
    49 122.5469 MiB   0.0000 MiB        1160           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 122.5469 MiB   0.0000 MiB        1160           current = open_set.get()[2]
    55 122.5469 MiB   0.0000 MiB        1160           open_set_hash.remove(current)
    56                                         
    57 122.5469 MiB   0.0000 MiB        1160           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 122.5469 MiB   0.0000 MiB        1160           if current == end:
    62 122.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 122.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 122.5469 MiB   0.0000 MiB       10431           for neighbor in current.neighbors:
    67 122.5469 MiB   0.0000 MiB        9272               if current.row != neighbor.row and current.col != neighbor.col:
    68 122.5469 MiB   0.0000 MiB        4636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 122.5469 MiB   0.0000 MiB        4636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 122.5469 MiB   0.0000 MiB        9272               if temp_g_score < g_score[neighbor]:
    73 122.5469 MiB   0.0000 MiB        1354                   came_from[neighbor] = current
    74 122.5469 MiB   0.0000 MiB        1354                   g_score[neighbor] = temp_g_score
    75 122.5469 MiB   0.0000 MiB        1354                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 122.5469 MiB   0.0000 MiB        1354                   if neighbor not in open_set_hash:
    77 122.5469 MiB   0.0000 MiB        1354                       count += 1
    78 122.5469 MiB   0.0000 MiB        1354                       open_set.put((f_score[neighbor], count, neighbor))
    79 122.5469 MiB   0.0000 MiB        1354                       open_set_hash.add(neighbor)
    80                                                             
    81 122.5469 MiB   0.0000 MiB        1159           if draw is not None:
    82                                                     draw()
    83                                         
    84 122.5469 MiB   0.0000 MiB        1159           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 122.5469 MiB 122.5469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 122.5469 MiB   0.0000 MiB         257       for row in grid:
    32 122.5469 MiB   0.0000 MiB       65792           for spot in row:
    33 122.5469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 122.5469 MiB   0.0000 MiB           1       count = 0
    36 122.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 122.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 122.5469 MiB   0.0000 MiB           1       came_from = {}
    39 123.1250 MiB   0.5781 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 123.1250 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.1250 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.1250 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.1250 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.1250 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.1250 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.1250 MiB   0.0000 MiB         840       while not open_set.empty():
    49 123.1250 MiB   0.0000 MiB         840           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.1250 MiB   0.0000 MiB         840           current = open_set.get()[2]
    55 123.1250 MiB   0.0000 MiB         840           open_set_hash.remove(current)
    56                                         
    57 123.1250 MiB   0.0000 MiB         840           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.1250 MiB   0.0000 MiB         840           if current == end:
    62 123.1250 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 123.1250 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.1250 MiB   0.0000 MiB        7551           for neighbor in current.neighbors:
    67 123.1250 MiB   0.0000 MiB        6712               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.1250 MiB   0.0000 MiB        3356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.1250 MiB   0.0000 MiB        3356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.1250 MiB   0.0000 MiB        6712               if temp_g_score < g_score[neighbor]:
    73 123.1250 MiB   0.0000 MiB        1040                   came_from[neighbor] = current
    74 123.1250 MiB   0.0000 MiB        1040                   g_score[neighbor] = temp_g_score
    75 123.1250 MiB   0.0000 MiB        1040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.1250 MiB   0.0000 MiB        1040                   if neighbor not in open_set_hash:
    77 123.1250 MiB   0.0000 MiB        1040                       count += 1
    78 123.1250 MiB   0.0000 MiB        1040                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.1250 MiB   0.0000 MiB        1040                       open_set_hash.add(neighbor)
    80                                                             
    81 123.1250 MiB   0.0000 MiB         839           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.1250 MiB   0.0000 MiB         839           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 123.1250 MiB 123.1250 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 123.1250 MiB -400.9688 MiB         257       for row in grid:
    32 123.1250 MiB -102570.9688 MiB       65792           for spot in row:
    33 123.1250 MiB -102172.9531 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 119.0469 MiB  -4.0781 MiB           1       count = 0
    36 119.0469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 119.0469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 119.0469 MiB   0.0000 MiB           1       came_from = {}
    39 122.2969 MiB   3.2500 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 122.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.1094 MiB   0.8125 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.1094 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.1094 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.1094 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.1094 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.1094 MiB -11952.7812 MiB        1807       while not open_set.empty():
    49 123.1094 MiB -11953.0312 MiB        1807           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.1094 MiB -11953.7031 MiB        1807           current = open_set.get()[2]
    55 123.1094 MiB -11954.0781 MiB        1807           open_set_hash.remove(current)
    56                                         
    57 123.1094 MiB -11954.3906 MiB        1807           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.1094 MiB -11954.7656 MiB        1807           if current == end:
    62 115.2031 MiB  -7.9062 MiB           1               if draw:
    63                                                         end.make_end()
    64 115.2031 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.1094 MiB -107541.4688 MiB       16254           for neighbor in current.neighbors:
    67 123.1094 MiB -95590.7031 MiB       14448               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.1094 MiB -47800.4531 MiB        7224                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.1094 MiB -47791.1562 MiB        7224                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.1094 MiB -95592.3906 MiB       14448               if temp_g_score < g_score[neighbor]:
    73 123.1094 MiB -15619.0625 MiB        2387                   came_from[neighbor] = current
    74 123.1094 MiB -15619.0625 MiB        2387                   g_score[neighbor] = temp_g_score
    75 123.1094 MiB -15619.0625 MiB        2387                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.1094 MiB -15619.2031 MiB        2387                   if neighbor not in open_set_hash:
    77 123.1094 MiB -15619.4062 MiB        2387                       count += 1
    78 123.1094 MiB -15619.7812 MiB        2387                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.1094 MiB -15619.9688 MiB        2387                       open_set_hash.add(neighbor)
    80                                                             
    81 123.1094 MiB -11952.2188 MiB        1806           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.1094 MiB -11952.4531 MiB        1806           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 115.2031 MiB 115.2031 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 115.2031 MiB   0.0000 MiB         257       for row in grid:
    32 115.2031 MiB   0.0000 MiB       65792           for spot in row:
    33 115.2031 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 115.2031 MiB   0.0000 MiB           1       count = 0
    36 115.2031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 115.2031 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 115.2031 MiB   0.0000 MiB           1       came_from = {}
    39 117.7812 MiB   2.5781 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 117.7812 MiB   0.0000 MiB           1       g_score[start] = 0
    41 120.2812 MiB   2.5000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 120.2812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 120.2812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 120.2812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 120.2812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 120.2812 MiB   0.0000 MiB         539       while not open_set.empty():
    49 120.2812 MiB   0.0000 MiB         539           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 120.2812 MiB   0.0000 MiB         539           current = open_set.get()[2]
    55 120.2812 MiB   0.0000 MiB         539           open_set_hash.remove(current)
    56                                         
    57 120.2812 MiB   0.0000 MiB         539           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 120.2812 MiB   0.0000 MiB         539           if current == end:
    62 120.2812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 120.2812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 120.2812 MiB   0.0000 MiB        4842           for neighbor in current.neighbors:
    67 120.2812 MiB   0.0000 MiB        4304               if current.row != neighbor.row and current.col != neighbor.col:
    68 120.2812 MiB   0.0000 MiB        2152                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 120.2812 MiB   0.0000 MiB        2152                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 120.2812 MiB   0.0000 MiB        4304               if temp_g_score < g_score[neighbor]:
    73 120.2812 MiB   0.0000 MiB         755                   came_from[neighbor] = current
    74 120.2812 MiB   0.0000 MiB         755                   g_score[neighbor] = temp_g_score
    75 120.2812 MiB   0.0000 MiB         755                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 120.2812 MiB   0.0000 MiB         755                   if neighbor not in open_set_hash:
    77 120.2812 MiB   0.0000 MiB         755                       count += 1
    78 120.2812 MiB   0.0000 MiB         755                       open_set.put((f_score[neighbor], count, neighbor))
    79 120.2812 MiB   0.0000 MiB         755                       open_set_hash.add(neighbor)
    80                                                             
    81 120.2812 MiB   0.0000 MiB         538           if draw is not None:
    82                                                     draw()
    83                                         
    84 120.2812 MiB   0.0000 MiB         538           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 120.2812 MiB 120.2812 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 120.2812 MiB   0.0000 MiB         257       for row in grid:
    32 120.2812 MiB   0.0000 MiB       65792           for spot in row:
    33 120.2812 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 120.2812 MiB   0.0000 MiB           1       count = 0
    36 120.2812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 120.2812 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 120.2812 MiB   0.0000 MiB           1       came_from = {}
    39 120.2812 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 120.2812 MiB   0.0000 MiB           1       g_score[start] = 0
    41 122.7969 MiB   2.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 122.7969 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 122.7969 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 122.7969 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 122.7969 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 122.7969 MiB   0.0000 MiB         322       while not open_set.empty():
    49 122.7969 MiB   0.0000 MiB         322           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 122.7969 MiB   0.0000 MiB         322           current = open_set.get()[2]
    55 122.7969 MiB   0.0000 MiB         322           open_set_hash.remove(current)
    56                                         
    57 122.7969 MiB   0.0000 MiB         322           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 122.7969 MiB   0.0000 MiB         322           if current == end:
    62 122.7969 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 122.7969 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 122.7969 MiB   0.0000 MiB        2889           for neighbor in current.neighbors:
    67 122.7969 MiB   0.0000 MiB        2568               if current.row != neighbor.row and current.col != neighbor.col:
    68 122.7969 MiB   0.0000 MiB        1284                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 122.7969 MiB   0.0000 MiB        1284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 122.7969 MiB   0.0000 MiB        2568               if temp_g_score < g_score[neighbor]:
    73 122.7969 MiB   0.0000 MiB         440                   came_from[neighbor] = current
    74 122.7969 MiB   0.0000 MiB         440                   g_score[neighbor] = temp_g_score
    75 122.7969 MiB   0.0000 MiB         440                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 122.7969 MiB   0.0000 MiB         440                   if neighbor not in open_set_hash:
    77 122.7969 MiB   0.0000 MiB         440                       count += 1
    78 122.7969 MiB   0.0000 MiB         440                       open_set.put((f_score[neighbor], count, neighbor))
    79 122.7969 MiB   0.0000 MiB         440                       open_set_hash.add(neighbor)
    80                                                             
    81 122.7969 MiB   0.0000 MiB         321           if draw is not None:
    82                                                     draw()
    83                                         
    84 122.7969 MiB   0.0000 MiB         321           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 122.8281 MiB 122.8281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 122.8281 MiB   0.0000 MiB         257       for row in grid:
    32 122.8281 MiB   0.0000 MiB       65792           for spot in row:
    33 122.8281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 122.8281 MiB   0.0000 MiB           1       count = 0
    36 122.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 122.8281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 122.8281 MiB   0.0000 MiB           1       came_from = {}
    39 123.0156 MiB   0.1875 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 123.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.0625 MiB   0.0469 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.0625 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.0625 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.0625 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.0625 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.0625 MiB   0.0000 MiB        4577       while not open_set.empty():
    49 123.0625 MiB   0.0000 MiB        4577           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.0625 MiB   0.0000 MiB        4577           current = open_set.get()[2]
    55 123.0625 MiB   0.0000 MiB        4577           open_set_hash.remove(current)
    56                                         
    57 123.0625 MiB   0.0000 MiB        4577           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.0625 MiB   0.0000 MiB        4577           if current == end:
    62 123.0625 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 123.0625 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.0625 MiB   0.0000 MiB       41184           for neighbor in current.neighbors:
    67 123.0625 MiB   0.0000 MiB       36608               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.0625 MiB   0.0000 MiB       18304                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.0625 MiB   0.0000 MiB       18304                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.0625 MiB   0.0000 MiB       36608               if temp_g_score < g_score[neighbor]:
    73 123.0625 MiB   0.0000 MiB        5417                   came_from[neighbor] = current
    74 123.0625 MiB   0.0000 MiB        5417                   g_score[neighbor] = temp_g_score
    75 123.0625 MiB   0.0000 MiB        5417                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.0625 MiB   0.0000 MiB        5417                   if neighbor not in open_set_hash:
    77 123.0625 MiB   0.0000 MiB        5417                       count += 1
    78 123.0625 MiB   0.0000 MiB        5417                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.0625 MiB   0.0000 MiB        5417                       open_set_hash.add(neighbor)
    80                                                             
    81 123.0625 MiB   0.0000 MiB        4576           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.0625 MiB   0.0000 MiB        4576           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 123.0625 MiB 123.0625 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 123.0625 MiB   0.0000 MiB         257       for row in grid:
    32 123.0625 MiB   0.0000 MiB       65792           for spot in row:
    33 123.0625 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 123.0625 MiB   0.0000 MiB           1       count = 0
    36 123.0625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 123.0625 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 123.0625 MiB   0.0000 MiB           1       came_from = {}
    39 123.0625 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 123.0625 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.0625 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.0625 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.0625 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.0625 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.0625 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.0625 MiB   0.0000 MiB         318       while not open_set.empty():
    49 123.0625 MiB   0.0000 MiB         318           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.0625 MiB   0.0000 MiB         318           current = open_set.get()[2]
    55 123.0625 MiB   0.0000 MiB         318           open_set_hash.remove(current)
    56                                         
    57 123.0625 MiB   0.0000 MiB         318           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.0625 MiB   0.0000 MiB         318           if current == end:
    62 123.0625 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 123.0625 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.0625 MiB   0.0000 MiB        2853           for neighbor in current.neighbors:
    67 123.0625 MiB   0.0000 MiB        2536               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.0625 MiB   0.0000 MiB        1268                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.0625 MiB   0.0000 MiB        1268                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.0625 MiB   0.0000 MiB        2536               if temp_g_score < g_score[neighbor]:
    73 123.0625 MiB   0.0000 MiB         746                   came_from[neighbor] = current
    74 123.0625 MiB   0.0000 MiB         746                   g_score[neighbor] = temp_g_score
    75 123.0625 MiB   0.0000 MiB         746                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.0625 MiB   0.0000 MiB         746                   if neighbor not in open_set_hash:
    77 123.0625 MiB   0.0000 MiB         746                       count += 1
    78 123.0625 MiB   0.0000 MiB         746                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.0625 MiB   0.0000 MiB         746                       open_set_hash.add(neighbor)
    80                                                             
    81 123.0625 MiB   0.0000 MiB         317           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.0625 MiB   0.0000 MiB         317           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 123.0625 MiB 123.0625 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 123.0625 MiB -2402.9531 MiB         257       for row in grid:
    32 123.0625 MiB -615513.3750 MiB       65792           for spot in row:
    33 123.0625 MiB -613121.0312 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 106.6875 MiB -16.3750 MiB           1       count = 0
    36 106.6875 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 106.6875 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 106.6875 MiB   0.0000 MiB           1       came_from = {}
    39 109.3906 MiB   2.7031 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 109.3906 MiB   0.0000 MiB           1       g_score[start] = 0
    41 112.9531 MiB   3.5625 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 112.9531 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 112.9531 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 112.9531 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 112.9531 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 112.9531 MiB   0.0000 MiB        1176       while not open_set.empty():
    49 112.9531 MiB   0.0000 MiB        1176           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 112.9531 MiB   0.0000 MiB        1176           current = open_set.get()[2]
    55 112.9531 MiB   0.0000 MiB        1176           open_set_hash.remove(current)
    56                                         
    57 112.9531 MiB   0.0000 MiB        1176           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 112.9531 MiB   0.0000 MiB        1176           if current == end:
    62 112.9531 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 112.9531 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 112.9531 MiB   0.0000 MiB       10575           for neighbor in current.neighbors:
    67 112.9531 MiB   0.0000 MiB        9400               if current.row != neighbor.row and current.col != neighbor.col:
    68 112.9531 MiB   0.0000 MiB        4700                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 112.9531 MiB   0.0000 MiB        4700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 112.9531 MiB   0.0000 MiB        9400               if temp_g_score < g_score[neighbor]:
    73 112.9531 MiB   0.0000 MiB        1398                   came_from[neighbor] = current
    74 112.9531 MiB   0.0000 MiB        1398                   g_score[neighbor] = temp_g_score
    75 112.9531 MiB   0.0000 MiB        1398                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 112.9531 MiB   0.0000 MiB        1398                   if neighbor not in open_set_hash:
    77 112.9531 MiB   0.0000 MiB        1398                       count += 1
    78 112.9531 MiB   0.0000 MiB        1398                       open_set.put((f_score[neighbor], count, neighbor))
    79 112.9531 MiB   0.0000 MiB        1398                       open_set_hash.add(neighbor)
    80                                                             
    81 112.9531 MiB   0.0000 MiB        1175           if draw is not None:
    82                                                     draw()
    83                                         
    84 112.9531 MiB   0.0000 MiB        1175           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 112.9531 MiB 112.9531 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 112.9531 MiB -1227.2812 MiB         257       for row in grid:
    32 112.9531 MiB -314751.2031 MiB       65792           for spot in row:
    33 112.9531 MiB -313528.3438 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 106.7031 MiB  -6.2500 MiB           1       count = 0
    36 106.7031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 106.7031 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 106.7031 MiB   0.0000 MiB           1       came_from = {}
    39 110.4531 MiB   3.7500 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 110.4531 MiB   0.0000 MiB           1       g_score[start] = 0
    41 113.0312 MiB   2.5781 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 113.0312 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 113.0312 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 113.0312 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 113.0312 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 113.0312 MiB   0.0000 MiB         820       while not open_set.empty():
    49 113.0312 MiB   0.0000 MiB         820           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 113.0312 MiB   0.0000 MiB         820           current = open_set.get()[2]
    55 113.0312 MiB   0.0000 MiB         820           open_set_hash.remove(current)
    56                                         
    57 113.0312 MiB   0.0000 MiB         820           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 113.0312 MiB   0.0000 MiB         820           if current == end:
    62 113.0312 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 113.0312 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 113.0312 MiB   0.0000 MiB        7371           for neighbor in current.neighbors:
    67 113.0312 MiB   0.0000 MiB        6552               if current.row != neighbor.row and current.col != neighbor.col:
    68 113.0312 MiB   0.0000 MiB        3276                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 113.0312 MiB   0.0000 MiB        3276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 113.0312 MiB   0.0000 MiB        6552               if temp_g_score < g_score[neighbor]:
    73 113.0312 MiB   0.0000 MiB         980                   came_from[neighbor] = current
    74 113.0312 MiB   0.0000 MiB         980                   g_score[neighbor] = temp_g_score
    75 113.0312 MiB   0.0000 MiB         980                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 113.0312 MiB   0.0000 MiB         980                   if neighbor not in open_set_hash:
    77 113.0312 MiB   0.0000 MiB         980                       count += 1
    78 113.0312 MiB   0.0000 MiB         980                       open_set.put((f_score[neighbor], count, neighbor))
    79 113.0312 MiB   0.0000 MiB         980                       open_set_hash.add(neighbor)
    80                                                             
    81 113.0312 MiB   0.0000 MiB         819           if draw is not None:
    82                                                     draw()
    83                                         
    84 113.0312 MiB   0.0000 MiB         819           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 113.1094 MiB 113.1094 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 113.1094 MiB   0.0000 MiB         257       for row in grid:
    32 113.1094 MiB   0.0000 MiB       65792           for spot in row:
    33 113.1094 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 113.1094 MiB   0.0000 MiB           1       count = 0
    36 113.1094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 113.1094 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 113.1094 MiB   0.0000 MiB           1       came_from = {}
    39 114.3281 MiB   1.2188 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 114.3281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 114.4688 MiB   0.1406 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 114.4688 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 114.4688 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 114.4688 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 114.4688 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 114.4688 MiB   0.0000 MiB        4750       while not open_set.empty():
    49 114.4688 MiB   0.0000 MiB        4750           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 114.4688 MiB   0.0000 MiB        4750           current = open_set.get()[2]
    55 114.4688 MiB   0.0000 MiB        4750           open_set_hash.remove(current)
    56                                         
    57 114.4688 MiB   0.0000 MiB        4750           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 114.4688 MiB   0.0000 MiB        4750           if current == end:
    62 114.4688 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 114.4688 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 114.4688 MiB   0.0000 MiB       42741           for neighbor in current.neighbors:
    67 114.4688 MiB   0.0000 MiB       37992               if current.row != neighbor.row and current.col != neighbor.col:
    68 114.4688 MiB   0.0000 MiB       18996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 114.4688 MiB   0.0000 MiB       18996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 114.4688 MiB   0.0000 MiB       37992               if temp_g_score < g_score[neighbor]:
    73 114.4688 MiB   0.0000 MiB        5324                   came_from[neighbor] = current
    74 114.4688 MiB   0.0000 MiB        5324                   g_score[neighbor] = temp_g_score
    75 114.4688 MiB   0.0000 MiB        5324                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 114.4688 MiB   0.0000 MiB        5324                   if neighbor not in open_set_hash:
    77 114.4688 MiB   0.0000 MiB        5324                       count += 1
    78 114.4688 MiB   0.0000 MiB        5324                       open_set.put((f_score[neighbor], count, neighbor))
    79 114.4688 MiB   0.0000 MiB        5324                       open_set_hash.add(neighbor)
    80                                                             
    81 114.4688 MiB   0.0000 MiB        4749           if draw is not None:
    82                                                     draw()
    83                                         
    84 114.4688 MiB   0.0000 MiB        4749           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 115.0000 MiB 115.0000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 115.0000 MiB   0.0000 MiB         257       for row in grid:
    32 115.0000 MiB   0.0000 MiB       65792           for spot in row:
    33 115.0000 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 115.0000 MiB   0.0000 MiB           1       count = 0
    36 115.0000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 115.0000 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 115.0000 MiB   0.0000 MiB           1       came_from = {}
    39 116.1406 MiB   1.1406 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 116.1406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.0000 MiB   1.8594 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.0000 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.0000 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.0000 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.0000 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.0000 MiB   0.0000 MiB        1323       while not open_set.empty():
    49 118.0000 MiB   0.0000 MiB        1323           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.0000 MiB   0.0000 MiB        1323           current = open_set.get()[2]
    55 118.0000 MiB   0.0000 MiB        1323           open_set_hash.remove(current)
    56                                         
    57 118.0000 MiB   0.0000 MiB        1323           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.0000 MiB   0.0000 MiB        1323           if current == end:
    62 118.0000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.0000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.0000 MiB   0.0000 MiB       11898           for neighbor in current.neighbors:
    67 118.0000 MiB   0.0000 MiB       10576               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.0000 MiB   0.0000 MiB        5288                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.0000 MiB   0.0000 MiB        5288                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.0000 MiB   0.0000 MiB       10576               if temp_g_score < g_score[neighbor]:
    73 118.0000 MiB   0.0000 MiB        1527                   came_from[neighbor] = current
    74 118.0000 MiB   0.0000 MiB        1527                   g_score[neighbor] = temp_g_score
    75 118.0000 MiB   0.0000 MiB        1527                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.0000 MiB   0.0000 MiB        1527                   if neighbor not in open_set_hash:
    77 118.0000 MiB   0.0000 MiB        1527                       count += 1
    78 118.0000 MiB   0.0000 MiB        1527                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.0000 MiB   0.0000 MiB        1527                       open_set_hash.add(neighbor)
    80                                                             
    81 118.0000 MiB   0.0000 MiB        1322           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.0000 MiB   0.0000 MiB        1322           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.1250 MiB 118.1250 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.1250 MiB   0.0000 MiB         257       for row in grid:
    32 118.1250 MiB   0.0000 MiB       65792           for spot in row:
    33 118.1250 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.1250 MiB   0.0000 MiB           1       count = 0
    36 118.1250 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.1250 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.1250 MiB   0.0000 MiB           1       came_from = {}
    39 118.1250 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 118.1250 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.1250 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.1250 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.1250 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.1250 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.1250 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.1250 MiB   0.0000 MiB       12580       while not open_set.empty():
    49 118.1250 MiB   0.0000 MiB       12580           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.1250 MiB   0.0000 MiB       12580           current = open_set.get()[2]
    55 118.1250 MiB   0.0000 MiB       12580           open_set_hash.remove(current)
    56                                         
    57 118.1250 MiB   0.0000 MiB       12580           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.1250 MiB   0.0000 MiB       12580           if current == end:
    62 118.1250 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.1250 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.1250 MiB   0.0000 MiB      113211           for neighbor in current.neighbors:
    67 118.1250 MiB   0.0000 MiB      100632               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.1250 MiB   0.0000 MiB       50316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.1250 MiB   0.0000 MiB       50316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.1250 MiB   0.0000 MiB      100632               if temp_g_score < g_score[neighbor]:
    73 118.1250 MiB   0.0000 MiB       13214                   came_from[neighbor] = current
    74 118.1250 MiB   0.0000 MiB       13214                   g_score[neighbor] = temp_g_score
    75 118.1250 MiB   0.0000 MiB       13214                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.1250 MiB   0.0000 MiB       13214                   if neighbor not in open_set_hash:
    77 118.1250 MiB   0.0000 MiB       13214                       count += 1
    78 118.1250 MiB   0.0000 MiB       13214                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.1250 MiB   0.0000 MiB       13214                       open_set_hash.add(neighbor)
    80                                                             
    81 118.1250 MiB   0.0000 MiB       12579           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.1250 MiB   0.0000 MiB       12579           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.1250 MiB 118.1250 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.1250 MiB   0.0000 MiB         257       for row in grid:
    32 118.1250 MiB   0.0000 MiB       65792           for spot in row:
    33 118.1250 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.1250 MiB   0.0000 MiB           1       count = 0
    36 118.1250 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.1250 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.1250 MiB   0.0000 MiB           1       came_from = {}
    39 118.1250 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 118.1250 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.5000 MiB   0.3750 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.5000 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.5000 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.5000 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.5000 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.5000 MiB   0.0000 MiB        1656       while not open_set.empty():
    49 118.5000 MiB   0.0000 MiB        1656           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.5000 MiB   0.0000 MiB        1656           current = open_set.get()[2]
    55 118.5000 MiB   0.0000 MiB        1656           open_set_hash.remove(current)
    56                                         
    57 118.5000 MiB   0.0000 MiB        1656           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.5000 MiB   0.0000 MiB        1656           if current == end:
    62 118.5000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.5000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.5000 MiB   0.0000 MiB       14895           for neighbor in current.neighbors:
    67 118.5000 MiB   0.0000 MiB       13240               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.5000 MiB   0.0000 MiB        6620                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.5000 MiB   0.0000 MiB        6620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.5000 MiB   0.0000 MiB       13240               if temp_g_score < g_score[neighbor]:
    73 118.5000 MiB   0.0000 MiB        1978                   came_from[neighbor] = current
    74 118.5000 MiB   0.0000 MiB        1978                   g_score[neighbor] = temp_g_score
    75 118.5000 MiB   0.0000 MiB        1978                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.5000 MiB   0.0000 MiB        1978                   if neighbor not in open_set_hash:
    77 118.5000 MiB   0.0000 MiB        1978                       count += 1
    78 118.5000 MiB   0.0000 MiB        1978                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.5000 MiB   0.0000 MiB        1978                       open_set_hash.add(neighbor)
    80                                                             
    81 118.5000 MiB   0.0000 MiB        1655           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.5000 MiB   0.0000 MiB        1655           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.5000 MiB 118.5000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.5000 MiB   0.0000 MiB         257       for row in grid:
    32 118.5000 MiB   0.0000 MiB       65792           for spot in row:
    33 118.5000 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.5000 MiB   0.0000 MiB           1       count = 0
    36 118.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.5000 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.5000 MiB   0.0000 MiB           1       came_from = {}
    39 119.2656 MiB   0.7656 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 119.2656 MiB   0.0000 MiB           1       g_score[start] = 0
    41 119.2656 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 119.2656 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 119.2656 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 119.2656 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 119.2656 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 119.2656 MiB   0.0000 MiB         660       while not open_set.empty():
    49 119.2656 MiB   0.0000 MiB         660           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 119.2656 MiB   0.0000 MiB         660           current = open_set.get()[2]
    55 119.2656 MiB   0.0000 MiB         660           open_set_hash.remove(current)
    56                                         
    57 119.2656 MiB   0.0000 MiB         660           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 119.2656 MiB   0.0000 MiB         660           if current == end:
    62 119.2656 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 119.2656 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 119.2656 MiB   0.0000 MiB        5931           for neighbor in current.neighbors:
    67 119.2656 MiB   0.0000 MiB        5272               if current.row != neighbor.row and current.col != neighbor.col:
    68 119.2656 MiB   0.0000 MiB        2636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 119.2656 MiB   0.0000 MiB        2636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 119.2656 MiB   0.0000 MiB        5272               if temp_g_score < g_score[neighbor]:
    73 119.2656 MiB   0.0000 MiB         816                   came_from[neighbor] = current
    74 119.2656 MiB   0.0000 MiB         816                   g_score[neighbor] = temp_g_score
    75 119.2656 MiB   0.0000 MiB         816                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 119.2656 MiB   0.0000 MiB         816                   if neighbor not in open_set_hash:
    77 119.2656 MiB   0.0000 MiB         816                       count += 1
    78 119.2656 MiB   0.0000 MiB         816                       open_set.put((f_score[neighbor], count, neighbor))
    79 119.2656 MiB   0.0000 MiB         816                       open_set_hash.add(neighbor)
    80                                                             
    81 119.2656 MiB   0.0000 MiB         659           if draw is not None:
    82                                                     draw()
    83                                         
    84 119.2656 MiB   0.0000 MiB         659           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 119.2969 MiB 119.2969 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 119.2969 MiB   0.0000 MiB         257       for row in grid:
    32 119.2969 MiB   0.0000 MiB       65792           for spot in row:
    33 119.2969 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 119.2969 MiB   0.0000 MiB           1       count = 0
    36 119.2969 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 119.2969 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 119.2969 MiB   0.0000 MiB           1       came_from = {}
    39 119.2969 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 119.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 121.8125 MiB   2.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 121.8125 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 121.8125 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 121.8125 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 121.8125 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 121.8125 MiB   0.0000 MiB        2744       while not open_set.empty():
    49 121.8125 MiB   0.0000 MiB        2744           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 121.8125 MiB   0.0000 MiB        2744           current = open_set.get()[2]
    55 121.8125 MiB   0.0000 MiB        2744           open_set_hash.remove(current)
    56                                         
    57 121.8125 MiB   0.0000 MiB        2744           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 121.8125 MiB   0.0000 MiB        2744           if current == end:
    62 121.8125 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 121.8125 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 121.8125 MiB   0.0000 MiB       24687           for neighbor in current.neighbors:
    67 121.8125 MiB   0.0000 MiB       21944               if current.row != neighbor.row and current.col != neighbor.col:
    68 121.8125 MiB   0.0000 MiB       10972                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 121.8125 MiB   0.0000 MiB       10972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 121.8125 MiB   0.0000 MiB       21944               if temp_g_score < g_score[neighbor]:
    73 121.8125 MiB   0.0000 MiB        3190                   came_from[neighbor] = current
    74 121.8125 MiB   0.0000 MiB        3190                   g_score[neighbor] = temp_g_score
    75 121.8125 MiB   0.0000 MiB        3190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 121.8125 MiB   0.0000 MiB        3190                   if neighbor not in open_set_hash:
    77 121.8125 MiB   0.0000 MiB        3190                       count += 1
    78 121.8125 MiB   0.0000 MiB        3190                       open_set.put((f_score[neighbor], count, neighbor))
    79 121.8125 MiB   0.0000 MiB        3190                       open_set_hash.add(neighbor)
    80                                                             
    81 121.8125 MiB   0.0000 MiB        2743           if draw is not None:
    82                                                     draw()
    83                                         
    84 121.8125 MiB   0.0000 MiB        2743           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 121.8281 MiB 121.8281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 121.8281 MiB   0.0000 MiB         257       for row in grid:
    32 121.8281 MiB   0.0000 MiB       65792           for spot in row:
    33 121.8281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 121.8281 MiB   0.0000 MiB           1       count = 0
    36 121.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 121.8281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 121.8281 MiB   0.0000 MiB           1       came_from = {}
    39 121.8281 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 121.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 124.3438 MiB   2.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 124.3438 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 124.3438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 124.3438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 124.3438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 124.3438 MiB   0.0000 MiB        5740       while not open_set.empty():
    49 124.3438 MiB   0.0000 MiB        5740           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 124.3438 MiB   0.0000 MiB        5740           current = open_set.get()[2]
    55 124.3438 MiB   0.0000 MiB        5740           open_set_hash.remove(current)
    56                                         
    57 124.3438 MiB   0.0000 MiB        5740           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 124.3438 MiB   0.0000 MiB        5740           if current == end:
    62 124.3438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 124.3438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 124.3438 MiB   0.0000 MiB       51651           for neighbor in current.neighbors:
    67 124.3438 MiB   0.0000 MiB       45912               if current.row != neighbor.row and current.col != neighbor.col:
    68 124.3438 MiB   0.0000 MiB       22956                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 124.3438 MiB   0.0000 MiB       22956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 124.3438 MiB   0.0000 MiB       45912               if temp_g_score < g_score[neighbor]:
    73 124.3438 MiB   0.0000 MiB        6206                   came_from[neighbor] = current
    74 124.3438 MiB   0.0000 MiB        6206                   g_score[neighbor] = temp_g_score
    75 124.3438 MiB   0.0000 MiB        6206                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 124.3438 MiB   0.0000 MiB        6206                   if neighbor not in open_set_hash:
    77 124.3438 MiB   0.0000 MiB        6206                       count += 1
    78 124.3438 MiB   0.0000 MiB        6206                       open_set.put((f_score[neighbor], count, neighbor))
    79 124.3438 MiB   0.0000 MiB        6206                       open_set_hash.add(neighbor)
    80                                                             
    81 124.3438 MiB   0.0000 MiB        5739           if draw is not None:
    82                                                     draw()
    83                                         
    84 124.3438 MiB   0.0000 MiB        5739           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 124.3438 MiB 124.3438 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 124.3438 MiB   0.0000 MiB         257       for row in grid:
    32 124.3438 MiB   0.0000 MiB       65792           for spot in row:
    33 124.3438 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 124.3438 MiB   0.0000 MiB           1       count = 0
    36 124.3438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 124.3438 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 124.3438 MiB   0.0000 MiB           1       came_from = {}
    39 124.3438 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 124.3438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 125.5625 MiB   1.2188 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 125.5625 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 125.5625 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 125.5625 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 125.5625 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 125.5625 MiB   0.0000 MiB          44       while not open_set.empty():
    49 125.5625 MiB   0.0000 MiB          44           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 125.5625 MiB   0.0000 MiB          44           current = open_set.get()[2]
    55 125.5625 MiB   0.0000 MiB          44           open_set_hash.remove(current)
    56                                         
    57 125.5625 MiB   0.0000 MiB          44           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 125.5625 MiB   0.0000 MiB          44           if current == end:
    62 125.5625 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 125.5625 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 125.5625 MiB   0.0000 MiB         387           for neighbor in current.neighbors:
    67 125.5625 MiB   0.0000 MiB         344               if current.row != neighbor.row and current.col != neighbor.col:
    68 125.5625 MiB   0.0000 MiB         172                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 125.5625 MiB   0.0000 MiB         172                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 125.5625 MiB   0.0000 MiB         344               if temp_g_score < g_score[neighbor]:
    73 125.5625 MiB   0.0000 MiB          94                   came_from[neighbor] = current
    74 125.5625 MiB   0.0000 MiB          94                   g_score[neighbor] = temp_g_score
    75 125.5625 MiB   0.0000 MiB          94                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 125.5625 MiB   0.0000 MiB          94                   if neighbor not in open_set_hash:
    77 125.5625 MiB   0.0000 MiB          94                       count += 1
    78 125.5625 MiB   0.0000 MiB          94                       open_set.put((f_score[neighbor], count, neighbor))
    79 125.5625 MiB   0.0000 MiB          94                       open_set_hash.add(neighbor)
    80                                                             
    81 125.5625 MiB   0.0000 MiB          43           if draw is not None:
    82                                                     draw()
    83                                         
    84 125.5625 MiB   0.0000 MiB          43           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 125.6406 MiB 125.6406 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 125.6406 MiB   0.0000 MiB         257       for row in grid:
    32 125.6406 MiB   0.0000 MiB       65792           for spot in row:
    33 125.6406 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 125.6406 MiB   0.0000 MiB           1       count = 0
    36 125.6406 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 125.6406 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 125.6406 MiB   0.0000 MiB           1       came_from = {}
    39 125.9375 MiB   0.2969 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 125.9375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 125.9375 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 125.9375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 125.9375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 125.9375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 125.9375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 125.9375 MiB   0.0000 MiB         576       while not open_set.empty():
    49 125.9375 MiB   0.0000 MiB         576           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 125.9375 MiB   0.0000 MiB         576           current = open_set.get()[2]
    55 125.9375 MiB   0.0000 MiB         576           open_set_hash.remove(current)
    56                                         
    57 125.9375 MiB   0.0000 MiB         576           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 125.9375 MiB   0.0000 MiB         576           if current == end:
    62 125.9375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 125.9375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 125.9375 MiB   0.0000 MiB        5175           for neighbor in current.neighbors:
    67 125.9375 MiB   0.0000 MiB        4600               if current.row != neighbor.row and current.col != neighbor.col:
    68 125.9375 MiB   0.0000 MiB        2300                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 125.9375 MiB   0.0000 MiB        2300                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 125.9375 MiB   0.0000 MiB        4600               if temp_g_score < g_score[neighbor]:
    73 125.9375 MiB   0.0000 MiB         738                   came_from[neighbor] = current
    74 125.9375 MiB   0.0000 MiB         738                   g_score[neighbor] = temp_g_score
    75 125.9375 MiB   0.0000 MiB         738                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 125.9375 MiB   0.0000 MiB         738                   if neighbor not in open_set_hash:
    77 125.9375 MiB   0.0000 MiB         738                       count += 1
    78 125.9375 MiB   0.0000 MiB         738                       open_set.put((f_score[neighbor], count, neighbor))
    79 125.9375 MiB   0.0000 MiB         738                       open_set_hash.add(neighbor)
    80                                                             
    81 125.9375 MiB   0.0000 MiB         575           if draw is not None:
    82                                                     draw()
    83                                         
    84 125.9375 MiB   0.0000 MiB         575           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 125.9375 MiB 125.9375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 125.9375 MiB   0.0000 MiB         257       for row in grid:
    32 125.9375 MiB   0.0000 MiB       65792           for spot in row:
    33 125.9375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 125.9375 MiB   0.0000 MiB           1       count = 0
    36 125.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 125.9375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 125.9375 MiB   0.0000 MiB           1       came_from = {}
    39 127.4375 MiB   1.5000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 127.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.1719 MiB   0.7344 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1719 MiB   0.0000 MiB          88       while not open_set.empty():
    49 128.1719 MiB   0.0000 MiB          88           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1719 MiB   0.0000 MiB          88           current = open_set.get()[2]
    55 128.1719 MiB   0.0000 MiB          88           open_set_hash.remove(current)
    56                                         
    57 128.1719 MiB   0.0000 MiB          88           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1719 MiB   0.0000 MiB          88           if current == end:
    62 128.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1719 MiB   0.0000 MiB         783           for neighbor in current.neighbors:
    67 128.1719 MiB   0.0000 MiB         696               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1719 MiB   0.0000 MiB         348                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1719 MiB   0.0000 MiB         348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1719 MiB   0.0000 MiB         696               if temp_g_score < g_score[neighbor]:
    73 128.1719 MiB   0.0000 MiB         182                   came_from[neighbor] = current
    74 128.1719 MiB   0.0000 MiB         182                   g_score[neighbor] = temp_g_score
    75 128.1719 MiB   0.0000 MiB         182                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1719 MiB   0.0000 MiB         182                   if neighbor not in open_set_hash:
    77 128.1719 MiB   0.0000 MiB         182                       count += 1
    78 128.1719 MiB   0.0000 MiB         182                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1719 MiB   0.0000 MiB         182                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1719 MiB   0.0000 MiB          87           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1719 MiB   0.0000 MiB          87           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.1719 MiB 128.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.1719 MiB   0.0000 MiB         257       for row in grid:
    32 128.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 128.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.1719 MiB   0.0000 MiB           1       count = 0
    36 128.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.1719 MiB   0.0000 MiB           1       came_from = {}
    39 128.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1719 MiB   0.0000 MiB        4602       while not open_set.empty():
    49 128.1719 MiB   0.0000 MiB        4602           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1719 MiB   0.0000 MiB        4602           current = open_set.get()[2]
    55 128.1719 MiB   0.0000 MiB        4602           open_set_hash.remove(current)
    56                                         
    57 128.1719 MiB   0.0000 MiB        4602           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1719 MiB   0.0000 MiB        4602           if current == end:
    62 128.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1719 MiB   0.0000 MiB       41409           for neighbor in current.neighbors:
    67 128.1719 MiB   0.0000 MiB       36808               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1719 MiB   0.0000 MiB       18404                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1719 MiB   0.0000 MiB       18404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1719 MiB   0.0000 MiB       36808               if temp_g_score < g_score[neighbor]:
    73 128.1719 MiB   0.0000 MiB        4992                   came_from[neighbor] = current
    74 128.1719 MiB   0.0000 MiB        4992                   g_score[neighbor] = temp_g_score
    75 128.1719 MiB   0.0000 MiB        4992                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1719 MiB   0.0000 MiB        4992                   if neighbor not in open_set_hash:
    77 128.1719 MiB   0.0000 MiB        4992                       count += 1
    78 128.1719 MiB   0.0000 MiB        4992                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1719 MiB   0.0000 MiB        4992                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1719 MiB   0.0000 MiB        4601           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1719 MiB   0.0000 MiB        4601           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.1719 MiB 128.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.1719 MiB   0.0000 MiB         257       for row in grid:
    32 128.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 128.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.1719 MiB   0.0000 MiB           1       count = 0
    36 128.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.1719 MiB   0.0000 MiB           1       came_from = {}
    39 128.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1719 MiB   0.0000 MiB        3344       while not open_set.empty():
    49 128.1719 MiB   0.0000 MiB        3344           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1719 MiB   0.0000 MiB        3344           current = open_set.get()[2]
    55 128.1719 MiB   0.0000 MiB        3344           open_set_hash.remove(current)
    56                                         
    57 128.1719 MiB   0.0000 MiB        3344           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1719 MiB   0.0000 MiB        3344           if current == end:
    62 128.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1719 MiB   0.0000 MiB       30087           for neighbor in current.neighbors:
    67 128.1719 MiB   0.0000 MiB       26744               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1719 MiB   0.0000 MiB       13372                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1719 MiB   0.0000 MiB       13372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1719 MiB   0.0000 MiB       26744               if temp_g_score < g_score[neighbor]:
    73 128.1719 MiB   0.0000 MiB        3734                   came_from[neighbor] = current
    74 128.1719 MiB   0.0000 MiB        3734                   g_score[neighbor] = temp_g_score
    75 128.1719 MiB   0.0000 MiB        3734                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1719 MiB   0.0000 MiB        3734                   if neighbor not in open_set_hash:
    77 128.1719 MiB   0.0000 MiB        3734                       count += 1
    78 128.1719 MiB   0.0000 MiB        3734                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1719 MiB   0.0000 MiB        3734                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1719 MiB   0.0000 MiB        3343           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1719 MiB   0.0000 MiB        3343           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.1719 MiB 128.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.1719 MiB   0.0000 MiB         257       for row in grid:
    32 128.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 128.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.1719 MiB   0.0000 MiB           1       count = 0
    36 128.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.1719 MiB   0.0000 MiB           1       came_from = {}
    39 128.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1719 MiB   0.0000 MiB        1040       while not open_set.empty():
    49 128.1719 MiB   0.0000 MiB        1040           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1719 MiB   0.0000 MiB        1040           current = open_set.get()[2]
    55 128.1719 MiB   0.0000 MiB        1040           open_set_hash.remove(current)
    56                                         
    57 128.1719 MiB   0.0000 MiB        1040           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1719 MiB   0.0000 MiB        1040           if current == end:
    62 128.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1719 MiB   0.0000 MiB        9351           for neighbor in current.neighbors:
    67 128.1719 MiB   0.0000 MiB        8312               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1719 MiB   0.0000 MiB        4156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1719 MiB   0.0000 MiB        4156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1719 MiB   0.0000 MiB        8312               if temp_g_score < g_score[neighbor]:
    73 128.1719 MiB   0.0000 MiB        1232                   came_from[neighbor] = current
    74 128.1719 MiB   0.0000 MiB        1232                   g_score[neighbor] = temp_g_score
    75 128.1719 MiB   0.0000 MiB        1232                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1719 MiB   0.0000 MiB        1232                   if neighbor not in open_set_hash:
    77 128.1719 MiB   0.0000 MiB        1232                       count += 1
    78 128.1719 MiB   0.0000 MiB        1232                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1719 MiB   0.0000 MiB        1232                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1719 MiB   0.0000 MiB        1039           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1719 MiB   0.0000 MiB        1039           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.1719 MiB 128.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.1719 MiB   0.0000 MiB         257       for row in grid:
    32 128.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 128.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.1719 MiB   0.0000 MiB           1       count = 0
    36 128.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.1719 MiB   0.0000 MiB           1       came_from = {}
    39 128.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.7656 MiB   0.5938 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.7656 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.7656 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.7656 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.7656 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.7656 MiB   0.0000 MiB        3799       while not open_set.empty():
    49 128.7656 MiB   0.0000 MiB        3799           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.7656 MiB   0.0000 MiB        3799           current = open_set.get()[2]
    55 128.7656 MiB   0.0000 MiB        3799           open_set_hash.remove(current)
    56                                         
    57 128.7656 MiB   0.0000 MiB        3799           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.7656 MiB   0.0000 MiB        3799           if current == end:
    62 128.7656 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.7656 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.7656 MiB   0.0000 MiB       34182           for neighbor in current.neighbors:
    67 128.7656 MiB   0.0000 MiB       30384               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.7656 MiB   0.0000 MiB       15192                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.7656 MiB   0.0000 MiB       15192                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.7656 MiB   0.0000 MiB       30384               if temp_g_score < g_score[neighbor]:
    73 128.7656 MiB   0.0000 MiB        4175                   came_from[neighbor] = current
    74 128.7656 MiB   0.0000 MiB        4175                   g_score[neighbor] = temp_g_score
    75 128.7656 MiB   0.0000 MiB        4175                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.7656 MiB   0.0000 MiB        4175                   if neighbor not in open_set_hash:
    77 128.7656 MiB   0.0000 MiB        4175                       count += 1
    78 128.7656 MiB   0.0000 MiB        4175                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.7656 MiB   0.0000 MiB        4175                       open_set_hash.add(neighbor)
    80                                                             
    81 128.7656 MiB   0.0000 MiB        3798           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.7656 MiB   0.0000 MiB        3798           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.7656 MiB 128.7656 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.7656 MiB   0.0000 MiB         257       for row in grid:
    32 128.7656 MiB   0.0000 MiB       65792           for spot in row:
    33 128.7656 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.7656 MiB   0.0000 MiB           1       count = 0
    36 128.7656 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.7656 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.7656 MiB   0.0000 MiB           1       came_from = {}
    39 128.7656 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.7656 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.7969 MiB   0.0312 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.7969 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.7969 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.7969 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.7969 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.7969 MiB   0.0000 MiB        2448       while not open_set.empty():
    49 128.7969 MiB   0.0000 MiB        2448           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.7969 MiB   0.0000 MiB        2448           current = open_set.get()[2]
    55 128.7969 MiB   0.0000 MiB        2448           open_set_hash.remove(current)
    56                                         
    57 128.7969 MiB   0.0000 MiB        2448           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.7969 MiB   0.0000 MiB        2448           if current == end:
    62 128.7969 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.7969 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.7969 MiB   0.0000 MiB       22023           for neighbor in current.neighbors:
    67 128.7969 MiB   0.0000 MiB       19576               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.7969 MiB   0.0000 MiB        9788                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.7969 MiB   0.0000 MiB        9788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.7969 MiB   0.0000 MiB       19576               if temp_g_score < g_score[neighbor]:
    73 128.7969 MiB   0.0000 MiB        2790                   came_from[neighbor] = current
    74 128.7969 MiB   0.0000 MiB        2790                   g_score[neighbor] = temp_g_score
    75 128.7969 MiB   0.0000 MiB        2790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.7969 MiB   0.0000 MiB        2790                   if neighbor not in open_set_hash:
    77 128.7969 MiB   0.0000 MiB        2790                       count += 1
    78 128.7969 MiB   0.0000 MiB        2790                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.7969 MiB   0.0000 MiB        2790                       open_set_hash.add(neighbor)
    80                                                             
    81 128.7969 MiB   0.0000 MiB        2447           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.7969 MiB   0.0000 MiB        2447           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.7969 MiB 128.7969 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.7969 MiB   0.0000 MiB         257       for row in grid:
    32 128.7969 MiB   0.0000 MiB       65792           for spot in row:
    33 128.7969 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.7969 MiB   0.0000 MiB           1       count = 0
    36 128.7969 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.7969 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.7969 MiB   0.0000 MiB           1       came_from = {}
    39 129.6562 MiB   0.8594 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.6562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.7812 MiB   0.1250 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.7812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.7812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.7812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.7812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.7812 MiB   0.0000 MiB        6700       while not open_set.empty():
    49 129.7812 MiB   0.0000 MiB        6700           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.7812 MiB   0.0000 MiB        6700           current = open_set.get()[2]
    55 129.7812 MiB   0.0000 MiB        6700           open_set_hash.remove(current)
    56                                         
    57 129.7812 MiB   0.0000 MiB        6700           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.7812 MiB   0.0000 MiB        6700           if current == end:
    62 129.7812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.7812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.7812 MiB   0.0000 MiB       60291           for neighbor in current.neighbors:
    67 129.7812 MiB   0.0000 MiB       53592               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.7812 MiB   0.0000 MiB       26796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.7812 MiB   0.0000 MiB       26796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.7812 MiB   0.0000 MiB       53592               if temp_g_score < g_score[neighbor]:
    73 129.7812 MiB   0.0000 MiB        7166                   came_from[neighbor] = current
    74 129.7812 MiB   0.0000 MiB        7166                   g_score[neighbor] = temp_g_score
    75 129.7812 MiB   0.0000 MiB        7166                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.7812 MiB   0.0000 MiB        7166                   if neighbor not in open_set_hash:
    77 129.7812 MiB   0.0000 MiB        7166                       count += 1
    78 129.7812 MiB   0.0000 MiB        7166                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.7812 MiB   0.0000 MiB        7166                       open_set_hash.add(neighbor)
    80                                                             
    81 129.7812 MiB   0.0000 MiB        6699           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.7812 MiB   0.0000 MiB        6699           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.7812 MiB 129.7812 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.7812 MiB   0.0000 MiB         257       for row in grid:
    32 129.7812 MiB   0.0000 MiB       65792           for spot in row:
    33 129.7812 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.7812 MiB   0.0000 MiB           1       count = 0
    36 129.7812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.7812 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.7812 MiB   0.0000 MiB           1       came_from = {}
    39 129.7812 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.7812 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.7812 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.7812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.7812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.7812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.7812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.7812 MiB   0.0000 MiB        6750       while not open_set.empty():
    49 129.7812 MiB   0.0000 MiB        6750           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.7812 MiB   0.0000 MiB        6750           current = open_set.get()[2]
    55 129.7812 MiB   0.0000 MiB        6750           open_set_hash.remove(current)
    56                                         
    57 129.7812 MiB   0.0000 MiB        6750           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.7812 MiB   0.0000 MiB        6750           if current == end:
    62 129.7812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.7812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.7812 MiB   0.0000 MiB       60741           for neighbor in current.neighbors:
    67 129.7812 MiB   0.0000 MiB       53992               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.7812 MiB   0.0000 MiB       26996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.7812 MiB   0.0000 MiB       26996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.7812 MiB   0.0000 MiB       53992               if temp_g_score < g_score[neighbor]:
    73 129.7812 MiB   0.0000 MiB        7218                   came_from[neighbor] = current
    74 129.7812 MiB   0.0000 MiB        7218                   g_score[neighbor] = temp_g_score
    75 129.7812 MiB   0.0000 MiB        7218                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.7812 MiB   0.0000 MiB        7218                   if neighbor not in open_set_hash:
    77 129.7812 MiB   0.0000 MiB        7218                       count += 1
    78 129.7812 MiB   0.0000 MiB        7218                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.7812 MiB   0.0000 MiB        7218                       open_set_hash.add(neighbor)
    80                                                             
    81 129.7812 MiB   0.0000 MiB        6749           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.7812 MiB   0.0000 MiB        6749           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.7812 MiB 129.7812 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.7812 MiB   0.0000 MiB         257       for row in grid:
    32 129.7812 MiB   0.0000 MiB       65792           for spot in row:
    33 129.7812 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.7812 MiB   0.0000 MiB           1       count = 0
    36 129.7812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.7812 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.7812 MiB   0.0000 MiB           1       came_from = {}
    39 129.7812 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.7812 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.7812 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.7812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.7812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.7812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.7812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.7812 MiB   0.0000 MiB       13892       while not open_set.empty():
    49 129.7812 MiB   0.0000 MiB       13892           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.7812 MiB   0.0000 MiB       13892           current = open_set.get()[2]
    55 129.7812 MiB   0.0000 MiB       13892           open_set_hash.remove(current)
    56                                         
    57 129.7812 MiB   0.0000 MiB       13892           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.7812 MiB   0.0000 MiB       13892           if current == end:
    62 129.7812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.7812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.7812 MiB   0.0000 MiB      125019           for neighbor in current.neighbors:
    67 129.7812 MiB   0.0000 MiB      111128               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.7812 MiB   0.0000 MiB       55564                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.7812 MiB   0.0000 MiB       55564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.7812 MiB   0.0000 MiB      111128               if temp_g_score < g_score[neighbor]:
    73 129.7812 MiB   0.0000 MiB       14560                   came_from[neighbor] = current
    74 129.7812 MiB   0.0000 MiB       14560                   g_score[neighbor] = temp_g_score
    75 129.7812 MiB   0.0000 MiB       14560                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.7812 MiB   0.0000 MiB       14560                   if neighbor not in open_set_hash:
    77 129.7812 MiB   0.0000 MiB       14560                       count += 1
    78 129.7812 MiB   0.0000 MiB       14560                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.7812 MiB   0.0000 MiB       14560                       open_set_hash.add(neighbor)
    80                                                             
    81 129.7812 MiB   0.0000 MiB       13891           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.7812 MiB   0.0000 MiB       13891           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.7812 MiB 129.7812 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.7812 MiB   0.0000 MiB         257       for row in grid:
    32 129.7812 MiB   0.0000 MiB       65792           for spot in row:
    33 129.7812 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.7812 MiB   0.0000 MiB           1       count = 0
    36 129.7812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.7812 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.7812 MiB   0.0000 MiB           1       came_from = {}
    39 129.7812 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.7812 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.7812 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.7812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.7812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.7812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.7812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.7812 MiB   0.0000 MiB        4104       while not open_set.empty():
    49 129.7812 MiB   0.0000 MiB        4104           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.7812 MiB   0.0000 MiB        4104           current = open_set.get()[2]
    55 129.7812 MiB   0.0000 MiB        4104           open_set_hash.remove(current)
    56                                         
    57 129.7812 MiB   0.0000 MiB        4104           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.7812 MiB   0.0000 MiB        4104           if current == end:
    62 129.7812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.7812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.7812 MiB   0.0000 MiB       36927           for neighbor in current.neighbors:
    67 129.7812 MiB   0.0000 MiB       32824               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.7812 MiB   0.0000 MiB       16412                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.7812 MiB   0.0000 MiB       16412                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.7812 MiB   0.0000 MiB       32824               if temp_g_score < g_score[neighbor]:
    73 129.7812 MiB   0.0000 MiB        4764                   came_from[neighbor] = current
    74 129.7812 MiB   0.0000 MiB        4764                   g_score[neighbor] = temp_g_score
    75 129.7812 MiB   0.0000 MiB        4764                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.7812 MiB   0.0000 MiB        4764                   if neighbor not in open_set_hash:
    77 129.7812 MiB   0.0000 MiB        4764                       count += 1
    78 129.7812 MiB   0.0000 MiB        4764                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.7812 MiB   0.0000 MiB        4764                       open_set_hash.add(neighbor)
    80                                                             
    81 129.7812 MiB   0.0000 MiB        4103           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.7812 MiB   0.0000 MiB        4103           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 131.7031 MiB 131.7031 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 131.7031 MiB   0.0000 MiB         257       for row in grid:
    32 131.7031 MiB   0.0000 MiB       65792           for spot in row:
    33 131.7031 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 131.7031 MiB   0.0000 MiB           1       count = 0
    36 131.7031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 131.7031 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 131.7031 MiB   0.0000 MiB           1       came_from = {}
    39 131.7031 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 131.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.3125 MiB   2.6094 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.3125 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.3125 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.3125 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.3125 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.3125 MiB   0.0000 MiB        4797       while not open_set.empty():
    49 134.3125 MiB   0.0000 MiB        4797           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.3125 MiB   0.0000 MiB        4797           current = open_set.get()[2]
    55 134.3125 MiB   0.0000 MiB        4797           open_set_hash.remove(current)
    56                                         
    57 134.3125 MiB   0.0000 MiB        4797           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.3125 MiB   0.0000 MiB        4797           if current == end:
    62 134.3125 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.3125 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.3125 MiB   0.0000 MiB       43164           for neighbor in current.neighbors:
    67 134.3125 MiB   0.0000 MiB       38368               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.3125 MiB   0.0000 MiB       19184                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.3125 MiB   0.0000 MiB       19184                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.3125 MiB   0.0000 MiB       38368               if temp_g_score < g_score[neighbor]:
    73 134.3125 MiB   0.0000 MiB        5193                   came_from[neighbor] = current
    74 134.3125 MiB   0.0000 MiB        5193                   g_score[neighbor] = temp_g_score
    75 134.3125 MiB   0.0000 MiB        5193                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.3125 MiB   0.0000 MiB        5193                   if neighbor not in open_set_hash:
    77 134.3125 MiB   0.0000 MiB        5193                       count += 1
    78 134.3125 MiB   0.0000 MiB        5193                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.3125 MiB   0.0000 MiB        5193                       open_set_hash.add(neighbor)
    80                                                             
    81 134.3125 MiB   0.0000 MiB        4796           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.3125 MiB   0.0000 MiB        4796           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.3125 MiB 134.3125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.3125 MiB   0.0000 MiB         257       for row in grid:
    32 134.3125 MiB   0.0000 MiB       65792           for spot in row:
    33 134.3125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.3125 MiB   0.0000 MiB           1       count = 0
    36 134.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.3125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.3125 MiB   0.0000 MiB           1       came_from = {}
    39 134.3125 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.3125 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.2500 MiB   1.9375 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.2500 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.2500 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.2500 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.2500 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.2500 MiB   0.0000 MiB         200       while not open_set.empty():
    49 136.2500 MiB   0.0000 MiB         200           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.2500 MiB   0.0000 MiB         200           current = open_set.get()[2]
    55 136.2500 MiB   0.0000 MiB         200           open_set_hash.remove(current)
    56                                         
    57 136.2500 MiB   0.0000 MiB         200           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.2500 MiB   0.0000 MiB         200           if current == end:
    62 136.2500 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.2500 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.2500 MiB   0.0000 MiB        1791           for neighbor in current.neighbors:
    67 136.2500 MiB   0.0000 MiB        1592               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.2500 MiB   0.0000 MiB         796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.2500 MiB   0.0000 MiB         796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.2500 MiB   0.0000 MiB        1592               if temp_g_score < g_score[neighbor]:
    73 136.2500 MiB   0.0000 MiB         314                   came_from[neighbor] = current
    74 136.2500 MiB   0.0000 MiB         314                   g_score[neighbor] = temp_g_score
    75 136.2500 MiB   0.0000 MiB         314                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.2500 MiB   0.0000 MiB         314                   if neighbor not in open_set_hash:
    77 136.2500 MiB   0.0000 MiB         314                       count += 1
    78 136.2500 MiB   0.0000 MiB         314                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.2500 MiB   0.0000 MiB         314                       open_set_hash.add(neighbor)
    80                                                             
    81 136.2500 MiB   0.0000 MiB         199           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.2500 MiB   0.0000 MiB         199           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.2500 MiB 136.2500 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.2500 MiB   0.0000 MiB         257       for row in grid:
    32 136.2500 MiB   0.0000 MiB       65792           for spot in row:
    33 136.2500 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.2500 MiB   0.0000 MiB           1       count = 0
    36 136.2500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.2500 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.2500 MiB   0.0000 MiB           1       came_from = {}
    39 136.2500 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.2500 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.2500 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.2500 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.2500 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.2500 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.2500 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.2500 MiB   0.0000 MiB         730       while not open_set.empty():
    49 136.2500 MiB   0.0000 MiB         730           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.2500 MiB   0.0000 MiB         730           current = open_set.get()[2]
    55 136.2500 MiB   0.0000 MiB         730           open_set_hash.remove(current)
    56                                         
    57 136.2500 MiB   0.0000 MiB         730           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.2500 MiB   0.0000 MiB         730           if current == end:
    62 136.2500 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.2500 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.2500 MiB   0.0000 MiB        6561           for neighbor in current.neighbors:
    67 136.2500 MiB   0.0000 MiB        5832               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.2500 MiB   0.0000 MiB        2916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.2500 MiB   0.0000 MiB        2916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.2500 MiB   0.0000 MiB        5832               if temp_g_score < g_score[neighbor]:
    73 136.2500 MiB   0.0000 MiB        1322                   came_from[neighbor] = current
    74 136.2500 MiB   0.0000 MiB        1322                   g_score[neighbor] = temp_g_score
    75 136.2500 MiB   0.0000 MiB        1322                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.2500 MiB   0.0000 MiB        1322                   if neighbor not in open_set_hash:
    77 136.2500 MiB   0.0000 MiB        1322                       count += 1
    78 136.2500 MiB   0.0000 MiB        1322                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.2500 MiB   0.0000 MiB        1322                       open_set_hash.add(neighbor)
    80                                                             
    81 136.2500 MiB   0.0000 MiB         729           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.2500 MiB   0.0000 MiB         729           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.5000 MiB 136.5000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.5000 MiB   0.0000 MiB         257       for row in grid:
    32 136.5000 MiB   0.0000 MiB       65792           for spot in row:
    33 136.5000 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.5000 MiB   0.0000 MiB           1       count = 0
    36 136.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.5000 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.5000 MiB   0.0000 MiB           1       came_from = {}
    39 136.5000 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.5000 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.5000 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.5000 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.5000 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.5000 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.5000 MiB   0.0000 MiB         560       while not open_set.empty():
    49 136.5000 MiB   0.0000 MiB         560           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.5000 MiB   0.0000 MiB         560           current = open_set.get()[2]
    55 136.5000 MiB   0.0000 MiB         560           open_set_hash.remove(current)
    56                                         
    57 136.5000 MiB   0.0000 MiB         560           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.5000 MiB   0.0000 MiB         560           if current == end:
    62 136.5000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.5000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.5000 MiB   0.0000 MiB        5031           for neighbor in current.neighbors:
    67 136.5000 MiB   0.0000 MiB        4472               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.5000 MiB   0.0000 MiB        2236                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.5000 MiB   0.0000 MiB        2236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.5000 MiB   0.0000 MiB        4472               if temp_g_score < g_score[neighbor]:
    73 136.5000 MiB   0.0000 MiB         746                   came_from[neighbor] = current
    74 136.5000 MiB   0.0000 MiB         746                   g_score[neighbor] = temp_g_score
    75 136.5000 MiB   0.0000 MiB         746                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.5000 MiB   0.0000 MiB         746                   if neighbor not in open_set_hash:
    77 136.5000 MiB   0.0000 MiB         746                       count += 1
    78 136.5000 MiB   0.0000 MiB         746                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.5000 MiB   0.0000 MiB         746                       open_set_hash.add(neighbor)
    80                                                             
    81 136.5000 MiB   0.0000 MiB         559           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.5000 MiB   0.0000 MiB         559           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.5000 MiB 136.5000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.5000 MiB -20.8906 MiB         257       for row in grid:
    32 136.5000 MiB -5347.3594 MiB       65792           for spot in row:
    33 136.5000 MiB -5326.5781 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.3906 MiB  -0.1094 MiB           1       count = 0
    36 136.3906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.3906 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.3906 MiB   0.0000 MiB           1       came_from = {}
    39 136.3906 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.3906 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.3906 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.3906 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.3906 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.3906 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.3906 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.3906 MiB   0.0000 MiB         297       while not open_set.empty():
    49 136.3906 MiB   0.0000 MiB         297           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.3906 MiB   0.0000 MiB         297           current = open_set.get()[2]
    55 136.3906 MiB   0.0000 MiB         297           open_set_hash.remove(current)
    56                                         
    57 136.3906 MiB   0.0000 MiB         297           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.3906 MiB   0.0000 MiB         297           if current == end:
    62 136.3906 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.3906 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.3906 MiB   0.0000 MiB        2664           for neighbor in current.neighbors:
    67 136.3906 MiB   0.0000 MiB        2368               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.3906 MiB   0.0000 MiB        1184                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.3906 MiB   0.0000 MiB        1184                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.3906 MiB   0.0000 MiB        2368               if temp_g_score < g_score[neighbor]:
    73 136.3906 MiB   0.0000 MiB         425                   came_from[neighbor] = current
    74 136.3906 MiB   0.0000 MiB         425                   g_score[neighbor] = temp_g_score
    75 136.3906 MiB   0.0000 MiB         425                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.3906 MiB   0.0000 MiB         425                   if neighbor not in open_set_hash:
    77 136.3906 MiB   0.0000 MiB         425                       count += 1
    78 136.3906 MiB   0.0000 MiB         425                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.3906 MiB   0.0000 MiB         425                       open_set_hash.add(neighbor)
    80                                                             
    81 136.3906 MiB   0.0000 MiB         296           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.3906 MiB   0.0000 MiB         296           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.3906 MiB 136.3906 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.3906 MiB -201.2500 MiB         257       for row in grid:
    32 136.3906 MiB -51534.8750 MiB       65792           for spot in row:
    33 136.3906 MiB -51334.5938 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.9531 MiB  -1.4375 MiB           1       count = 0
    36 134.9531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.9531 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.9531 MiB   0.0000 MiB           1       came_from = {}
    39 134.9531 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.9531 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.9531 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.9531 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.9531 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.9531 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.9531 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.9531 MiB   0.0000 MiB        4033       while not open_set.empty():
    49 134.9531 MiB   0.0000 MiB        4033           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.9531 MiB   0.0000 MiB        4033           current = open_set.get()[2]
    55 134.9531 MiB   0.0000 MiB        4033           open_set_hash.remove(current)
    56                                         
    57 134.9531 MiB   0.0000 MiB        4033           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.9531 MiB   0.0000 MiB        4033           if current == end:
    62 134.9531 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.9531 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.9531 MiB   0.0000 MiB       36288           for neighbor in current.neighbors:
    67 134.9531 MiB   0.0000 MiB       32256               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.9531 MiB   0.0000 MiB       16128                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.9531 MiB   0.0000 MiB       16128                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.9531 MiB   0.0000 MiB       32256               if temp_g_score < g_score[neighbor]:
    73 134.9531 MiB   0.0000 MiB        4541                   came_from[neighbor] = current
    74 134.9531 MiB   0.0000 MiB        4541                   g_score[neighbor] = temp_g_score
    75 134.9531 MiB   0.0000 MiB        4541                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.9531 MiB   0.0000 MiB        4541                   if neighbor not in open_set_hash:
    77 134.9531 MiB   0.0000 MiB        4541                       count += 1
    78 134.9531 MiB   0.0000 MiB        4541                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.9531 MiB   0.0000 MiB        4541                       open_set_hash.add(neighbor)
    80                                                             
    81 134.9531 MiB   0.0000 MiB        4032           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.9531 MiB   0.0000 MiB        4032           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.9531 MiB 134.9531 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.9531 MiB   0.0000 MiB         257       for row in grid:
    32 134.9531 MiB   0.0000 MiB       65792           for spot in row:
    33 134.9531 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.9531 MiB   0.0000 MiB           1       count = 0
    36 134.9531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.9531 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.9531 MiB   0.0000 MiB           1       came_from = {}
    39 134.9531 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.9531 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.9531 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.9531 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.9531 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.9531 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.9531 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.9531 MiB   0.0000 MiB       14170       while not open_set.empty():
    49 134.9531 MiB   0.0000 MiB       14170           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.9531 MiB   0.0000 MiB       14170           current = open_set.get()[2]
    55 134.9531 MiB   0.0000 MiB       14170           open_set_hash.remove(current)
    56                                         
    57 134.9531 MiB   0.0000 MiB       14170           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.9531 MiB   0.0000 MiB       14170           if current == end:
    62 134.9531 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.9531 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.9531 MiB   0.0000 MiB      127521           for neighbor in current.neighbors:
    67 134.9531 MiB   0.0000 MiB      113352               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.9531 MiB   0.0000 MiB       56676                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.9531 MiB   0.0000 MiB       56676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.9531 MiB   0.0000 MiB      113352               if temp_g_score < g_score[neighbor]:
    73 134.9531 MiB   0.0000 MiB       14864                   came_from[neighbor] = current
    74 134.9531 MiB   0.0000 MiB       14864                   g_score[neighbor] = temp_g_score
    75 134.9531 MiB   0.0000 MiB       14864                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.9531 MiB   0.0000 MiB       14864                   if neighbor not in open_set_hash:
    77 134.9531 MiB   0.0000 MiB       14864                       count += 1
    78 134.9531 MiB   0.0000 MiB       14864                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.9531 MiB   0.0000 MiB       14864                       open_set_hash.add(neighbor)
    80                                                             
    81 134.9531 MiB   0.0000 MiB       14169           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.9531 MiB   0.0000 MiB       14169           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.9531 MiB 134.9531 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.9531 MiB  -1.1719 MiB         257       for row in grid:
    32 134.9531 MiB -297.4062 MiB       65792           for spot in row:
    33 134.9531 MiB -296.2344 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.9375 MiB  -0.0156 MiB           1       count = 0
    36 134.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.9375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.9375 MiB   0.0000 MiB           1       came_from = {}
    39 134.9375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.9375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.9375 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.9375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.9375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.9375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.9375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.9375 MiB   0.0000 MiB        1358       while not open_set.empty():
    49 134.9375 MiB   0.0000 MiB        1358           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.9375 MiB   0.0000 MiB        1358           current = open_set.get()[2]
    55 134.9375 MiB   0.0000 MiB        1358           open_set_hash.remove(current)
    56                                         
    57 134.9375 MiB   0.0000 MiB        1358           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.9375 MiB   0.0000 MiB        1358           if current == end:
    62 134.9375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.9375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.9375 MiB   0.0000 MiB       12213           for neighbor in current.neighbors:
    67 134.9375 MiB   0.0000 MiB       10856               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.9375 MiB   0.0000 MiB        5428                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.9375 MiB   0.0000 MiB        5428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.9375 MiB   0.0000 MiB       10856               if temp_g_score < g_score[neighbor]:
    73 134.9375 MiB   0.0000 MiB        1606                   came_from[neighbor] = current
    74 134.9375 MiB   0.0000 MiB        1606                   g_score[neighbor] = temp_g_score
    75 134.9375 MiB   0.0000 MiB        1606                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.9375 MiB   0.0000 MiB        1606                   if neighbor not in open_set_hash:
    77 134.9375 MiB   0.0000 MiB        1606                       count += 1
    78 134.9375 MiB   0.0000 MiB        1606                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.9375 MiB   0.0000 MiB        1606                       open_set_hash.add(neighbor)
    80                                                             
    81 134.9375 MiB   0.0000 MiB        1357           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.9375 MiB   0.0000 MiB        1357           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.9375 MiB 134.9375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.9375 MiB -25.5000 MiB         257       for row in grid:
    32 134.9375 MiB -6533.5938 MiB       65792           for spot in row:
    33 134.9375 MiB -6508.1406 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.8125 MiB  -0.1250 MiB           1       count = 0
    36 134.8125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.8125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.8125 MiB   0.0000 MiB           1       came_from = {}
    39 134.8281 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.8281 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.8281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.8281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.8281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.8281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.8281 MiB   0.0000 MiB        2080       while not open_set.empty():
    49 134.8281 MiB   0.0000 MiB        2080           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.8281 MiB   0.0000 MiB        2080           current = open_set.get()[2]
    55 134.8281 MiB   0.0000 MiB        2080           open_set_hash.remove(current)
    56                                         
    57 134.8281 MiB   0.0000 MiB        2080           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.8281 MiB   0.0000 MiB        2080           if current == end:
    62 134.8281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.8281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.8281 MiB   0.0000 MiB       18711           for neighbor in current.neighbors:
    67 134.8281 MiB   0.0000 MiB       16632               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.8281 MiB   0.0000 MiB        8316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.8281 MiB   0.0000 MiB        8316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.8281 MiB   0.0000 MiB       16632               if temp_g_score < g_score[neighbor]:
    73 134.8281 MiB   0.0000 MiB        2366                   came_from[neighbor] = current
    74 134.8281 MiB   0.0000 MiB        2366                   g_score[neighbor] = temp_g_score
    75 134.8281 MiB   0.0000 MiB        2366                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.8281 MiB   0.0000 MiB        2366                   if neighbor not in open_set_hash:
    77 134.8281 MiB   0.0000 MiB        2366                       count += 1
    78 134.8281 MiB   0.0000 MiB        2366                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.8281 MiB   0.0000 MiB        2366                       open_set_hash.add(neighbor)
    80                                                             
    81 134.8281 MiB   0.0000 MiB        2079           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.8281 MiB   0.0000 MiB        2079           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.8438 MiB 134.8438 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.8438 MiB   0.0000 MiB         257       for row in grid:
    32 134.8438 MiB   0.0000 MiB       65792           for spot in row:
    33 134.8438 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.8438 MiB   0.0000 MiB           1       count = 0
    36 134.8438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.8438 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.8438 MiB   0.0000 MiB           1       came_from = {}
    39 134.8438 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.8438 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.8438 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.8438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.8438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.8438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.8438 MiB   0.0000 MiB        3696       while not open_set.empty():
    49 134.8438 MiB   0.0000 MiB        3696           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.8438 MiB   0.0000 MiB        3696           current = open_set.get()[2]
    55 134.8438 MiB   0.0000 MiB        3696           open_set_hash.remove(current)
    56                                         
    57 134.8438 MiB   0.0000 MiB        3696           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.8438 MiB   0.0000 MiB        3696           if current == end:
    62 134.8438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.8438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.8438 MiB   0.0000 MiB       33255           for neighbor in current.neighbors:
    67 134.8438 MiB   0.0000 MiB       29560               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.8438 MiB   0.0000 MiB       14780                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.8438 MiB   0.0000 MiB       14780                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.8438 MiB   0.0000 MiB       29560               if temp_g_score < g_score[neighbor]:
    73 134.8438 MiB   0.0000 MiB        4040                   came_from[neighbor] = current
    74 134.8438 MiB   0.0000 MiB        4040                   g_score[neighbor] = temp_g_score
    75 134.8438 MiB   0.0000 MiB        4040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.8438 MiB   0.0000 MiB        4040                   if neighbor not in open_set_hash:
    77 134.8438 MiB   0.0000 MiB        4040                       count += 1
    78 134.8438 MiB   0.0000 MiB        4040                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.8438 MiB   0.0000 MiB        4040                       open_set_hash.add(neighbor)
    80                                                             
    81 134.8438 MiB   0.0000 MiB        3695           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.8438 MiB   0.0000 MiB        3695           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.8438 MiB 134.8438 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.8438 MiB   0.0000 MiB         257       for row in grid:
    32 134.8438 MiB   0.0000 MiB       65792           for spot in row:
    33 134.8438 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.8438 MiB   0.0000 MiB           1       count = 0
    36 134.8438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.8438 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.8438 MiB   0.0000 MiB           1       came_from = {}
    39 134.8438 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.8438 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.8438 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.8438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.8438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.8438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.8438 MiB   0.0000 MiB         775       while not open_set.empty():
    49 134.8438 MiB   0.0000 MiB         775           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.8438 MiB   0.0000 MiB         775           current = open_set.get()[2]
    55 134.8438 MiB   0.0000 MiB         775           open_set_hash.remove(current)
    56                                         
    57 134.8438 MiB   0.0000 MiB         775           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.8438 MiB   0.0000 MiB         775           if current == end:
    62 134.8438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.8438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.8438 MiB   0.0000 MiB        6966           for neighbor in current.neighbors:
    67 134.8438 MiB   0.0000 MiB        6192               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.8438 MiB   0.0000 MiB        3096                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.8438 MiB   0.0000 MiB        3096                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.8438 MiB   0.0000 MiB        6192               if temp_g_score < g_score[neighbor]:
    73 134.8438 MiB   0.0000 MiB        1103                   came_from[neighbor] = current
    74 134.8438 MiB   0.0000 MiB        1103                   g_score[neighbor] = temp_g_score
    75 134.8438 MiB   0.0000 MiB        1103                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.8438 MiB   0.0000 MiB        1103                   if neighbor not in open_set_hash:
    77 134.8438 MiB   0.0000 MiB        1103                       count += 1
    78 134.8438 MiB   0.0000 MiB        1103                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.8438 MiB   0.0000 MiB        1103                       open_set_hash.add(neighbor)
    80                                                             
    81 134.8438 MiB   0.0000 MiB         774           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.8438 MiB   0.0000 MiB         774           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.8438 MiB 134.8438 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.8438 MiB   0.0000 MiB         257       for row in grid:
    32 134.8438 MiB   0.0000 MiB       65792           for spot in row:
    33 134.8438 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.8438 MiB   0.0000 MiB           1       count = 0
    36 134.8438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.8438 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.8438 MiB   0.0000 MiB           1       came_from = {}
    39 134.8438 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.8438 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.8438 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.8438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.8438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.8438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.8438 MiB   0.0000 MiB        1690       while not open_set.empty():
    49 134.8438 MiB   0.0000 MiB        1690           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.8438 MiB   0.0000 MiB        1690           current = open_set.get()[2]
    55 134.8438 MiB   0.0000 MiB        1690           open_set_hash.remove(current)
    56                                         
    57 134.8438 MiB   0.0000 MiB        1690           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.8438 MiB   0.0000 MiB        1690           if current == end:
    62 134.8438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.8438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.8438 MiB   0.0000 MiB       15201           for neighbor in current.neighbors:
    67 134.8438 MiB   0.0000 MiB       13512               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.8438 MiB   0.0000 MiB        6756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.8438 MiB   0.0000 MiB        6756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.8438 MiB   0.0000 MiB       13512               if temp_g_score < g_score[neighbor]:
    73 134.8438 MiB   0.0000 MiB        1922                   came_from[neighbor] = current
    74 134.8438 MiB   0.0000 MiB        1922                   g_score[neighbor] = temp_g_score
    75 134.8438 MiB   0.0000 MiB        1922                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.8438 MiB   0.0000 MiB        1922                   if neighbor not in open_set_hash:
    77 134.8438 MiB   0.0000 MiB        1922                       count += 1
    78 134.8438 MiB   0.0000 MiB        1922                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.8438 MiB   0.0000 MiB        1922                       open_set_hash.add(neighbor)
    80                                                             
    81 134.8438 MiB   0.0000 MiB        1689           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.8438 MiB   0.0000 MiB        1689           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.8438 MiB 134.8438 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.8438 MiB   0.0000 MiB         257       for row in grid:
    32 134.8438 MiB   0.0000 MiB       65792           for spot in row:
    33 134.8438 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.8438 MiB   0.0000 MiB           1       count = 0
    36 134.8438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.8438 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.8438 MiB   0.0000 MiB           1       came_from = {}
    39 134.8438 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.8438 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.8438 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.8438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.8438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.8438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.8438 MiB   0.0000 MiB         434       while not open_set.empty():
    49 134.8438 MiB   0.0000 MiB         434           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.8438 MiB   0.0000 MiB         434           current = open_set.get()[2]
    55 134.8438 MiB   0.0000 MiB         434           open_set_hash.remove(current)
    56                                         
    57 134.8438 MiB   0.0000 MiB         434           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.8438 MiB   0.0000 MiB         434           if current == end:
    62 134.8438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.8438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.8438 MiB   0.0000 MiB        3897           for neighbor in current.neighbors:
    67 134.8438 MiB   0.0000 MiB        3464               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.8438 MiB   0.0000 MiB        1732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.8438 MiB   0.0000 MiB        1732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.8438 MiB   0.0000 MiB        3464               if temp_g_score < g_score[neighbor]:
    73 134.8438 MiB   0.0000 MiB         584                   came_from[neighbor] = current
    74 134.8438 MiB   0.0000 MiB         584                   g_score[neighbor] = temp_g_score
    75 134.8438 MiB   0.0000 MiB         584                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.8438 MiB   0.0000 MiB         584                   if neighbor not in open_set_hash:
    77 134.8438 MiB   0.0000 MiB         584                       count += 1
    78 134.8438 MiB   0.0000 MiB         584                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.8438 MiB   0.0000 MiB         584                       open_set_hash.add(neighbor)
    80                                                             
    81 134.8438 MiB   0.0000 MiB         433           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.8438 MiB   0.0000 MiB         433           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.8438 MiB 134.8438 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.8438 MiB   0.0000 MiB         257       for row in grid:
    32 134.8438 MiB   0.0000 MiB       65792           for spot in row:
    33 134.8438 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.8438 MiB   0.0000 MiB           1       count = 0
    36 134.8438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.8438 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.8438 MiB   0.0000 MiB           1       came_from = {}
    39 134.8438 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.8125 MiB   0.9688 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.8125 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.8125 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.8125 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.8125 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.8125 MiB   0.0000 MiB          80       while not open_set.empty():
    49 135.8125 MiB   0.0000 MiB          80           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.8125 MiB   0.0000 MiB          80           current = open_set.get()[2]
    55 135.8125 MiB   0.0000 MiB          80           open_set_hash.remove(current)
    56                                         
    57 135.8125 MiB   0.0000 MiB          80           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.8125 MiB   0.0000 MiB          80           if current == end:
    62 135.8125 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.8125 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.8125 MiB   0.0000 MiB         711           for neighbor in current.neighbors:
    67 135.8125 MiB   0.0000 MiB         632               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.8125 MiB   0.0000 MiB         316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.8125 MiB   0.0000 MiB         316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.8125 MiB   0.0000 MiB         632               if temp_g_score < g_score[neighbor]:
    73 135.8125 MiB   0.0000 MiB         242                   came_from[neighbor] = current
    74 135.8125 MiB   0.0000 MiB         242                   g_score[neighbor] = temp_g_score
    75 135.8125 MiB   0.0000 MiB         242                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.8125 MiB   0.0000 MiB         242                   if neighbor not in open_set_hash:
    77 135.8125 MiB   0.0000 MiB         242                       count += 1
    78 135.8125 MiB   0.0000 MiB         242                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.8125 MiB   0.0000 MiB         242                       open_set_hash.add(neighbor)
    80                                                             
    81 135.8125 MiB   0.0000 MiB          79           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.8125 MiB   0.0000 MiB          79           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.8906 MiB 135.8906 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.8906 MiB   0.0000 MiB         257       for row in grid:
    32 135.8906 MiB   0.0000 MiB       65792           for spot in row:
    33 135.8906 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.8906 MiB   0.0000 MiB           1       count = 0
    36 135.8906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.8906 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.8906 MiB   0.0000 MiB           1       came_from = {}
    39 135.8906 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.8906 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.8906 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.8906 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.8906 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.8906 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.8906 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.8906 MiB   0.0000 MiB        3422       while not open_set.empty():
    49 135.8906 MiB   0.0000 MiB        3422           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.8906 MiB   0.0000 MiB        3422           current = open_set.get()[2]
    55 135.8906 MiB   0.0000 MiB        3422           open_set_hash.remove(current)
    56                                         
    57 135.8906 MiB   0.0000 MiB        3422           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.8906 MiB   0.0000 MiB        3422           if current == end:
    62 135.8906 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.8906 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.8906 MiB   0.0000 MiB       30789           for neighbor in current.neighbors:
    67 135.8906 MiB   0.0000 MiB       27368               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.8906 MiB   0.0000 MiB       13684                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.8906 MiB   0.0000 MiB       13684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.8906 MiB   0.0000 MiB       27368               if temp_g_score < g_score[neighbor]:
    73 135.8906 MiB   0.0000 MiB        3770                   came_from[neighbor] = current
    74 135.8906 MiB   0.0000 MiB        3770                   g_score[neighbor] = temp_g_score
    75 135.8906 MiB   0.0000 MiB        3770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.8906 MiB   0.0000 MiB        3770                   if neighbor not in open_set_hash:
    77 135.8906 MiB   0.0000 MiB        3770                       count += 1
    78 135.8906 MiB   0.0000 MiB        3770                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.8906 MiB   0.0000 MiB        3770                       open_set_hash.add(neighbor)
    80                                                             
    81 135.8906 MiB   0.0000 MiB        3421           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.8906 MiB   0.0000 MiB        3421           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.9844 MiB 135.9844 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.9844 MiB -1633.5938 MiB         257       for row in grid:
    32 135.9844 MiB -418969.2188 MiB       65792           for spot in row:
    33 135.9844 MiB -417340.4688 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.8438 MiB  -7.1406 MiB           1       count = 0
    36 128.8438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.8438 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.8438 MiB   0.0000 MiB           1       came_from = {}
    39 129.2969 MiB   0.4531 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 132.8125 MiB   3.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 132.8125 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 132.8125 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 132.8125 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 132.8125 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 132.8281 MiB -296.5312 MiB        4608       while not open_set.empty():
    49 132.8281 MiB -296.5312 MiB        4608           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 132.8281 MiB -296.5312 MiB        4608           current = open_set.get()[2]
    55 132.8281 MiB -296.5312 MiB        4608           open_set_hash.remove(current)
    56                                         
    57 132.8281 MiB -296.5312 MiB        4608           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 132.8281 MiB -296.5312 MiB        4608           if current == end:
    62 132.7188 MiB  -0.1094 MiB           1               if draw:
    63                                                         end.make_end()
    64 132.7188 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 132.8281 MiB -2668.0156 MiB       41463           for neighbor in current.neighbors:
    67 132.8281 MiB -2371.4844 MiB       36856               if current.row != neighbor.row and current.col != neighbor.col:
    68 132.8281 MiB -1185.7969 MiB       18428                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 132.8281 MiB -1185.6875 MiB       18428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 132.8281 MiB -2371.5000 MiB       36856               if temp_g_score < g_score[neighbor]:
    73 132.8281 MiB -329.2812 MiB        5190                   came_from[neighbor] = current
    74 132.8281 MiB -329.3906 MiB        5190                   g_score[neighbor] = temp_g_score
    75 132.8281 MiB -329.4062 MiB        5190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 132.8281 MiB -329.4062 MiB        5190                   if neighbor not in open_set_hash:
    77 132.8281 MiB -329.4062 MiB        5190                       count += 1
    78 132.8281 MiB -329.4062 MiB        5190                       open_set.put((f_score[neighbor], count, neighbor))
    79 132.8281 MiB -329.3594 MiB        5190                       open_set_hash.add(neighbor)
    80                                                             
    81 132.8281 MiB -296.5312 MiB        4607           if draw is not None:
    82                                                     draw()
    83                                         
    84 132.8281 MiB -296.5312 MiB        4607           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 132.7188 MiB 132.7188 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 132.7188 MiB   0.0000 MiB         257       for row in grid:
    32 132.7188 MiB   0.0000 MiB       65792           for spot in row:
    33 132.7188 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 132.7188 MiB   0.0000 MiB           1       count = 0
    36 132.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 132.7188 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 132.7188 MiB   0.0000 MiB           1       came_from = {}
    39 133.7031 MiB   0.9844 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.7500 MiB   0.0469 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.7500 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.7500 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.7500 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.7500 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.7500 MiB   0.0000 MiB        5616       while not open_set.empty():
    49 133.7500 MiB   0.0000 MiB        5616           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.7500 MiB   0.0000 MiB        5616           current = open_set.get()[2]
    55 133.7500 MiB   0.0000 MiB        5616           open_set_hash.remove(current)
    56                                         
    57 133.7500 MiB   0.0000 MiB        5616           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.7500 MiB   0.0000 MiB        5616           if current == end:
    62 133.7500 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.7500 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.7500 MiB   0.0000 MiB       50535           for neighbor in current.neighbors:
    67 133.7500 MiB   0.0000 MiB       44920               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.7500 MiB   0.0000 MiB       22460                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.7500 MiB   0.0000 MiB       22460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.7500 MiB   0.0000 MiB       44920               if temp_g_score < g_score[neighbor]:
    73 133.7500 MiB   0.0000 MiB        6040                   came_from[neighbor] = current
    74 133.7500 MiB   0.0000 MiB        6040                   g_score[neighbor] = temp_g_score
    75 133.7500 MiB   0.0000 MiB        6040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.7500 MiB   0.0000 MiB        6040                   if neighbor not in open_set_hash:
    77 133.7500 MiB   0.0000 MiB        6040                       count += 1
    78 133.7500 MiB   0.0000 MiB        6040                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.7500 MiB   0.0000 MiB        6040                       open_set_hash.add(neighbor)
    80                                                             
    81 133.7500 MiB   0.0000 MiB        5615           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.7500 MiB   0.0000 MiB        5615           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.7500 MiB 133.7500 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.7500 MiB   0.0000 MiB         257       for row in grid:
    32 133.7500 MiB   0.0000 MiB       65792           for spot in row:
    33 133.7500 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.7500 MiB   0.0000 MiB           1       count = 0
    36 133.7500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.7500 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.7500 MiB   0.0000 MiB           1       came_from = {}
    39 133.7500 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.7500 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.7500 MiB -34392.0312 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 126.8438 MiB  -6.9062 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 126.8438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 126.8438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 126.8438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 126.8438 MiB -4167.0469 MiB        4700       while not open_set.empty():
    49 126.8438 MiB -4167.0469 MiB        4700           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 126.8438 MiB -4167.0469 MiB        4700           current = open_set.get()[2]
    55 126.8438 MiB -4167.0469 MiB        4700           open_set_hash.remove(current)
    56                                         
    57 126.8438 MiB -4167.0469 MiB        4700           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 126.8438 MiB -4167.0469 MiB        4700           if current == end:
    62 125.5312 MiB  -1.3125 MiB           1               if draw:
    63                                                         end.make_end()
    64 125.5312 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 126.8438 MiB -37496.0000 MiB       42291           for neighbor in current.neighbors:
    67 126.8438 MiB -33329.4062 MiB       37592               if current.row != neighbor.row and current.col != neighbor.col:
    68 126.8438 MiB -16666.3906 MiB       18796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 126.8438 MiB -16663.2656 MiB       18796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 126.8438 MiB -33330.0312 MiB       37592               if temp_g_score < g_score[neighbor]:
    73 126.8438 MiB -4528.9531 MiB        5174                   came_from[neighbor] = current
    74 126.8438 MiB -4528.9531 MiB        5174                   g_score[neighbor] = temp_g_score
    75 126.8438 MiB -4528.9531 MiB        5174                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 126.8438 MiB -4528.9531 MiB        5174                   if neighbor not in open_set_hash:
    77 126.8438 MiB -4528.9531 MiB        5174                       count += 1
    78 126.8438 MiB -4528.9531 MiB        5174                       open_set.put((f_score[neighbor], count, neighbor))
    79 126.8438 MiB -4528.9844 MiB        5174                       open_set_hash.add(neighbor)
    80                                                             
    81 126.8438 MiB -4167.0156 MiB        4699           if draw is not None:
    82                                                     draw()
    83                                         
    84 126.8438 MiB -4167.0469 MiB        4699           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 125.5312 MiB 125.5312 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 125.5312 MiB   0.0000 MiB         257       for row in grid:
    32 125.5312 MiB   0.0000 MiB       65792           for spot in row:
    33 125.5312 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 125.5312 MiB   0.0000 MiB           1       count = 0
    36 125.5312 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 125.5312 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 125.5312 MiB   0.0000 MiB           1       came_from = {}
    39 125.9219 MiB   0.3906 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 125.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 127.5156 MiB   1.5938 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 127.5156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 127.5156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 127.5156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 127.5156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 127.5156 MiB   0.0000 MiB        1342       while not open_set.empty():
    49 127.5156 MiB   0.0000 MiB        1342           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 127.5156 MiB   0.0000 MiB        1342           current = open_set.get()[2]
    55 127.5156 MiB   0.0000 MiB        1342           open_set_hash.remove(current)
    56                                         
    57 127.5156 MiB   0.0000 MiB        1342           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 127.5156 MiB   0.0000 MiB        1342           if current == end:
    62 127.5156 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 127.5156 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 127.5156 MiB   0.0000 MiB       12069           for neighbor in current.neighbors:
    67 127.5156 MiB   0.0000 MiB       10728               if current.row != neighbor.row and current.col != neighbor.col:
    68 127.5156 MiB   0.0000 MiB        5364                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 127.5156 MiB   0.0000 MiB        5364                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 127.5156 MiB   0.0000 MiB       10728               if temp_g_score < g_score[neighbor]:
    73 127.5156 MiB   0.0000 MiB        1628                   came_from[neighbor] = current
    74 127.5156 MiB   0.0000 MiB        1628                   g_score[neighbor] = temp_g_score
    75 127.5156 MiB   0.0000 MiB        1628                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 127.5156 MiB   0.0000 MiB        1628                   if neighbor not in open_set_hash:
    77 127.5156 MiB   0.0000 MiB        1628                       count += 1
    78 127.5156 MiB   0.0000 MiB        1628                       open_set.put((f_score[neighbor], count, neighbor))
    79 127.5156 MiB   0.0000 MiB        1628                       open_set_hash.add(neighbor)
    80                                                             
    81 127.5156 MiB   0.0000 MiB        1341           if draw is not None:
    82                                                     draw()
    83                                         
    84 127.5156 MiB   0.0000 MiB        1341           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 127.5156 MiB 127.5156 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 127.5156 MiB   0.0000 MiB         257       for row in grid:
    32 127.5156 MiB   0.0000 MiB       65792           for spot in row:
    33 127.5156 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.5156 MiB   0.0000 MiB           1       count = 0
    36 127.5156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.5156 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.5156 MiB   0.0000 MiB           1       came_from = {}
    39 128.6719 MiB   1.1562 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.6719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.6719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.6719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.6719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.6719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.6719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.6719 MiB   0.0000 MiB         156       while not open_set.empty():
    49 128.6719 MiB   0.0000 MiB         156           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.6719 MiB   0.0000 MiB         156           current = open_set.get()[2]
    55 128.6719 MiB   0.0000 MiB         156           open_set_hash.remove(current)
    56                                         
    57 128.6719 MiB   0.0000 MiB         156           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.6719 MiB   0.0000 MiB         156           if current == end:
    62 128.6719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.6719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.6719 MiB   0.0000 MiB        1395           for neighbor in current.neighbors:
    67 128.6719 MiB   0.0000 MiB        1240               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.6719 MiB   0.0000 MiB         620                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.6719 MiB   0.0000 MiB         620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.6719 MiB   0.0000 MiB        1240               if temp_g_score < g_score[neighbor]:
    73 128.6719 MiB   0.0000 MiB         248                   came_from[neighbor] = current
    74 128.6719 MiB   0.0000 MiB         248                   g_score[neighbor] = temp_g_score
    75 128.6719 MiB   0.0000 MiB         248                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.6719 MiB   0.0000 MiB         248                   if neighbor not in open_set_hash:
    77 128.6719 MiB   0.0000 MiB         248                       count += 1
    78 128.6719 MiB   0.0000 MiB         248                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.6719 MiB   0.0000 MiB         248                       open_set_hash.add(neighbor)
    80                                                             
    81 128.6719 MiB   0.0000 MiB         155           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.6719 MiB   0.0000 MiB         155           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.6719 MiB 128.6719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.6719 MiB   0.0000 MiB         257       for row in grid:
    32 128.6719 MiB   0.0000 MiB       65792           for spot in row:
    33 128.6719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.6719 MiB   0.0000 MiB           1       count = 0
    36 128.6719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.6719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.6719 MiB   0.0000 MiB           1       came_from = {}
    39 128.7031 MiB   0.0312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.7188 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.7188 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.7188 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.7188 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.7188 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.7188 MiB   0.0000 MiB         570       while not open_set.empty():
    49 128.7188 MiB   0.0000 MiB         570           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.7188 MiB   0.0000 MiB         570           current = open_set.get()[2]
    55 128.7188 MiB   0.0000 MiB         570           open_set_hash.remove(current)
    56                                         
    57 128.7188 MiB   0.0000 MiB         570           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.7188 MiB   0.0000 MiB         570           if current == end:
    62 128.7188 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.7188 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.7188 MiB   0.0000 MiB        5121           for neighbor in current.neighbors:
    67 128.7188 MiB   0.0000 MiB        4552               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.7188 MiB   0.0000 MiB        2276                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.7188 MiB   0.0000 MiB        2276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.7188 MiB   0.0000 MiB        4552               if temp_g_score < g_score[neighbor]:
    73 128.7188 MiB   0.0000 MiB         726                   came_from[neighbor] = current
    74 128.7188 MiB   0.0000 MiB         726                   g_score[neighbor] = temp_g_score
    75 128.7188 MiB   0.0000 MiB         726                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.7188 MiB   0.0000 MiB         726                   if neighbor not in open_set_hash:
    77 128.7188 MiB   0.0000 MiB         726                       count += 1
    78 128.7188 MiB   0.0000 MiB         726                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.7188 MiB   0.0000 MiB         726                       open_set_hash.add(neighbor)
    80                                                             
    81 128.7188 MiB   0.0000 MiB         569           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.7188 MiB   0.0000 MiB         569           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.7188 MiB 128.7188 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.7188 MiB   0.0000 MiB         257       for row in grid:
    32 128.7188 MiB   0.0000 MiB       65792           for spot in row:
    33 128.7188 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.7188 MiB   0.0000 MiB           1       count = 0
    36 128.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.7188 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.7188 MiB   0.0000 MiB           1       came_from = {}
    39 128.7188 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.7188 MiB -552224.7031 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.3750 MiB -10.3438 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.3750 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.3750 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.3750 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.3750 MiB   0.0000 MiB       12932       while not open_set.empty():
    49 118.3750 MiB   0.0000 MiB       12932           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.3750 MiB   0.0000 MiB       12932           current = open_set.get()[2]
    55 118.3750 MiB   0.0000 MiB       12932           open_set_hash.remove(current)
    56                                         
    57 118.3750 MiB   0.0000 MiB       12932           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.3750 MiB   0.0000 MiB       12932           if current == end:
    62 118.3750 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.3750 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.3750 MiB   0.0000 MiB      116379           for neighbor in current.neighbors:
    67 118.3750 MiB   0.0000 MiB      103448               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.3750 MiB   0.0000 MiB       51724                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.3750 MiB   0.0000 MiB       51724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.3750 MiB   0.0000 MiB      103448               if temp_g_score < g_score[neighbor]:
    73 118.3750 MiB   0.0000 MiB       13630                   came_from[neighbor] = current
    74 118.3750 MiB   0.0000 MiB       13630                   g_score[neighbor] = temp_g_score
    75 118.3750 MiB   0.0000 MiB       13630                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.3750 MiB   0.0000 MiB       13630                   if neighbor not in open_set_hash:
    77 118.3750 MiB   0.0000 MiB       13630                       count += 1
    78 118.3750 MiB   0.0000 MiB       13630                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.3750 MiB   0.0000 MiB       13630                       open_set_hash.add(neighbor)
    80                                                             
    81 118.3750 MiB   0.0000 MiB       12931           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.3750 MiB   0.0000 MiB       12931           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.3750 MiB 118.3750 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.3750 MiB -1373.3906 MiB         257       for row in grid:
    32 118.3750 MiB -351981.5469 MiB       65792           for spot in row:
    33 118.3750 MiB -350613.2969 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 110.8594 MiB  -7.5156 MiB           1       count = 0
    36 110.8594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 110.8594 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 110.8594 MiB   0.0000 MiB           1       came_from = {}
    39 113.1406 MiB   2.2812 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 113.1406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 115.5312 MiB -8773.6562 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 114.8125 MiB  -0.7188 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 114.8125 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 114.8125 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 114.8125 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 114.8125 MiB   0.0000 MiB        5148       while not open_set.empty():
    49 114.8125 MiB   0.0000 MiB        5148           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 114.8125 MiB   0.0000 MiB        5148           current = open_set.get()[2]
    55 114.8125 MiB   0.0000 MiB        5148           open_set_hash.remove(current)
    56                                         
    57 114.8125 MiB   0.0000 MiB        5148           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 114.8125 MiB   0.0000 MiB        5148           if current == end:
    62 114.8125 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 114.8125 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 114.8125 MiB   0.0000 MiB       46323           for neighbor in current.neighbors:
    67 114.8125 MiB   0.0000 MiB       41176               if current.row != neighbor.row and current.col != neighbor.col:
    68 114.8125 MiB   0.0000 MiB       20588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 114.8125 MiB   0.0000 MiB       20588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 114.8125 MiB   0.0000 MiB       41176               if temp_g_score < g_score[neighbor]:
    73 114.8125 MiB   0.0000 MiB        5590                   came_from[neighbor] = current
    74 114.8125 MiB   0.0000 MiB        5590                   g_score[neighbor] = temp_g_score
    75 114.8125 MiB   0.0000 MiB        5590                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 114.8125 MiB   0.0000 MiB        5590                   if neighbor not in open_set_hash:
    77 114.8125 MiB   0.0000 MiB        5590                       count += 1
    78 114.8125 MiB   0.0000 MiB        5590                       open_set.put((f_score[neighbor], count, neighbor))
    79 114.8125 MiB   0.0000 MiB        5590                       open_set_hash.add(neighbor)
    80                                                             
    81 114.8125 MiB   0.0000 MiB        5147           if draw is not None:
    82                                                     draw()
    83                                         
    84 114.8125 MiB   0.0000 MiB        5147           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 114.8125 MiB 114.8125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 114.8125 MiB   0.0000 MiB         257       for row in grid:
    32 114.8125 MiB   0.0000 MiB       65792           for spot in row:
    33 114.8125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 114.8125 MiB   0.0000 MiB           1       count = 0
    36 114.8125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 114.8125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 114.8125 MiB   0.0000 MiB           1       came_from = {}
    39 114.8125 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 114.8125 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.5938 MiB   3.7812 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.5938 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.5938 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.5938 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.5938 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.5938 MiB   0.0000 MiB         184       while not open_set.empty():
    49 118.5938 MiB   0.0000 MiB         184           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.5938 MiB   0.0000 MiB         184           current = open_set.get()[2]
    55 118.5938 MiB   0.0000 MiB         184           open_set_hash.remove(current)
    56                                         
    57 118.5938 MiB   0.0000 MiB         184           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.5938 MiB   0.0000 MiB         184           if current == end:
    62 118.5938 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.5938 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.5938 MiB   0.0000 MiB        1647           for neighbor in current.neighbors:
    67 118.5938 MiB   0.0000 MiB        1464               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.5938 MiB   0.0000 MiB         732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.5938 MiB   0.0000 MiB         732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.5938 MiB   0.0000 MiB        1464               if temp_g_score < g_score[neighbor]:
    73 118.5938 MiB   0.0000 MiB         374                   came_from[neighbor] = current
    74 118.5938 MiB   0.0000 MiB         374                   g_score[neighbor] = temp_g_score
    75 118.5938 MiB   0.0000 MiB         374                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.5938 MiB   0.0000 MiB         374                   if neighbor not in open_set_hash:
    77 118.5938 MiB   0.0000 MiB         374                       count += 1
    78 118.5938 MiB   0.0000 MiB         374                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.5938 MiB   0.0000 MiB         374                       open_set_hash.add(neighbor)
    80                                                             
    81 118.5938 MiB   0.0000 MiB         183           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.5938 MiB   0.0000 MiB         183           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.6719 MiB 118.6719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.6719 MiB   0.0000 MiB         257       for row in grid:
    32 118.6719 MiB   0.0000 MiB       65792           for spot in row:
    33 118.6719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.6719 MiB   0.0000 MiB           1       count = 0
    36 118.6719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.6719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.6719 MiB   0.0000 MiB           1       came_from = {}
    39 119.4062 MiB   0.7344 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 119.4062 MiB   0.0000 MiB           1       g_score[start] = 0
    41 121.0625 MiB   1.6562 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 121.0625 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 121.0625 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 121.0625 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 121.0625 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 121.0625 MiB   0.0000 MiB        4500       while not open_set.empty():
    49 121.0625 MiB   0.0000 MiB        4500           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 121.0625 MiB   0.0000 MiB        4500           current = open_set.get()[2]
    55 121.0625 MiB   0.0000 MiB        4500           open_set_hash.remove(current)
    56                                         
    57 121.0625 MiB   0.0000 MiB        4500           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 121.0625 MiB   0.0000 MiB        4500           if current == end:
    62 121.0625 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 121.0625 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 121.0625 MiB   0.0000 MiB       40491           for neighbor in current.neighbors:
    67 121.0625 MiB   0.0000 MiB       35992               if current.row != neighbor.row and current.col != neighbor.col:
    68 121.0625 MiB   0.0000 MiB       17996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 121.0625 MiB   0.0000 MiB       17996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 121.0625 MiB   0.0000 MiB       35992               if temp_g_score < g_score[neighbor]:
    73 121.0625 MiB   0.0000 MiB        4878                   came_from[neighbor] = current
    74 121.0625 MiB   0.0000 MiB        4878                   g_score[neighbor] = temp_g_score
    75 121.0625 MiB   0.0000 MiB        4878                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 121.0625 MiB   0.0000 MiB        4878                   if neighbor not in open_set_hash:
    77 121.0625 MiB   0.0000 MiB        4878                       count += 1
    78 121.0625 MiB   0.0000 MiB        4878                       open_set.put((f_score[neighbor], count, neighbor))
    79 121.0625 MiB   0.0000 MiB        4878                       open_set_hash.add(neighbor)
    80                                                             
    81 121.0625 MiB   0.0000 MiB        4499           if draw is not None:
    82                                                     draw()
    83                                         
    84 121.0625 MiB   0.0000 MiB        4499           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 121.0625 MiB 121.0625 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 121.0625 MiB   0.0000 MiB         257       for row in grid:
    32 121.0625 MiB   0.0000 MiB       65792           for spot in row:
    33 121.0625 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 121.0625 MiB   0.0000 MiB           1       count = 0
    36 121.0625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 121.0625 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 121.0625 MiB   0.0000 MiB           1       came_from = {}
    39 121.0625 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 121.0625 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.1562 MiB   2.0938 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.1562 MiB   0.0000 MiB        6255       while not open_set.empty():
    49 123.1562 MiB   0.0000 MiB        6255           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.1562 MiB   0.0000 MiB        6255           current = open_set.get()[2]
    55 123.1562 MiB   0.0000 MiB        6255           open_set_hash.remove(current)
    56                                         
    57 123.1562 MiB   0.0000 MiB        6255           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.1562 MiB   0.0000 MiB        6255           if current == end:
    62 123.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 123.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.1562 MiB   0.0000 MiB       56286           for neighbor in current.neighbors:
    67 123.1562 MiB   0.0000 MiB       50032               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.1562 MiB   0.0000 MiB       25016                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.1562 MiB   0.0000 MiB       25016                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.1562 MiB   0.0000 MiB       50032               if temp_g_score < g_score[neighbor]:
    73 123.1562 MiB   0.0000 MiB        6899                   came_from[neighbor] = current
    74 123.1562 MiB   0.0000 MiB        6899                   g_score[neighbor] = temp_g_score
    75 123.1562 MiB   0.0000 MiB        6899                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.1562 MiB   0.0000 MiB        6899                   if neighbor not in open_set_hash:
    77 123.1562 MiB   0.0000 MiB        6899                       count += 1
    78 123.1562 MiB   0.0000 MiB        6899                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.1562 MiB   0.0000 MiB        6899                       open_set_hash.add(neighbor)
    80                                                             
    81 123.1562 MiB   0.0000 MiB        6254           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.1562 MiB   0.0000 MiB        6254           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 123.1562 MiB 123.1562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 123.1562 MiB   0.0000 MiB         257       for row in grid:
    32 123.1562 MiB   0.0000 MiB       65792           for spot in row:
    33 123.1562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 123.1562 MiB   0.0000 MiB           1       count = 0
    36 123.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 123.1562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 123.1562 MiB   0.0000 MiB           1       came_from = {}
    39 123.1562 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 123.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.6875 MiB   0.5312 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.6875 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.6875 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.6875 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.6875 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.6875 MiB   0.0000 MiB         156       while not open_set.empty():
    49 123.6875 MiB   0.0000 MiB         156           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.6875 MiB   0.0000 MiB         156           current = open_set.get()[2]
    55 123.6875 MiB   0.0000 MiB         156           open_set_hash.remove(current)
    56                                         
    57 123.6875 MiB   0.0000 MiB         156           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.6875 MiB   0.0000 MiB         156           if current == end:
    62 123.6875 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 123.6875 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.6875 MiB   0.0000 MiB        1395           for neighbor in current.neighbors:
    67 123.6875 MiB   0.0000 MiB        1240               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.6875 MiB   0.0000 MiB         620                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.6875 MiB   0.0000 MiB         620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.6875 MiB   0.0000 MiB        1240               if temp_g_score < g_score[neighbor]:
    73 123.6875 MiB   0.0000 MiB         318                   came_from[neighbor] = current
    74 123.6875 MiB   0.0000 MiB         318                   g_score[neighbor] = temp_g_score
    75 123.6875 MiB   0.0000 MiB         318                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.6875 MiB   0.0000 MiB         318                   if neighbor not in open_set_hash:
    77 123.6875 MiB   0.0000 MiB         318                       count += 1
    78 123.6875 MiB   0.0000 MiB         318                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.6875 MiB   0.0000 MiB         318                       open_set_hash.add(neighbor)
    80                                                             
    81 123.6875 MiB   0.0000 MiB         155           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.6875 MiB   0.0000 MiB         155           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 123.6875 MiB 123.6875 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 123.6875 MiB   0.0000 MiB         257       for row in grid:
    32 123.6875 MiB   0.0000 MiB       65792           for spot in row:
    33 123.6875 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 123.6875 MiB   0.0000 MiB           1       count = 0
    36 123.6875 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 123.6875 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 123.6875 MiB   0.0000 MiB           1       came_from = {}
    39 123.7031 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 123.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    41 124.6094 MiB   0.9062 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 124.6094 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 124.6094 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 124.6094 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 124.6094 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 124.6094 MiB   0.0000 MiB         110       while not open_set.empty():
    49 124.6094 MiB   0.0000 MiB         110           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 124.6094 MiB   0.0000 MiB         110           current = open_set.get()[2]
    55 124.6094 MiB   0.0000 MiB         110           open_set_hash.remove(current)
    56                                         
    57 124.6094 MiB   0.0000 MiB         110           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 124.6094 MiB   0.0000 MiB         110           if current == end:
    62 124.6094 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 124.6094 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 124.6094 MiB   0.0000 MiB         981           for neighbor in current.neighbors:
    67 124.6094 MiB   0.0000 MiB         872               if current.row != neighbor.row and current.col != neighbor.col:
    68 124.6094 MiB   0.0000 MiB         436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 124.6094 MiB   0.0000 MiB         436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 124.6094 MiB   0.0000 MiB         872               if temp_g_score < g_score[neighbor]:
    73 124.6094 MiB   0.0000 MiB         206                   came_from[neighbor] = current
    74 124.6094 MiB   0.0000 MiB         206                   g_score[neighbor] = temp_g_score
    75 124.6094 MiB   0.0000 MiB         206                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 124.6094 MiB   0.0000 MiB         206                   if neighbor not in open_set_hash:
    77 124.6094 MiB   0.0000 MiB         206                       count += 1
    78 124.6094 MiB   0.0000 MiB         206                       open_set.put((f_score[neighbor], count, neighbor))
    79 124.6094 MiB   0.0000 MiB         206                       open_set_hash.add(neighbor)
    80                                                             
    81 124.6094 MiB   0.0000 MiB         109           if draw is not None:
    82                                                     draw()
    83                                         
    84 124.6094 MiB   0.0000 MiB         109           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 124.6094 MiB 124.6094 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 124.6094 MiB   0.0000 MiB         257       for row in grid:
    32 124.6094 MiB   0.0000 MiB       65792           for spot in row:
    33 124.6094 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 124.6094 MiB   0.0000 MiB           1       count = 0
    36 124.6094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 124.6094 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 124.6094 MiB   0.0000 MiB           1       came_from = {}
    39 124.6094 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 124.6094 MiB   0.0000 MiB           1       g_score[start] = 0
    41 127.2812 MiB   2.6719 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 127.2812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 127.2812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 127.2812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 127.2812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 127.2812 MiB   0.0000 MiB        1744       while not open_set.empty():
    49 127.2812 MiB   0.0000 MiB        1744           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 127.2812 MiB   0.0000 MiB        1744           current = open_set.get()[2]
    55 127.2812 MiB   0.0000 MiB        1744           open_set_hash.remove(current)
    56                                         
    57 127.2812 MiB   0.0000 MiB        1744           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 127.2812 MiB   0.0000 MiB        1744           if current == end:
    62 127.2812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 127.2812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 127.2812 MiB   0.0000 MiB       15687           for neighbor in current.neighbors:
    67 127.2812 MiB   0.0000 MiB       13944               if current.row != neighbor.row and current.col != neighbor.col:
    68 127.2812 MiB   0.0000 MiB        6972                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 127.2812 MiB   0.0000 MiB        6972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 127.2812 MiB   0.0000 MiB       13944               if temp_g_score < g_score[neighbor]:
    73 127.2812 MiB   0.0000 MiB        2024                   came_from[neighbor] = current
    74 127.2812 MiB   0.0000 MiB        2024                   g_score[neighbor] = temp_g_score
    75 127.2812 MiB   0.0000 MiB        2024                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 127.2812 MiB   0.0000 MiB        2024                   if neighbor not in open_set_hash:
    77 127.2812 MiB   0.0000 MiB        2024                       count += 1
    78 127.2812 MiB   0.0000 MiB        2024                       open_set.put((f_score[neighbor], count, neighbor))
    79 127.2812 MiB   0.0000 MiB        2024                       open_set_hash.add(neighbor)
    80                                                             
    81 127.2812 MiB   0.0000 MiB        1743           if draw is not None:
    82                                                     draw()
    83                                         
    84 127.2812 MiB   0.0000 MiB        1743           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 127.4375 MiB 127.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 127.4375 MiB   0.0000 MiB         257       for row in grid:
    32 127.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 127.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.4375 MiB   0.0000 MiB           1       count = 0
    36 127.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.4375 MiB   0.0000 MiB           1       came_from = {}
    39 127.4375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 127.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 127.4375 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 127.4375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 127.4375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 127.4375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 127.4375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 127.4375 MiB   0.0000 MiB         732       while not open_set.empty():
    49 127.4375 MiB   0.0000 MiB         732           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 127.4375 MiB   0.0000 MiB         732           current = open_set.get()[2]
    55 127.4375 MiB   0.0000 MiB         732           open_set_hash.remove(current)
    56                                         
    57 127.4375 MiB   0.0000 MiB         732           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 127.4375 MiB   0.0000 MiB         732           if current == end:
    62 127.4375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 127.4375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 127.4375 MiB   0.0000 MiB        6579           for neighbor in current.neighbors:
    67 127.4375 MiB   0.0000 MiB        5848               if current.row != neighbor.row and current.col != neighbor.col:
    68 127.4375 MiB   0.0000 MiB        2924                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 127.4375 MiB   0.0000 MiB        2924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 127.4375 MiB   0.0000 MiB        5848               if temp_g_score < g_score[neighbor]:
    73 127.4375 MiB   0.0000 MiB         900                   came_from[neighbor] = current
    74 127.4375 MiB   0.0000 MiB         900                   g_score[neighbor] = temp_g_score
    75 127.4375 MiB   0.0000 MiB         900                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 127.4375 MiB   0.0000 MiB         900                   if neighbor not in open_set_hash:
    77 127.4375 MiB   0.0000 MiB         900                       count += 1
    78 127.4375 MiB   0.0000 MiB         900                       open_set.put((f_score[neighbor], count, neighbor))
    79 127.4375 MiB   0.0000 MiB         900                       open_set_hash.add(neighbor)
    80                                                             
    81 127.4375 MiB   0.0000 MiB         731           if draw is not None:
    82                                                     draw()
    83                                         
    84 127.4375 MiB   0.0000 MiB         731           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 127.4375 MiB 127.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 127.4375 MiB   0.0000 MiB         257       for row in grid:
    32 127.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 127.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.4375 MiB   0.0000 MiB           1       count = 0
    36 127.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.4375 MiB   0.0000 MiB           1       came_from = {}
    39 127.4375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 127.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.5000 MiB   1.0625 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.5000 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.5000 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.5000 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.5000 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.5000 MiB   0.0000 MiB       11176       while not open_set.empty():
    49 128.5000 MiB   0.0000 MiB       11176           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.5000 MiB   0.0000 MiB       11176           current = open_set.get()[2]
    55 128.5000 MiB   0.0000 MiB       11176           open_set_hash.remove(current)
    56                                         
    57 128.5000 MiB   0.0000 MiB       11176           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.5000 MiB   0.0000 MiB       11176           if current == end:
    62 128.5000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.5000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.5000 MiB   0.0000 MiB      100575           for neighbor in current.neighbors:
    67 128.5000 MiB   0.0000 MiB       89400               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.5000 MiB   0.0000 MiB       44700                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.5000 MiB   0.0000 MiB       44700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.5000 MiB   0.0000 MiB       89400               if temp_g_score < g_score[neighbor]:
    73 128.5000 MiB   0.0000 MiB       11780                   came_from[neighbor] = current
    74 128.5000 MiB   0.0000 MiB       11780                   g_score[neighbor] = temp_g_score
    75 128.5000 MiB   0.0000 MiB       11780                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.5000 MiB   0.0000 MiB       11780                   if neighbor not in open_set_hash:
    77 128.5000 MiB   0.0000 MiB       11780                       count += 1
    78 128.5000 MiB   0.0000 MiB       11780                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.5000 MiB   0.0000 MiB       11780                       open_set_hash.add(neighbor)
    80                                                             
    81 128.5000 MiB   0.0000 MiB       11175           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.5000 MiB   0.0000 MiB       11175           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.5000 MiB 128.5000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.5000 MiB   0.0000 MiB         257       for row in grid:
    32 128.5000 MiB   0.0000 MiB       65792           for spot in row:
    33 128.5000 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.5000 MiB   0.0000 MiB           1       count = 0
    36 128.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.5000 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.5000 MiB   0.0000 MiB           1       came_from = {}
    39 128.5000 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.5000 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.5000 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.5000 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.5000 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.5000 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.5000 MiB   0.0000 MiB        1952       while not open_set.empty():
    49 128.5000 MiB   0.0000 MiB        1952           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.5000 MiB   0.0000 MiB        1952           current = open_set.get()[2]
    55 128.5000 MiB   0.0000 MiB        1952           open_set_hash.remove(current)
    56                                         
    57 128.5000 MiB   0.0000 MiB        1952           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.5000 MiB   0.0000 MiB        1952           if current == end:
    62 128.5000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.5000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.5000 MiB   0.0000 MiB       17559           for neighbor in current.neighbors:
    67 128.5000 MiB   0.0000 MiB       15608               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.5000 MiB   0.0000 MiB        7804                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.5000 MiB   0.0000 MiB        7804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.5000 MiB   0.0000 MiB       15608               if temp_g_score < g_score[neighbor]:
    73 128.5000 MiB   0.0000 MiB        2200                   came_from[neighbor] = current
    74 128.5000 MiB   0.0000 MiB        2200                   g_score[neighbor] = temp_g_score
    75 128.5000 MiB   0.0000 MiB        2200                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.5000 MiB   0.0000 MiB        2200                   if neighbor not in open_set_hash:
    77 128.5000 MiB   0.0000 MiB        2200                       count += 1
    78 128.5000 MiB   0.0000 MiB        2200                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.5000 MiB   0.0000 MiB        2200                       open_set_hash.add(neighbor)
    80                                                             
    81 128.5000 MiB   0.0000 MiB        1951           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.5000 MiB   0.0000 MiB        1951           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.5000 MiB 128.5000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.5000 MiB   0.0000 MiB         257       for row in grid:
    32 128.5000 MiB   0.0000 MiB       65792           for spot in row:
    33 128.5000 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.5000 MiB   0.0000 MiB           1       count = 0
    36 128.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.5000 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.5000 MiB   0.0000 MiB           1       came_from = {}
    39 128.5000 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.5000 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.5000 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.5000 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.5000 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.5000 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.5000 MiB   0.0000 MiB        5120       while not open_set.empty():
    49 128.5000 MiB   0.0000 MiB        5120           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.5000 MiB   0.0000 MiB        5120           current = open_set.get()[2]
    55 128.5000 MiB   0.0000 MiB        5120           open_set_hash.remove(current)
    56                                         
    57 128.5000 MiB   0.0000 MiB        5120           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.5000 MiB   0.0000 MiB        5120           if current == end:
    62 128.5000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.5000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.5000 MiB   0.0000 MiB       46071           for neighbor in current.neighbors:
    67 128.5000 MiB   0.0000 MiB       40952               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.5000 MiB   0.0000 MiB       20476                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.5000 MiB   0.0000 MiB       20476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.5000 MiB   0.0000 MiB       40952               if temp_g_score < g_score[neighbor]:
    73 128.5000 MiB   0.0000 MiB        5534                   came_from[neighbor] = current
    74 128.5000 MiB   0.0000 MiB        5534                   g_score[neighbor] = temp_g_score
    75 128.5000 MiB   0.0000 MiB        5534                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.5000 MiB   0.0000 MiB        5534                   if neighbor not in open_set_hash:
    77 128.5000 MiB   0.0000 MiB        5534                       count += 1
    78 128.5000 MiB   0.0000 MiB        5534                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.5000 MiB   0.0000 MiB        5534                       open_set_hash.add(neighbor)
    80                                                             
    81 128.5000 MiB   0.0000 MiB        5119           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.5000 MiB   0.0000 MiB        5119           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.5000 MiB 128.5000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.5000 MiB   0.0000 MiB         257       for row in grid:
    32 128.5000 MiB   0.0000 MiB       65792           for spot in row:
    33 128.5000 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.5000 MiB   0.0000 MiB           1       count = 0
    36 128.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.5000 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.5000 MiB   0.0000 MiB           1       came_from = {}
    39 128.5000 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.5000 MiB -12755.8906 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1562 MiB  -0.3438 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1562 MiB   0.0000 MiB        1648       while not open_set.empty():
    49 128.1562 MiB   0.0000 MiB        1648           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1562 MiB   0.0000 MiB        1648           current = open_set.get()[2]
    55 128.1562 MiB   0.0000 MiB        1648           open_set_hash.remove(current)
    56                                         
    57 128.1562 MiB   0.0000 MiB        1648           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1562 MiB   0.0000 MiB        1648           if current == end:
    62 128.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1562 MiB   0.0000 MiB       14823           for neighbor in current.neighbors:
    67 128.1562 MiB   0.0000 MiB       13176               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1562 MiB   0.0000 MiB        6588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1562 MiB  -0.0312 MiB        6588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1562 MiB   0.0000 MiB       13176               if temp_g_score < g_score[neighbor]:
    73 128.1562 MiB   0.0000 MiB        2090                   came_from[neighbor] = current
    74 128.1562 MiB   0.0000 MiB        2090                   g_score[neighbor] = temp_g_score
    75 128.1562 MiB   0.0000 MiB        2090                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1562 MiB   0.0000 MiB        2090                   if neighbor not in open_set_hash:
    77 128.1562 MiB   0.0000 MiB        2090                       count += 1
    78 128.1562 MiB   0.0000 MiB        2090                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1562 MiB   0.0000 MiB        2090                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1562 MiB   0.0000 MiB        1647           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1562 MiB   0.0000 MiB        1647           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.1562 MiB 128.1562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.1562 MiB   0.0000 MiB         257       for row in grid:
    32 128.1562 MiB   0.0000 MiB       65792           for spot in row:
    33 128.1562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.1562 MiB   0.0000 MiB           1       count = 0
    36 128.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.1562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.1562 MiB   0.0000 MiB           1       came_from = {}
    39 128.1562 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 130.5312 MiB   2.3750 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 130.5312 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 130.5312 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 130.5312 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 130.5312 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 130.5781 MiB   0.0000 MiB        4356       while not open_set.empty():
    49 130.5781 MiB   0.0000 MiB        4356           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 130.5781 MiB   0.0000 MiB        4356           current = open_set.get()[2]
    55 130.5781 MiB   0.0000 MiB        4356           open_set_hash.remove(current)
    56                                         
    57 130.5781 MiB   0.0000 MiB        4356           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 130.5781 MiB   0.0000 MiB        4356           if current == end:
    62 130.5781 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 130.5781 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 130.5781 MiB   0.0000 MiB       39195           for neighbor in current.neighbors:
    67 130.5781 MiB   0.0000 MiB       34840               if current.row != neighbor.row and current.col != neighbor.col:
    68 130.5781 MiB   0.0000 MiB       17420                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 130.5781 MiB   0.0000 MiB       17420                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 130.5781 MiB   0.0000 MiB       34840               if temp_g_score < g_score[neighbor]:
    73 130.5781 MiB   0.0469 MiB        4838                   came_from[neighbor] = current
    74 130.5781 MiB   0.0000 MiB        4838                   g_score[neighbor] = temp_g_score
    75 130.5781 MiB   0.0000 MiB        4838                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 130.5781 MiB   0.0000 MiB        4838                   if neighbor not in open_set_hash:
    77 130.5781 MiB   0.0000 MiB        4838                       count += 1
    78 130.5781 MiB   0.0000 MiB        4838                       open_set.put((f_score[neighbor], count, neighbor))
    79 130.5781 MiB   0.0000 MiB        4838                       open_set_hash.add(neighbor)
    80                                                             
    81 130.5781 MiB   0.0000 MiB        4355           if draw is not None:
    82                                                     draw()
    83                                         
    84 130.5781 MiB   0.0000 MiB        4355           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 130.6094 MiB 130.6094 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 130.6094 MiB   0.0000 MiB         257       for row in grid:
    32 130.6094 MiB   0.0000 MiB       65792           for spot in row:
    33 130.6094 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 130.6094 MiB   0.0000 MiB           1       count = 0
    36 130.6094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 130.6094 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 130.6094 MiB   0.0000 MiB           1       came_from = {}
    39 130.6094 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 130.6094 MiB   0.0000 MiB           1       g_score[start] = 0
    41 130.8125 MiB   0.2031 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 130.8125 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 130.8125 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 130.8125 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 130.8125 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 130.8125 MiB   0.0000 MiB        1014       while not open_set.empty():
    49 130.8125 MiB   0.0000 MiB        1014           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 130.8125 MiB   0.0000 MiB        1014           current = open_set.get()[2]
    55 130.8125 MiB   0.0000 MiB        1014           open_set_hash.remove(current)
    56                                         
    57 130.8125 MiB   0.0000 MiB        1014           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 130.8125 MiB   0.0000 MiB        1014           if current == end:
    62 130.8125 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 130.8125 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 130.8125 MiB   0.0000 MiB        9117           for neighbor in current.neighbors:
    67 130.8125 MiB   0.0000 MiB        8104               if current.row != neighbor.row and current.col != neighbor.col:
    68 130.8125 MiB   0.0000 MiB        4052                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 130.8125 MiB   0.0000 MiB        4052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 130.8125 MiB   0.0000 MiB        8104               if temp_g_score < g_score[neighbor]:
    73 130.8125 MiB   0.0000 MiB        1220                   came_from[neighbor] = current
    74 130.8125 MiB   0.0000 MiB        1220                   g_score[neighbor] = temp_g_score
    75 130.8125 MiB   0.0000 MiB        1220                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 130.8125 MiB   0.0000 MiB        1220                   if neighbor not in open_set_hash:
    77 130.8125 MiB   0.0000 MiB        1220                       count += 1
    78 130.8125 MiB   0.0000 MiB        1220                       open_set.put((f_score[neighbor], count, neighbor))
    79 130.8125 MiB   0.0000 MiB        1220                       open_set_hash.add(neighbor)
    80                                                             
    81 130.8125 MiB   0.0000 MiB        1013           if draw is not None:
    82                                                     draw()
    83                                         
    84 130.8125 MiB   0.0000 MiB        1013           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 130.8125 MiB 130.8125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 130.8125 MiB   0.0000 MiB         257       for row in grid:
    32 130.8125 MiB   0.0000 MiB       65792           for spot in row:
    33 130.8125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 130.8125 MiB   0.0000 MiB           1       count = 0
    36 130.8125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 130.8125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 130.8125 MiB   0.0000 MiB           1       came_from = {}
    39 130.8281 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 130.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 130.8281 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 130.8281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 130.8281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 130.8281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 130.8281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 130.8281 MiB   0.0000 MiB        1692       while not open_set.empty():
    49 130.8281 MiB   0.0000 MiB        1692           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 130.8281 MiB   0.0000 MiB        1692           current = open_set.get()[2]
    55 130.8281 MiB   0.0000 MiB        1692           open_set_hash.remove(current)
    56                                         
    57 130.8281 MiB   0.0000 MiB        1692           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 130.8281 MiB   0.0000 MiB        1692           if current == end:
    62 130.8281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 130.8281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 130.8281 MiB   0.0000 MiB       15219           for neighbor in current.neighbors:
    67 130.8281 MiB   0.0000 MiB       13528               if current.row != neighbor.row and current.col != neighbor.col:
    68 130.8281 MiB   0.0000 MiB        6764                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 130.8281 MiB   0.0000 MiB        6764                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 130.8281 MiB   0.0000 MiB       13528               if temp_g_score < g_score[neighbor]:
    73 130.8281 MiB   0.0000 MiB        2020                   came_from[neighbor] = current
    74 130.8281 MiB   0.0000 MiB        2020                   g_score[neighbor] = temp_g_score
    75 130.8281 MiB   0.0000 MiB        2020                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 130.8281 MiB   0.0000 MiB        2020                   if neighbor not in open_set_hash:
    77 130.8281 MiB   0.0000 MiB        2020                       count += 1
    78 130.8281 MiB   0.0000 MiB        2020                       open_set.put((f_score[neighbor], count, neighbor))
    79 130.8281 MiB   0.0000 MiB        2020                       open_set_hash.add(neighbor)
    80                                                             
    81 130.8281 MiB   0.0000 MiB        1691           if draw is not None:
    82                                                     draw()
    83                                         
    84 130.8281 MiB   0.0000 MiB        1691           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 130.8281 MiB 130.8281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 130.8281 MiB   0.0000 MiB         257       for row in grid:
    32 130.8281 MiB   0.0000 MiB       65792           for spot in row:
    33 130.8281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 130.8281 MiB   0.0000 MiB           1       count = 0
    36 130.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 130.8281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 130.8281 MiB   0.0000 MiB           1       came_from = {}
    39 130.8281 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 130.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 130.8281 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 130.8281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 130.8281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 130.8281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 130.8281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 130.8594 MiB   0.0000 MiB        6370       while not open_set.empty():
    49 130.8594 MiB   0.0000 MiB        6370           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 130.8594 MiB   0.0000 MiB        6370           current = open_set.get()[2]
    55 130.8594 MiB   0.0000 MiB        6370           open_set_hash.remove(current)
    56                                         
    57 130.8594 MiB   0.0000 MiB        6370           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 130.8594 MiB   0.0000 MiB        6370           if current == end:
    62 130.8594 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 130.8594 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 130.8594 MiB   0.0000 MiB       57321           for neighbor in current.neighbors:
    67 130.8594 MiB   0.0000 MiB       50952               if current.row != neighbor.row and current.col != neighbor.col:
    68 130.8594 MiB   0.0000 MiB       25476                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 130.8594 MiB   0.0000 MiB       25476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 130.8594 MiB   0.0000 MiB       50952               if temp_g_score < g_score[neighbor]:
    73 130.8594 MiB   0.0312 MiB        6872                   came_from[neighbor] = current
    74 130.8594 MiB   0.0000 MiB        6872                   g_score[neighbor] = temp_g_score
    75 130.8594 MiB   0.0000 MiB        6872                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 130.8594 MiB   0.0000 MiB        6872                   if neighbor not in open_set_hash:
    77 130.8594 MiB   0.0000 MiB        6872                       count += 1
    78 130.8594 MiB   0.0000 MiB        6872                       open_set.put((f_score[neighbor], count, neighbor))
    79 130.8594 MiB   0.0000 MiB        6872                       open_set_hash.add(neighbor)
    80                                                             
    81 130.8594 MiB   0.0000 MiB        6369           if draw is not None:
    82                                                     draw()
    83                                         
    84 130.8594 MiB   0.0000 MiB        6369           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 130.9062 MiB 130.9062 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 130.9062 MiB   0.0000 MiB         257       for row in grid:
    32 130.9062 MiB   0.0000 MiB       65792           for spot in row:
    33 130.9062 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 130.9062 MiB   0.0000 MiB           1       count = 0
    36 130.9062 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 130.9062 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 130.9062 MiB   0.0000 MiB           1       came_from = {}
    39 130.9062 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 130.9062 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.4219 MiB   2.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.4219 MiB   0.0000 MiB        2232       while not open_set.empty():
    49 133.4219 MiB   0.0000 MiB        2232           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.4219 MiB   0.0000 MiB        2232           current = open_set.get()[2]
    55 133.4219 MiB   0.0000 MiB        2232           open_set_hash.remove(current)
    56                                         
    57 133.4219 MiB   0.0000 MiB        2232           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.4219 MiB   0.0000 MiB        2232           if current == end:
    62 133.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.4219 MiB   0.0000 MiB       20079           for neighbor in current.neighbors:
    67 133.4219 MiB   0.0000 MiB       17848               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.4219 MiB   0.0000 MiB        8924                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.4219 MiB   0.0000 MiB        8924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.4219 MiB   0.0000 MiB       17848               if temp_g_score < g_score[neighbor]:
    73 133.4219 MiB   0.0000 MiB        2512                   came_from[neighbor] = current
    74 133.4219 MiB   0.0000 MiB        2512                   g_score[neighbor] = temp_g_score
    75 133.4219 MiB   0.0000 MiB        2512                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.4219 MiB   0.0000 MiB        2512                   if neighbor not in open_set_hash:
    77 133.4219 MiB   0.0000 MiB        2512                       count += 1
    78 133.4219 MiB   0.0000 MiB        2512                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.4219 MiB   0.0000 MiB        2512                       open_set_hash.add(neighbor)
    80                                                             
    81 133.4219 MiB   0.0000 MiB        2231           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.4219 MiB   0.0000 MiB        2231           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.4219 MiB 133.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.4219 MiB   0.0000 MiB         257       for row in grid:
    32 133.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 133.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.4219 MiB   0.0000 MiB           1       count = 0
    36 133.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.4219 MiB   0.0000 MiB           1       came_from = {}
    39 133.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.4219 MiB   0.0000 MiB        1634       while not open_set.empty():
    49 133.4219 MiB   0.0000 MiB        1634           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.4219 MiB   0.0000 MiB        1634           current = open_set.get()[2]
    55 133.4219 MiB   0.0000 MiB        1634           open_set_hash.remove(current)
    56                                         
    57 133.4219 MiB   0.0000 MiB        1634           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.4219 MiB   0.0000 MiB        1634           if current == end:
    62 133.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.4219 MiB   0.0000 MiB       14697           for neighbor in current.neighbors:
    67 133.4219 MiB   0.0000 MiB       13064               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.4219 MiB   0.0000 MiB        6532                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.4219 MiB   0.0000 MiB        6532                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.4219 MiB   0.0000 MiB       13064               if temp_g_score < g_score[neighbor]:
    73 133.4219 MiB   0.0000 MiB        1880                   came_from[neighbor] = current
    74 133.4219 MiB   0.0000 MiB        1880                   g_score[neighbor] = temp_g_score
    75 133.4219 MiB   0.0000 MiB        1880                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.4219 MiB   0.0000 MiB        1880                   if neighbor not in open_set_hash:
    77 133.4219 MiB   0.0000 MiB        1880                       count += 1
    78 133.4219 MiB   0.0000 MiB        1880                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.4219 MiB   0.0000 MiB        1880                       open_set_hash.add(neighbor)
    80                                                             
    81 133.4219 MiB   0.0000 MiB        1633           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.4219 MiB   0.0000 MiB        1633           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.4219 MiB 133.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.4219 MiB   0.0000 MiB         257       for row in grid:
    32 133.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 133.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.4219 MiB   0.0000 MiB           1       count = 0
    36 133.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.4219 MiB   0.0000 MiB           1       came_from = {}
    39 133.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.4375 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.4375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.4375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.4375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.4375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.4375 MiB   0.0000 MiB        6560       while not open_set.empty():
    49 133.4375 MiB   0.0000 MiB        6560           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.4375 MiB   0.0000 MiB        6560           current = open_set.get()[2]
    55 133.4375 MiB   0.0000 MiB        6560           open_set_hash.remove(current)
    56                                         
    57 133.4375 MiB   0.0000 MiB        6560           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.4375 MiB   0.0000 MiB        6560           if current == end:
    62 133.4375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.4375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.4375 MiB   0.0000 MiB       59031           for neighbor in current.neighbors:
    67 133.4375 MiB   0.0000 MiB       52472               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.4375 MiB   0.0000 MiB       26236                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.4375 MiB   0.0000 MiB       26236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.4375 MiB   0.0000 MiB       52472               if temp_g_score < g_score[neighbor]:
    73 133.4375 MiB   0.0000 MiB        7042                   came_from[neighbor] = current
    74 133.4375 MiB   0.0000 MiB        7042                   g_score[neighbor] = temp_g_score
    75 133.4375 MiB   0.0000 MiB        7042                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.4375 MiB   0.0000 MiB        7042                   if neighbor not in open_set_hash:
    77 133.4375 MiB   0.0000 MiB        7042                       count += 1
    78 133.4375 MiB   0.0000 MiB        7042                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.4375 MiB   0.0000 MiB        7042                       open_set_hash.add(neighbor)
    80                                                             
    81 133.4375 MiB   0.0000 MiB        6559           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.4375 MiB   0.0000 MiB        6559           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.4375 MiB 133.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.4375 MiB   0.0000 MiB         257       for row in grid:
    32 133.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 133.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.4375 MiB   0.0000 MiB           1       count = 0
    36 133.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.4375 MiB   0.0000 MiB           1       came_from = {}
    39 133.4375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.4375 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.4375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.4375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.4375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.4375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.4375 MiB   0.0000 MiB        4524       while not open_set.empty():
    49 133.4375 MiB   0.0000 MiB        4524           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.4375 MiB   0.0000 MiB        4524           current = open_set.get()[2]
    55 133.4375 MiB   0.0000 MiB        4524           open_set_hash.remove(current)
    56                                         
    57 133.4375 MiB   0.0000 MiB        4524           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.4375 MiB   0.0000 MiB        4524           if current == end:
    62 133.4375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.4375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.4375 MiB   0.0000 MiB       40707           for neighbor in current.neighbors:
    67 133.4375 MiB   0.0000 MiB       36184               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.4375 MiB   0.0000 MiB       18092                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.4375 MiB   0.0000 MiB       18092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.4375 MiB   0.0000 MiB       36184               if temp_g_score < g_score[neighbor]:
    73 133.4375 MiB   0.0000 MiB        4950                   came_from[neighbor] = current
    74 133.4375 MiB   0.0000 MiB        4950                   g_score[neighbor] = temp_g_score
    75 133.4375 MiB   0.0000 MiB        4950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.4375 MiB   0.0000 MiB        4950                   if neighbor not in open_set_hash:
    77 133.4375 MiB   0.0000 MiB        4950                       count += 1
    78 133.4375 MiB   0.0000 MiB        4950                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.4375 MiB   0.0000 MiB        4950                       open_set_hash.add(neighbor)
    80                                                             
    81 133.4375 MiB   0.0000 MiB        4523           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.4375 MiB   0.0000 MiB        4523           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.4375 MiB 133.4375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.4375 MiB   0.0000 MiB         257       for row in grid:
    32 133.4375 MiB   0.0000 MiB       65792           for spot in row:
    33 133.4375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.4375 MiB   0.0000 MiB           1       count = 0
    36 133.4375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.4375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.4375 MiB   0.0000 MiB           1       came_from = {}
    39 133.4375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.5000 MiB   0.0625 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.5000 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.5000 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.5000 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.5000 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.5000 MiB   0.0000 MiB         792       while not open_set.empty():
    49 133.5000 MiB   0.0000 MiB         792           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.5000 MiB   0.0000 MiB         792           current = open_set.get()[2]
    55 133.5000 MiB   0.0000 MiB         792           open_set_hash.remove(current)
    56                                         
    57 133.5000 MiB   0.0000 MiB         792           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.5000 MiB   0.0000 MiB         792           if current == end:
    62 133.5000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.5000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.5000 MiB   0.0000 MiB        7119           for neighbor in current.neighbors:
    67 133.5000 MiB   0.0000 MiB        6328               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.5000 MiB   0.0000 MiB        3164                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.5000 MiB   0.0000 MiB        3164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.5000 MiB   0.0000 MiB        6328               if temp_g_score < g_score[neighbor]:
    73 133.5000 MiB   0.0000 MiB         978                   came_from[neighbor] = current
    74 133.5000 MiB   0.0000 MiB         978                   g_score[neighbor] = temp_g_score
    75 133.5000 MiB   0.0000 MiB         978                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.5000 MiB   0.0000 MiB         978                   if neighbor not in open_set_hash:
    77 133.5000 MiB   0.0000 MiB         978                       count += 1
    78 133.5000 MiB   0.0000 MiB         978                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.5000 MiB   0.0000 MiB         978                       open_set_hash.add(neighbor)
    80                                                             
    81 133.5000 MiB   0.0000 MiB         791           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.5000 MiB   0.0000 MiB         791           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.5000 MiB 133.5000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.5000 MiB   0.0000 MiB         257       for row in grid:
    32 133.5000 MiB   0.0000 MiB       65792           for spot in row:
    33 133.5000 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.5000 MiB   0.0000 MiB           1       count = 0
    36 133.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.5000 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.5000 MiB   0.0000 MiB           1       came_from = {}
    39 133.5000 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.5156 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.5156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.5156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.5156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.5156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.5156 MiB   0.0000 MiB         928       while not open_set.empty():
    49 133.5156 MiB   0.0000 MiB         928           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.5156 MiB   0.0000 MiB         928           current = open_set.get()[2]
    55 133.5156 MiB   0.0000 MiB         928           open_set_hash.remove(current)
    56                                         
    57 133.5156 MiB   0.0000 MiB         928           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.5156 MiB   0.0000 MiB         928           if current == end:
    62 133.5156 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.5156 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.5156 MiB   0.0000 MiB        8343           for neighbor in current.neighbors:
    67 133.5156 MiB   0.0000 MiB        7416               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.5156 MiB   0.0000 MiB        3708                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.5156 MiB   0.0000 MiB        3708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.5156 MiB   0.0000 MiB        7416               if temp_g_score < g_score[neighbor]:
    73 133.5156 MiB   0.0000 MiB        1106                   came_from[neighbor] = current
    74 133.5156 MiB   0.0000 MiB        1106                   g_score[neighbor] = temp_g_score
    75 133.5156 MiB   0.0000 MiB        1106                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.5156 MiB   0.0000 MiB        1106                   if neighbor not in open_set_hash:
    77 133.5156 MiB   0.0000 MiB        1106                       count += 1
    78 133.5156 MiB   0.0000 MiB        1106                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.5156 MiB   0.0000 MiB        1106                       open_set_hash.add(neighbor)
    80                                                             
    81 133.5156 MiB   0.0000 MiB         927           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.5156 MiB   0.0000 MiB         927           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.6406 MiB 133.6406 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.6406 MiB   0.0000 MiB         257       for row in grid:
    32 133.6406 MiB   0.0000 MiB       65792           for spot in row:
    33 133.6406 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.6406 MiB   0.0000 MiB           1       count = 0
    36 133.6406 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.6406 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.6406 MiB   0.0000 MiB           1       came_from = {}
    39 133.6406 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.6406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.6406 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.6406 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.6406 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.6406 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.6406 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.6406 MiB   0.0000 MiB        8715       while not open_set.empty():
    49 133.6406 MiB   0.0000 MiB        8715           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.6406 MiB   0.0000 MiB        8715           current = open_set.get()[2]
    55 133.6406 MiB   0.0000 MiB        8715           open_set_hash.remove(current)
    56                                         
    57 133.6406 MiB   0.0000 MiB        8715           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.6406 MiB   0.0000 MiB        8715           if current == end:
    62 133.6406 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.6406 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.6406 MiB   0.0000 MiB       78426           for neighbor in current.neighbors:
    67 133.6406 MiB   0.0000 MiB       69712               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.6406 MiB   0.0000 MiB       34856                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.6406 MiB   0.0000 MiB       34856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.6406 MiB   0.0000 MiB       69712               if temp_g_score < g_score[neighbor]:
    73 133.6406 MiB   0.0000 MiB        9299                   came_from[neighbor] = current
    74 133.6406 MiB   0.0000 MiB        9299                   g_score[neighbor] = temp_g_score
    75 133.6406 MiB   0.0000 MiB        9299                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.6406 MiB   0.0000 MiB        9299                   if neighbor not in open_set_hash:
    77 133.6406 MiB   0.0000 MiB        9299                       count += 1
    78 133.6406 MiB   0.0000 MiB        9299                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.6406 MiB   0.0000 MiB        9299                       open_set_hash.add(neighbor)
    80                                                             
    81 133.6406 MiB   0.0000 MiB        8714           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.6406 MiB   0.0000 MiB        8714           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.6406 MiB 133.6406 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.6406 MiB   0.0000 MiB         257       for row in grid:
    32 133.6406 MiB   0.0000 MiB       65792           for spot in row:
    33 133.6406 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.6406 MiB   0.0000 MiB           1       count = 0
    36 133.6406 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.6406 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.6406 MiB   0.0000 MiB           1       came_from = {}
    39 133.6406 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.6406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.6406 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.6406 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.6406 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.6406 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.6406 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.6406 MiB   0.0000 MiB        2280       while not open_set.empty():
    49 133.6406 MiB   0.0000 MiB        2280           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.6406 MiB   0.0000 MiB        2280           current = open_set.get()[2]
    55 133.6406 MiB   0.0000 MiB        2280           open_set_hash.remove(current)
    56                                         
    57 133.6406 MiB   0.0000 MiB        2280           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.6406 MiB   0.0000 MiB        2280           if current == end:
    62 133.6406 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.6406 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.6406 MiB   0.0000 MiB       20511           for neighbor in current.neighbors:
    67 133.6406 MiB   0.0000 MiB       18232               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.6406 MiB   0.0000 MiB        9116                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.6406 MiB   0.0000 MiB        9116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.6406 MiB   0.0000 MiB       18232               if temp_g_score < g_score[neighbor]:
    73 133.6406 MiB   0.0000 MiB        2564                   came_from[neighbor] = current
    74 133.6406 MiB   0.0000 MiB        2564                   g_score[neighbor] = temp_g_score
    75 133.6406 MiB   0.0000 MiB        2564                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.6406 MiB   0.0000 MiB        2564                   if neighbor not in open_set_hash:
    77 133.6406 MiB   0.0000 MiB        2564                       count += 1
    78 133.6406 MiB   0.0000 MiB        2564                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.6406 MiB   0.0000 MiB        2564                       open_set_hash.add(neighbor)
    80                                                             
    81 133.6406 MiB   0.0000 MiB        2279           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.6406 MiB   0.0000 MiB        2279           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.6406 MiB 133.6406 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.6406 MiB   0.0000 MiB         257       for row in grid:
    32 133.6406 MiB   0.0000 MiB       65792           for spot in row:
    33 133.6406 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.6406 MiB   0.0000 MiB           1       count = 0
    36 133.6406 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.6406 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.6406 MiB   0.0000 MiB           1       came_from = {}
    39 133.6406 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.6406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.6406 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.6406 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.6406 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.6406 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.6406 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.6406 MiB   0.0000 MiB        3717       while not open_set.empty():
    49 133.6406 MiB   0.0000 MiB        3717           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.6406 MiB   0.0000 MiB        3717           current = open_set.get()[2]
    55 133.6406 MiB   0.0000 MiB        3717           open_set_hash.remove(current)
    56                                         
    57 133.6406 MiB   0.0000 MiB        3717           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.6406 MiB   0.0000 MiB        3717           if current == end:
    62 133.6406 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.6406 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.6406 MiB   0.0000 MiB       33444           for neighbor in current.neighbors:
    67 133.6406 MiB   0.0000 MiB       29728               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.6406 MiB   0.0000 MiB       14864                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.6406 MiB   0.0000 MiB       14864                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.6406 MiB   0.0000 MiB       29728               if temp_g_score < g_score[neighbor]:
    73 133.6406 MiB   0.0000 MiB        4077                   came_from[neighbor] = current
    74 133.6406 MiB   0.0000 MiB        4077                   g_score[neighbor] = temp_g_score
    75 133.6406 MiB   0.0000 MiB        4077                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.6406 MiB   0.0000 MiB        4077                   if neighbor not in open_set_hash:
    77 133.6406 MiB   0.0000 MiB        4077                       count += 1
    78 133.6406 MiB   0.0000 MiB        4077                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.6406 MiB   0.0000 MiB        4077                       open_set_hash.add(neighbor)
    80                                                             
    81 133.6406 MiB   0.0000 MiB        3716           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.6406 MiB   0.0000 MiB        3716           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.6406 MiB 133.6406 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.6406 MiB   0.0000 MiB         257       for row in grid:
    32 133.6406 MiB   0.0000 MiB       65792           for spot in row:
    33 133.6406 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.6406 MiB   0.0000 MiB           1       count = 0
    36 133.6406 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.6406 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.6406 MiB   0.0000 MiB           1       came_from = {}
    39 133.6406 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.6406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.6406 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.6406 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.6406 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.6406 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.6406 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.6406 MiB   0.0000 MiB         840       while not open_set.empty():
    49 133.6406 MiB   0.0000 MiB         840           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.6406 MiB   0.0000 MiB         840           current = open_set.get()[2]
    55 133.6406 MiB   0.0000 MiB         840           open_set_hash.remove(current)
    56                                         
    57 133.6406 MiB   0.0000 MiB         840           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.6406 MiB   0.0000 MiB         840           if current == end:
    62 133.6406 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.6406 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.6406 MiB   0.0000 MiB        7551           for neighbor in current.neighbors:
    67 133.6406 MiB   0.0000 MiB        6712               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.6406 MiB   0.0000 MiB        3356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.6406 MiB   0.0000 MiB        3356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.6406 MiB   0.0000 MiB        6712               if temp_g_score < g_score[neighbor]:
    73 133.6406 MiB   0.0000 MiB        1106                   came_from[neighbor] = current
    74 133.6406 MiB   0.0000 MiB        1106                   g_score[neighbor] = temp_g_score
    75 133.6406 MiB   0.0000 MiB        1106                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.6406 MiB   0.0000 MiB        1106                   if neighbor not in open_set_hash:
    77 133.6406 MiB   0.0000 MiB        1106                       count += 1
    78 133.6406 MiB   0.0000 MiB        1106                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.6406 MiB   0.0000 MiB        1106                       open_set_hash.add(neighbor)
    80                                                             
    81 133.6406 MiB   0.0000 MiB         839           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.6406 MiB   0.0000 MiB         839           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.0625 MiB 134.0625 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.0625 MiB   0.0000 MiB         257       for row in grid:
    32 134.0625 MiB   0.0000 MiB       65792           for spot in row:
    33 134.0625 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.0625 MiB   0.0000 MiB           1       count = 0
    36 134.0625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.0625 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.0625 MiB   0.0000 MiB           1       came_from = {}
    39 134.0625 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.0625 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.0625 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.0625 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.0625 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.0625 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.0625 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.0625 MiB   0.0000 MiB         621       while not open_set.empty():
    49 134.0625 MiB   0.0000 MiB         621           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.0625 MiB   0.0000 MiB         621           current = open_set.get()[2]
    55 134.0625 MiB   0.0000 MiB         621           open_set_hash.remove(current)
    56                                         
    57 134.0625 MiB   0.0000 MiB         621           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.0625 MiB   0.0000 MiB         621           if current == end:
    62 134.0625 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.0625 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.0625 MiB   0.0000 MiB        5580           for neighbor in current.neighbors:
    67 134.0625 MiB   0.0000 MiB        4960               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.0625 MiB   0.0000 MiB        2480                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.0625 MiB   0.0000 MiB        2480                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.0625 MiB   0.0000 MiB        4960               if temp_g_score < g_score[neighbor]:
    73 134.0625 MiB   0.0000 MiB         765                   came_from[neighbor] = current
    74 134.0625 MiB   0.0000 MiB         765                   g_score[neighbor] = temp_g_score
    75 134.0625 MiB   0.0000 MiB         765                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.0625 MiB   0.0000 MiB         765                   if neighbor not in open_set_hash:
    77 134.0625 MiB   0.0000 MiB         765                       count += 1
    78 134.0625 MiB   0.0000 MiB         765                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.0625 MiB   0.0000 MiB         765                       open_set_hash.add(neighbor)
    80                                                             
    81 134.0625 MiB   0.0000 MiB         620           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.0625 MiB   0.0000 MiB         620           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.0625 MiB 134.0625 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.0625 MiB   0.0000 MiB         257       for row in grid:
    32 134.0625 MiB   0.0000 MiB       65792           for spot in row:
    33 134.0625 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.0625 MiB   0.0000 MiB           1       count = 0
    36 134.0625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.0625 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.0625 MiB   0.0000 MiB           1       came_from = {}
    39 134.0625 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.0625 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.0625 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.0625 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.0625 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.0625 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.0625 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.0625 MiB   0.0000 MiB         276       while not open_set.empty():
    49 134.0625 MiB   0.0000 MiB         276           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.0625 MiB   0.0000 MiB         276           current = open_set.get()[2]
    55 134.0625 MiB   0.0000 MiB         276           open_set_hash.remove(current)
    56                                         
    57 134.0625 MiB   0.0000 MiB         276           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.0625 MiB   0.0000 MiB         276           if current == end:
    62 134.0625 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.0625 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.0625 MiB   0.0000 MiB        2475           for neighbor in current.neighbors:
    67 134.0625 MiB   0.0000 MiB        2200               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.0625 MiB   0.0000 MiB        1100                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.0625 MiB   0.0000 MiB        1100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.0625 MiB   0.0000 MiB        2200               if temp_g_score < g_score[neighbor]:
    73 134.0625 MiB   0.0000 MiB         390                   came_from[neighbor] = current
    74 134.0625 MiB   0.0000 MiB         390                   g_score[neighbor] = temp_g_score
    75 134.0625 MiB   0.0000 MiB         390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.0625 MiB   0.0000 MiB         390                   if neighbor not in open_set_hash:
    77 134.0625 MiB   0.0000 MiB         390                       count += 1
    78 134.0625 MiB   0.0000 MiB         390                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.0625 MiB   0.0000 MiB         390                       open_set_hash.add(neighbor)
    80                                                             
    81 134.0625 MiB   0.0000 MiB         275           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.0625 MiB   0.0000 MiB         275           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.0625 MiB 134.0625 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.0625 MiB   0.0000 MiB         257       for row in grid:
    32 134.0625 MiB   0.0000 MiB       65792           for spot in row:
    33 134.0625 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.0625 MiB   0.0000 MiB           1       count = 0
    36 134.0625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.0625 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.0625 MiB   0.0000 MiB           1       came_from = {}
    39 134.0625 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.0625 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.0938 MiB   0.0312 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.0938 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.0938 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.0938 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.0938 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.0938 MiB   0.0000 MiB        1152       while not open_set.empty():
    49 134.0938 MiB   0.0000 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.0938 MiB   0.0000 MiB        1152           current = open_set.get()[2]
    55 134.0938 MiB   0.0000 MiB        1152           open_set_hash.remove(current)
    56                                         
    57 134.0938 MiB   0.0000 MiB        1152           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.0938 MiB   0.0000 MiB        1152           if current == end:
    62 134.0938 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.0938 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.0938 MiB   0.0000 MiB       10359           for neighbor in current.neighbors:
    67 134.0938 MiB   0.0000 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.0938 MiB   0.0000 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.0938 MiB   0.0000 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.0938 MiB   0.0000 MiB        9208               if temp_g_score < g_score[neighbor]:
    73 134.0938 MiB   0.0000 MiB        1442                   came_from[neighbor] = current
    74 134.0938 MiB   0.0000 MiB        1442                   g_score[neighbor] = temp_g_score
    75 134.0938 MiB   0.0000 MiB        1442                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.0938 MiB   0.0000 MiB        1442                   if neighbor not in open_set_hash:
    77 134.0938 MiB   0.0000 MiB        1442                       count += 1
    78 134.0938 MiB   0.0000 MiB        1442                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.0938 MiB   0.0000 MiB        1442                       open_set_hash.add(neighbor)
    80                                                             
    81 134.0938 MiB   0.0000 MiB        1151           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.0938 MiB   0.0000 MiB        1151           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.0938 MiB 134.0938 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.0938 MiB   0.0000 MiB         257       for row in grid:
    32 134.0938 MiB   0.0000 MiB       65792           for spot in row:
    33 134.0938 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.0938 MiB   0.0000 MiB           1       count = 0
    36 134.0938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.0938 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.0938 MiB   0.0000 MiB           1       came_from = {}
    39 134.0938 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.0938 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.0938 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.0938 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.0938 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.0938 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.0938 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.0938 MiB   0.0000 MiB         918       while not open_set.empty():
    49 134.0938 MiB   0.0000 MiB         918           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.0938 MiB   0.0000 MiB         918           current = open_set.get()[2]
    55 134.0938 MiB   0.0000 MiB         918           open_set_hash.remove(current)
    56                                         
    57 134.0938 MiB   0.0000 MiB         918           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.0938 MiB   0.0000 MiB         918           if current == end:
    62 134.0938 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.0938 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.0938 MiB   0.0000 MiB        8253           for neighbor in current.neighbors:
    67 134.0938 MiB   0.0000 MiB        7336               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.0938 MiB   0.0000 MiB        3668                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.0938 MiB   0.0000 MiB        3668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.0938 MiB   0.0000 MiB        7336               if temp_g_score < g_score[neighbor]:
    73 134.0938 MiB   0.0000 MiB        1090                   came_from[neighbor] = current
    74 134.0938 MiB   0.0000 MiB        1090                   g_score[neighbor] = temp_g_score
    75 134.0938 MiB   0.0000 MiB        1090                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.0938 MiB   0.0000 MiB        1090                   if neighbor not in open_set_hash:
    77 134.0938 MiB   0.0000 MiB        1090                       count += 1
    78 134.0938 MiB   0.0000 MiB        1090                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.0938 MiB   0.0000 MiB        1090                       open_set_hash.add(neighbor)
    80                                                             
    81 134.0938 MiB   0.0000 MiB         917           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.0938 MiB   0.0000 MiB         917           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.0938 MiB 134.0938 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.0938 MiB -1141.9375 MiB         257       for row in grid:
    32 134.0938 MiB -292477.0469 MiB       65792           for spot in row:
    33 134.0938 MiB -291340.4062 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 126.9062 MiB  -7.1875 MiB           1       count = 0
    36 126.9062 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 126.9062 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 126.9062 MiB   0.0000 MiB           1       came_from = {}
    39 128.5938 MiB -904.4531 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.4688 MiB  -0.1250 MiB           1       g_score[start] = 0
    41 128.8906 MiB   0.4219 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.8906 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.8906 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.8906 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.8906 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.8906 MiB -17931.7500 MiB        2940       while not open_set.empty():
    49 128.8906 MiB -17931.9375 MiB        2940           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.8906 MiB -17932.3125 MiB        2940           current = open_set.get()[2]
    55 128.8906 MiB -17932.3594 MiB        2940           open_set_hash.remove(current)
    56                                         
    57 128.8906 MiB -17932.4375 MiB        2940           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.8906 MiB -17932.5000 MiB        2940           if current == end:
    62 119.7969 MiB  -9.0938 MiB           1               if draw:
    63                                                         end.make_end()
    64 119.7969 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.8906 MiB -161342.3281 MiB       26451           for neighbor in current.neighbors:
    67 128.8906 MiB -143412.9688 MiB       23512               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.8906 MiB -71715.6719 MiB       11756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.8906 MiB -71699.1562 MiB       11756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.8906 MiB -143416.5312 MiB       23512               if temp_g_score < g_score[neighbor]:
    73 128.8906 MiB -19427.2969 MiB        3276                   came_from[neighbor] = current
    74 128.8906 MiB -19427.4531 MiB        3276                   g_score[neighbor] = temp_g_score
    75 128.8906 MiB -19427.6406 MiB        3276                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.8906 MiB -19427.6406 MiB        3276                   if neighbor not in open_set_hash:
    77 128.8906 MiB -19427.7031 MiB        3276                       count += 1
    78 128.8906 MiB -19427.7656 MiB        3276                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.8906 MiB -19427.7969 MiB        3276                       open_set_hash.add(neighbor)
    80                                                             
    81 128.8906 MiB -17931.3594 MiB        2939           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.8906 MiB -17931.6094 MiB        2939           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 119.8750 MiB 119.8750 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 119.8750 MiB   0.0000 MiB         257       for row in grid:
    32 119.8750 MiB   0.0000 MiB       65792           for spot in row:
    33 119.8750 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 119.8750 MiB   0.0000 MiB           1       count = 0
    36 119.8750 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 119.8750 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 119.8750 MiB   0.0000 MiB           1       came_from = {}
    39 121.0781 MiB   1.2031 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 121.0781 MiB   0.0000 MiB           1       g_score[start] = 0
    41 121.3281 MiB   0.2500 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 121.3281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 121.3281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 121.3281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 121.3281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 121.3281 MiB   0.0000 MiB        3287       while not open_set.empty():
    49 121.3281 MiB   0.0000 MiB        3287           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 121.3281 MiB   0.0000 MiB        3287           current = open_set.get()[2]
    55 121.3281 MiB   0.0000 MiB        3287           open_set_hash.remove(current)
    56                                         
    57 121.3281 MiB   0.0000 MiB        3287           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 121.3281 MiB   0.0000 MiB        3287           if current == end:
    62 121.3281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 121.3281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 121.3281 MiB   0.0000 MiB       29574           for neighbor in current.neighbors:
    67 121.3281 MiB   0.0000 MiB       26288               if current.row != neighbor.row and current.col != neighbor.col:
    68 121.3281 MiB   0.0000 MiB       13144                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 121.3281 MiB   0.0000 MiB       13144                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 121.3281 MiB   0.0000 MiB       26288               if temp_g_score < g_score[neighbor]:
    73 121.3281 MiB   0.0000 MiB        3707                   came_from[neighbor] = current
    74 121.3281 MiB   0.0000 MiB        3707                   g_score[neighbor] = temp_g_score
    75 121.3281 MiB   0.0000 MiB        3707                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 121.3281 MiB   0.0000 MiB        3707                   if neighbor not in open_set_hash:
    77 121.3281 MiB   0.0000 MiB        3707                       count += 1
    78 121.3281 MiB   0.0000 MiB        3707                       open_set.put((f_score[neighbor], count, neighbor))
    79 121.3281 MiB   0.0000 MiB        3707                       open_set_hash.add(neighbor)
    80                                                             
    81 121.3281 MiB   0.0000 MiB        3286           if draw is not None:
    82                                                     draw()
    83                                         
    84 121.3281 MiB   0.0000 MiB        3286           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 121.3281 MiB 121.3281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 121.3281 MiB   0.0000 MiB         257       for row in grid:
    32 121.3281 MiB   0.0000 MiB       65792           for spot in row:
    33 121.3281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 121.3281 MiB   0.0000 MiB           1       count = 0
    36 121.3281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 121.3281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 121.3281 MiB   0.0000 MiB           1       came_from = {}
    39 122.9219 MiB   1.5938 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 122.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 122.9375 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 122.9375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 122.9375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 122.9375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 122.9375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 122.9375 MiB   0.0000 MiB        1235       while not open_set.empty():
    49 122.9375 MiB   0.0000 MiB        1235           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 122.9375 MiB   0.0000 MiB        1235           current = open_set.get()[2]
    55 122.9375 MiB   0.0000 MiB        1235           open_set_hash.remove(current)
    56                                         
    57 122.9375 MiB   0.0000 MiB        1235           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 122.9375 MiB   0.0000 MiB        1235           if current == end:
    62 122.9375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 122.9375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 122.9375 MiB   0.0000 MiB       11106           for neighbor in current.neighbors:
    67 122.9375 MiB   0.0000 MiB        9872               if current.row != neighbor.row and current.col != neighbor.col:
    68 122.9375 MiB   0.0000 MiB        4936                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 122.9375 MiB   0.0000 MiB        4936                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 122.9375 MiB   0.0000 MiB        9872               if temp_g_score < g_score[neighbor]:
    73 122.9375 MiB   0.0000 MiB        1531                   came_from[neighbor] = current
    74 122.9375 MiB   0.0000 MiB        1531                   g_score[neighbor] = temp_g_score
    75 122.9375 MiB   0.0000 MiB        1531                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 122.9375 MiB   0.0000 MiB        1531                   if neighbor not in open_set_hash:
    77 122.9375 MiB   0.0000 MiB        1531                       count += 1
    78 122.9375 MiB   0.0000 MiB        1531                       open_set.put((f_score[neighbor], count, neighbor))
    79 122.9375 MiB   0.0000 MiB        1531                       open_set_hash.add(neighbor)
    80                                                             
    81 122.9375 MiB   0.0000 MiB        1234           if draw is not None:
    82                                                     draw()
    83                                         
    84 122.9375 MiB   0.0000 MiB        1234           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 122.9375 MiB 122.9375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 122.9375 MiB   0.0000 MiB         257       for row in grid:
    32 122.9375 MiB   0.0000 MiB       65792           for spot in row:
    33 122.9375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 122.9375 MiB   0.0000 MiB           1       count = 0
    36 122.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 122.9375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 122.9375 MiB   0.0000 MiB           1       came_from = {}
    39 122.9375 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 122.9375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 124.3281 MiB   1.3906 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 124.3281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 124.3281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 124.3281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 124.3281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 124.3281 MiB   0.0000 MiB        4832       while not open_set.empty():
    49 124.3281 MiB   0.0000 MiB        4832           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 124.3281 MiB   0.0000 MiB        4832           current = open_set.get()[2]
    55 124.3281 MiB   0.0000 MiB        4832           open_set_hash.remove(current)
    56                                         
    57 124.3281 MiB   0.0000 MiB        4832           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 124.3281 MiB   0.0000 MiB        4832           if current == end:
    62 124.3281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 124.3281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 124.3281 MiB   0.0000 MiB       43479           for neighbor in current.neighbors:
    67 124.3281 MiB   0.0000 MiB       38648               if current.row != neighbor.row and current.col != neighbor.col:
    68 124.3281 MiB   0.0000 MiB       19324                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 124.3281 MiB   0.0000 MiB       19324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 124.3281 MiB   0.0000 MiB       38648               if temp_g_score < g_score[neighbor]:
    73 124.3281 MiB   0.0000 MiB        5260                   came_from[neighbor] = current
    74 124.3281 MiB   0.0000 MiB        5260                   g_score[neighbor] = temp_g_score
    75 124.3281 MiB   0.0000 MiB        5260                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 124.3281 MiB   0.0000 MiB        5260                   if neighbor not in open_set_hash:
    77 124.3281 MiB   0.0000 MiB        5260                       count += 1
    78 124.3281 MiB   0.0000 MiB        5260                       open_set.put((f_score[neighbor], count, neighbor))
    79 124.3281 MiB   0.0000 MiB        5260                       open_set_hash.add(neighbor)
    80                                                             
    81 124.3281 MiB   0.0000 MiB        4831           if draw is not None:
    82                                                     draw()
    83                                         
    84 124.3281 MiB   0.0000 MiB        4831           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 124.3281 MiB 124.3281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 124.3281 MiB   0.0000 MiB         257       for row in grid:
    32 124.3281 MiB   0.0000 MiB       65792           for spot in row:
    33 124.3281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 124.3281 MiB   0.0000 MiB           1       count = 0
    36 124.3281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 124.3281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 124.3281 MiB   0.0000 MiB           1       came_from = {}
    39 124.3281 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 124.3281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 124.3281 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 124.3281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 124.3281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 124.3281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 124.3281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 124.3281 MiB   0.0000 MiB         533       while not open_set.empty():
    49 124.3281 MiB   0.0000 MiB         533           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 124.3281 MiB   0.0000 MiB         533           current = open_set.get()[2]
    55 124.3281 MiB   0.0000 MiB         533           open_set_hash.remove(current)
    56                                         
    57 124.3281 MiB   0.0000 MiB         533           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 124.3281 MiB   0.0000 MiB         533           if current == end:
    62 124.3281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 124.3281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 124.3281 MiB   0.0000 MiB        4788           for neighbor in current.neighbors:
    67 124.3281 MiB   0.0000 MiB        4256               if current.row != neighbor.row and current.col != neighbor.col:
    68 124.3281 MiB   0.0000 MiB        2128                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 124.3281 MiB   0.0000 MiB        2128                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 124.3281 MiB   0.0000 MiB        4256               if temp_g_score < g_score[neighbor]:
    73 124.3281 MiB   0.0000 MiB         721                   came_from[neighbor] = current
    74 124.3281 MiB   0.0000 MiB         721                   g_score[neighbor] = temp_g_score
    75 124.3281 MiB   0.0000 MiB         721                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 124.3281 MiB   0.0000 MiB         721                   if neighbor not in open_set_hash:
    77 124.3281 MiB   0.0000 MiB         721                       count += 1
    78 124.3281 MiB   0.0000 MiB         721                       open_set.put((f_score[neighbor], count, neighbor))
    79 124.3281 MiB   0.0000 MiB         721                       open_set_hash.add(neighbor)
    80                                                             
    81 124.3281 MiB   0.0000 MiB         532           if draw is not None:
    82                                                     draw()
    83                                         
    84 124.3281 MiB   0.0000 MiB         532           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 124.3281 MiB 124.3281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 124.3281 MiB   0.0000 MiB         257       for row in grid:
    32 124.3281 MiB   0.0000 MiB       65792           for spot in row:
    33 124.3281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 124.3281 MiB   0.0000 MiB           1       count = 0
    36 124.3281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 124.3281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 124.3281 MiB   0.0000 MiB           1       came_from = {}
    39 124.6406 MiB   0.3125 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 124.6406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 127.1562 MiB   2.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 127.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 127.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 127.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 127.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 127.1562 MiB   0.0000 MiB         826       while not open_set.empty():
    49 127.1562 MiB   0.0000 MiB         826           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 127.1562 MiB   0.0000 MiB         826           current = open_set.get()[2]
    55 127.1562 MiB   0.0000 MiB         826           open_set_hash.remove(current)
    56                                         
    57 127.1562 MiB   0.0000 MiB         826           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 127.1562 MiB   0.0000 MiB         826           if current == end:
    62 127.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 127.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 127.1562 MiB   0.0000 MiB        7425           for neighbor in current.neighbors:
    67 127.1562 MiB   0.0000 MiB        6600               if current.row != neighbor.row and current.col != neighbor.col:
    68 127.1562 MiB   0.0000 MiB        3300                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 127.1562 MiB   0.0000 MiB        3300                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 127.1562 MiB   0.0000 MiB        6600               if temp_g_score < g_score[neighbor]:
    73 127.1562 MiB   0.0000 MiB         998                   came_from[neighbor] = current
    74 127.1562 MiB   0.0000 MiB         998                   g_score[neighbor] = temp_g_score
    75 127.1562 MiB   0.0000 MiB         998                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 127.1562 MiB   0.0000 MiB         998                   if neighbor not in open_set_hash:
    77 127.1562 MiB   0.0000 MiB         998                       count += 1
    78 127.1562 MiB   0.0000 MiB         998                       open_set.put((f_score[neighbor], count, neighbor))
    79 127.1562 MiB   0.0000 MiB         998                       open_set_hash.add(neighbor)
    80                                                             
    81 127.1562 MiB   0.0000 MiB         825           if draw is not None:
    82                                                     draw()
    83                                         
    84 127.1562 MiB   0.0000 MiB         825           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 127.1562 MiB 127.1562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 127.1562 MiB   0.0000 MiB         257       for row in grid:
    32 127.1562 MiB   0.0000 MiB       65792           for spot in row:
    33 127.1562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.1562 MiB   0.0000 MiB           1       count = 0
    36 127.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.1562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.1562 MiB   0.0000 MiB           1       came_from = {}
    39 127.1562 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 127.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 127.1562 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 127.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 127.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 127.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 127.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 127.1562 MiB   0.0000 MiB        3286       while not open_set.empty():
    49 127.1562 MiB   0.0000 MiB        3286           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 127.1562 MiB   0.0000 MiB        3286           current = open_set.get()[2]
    55 127.1562 MiB   0.0000 MiB        3286           open_set_hash.remove(current)
    56                                         
    57 127.1562 MiB   0.0000 MiB        3286           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 127.1562 MiB   0.0000 MiB        3286           if current == end:
    62 127.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 127.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 127.1562 MiB   0.0000 MiB       29565           for neighbor in current.neighbors:
    67 127.1562 MiB   0.0000 MiB       26280               if current.row != neighbor.row and current.col != neighbor.col:
    68 127.1562 MiB   0.0000 MiB       13140                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 127.1562 MiB   0.0000 MiB       13140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 127.1562 MiB   0.0000 MiB       26280               if temp_g_score < g_score[neighbor]:
    73 127.1562 MiB   0.0000 MiB        3620                   came_from[neighbor] = current
    74 127.1562 MiB   0.0000 MiB        3620                   g_score[neighbor] = temp_g_score
    75 127.1562 MiB   0.0000 MiB        3620                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 127.1562 MiB   0.0000 MiB        3620                   if neighbor not in open_set_hash:
    77 127.1562 MiB   0.0000 MiB        3620                       count += 1
    78 127.1562 MiB   0.0000 MiB        3620                       open_set.put((f_score[neighbor], count, neighbor))
    79 127.1562 MiB   0.0000 MiB        3620                       open_set_hash.add(neighbor)
    80                                                             
    81 127.1562 MiB   0.0000 MiB        3285           if draw is not None:
    82                                                     draw()
    83                                         
    84 127.1562 MiB   0.0000 MiB        3285           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 127.1562 MiB 127.1562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 127.1562 MiB   0.0000 MiB         257       for row in grid:
    32 127.1562 MiB   0.0000 MiB       65792           for spot in row:
    33 127.1562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.1562 MiB   0.0000 MiB           1       count = 0
    36 127.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.1562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.1562 MiB   0.0000 MiB           1       came_from = {}
    39 127.1562 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 127.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.5312 MiB   2.3750 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.5312 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.5312 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.5312 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.5312 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.5312 MiB   0.0000 MiB        1998       while not open_set.empty():
    49 129.5312 MiB   0.0000 MiB        1998           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.5312 MiB   0.0000 MiB        1998           current = open_set.get()[2]
    55 129.5312 MiB   0.0000 MiB        1998           open_set_hash.remove(current)
    56                                         
    57 129.5312 MiB   0.0000 MiB        1998           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.5312 MiB   0.0000 MiB        1998           if current == end:
    62 129.5312 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.5312 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.5312 MiB   0.0000 MiB       17973           for neighbor in current.neighbors:
    67 129.5312 MiB   0.0000 MiB       15976               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.5312 MiB   0.0000 MiB        7988                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.5312 MiB   0.0000 MiB        7988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.5312 MiB   0.0000 MiB       15976               if temp_g_score < g_score[neighbor]:
    73 129.5312 MiB   0.0000 MiB        2252                   came_from[neighbor] = current
    74 129.5312 MiB   0.0000 MiB        2252                   g_score[neighbor] = temp_g_score
    75 129.5312 MiB   0.0000 MiB        2252                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.5312 MiB   0.0000 MiB        2252                   if neighbor not in open_set_hash:
    77 129.5312 MiB   0.0000 MiB        2252                       count += 1
    78 129.5312 MiB   0.0000 MiB        2252                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.5312 MiB   0.0000 MiB        2252                       open_set_hash.add(neighbor)
    80                                                             
    81 129.5312 MiB   0.0000 MiB        1997           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.5312 MiB   0.0000 MiB        1997           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.6094 MiB 129.6094 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.6094 MiB   0.0000 MiB         257       for row in grid:
    32 129.6094 MiB   0.0000 MiB       65792           for spot in row:
    33 129.6094 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.6094 MiB   0.0000 MiB           1       count = 0
    36 129.6094 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.6094 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.6094 MiB   0.0000 MiB           1       came_from = {}
    39 129.6250 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.6250 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.7188 MiB   0.0938 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.7188 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.7188 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.7188 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.7188 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.7188 MiB   0.0000 MiB        5795       while not open_set.empty():
    49 129.7188 MiB   0.0000 MiB        5795           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.7188 MiB   0.0000 MiB        5795           current = open_set.get()[2]
    55 129.7188 MiB   0.0000 MiB        5795           open_set_hash.remove(current)
    56                                         
    57 129.7188 MiB   0.0000 MiB        5795           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.7188 MiB   0.0000 MiB        5795           if current == end:
    62 129.7188 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.7188 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.7188 MiB   0.0000 MiB       52146           for neighbor in current.neighbors:
    67 129.7188 MiB   0.0000 MiB       46352               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.7188 MiB   0.0000 MiB       23176                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.7188 MiB   0.0000 MiB       23176                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.7188 MiB   0.0000 MiB       46352               if temp_g_score < g_score[neighbor]:
    73 129.7188 MiB   0.0000 MiB        6227                   came_from[neighbor] = current
    74 129.7188 MiB   0.0000 MiB        6227                   g_score[neighbor] = temp_g_score
    75 129.7188 MiB   0.0000 MiB        6227                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.7188 MiB   0.0000 MiB        6227                   if neighbor not in open_set_hash:
    77 129.7188 MiB   0.0000 MiB        6227                       count += 1
    78 129.7188 MiB   0.0000 MiB        6227                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.7188 MiB   0.0000 MiB        6227                       open_set_hash.add(neighbor)
    80                                                             
    81 129.7188 MiB   0.0000 MiB        5794           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.7188 MiB   0.0000 MiB        5794           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.7188 MiB 129.7188 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.7188 MiB   0.0000 MiB         257       for row in grid:
    32 129.7188 MiB   0.0000 MiB       65792           for spot in row:
    33 129.7188 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.7188 MiB   0.0000 MiB           1       count = 0
    36 129.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.7188 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.7188 MiB   0.0000 MiB           1       came_from = {}
    39 130.5625 MiB   0.8438 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 130.5625 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.0781 MiB   2.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.0781 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.0781 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.0781 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.0781 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.0781 MiB   0.0000 MiB        4648       while not open_set.empty():
    49 133.0781 MiB   0.0000 MiB        4648           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.0781 MiB   0.0000 MiB        4648           current = open_set.get()[2]
    55 133.0781 MiB   0.0000 MiB        4648           open_set_hash.remove(current)
    56                                         
    57 133.0781 MiB   0.0000 MiB        4648           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.0781 MiB   0.0000 MiB        4648           if current == end:
    62 133.0781 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.0781 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.0781 MiB   0.0000 MiB       41823           for neighbor in current.neighbors:
    67 133.0781 MiB   0.0000 MiB       37176               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.0781 MiB   0.0000 MiB       18588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.0781 MiB   0.0000 MiB       18588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.0781 MiB   0.0000 MiB       37176               if temp_g_score < g_score[neighbor]:
    73 133.0781 MiB   0.0000 MiB        5036                   came_from[neighbor] = current
    74 133.0781 MiB   0.0000 MiB        5036                   g_score[neighbor] = temp_g_score
    75 133.0781 MiB   0.0000 MiB        5036                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.0781 MiB   0.0000 MiB        5036                   if neighbor not in open_set_hash:
    77 133.0781 MiB   0.0000 MiB        5036                       count += 1
    78 133.0781 MiB   0.0000 MiB        5036                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.0781 MiB   0.0000 MiB        5036                       open_set_hash.add(neighbor)
    80                                                             
    81 133.0781 MiB   0.0000 MiB        4647           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.0781 MiB   0.0000 MiB        4647           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.0781 MiB 133.0781 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.0781 MiB   0.0000 MiB         257       for row in grid:
    32 133.0781 MiB   0.0000 MiB       65792           for spot in row:
    33 133.0781 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.0781 MiB   0.0000 MiB           1       count = 0
    36 133.0781 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.0781 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.0781 MiB   0.0000 MiB           1       came_from = {}
    39 133.0781 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.0781 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.1562 MiB   1.0781 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.1562 MiB   0.0000 MiB        1080       while not open_set.empty():
    49 134.1562 MiB   0.0000 MiB        1080           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.1562 MiB   0.0000 MiB        1080           current = open_set.get()[2]
    55 134.1562 MiB   0.0000 MiB        1080           open_set_hash.remove(current)
    56                                         
    57 134.1562 MiB   0.0000 MiB        1080           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.1562 MiB   0.0000 MiB        1080           if current == end:
    62 134.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.1562 MiB   0.0000 MiB        9708           for neighbor in current.neighbors:
    67 134.1562 MiB   0.0000 MiB        8629               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.1562 MiB   0.0000 MiB        4314                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.1562 MiB   0.0000 MiB        4315                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.1562 MiB   0.0000 MiB        8629               if temp_g_score < g_score[neighbor]:
    73 134.1562 MiB   0.0000 MiB        1351                   came_from[neighbor] = current
    74 134.1562 MiB   0.0000 MiB        1351                   g_score[neighbor] = temp_g_score
    75 134.1562 MiB   0.0000 MiB        1351                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.1562 MiB   0.0000 MiB        1351                   if neighbor not in open_set_hash:
    77 134.1562 MiB   0.0000 MiB        1351                       count += 1
    78 134.1562 MiB   0.0000 MiB        1351                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.1562 MiB   0.0000 MiB        1351                       open_set_hash.add(neighbor)
    80                                                             
    81 134.1562 MiB   0.0000 MiB        1079           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.1562 MiB   0.0000 MiB        1079           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.1562 MiB 134.1562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.1562 MiB   0.0000 MiB         257       for row in grid:
    32 134.1562 MiB   0.0000 MiB       65792           for spot in row:
    33 134.1562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.1562 MiB   0.0000 MiB           1       count = 0
    36 134.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.1562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.1562 MiB   0.0000 MiB           1       came_from = {}
    39 134.2031 MiB   0.0469 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.2031 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.2812 MiB   2.0781 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.2812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.2812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.2812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.2812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.2812 MiB   0.0000 MiB        8686       while not open_set.empty():
    49 136.2812 MiB   0.0000 MiB        8686           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.2812 MiB   0.0000 MiB        8686           current = open_set.get()[2]
    55 136.2812 MiB   0.0000 MiB        8686           open_set_hash.remove(current)
    56                                         
    57 136.2812 MiB   0.0000 MiB        8686           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.2812 MiB   0.0000 MiB        8686           if current == end:
    62 136.2812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.2812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.2812 MiB   0.0000 MiB       78165           for neighbor in current.neighbors:
    67 136.2812 MiB   0.0000 MiB       69480               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.2812 MiB   0.0000 MiB       34740                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.2812 MiB   0.0000 MiB       34740                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.2812 MiB   0.0000 MiB       69480               if temp_g_score < g_score[neighbor]:
    73 136.2812 MiB   0.0000 MiB        9230                   came_from[neighbor] = current
    74 136.2812 MiB   0.0000 MiB        9230                   g_score[neighbor] = temp_g_score
    75 136.2812 MiB   0.0000 MiB        9230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.2812 MiB   0.0000 MiB        9230                   if neighbor not in open_set_hash:
    77 136.2812 MiB   0.0000 MiB        9230                       count += 1
    78 136.2812 MiB   0.0000 MiB        9230                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.2812 MiB   0.0000 MiB        9230                       open_set_hash.add(neighbor)
    80                                                             
    81 136.2812 MiB   0.0000 MiB        8685           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.2812 MiB   0.0000 MiB        8685           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.2812 MiB 136.2812 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.2812 MiB   0.0000 MiB         257       for row in grid:
    32 136.2812 MiB   0.0000 MiB       65792           for spot in row:
    33 136.2812 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.2812 MiB   0.0000 MiB           1       count = 0
    36 136.2812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.2812 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.2812 MiB   0.0000 MiB           1       came_from = {}
    39 136.2812 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.2812 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.2969 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.2969 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.2969 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.2969 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.2969 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.2969 MiB   0.0000 MiB        1400       while not open_set.empty():
    49 136.2969 MiB   0.0000 MiB        1400           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.2969 MiB   0.0000 MiB        1400           current = open_set.get()[2]
    55 136.2969 MiB   0.0000 MiB        1400           open_set_hash.remove(current)
    56                                         
    57 136.2969 MiB   0.0000 MiB        1400           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.2969 MiB   0.0000 MiB        1400           if current == end:
    62 136.2969 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.2969 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.2969 MiB   0.0000 MiB       12591           for neighbor in current.neighbors:
    67 136.2969 MiB   0.0000 MiB       11192               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.2969 MiB   0.0000 MiB        5596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.2969 MiB   0.0000 MiB        5596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.2969 MiB   0.0000 MiB       11192               if temp_g_score < g_score[neighbor]:
    73 136.2969 MiB   0.0000 MiB        1610                   came_from[neighbor] = current
    74 136.2969 MiB   0.0000 MiB        1610                   g_score[neighbor] = temp_g_score
    75 136.2969 MiB   0.0000 MiB        1610                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.2969 MiB   0.0000 MiB        1610                   if neighbor not in open_set_hash:
    77 136.2969 MiB   0.0000 MiB        1610                       count += 1
    78 136.2969 MiB   0.0000 MiB        1610                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.2969 MiB   0.0000 MiB        1610                       open_set_hash.add(neighbor)
    80                                                             
    81 136.2969 MiB   0.0000 MiB        1399           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.2969 MiB   0.0000 MiB        1399           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.2969 MiB 136.2969 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.2969 MiB   0.0000 MiB         257       for row in grid:
    32 136.2969 MiB   0.0000 MiB       65792           for spot in row:
    33 136.2969 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.2969 MiB   0.0000 MiB           1       count = 0
    36 136.2969 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.2969 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.2969 MiB   0.0000 MiB           1       came_from = {}
    39 136.2969 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.2969 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.2969 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.2969 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.2969 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.2969 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.2969 MiB   0.0000 MiB        9271       while not open_set.empty():
    49 136.2969 MiB   0.0000 MiB        9271           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.2969 MiB   0.0000 MiB        9271           current = open_set.get()[2]
    55 136.2969 MiB   0.0000 MiB        9271           open_set_hash.remove(current)
    56                                         
    57 136.2969 MiB   0.0000 MiB        9271           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.2969 MiB   0.0000 MiB        9271           if current == end:
    62 136.2969 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.2969 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.2969 MiB   0.0000 MiB       83430           for neighbor in current.neighbors:
    67 136.2969 MiB   0.0000 MiB       74160               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.2969 MiB   0.0000 MiB       37080                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.2969 MiB   0.0000 MiB       37080                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.2969 MiB   0.0000 MiB       74160               if temp_g_score < g_score[neighbor]:
    73 136.2969 MiB   0.0000 MiB        9815                   came_from[neighbor] = current
    74 136.2969 MiB   0.0000 MiB        9815                   g_score[neighbor] = temp_g_score
    75 136.2969 MiB   0.0000 MiB        9815                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.2969 MiB   0.0000 MiB        9815                   if neighbor not in open_set_hash:
    77 136.2969 MiB   0.0000 MiB        9815                       count += 1
    78 136.2969 MiB   0.0000 MiB        9815                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.2969 MiB   0.0000 MiB        9815                       open_set_hash.add(neighbor)
    80                                                             
    81 136.2969 MiB   0.0000 MiB        9270           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.2969 MiB   0.0000 MiB        9270           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.2969 MiB 136.2969 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.2969 MiB   0.0000 MiB         257       for row in grid:
    32 136.2969 MiB   0.0000 MiB       65792           for spot in row:
    33 136.2969 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.2969 MiB   0.0000 MiB           1       count = 0
    36 136.2969 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.2969 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.2969 MiB   0.0000 MiB           1       came_from = {}
    39 136.2969 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.2969 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.2969 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.2969 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.2969 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.2969 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.2969 MiB   0.0000 MiB          28       while not open_set.empty():
    49 136.2969 MiB   0.0000 MiB          28           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.2969 MiB   0.0000 MiB          28           current = open_set.get()[2]
    55 136.2969 MiB   0.0000 MiB          28           open_set_hash.remove(current)
    56                                         
    57 136.2969 MiB   0.0000 MiB          28           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.2969 MiB   0.0000 MiB          28           if current == end:
    62 136.2969 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.2969 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.2969 MiB   0.0000 MiB         243           for neighbor in current.neighbors:
    67 136.2969 MiB   0.0000 MiB         216               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.2969 MiB   0.0000 MiB         108                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.2969 MiB   0.0000 MiB         108                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.2969 MiB   0.0000 MiB         216               if temp_g_score < g_score[neighbor]:
    73 136.2969 MiB   0.0000 MiB          86                   came_from[neighbor] = current
    74 136.2969 MiB   0.0000 MiB          86                   g_score[neighbor] = temp_g_score
    75 136.2969 MiB   0.0000 MiB          86                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.2969 MiB   0.0000 MiB          86                   if neighbor not in open_set_hash:
    77 136.2969 MiB   0.0000 MiB          86                       count += 1
    78 136.2969 MiB   0.0000 MiB          86                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.2969 MiB   0.0000 MiB          86                       open_set_hash.add(neighbor)
    80                                                             
    81 136.2969 MiB   0.0000 MiB          27           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.2969 MiB   0.0000 MiB          27           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.2969 MiB 136.2969 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.2969 MiB   0.0000 MiB         257       for row in grid:
    32 136.2969 MiB   0.0000 MiB       65792           for spot in row:
    33 136.2969 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.2969 MiB   0.0000 MiB           1       count = 0
    36 136.2969 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.2969 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.2969 MiB   0.0000 MiB           1       came_from = {}
    39 136.2969 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.1250 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB        6767       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB        6767           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB        6767           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB        6767           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB        6767           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB        6767           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB       60894           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB       54128               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB       27064                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB       27064                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB       54128               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB        7235                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB        7235                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB        7235                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB        7235                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB        7235                       count += 1
    78 136.4219 MiB   0.0000 MiB        7235                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB        7235                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB        6766           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB        6766           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB        2340       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB        2340           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB        2340           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB        2340           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB        2340           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB        2340           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB       21051           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB       18712               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB        9356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB        9356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB       18712               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB        2670                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB        2670                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB        2670                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB        2670                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB        2670                       count += 1
    78 136.4219 MiB   0.0000 MiB        2670                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB        2670                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB        2339           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB        2339           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB        2262       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB        2262           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB        2262           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB        2262           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB        2262           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB        2262           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB       20349           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB       18088               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB        9044                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB        9044                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB       18088               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB        2570                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB        2570                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB        2570                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB        2570                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB        2570                       count += 1
    78 136.4219 MiB   0.0000 MiB        2570                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB        2570                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB        2261           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB        2261           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB        1152       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB        1152           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB        1152           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB        1152           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB        1152           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB       10359           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB        9208               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB        1358                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB        1358                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB        1358                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB        1358                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB        1358                       count += 1
    78 136.4219 MiB   0.0000 MiB        1358                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB        1358                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB        1151           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB        1151           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB        1494       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB        1494           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB        1494           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB        1494           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB        1494           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB        1494           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB       13437           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB       11944               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB        5972                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB        5972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB       11944               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB        1860                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB        1860                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB        1860                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB        1860                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB        1860                       count += 1
    78 136.4219 MiB   0.0000 MiB        1860                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB        1860                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB        1493           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB        1493           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB       10672       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB       10672           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB       10672           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB       10672           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB       10672           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB       10672           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB       96039           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB       85368               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB       42684                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB       42684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB       85368               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB       11270                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB       11270                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB       11270                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB       11270                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB       11270                       count += 1
    78 136.4219 MiB   0.0000 MiB       11270                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB       11270                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB       10671           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB       10671           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB         156       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB         156           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB         156           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB         156           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB         156           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB         156           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB        1395           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB        1240               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB         620                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB         620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB        1240               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB         230                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB         230                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB         230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB         230                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB         230                       count += 1
    78 136.4219 MiB   0.0000 MiB         230                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB         230                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB         155           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB         155           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB        1408       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB        1408           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB        1408           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB        1408           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB        1408           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB        1408           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB       12663           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB       11256               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB        5628                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB        5628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB       11256               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB        1622                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB        1622                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB        1622                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB        1622                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB        1622                       count += 1
    78 136.4219 MiB   0.0000 MiB        1622                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB        1622                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB        1407           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB        1407           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB         711       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB         711           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB         711           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB         711           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB         711           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB         711           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB        6390           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB        5680               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB        2840                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB        2840                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB        5680               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB        1043                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB        1043                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB        1043                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB        1043                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB        1043                       count += 1
    78 136.4219 MiB   0.0000 MiB        1043                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB        1043                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB         710           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB         710           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.4219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.4219 MiB   0.0000 MiB         490       while not open_set.empty():
    49 136.4219 MiB   0.0000 MiB         490           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.4219 MiB   0.0000 MiB         490           current = open_set.get()[2]
    55 136.4219 MiB   0.0000 MiB         490           open_set_hash.remove(current)
    56                                         
    57 136.4219 MiB   0.0000 MiB         490           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.4219 MiB   0.0000 MiB         490           if current == end:
    62 136.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.4219 MiB   0.0000 MiB        4401           for neighbor in current.neighbors:
    67 136.4219 MiB   0.0000 MiB        3912               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.4219 MiB   0.0000 MiB        1956                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.4219 MiB   0.0000 MiB        1956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.4219 MiB   0.0000 MiB        3912               if temp_g_score < g_score[neighbor]:
    73 136.4219 MiB   0.0000 MiB         614                   came_from[neighbor] = current
    74 136.4219 MiB   0.0000 MiB         614                   g_score[neighbor] = temp_g_score
    75 136.4219 MiB   0.0000 MiB         614                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.4219 MiB   0.0000 MiB         614                   if neighbor not in open_set_hash:
    77 136.4219 MiB   0.0000 MiB         614                       count += 1
    78 136.4219 MiB   0.0000 MiB         614                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.4219 MiB   0.0000 MiB         614                       open_set_hash.add(neighbor)
    80                                                             
    81 136.4219 MiB   0.0000 MiB         489           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.4219 MiB   0.0000 MiB         489           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.4219 MiB 136.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.4219 MiB   0.0000 MiB         257       for row in grid:
    32 136.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 136.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.4219 MiB   0.0000 MiB           1       count = 0
    36 136.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.4219 MiB   0.0000 MiB           1       came_from = {}
    39 136.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.6094 MiB   3.1875 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.6094 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.6094 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.6094 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.6094 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.6562 MiB   0.0000 MiB        6440       while not open_set.empty():
    49 139.6562 MiB   0.0000 MiB        6440           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.6562 MiB   0.0000 MiB        6440           current = open_set.get()[2]
    55 139.6562 MiB   0.0000 MiB        6440           open_set_hash.remove(current)
    56                                         
    57 139.6562 MiB   0.0000 MiB        6440           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.6562 MiB   0.0000 MiB        6440           if current == end:
    62 139.6562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.6562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.6562 MiB   0.0000 MiB       57951           for neighbor in current.neighbors:
    67 139.6562 MiB   0.0000 MiB       51512               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.6562 MiB   0.0000 MiB       25756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.6562 MiB   0.0000 MiB       25756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.6562 MiB   0.0000 MiB       51512               if temp_g_score < g_score[neighbor]:
    73 139.6562 MiB   0.0469 MiB        6946                   came_from[neighbor] = current
    74 139.6562 MiB   0.0000 MiB        6946                   g_score[neighbor] = temp_g_score
    75 139.6562 MiB   0.0000 MiB        6946                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.6562 MiB   0.0000 MiB        6946                   if neighbor not in open_set_hash:
    77 139.6562 MiB   0.0000 MiB        6946                       count += 1
    78 139.6562 MiB   0.0000 MiB        6946                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.6562 MiB   0.0000 MiB        6946                       open_set_hash.add(neighbor)
    80                                                             
    81 139.6562 MiB   0.0000 MiB        6439           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.6562 MiB   0.0000 MiB        6439           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.6562 MiB 139.6562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.6562 MiB   0.0000 MiB         257       for row in grid:
    32 139.6562 MiB   0.0000 MiB       65792           for spot in row:
    33 139.6562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.6562 MiB   0.0000 MiB           1       count = 0
    36 139.6562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.6562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.6562 MiB   0.0000 MiB           1       came_from = {}
    39 139.6562 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.6562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.7188 MiB   0.0625 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.7188 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.7188 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.7188 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.7188 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.7188 MiB   0.0000 MiB        1479       while not open_set.empty():
    49 139.7188 MiB   0.0000 MiB        1479           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.7188 MiB   0.0000 MiB        1479           current = open_set.get()[2]
    55 139.7188 MiB   0.0000 MiB        1479           open_set_hash.remove(current)
    56                                         
    57 139.7188 MiB   0.0000 MiB        1479           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.7188 MiB   0.0000 MiB        1479           if current == end:
    62 139.7188 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.7188 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.7188 MiB   0.0000 MiB       13302           for neighbor in current.neighbors:
    67 139.7188 MiB   0.0000 MiB       11824               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.7188 MiB   0.0000 MiB        5912                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.7188 MiB   0.0000 MiB        5912                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.7188 MiB   0.0000 MiB       11824               if temp_g_score < g_score[neighbor]:
    73 139.7188 MiB   0.0000 MiB        1695                   came_from[neighbor] = current
    74 139.7188 MiB   0.0000 MiB        1695                   g_score[neighbor] = temp_g_score
    75 139.7188 MiB   0.0000 MiB        1695                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.7188 MiB   0.0000 MiB        1695                   if neighbor not in open_set_hash:
    77 139.7188 MiB   0.0000 MiB        1695                       count += 1
    78 139.7188 MiB   0.0000 MiB        1695                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.7188 MiB   0.0000 MiB        1695                       open_set_hash.add(neighbor)
    80                                                             
    81 139.7188 MiB   0.0000 MiB        1478           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.7188 MiB   0.0000 MiB        1478           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.7188 MiB 139.7188 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.7188 MiB   0.0000 MiB         257       for row in grid:
    32 139.7188 MiB   0.0000 MiB       65792           for spot in row:
    33 139.7188 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.7188 MiB   0.0000 MiB           1       count = 0
    36 139.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.7188 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.7188 MiB   0.0000 MiB           1       came_from = {}
    39 139.7188 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.7188 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.7188 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.7188 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.7188 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.7188 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.7188 MiB   0.0000 MiB        2064       while not open_set.empty():
    49 139.7188 MiB   0.0000 MiB        2064           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.7188 MiB   0.0000 MiB        2064           current = open_set.get()[2]
    55 139.7188 MiB   0.0000 MiB        2064           open_set_hash.remove(current)
    56                                         
    57 139.7188 MiB   0.0000 MiB        2064           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.7188 MiB   0.0000 MiB        2064           if current == end:
    62 139.7188 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.7188 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.7188 MiB   0.0000 MiB       18567           for neighbor in current.neighbors:
    67 139.7188 MiB   0.0000 MiB       16504               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.7188 MiB   0.0000 MiB        8252                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.7188 MiB   0.0000 MiB        8252                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.7188 MiB   0.0000 MiB       16504               if temp_g_score < g_score[neighbor]:
    73 139.7188 MiB   0.0000 MiB        2340                   came_from[neighbor] = current
    74 139.7188 MiB   0.0000 MiB        2340                   g_score[neighbor] = temp_g_score
    75 139.7188 MiB   0.0000 MiB        2340                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.7188 MiB   0.0000 MiB        2340                   if neighbor not in open_set_hash:
    77 139.7188 MiB   0.0000 MiB        2340                       count += 1
    78 139.7188 MiB   0.0000 MiB        2340                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.7188 MiB   0.0000 MiB        2340                       open_set_hash.add(neighbor)
    80                                                             
    81 139.7188 MiB   0.0000 MiB        2063           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.7188 MiB   0.0000 MiB        2063           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.7188 MiB 139.7188 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.7188 MiB   0.0000 MiB         257       for row in grid:
    32 139.7188 MiB   0.0000 MiB       65792           for spot in row:
    33 139.7188 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.7188 MiB   0.0000 MiB           1       count = 0
    36 139.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.7188 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.7188 MiB   0.0000 MiB           1       came_from = {}
    39 139.7188 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.7188 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.7188 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.7188 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.7188 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.7188 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.7188 MiB   0.0000 MiB        8820       while not open_set.empty():
    49 139.7188 MiB   0.0000 MiB        8820           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.7188 MiB   0.0000 MiB        8820           current = open_set.get()[2]
    55 139.7188 MiB   0.0000 MiB        8820           open_set_hash.remove(current)
    56                                         
    57 139.7188 MiB   0.0000 MiB        8820           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.7188 MiB   0.0000 MiB        8820           if current == end:
    62 139.7188 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.7188 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.7188 MiB   0.0000 MiB       79371           for neighbor in current.neighbors:
    67 139.7188 MiB   0.0000 MiB       70552               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.7188 MiB   0.0000 MiB       35276                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.7188 MiB   0.0000 MiB       35276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.7188 MiB   0.0000 MiB       70552               if temp_g_score < g_score[neighbor]:
    73 139.7188 MiB   0.0000 MiB        9364                   came_from[neighbor] = current
    74 139.7188 MiB   0.0000 MiB        9364                   g_score[neighbor] = temp_g_score
    75 139.7188 MiB   0.0000 MiB        9364                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.7188 MiB   0.0000 MiB        9364                   if neighbor not in open_set_hash:
    77 139.7188 MiB   0.0000 MiB        9364                       count += 1
    78 139.7188 MiB   0.0000 MiB        9364                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.7188 MiB   0.0000 MiB        9364                       open_set_hash.add(neighbor)
    80                                                             
    81 139.7188 MiB   0.0000 MiB        8819           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.7188 MiB   0.0000 MiB        8819           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.7188 MiB 139.7188 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.7188 MiB   0.0000 MiB         257       for row in grid:
    32 139.7188 MiB   0.0000 MiB       65792           for spot in row:
    33 139.7188 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.7188 MiB   0.0000 MiB           1       count = 0
    36 139.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.7188 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.7188 MiB   0.0000 MiB           1       came_from = {}
    39 139.7188 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.7188 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.7188 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.7188 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.7188 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.7188 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.7188 MiB   0.0000 MiB         369       while not open_set.empty():
    49 139.7188 MiB   0.0000 MiB         369           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.7188 MiB   0.0000 MiB         369           current = open_set.get()[2]
    55 139.7188 MiB   0.0000 MiB         369           open_set_hash.remove(current)
    56                                         
    57 139.7188 MiB   0.0000 MiB         369           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.7188 MiB   0.0000 MiB         369           if current == end:
    62 139.7188 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.7188 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.7188 MiB   0.0000 MiB        3309           for neighbor in current.neighbors:
    67 139.7188 MiB   0.0000 MiB        2941               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.7188 MiB   0.0000 MiB        1470                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.7188 MiB   0.0000 MiB        1471                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.7188 MiB   0.0000 MiB        2941               if temp_g_score < g_score[neighbor]:
    73 139.7188 MiB   0.0000 MiB         622                   came_from[neighbor] = current
    74 139.7188 MiB   0.0000 MiB         622                   g_score[neighbor] = temp_g_score
    75 139.7188 MiB   0.0000 MiB         622                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.7188 MiB   0.0000 MiB         622                   if neighbor not in open_set_hash:
    77 139.7188 MiB   0.0000 MiB         622                       count += 1
    78 139.7188 MiB   0.0000 MiB         622                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.7188 MiB   0.0000 MiB         622                       open_set_hash.add(neighbor)
    80                                                             
    81 139.7188 MiB   0.0000 MiB         368           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.7188 MiB   0.0000 MiB         368           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.7188 MiB 139.7188 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.7188 MiB   0.0000 MiB         257       for row in grid:
    32 139.7188 MiB   0.0000 MiB       65792           for spot in row:
    33 139.7188 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.7188 MiB   0.0000 MiB           1       count = 0
    36 139.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.7188 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.7188 MiB   0.0000 MiB           1       came_from = {}
    39 139.7188 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.7188 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.7188 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.7188 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.7188 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.7188 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.7188 MiB   0.0000 MiB        1246       while not open_set.empty():
    49 139.7188 MiB   0.0000 MiB        1246           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.7188 MiB   0.0000 MiB        1246           current = open_set.get()[2]
    55 139.7188 MiB   0.0000 MiB        1246           open_set_hash.remove(current)
    56                                         
    57 139.7188 MiB   0.0000 MiB        1246           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.7188 MiB   0.0000 MiB        1246           if current == end:
    62 139.7188 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.7188 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.7188 MiB   0.0000 MiB       11205           for neighbor in current.neighbors:
    67 139.7188 MiB   0.0000 MiB        9960               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.7188 MiB   0.0000 MiB        4980                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.7188 MiB   0.0000 MiB        4980                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.7188 MiB   0.0000 MiB        9960               if temp_g_score < g_score[neighbor]:
    73 139.7188 MiB   0.0000 MiB        1628                   came_from[neighbor] = current
    74 139.7188 MiB   0.0000 MiB        1628                   g_score[neighbor] = temp_g_score
    75 139.7188 MiB   0.0000 MiB        1628                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.7188 MiB   0.0000 MiB        1628                   if neighbor not in open_set_hash:
    77 139.7188 MiB   0.0000 MiB        1628                       count += 1
    78 139.7188 MiB   0.0000 MiB        1628                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.7188 MiB   0.0000 MiB        1628                       open_set_hash.add(neighbor)
    80                                                             
    81 139.7188 MiB   0.0000 MiB        1245           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.7188 MiB   0.0000 MiB        1245           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.7188 MiB 139.7188 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.7188 MiB   0.0000 MiB         257       for row in grid:
    32 139.7188 MiB   0.0000 MiB       65792           for spot in row:
    33 139.7188 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.7188 MiB   0.0000 MiB           1       count = 0
    36 139.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.7188 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.7188 MiB   0.0000 MiB           1       came_from = {}
    39 139.7188 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.7344 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.7344 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.7344 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.7344 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.7344 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.7344 MiB   0.0000 MiB        2904       while not open_set.empty():
    49 139.7344 MiB   0.0000 MiB        2904           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.7344 MiB   0.0000 MiB        2904           current = open_set.get()[2]
    55 139.7344 MiB   0.0000 MiB        2904           open_set_hash.remove(current)
    56                                         
    57 139.7344 MiB   0.0000 MiB        2904           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.7344 MiB   0.0000 MiB        2904           if current == end:
    62 139.7344 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.7344 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.7344 MiB   0.0000 MiB       26127           for neighbor in current.neighbors:
    67 139.7344 MiB   0.0000 MiB       23224               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.7344 MiB   0.0000 MiB       11612                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.7344 MiB   0.0000 MiB       11612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.7344 MiB   0.0000 MiB       23224               if temp_g_score < g_score[neighbor]:
    73 139.7344 MiB   0.0000 MiB        3240                   came_from[neighbor] = current
    74 139.7344 MiB   0.0000 MiB        3240                   g_score[neighbor] = temp_g_score
    75 139.7344 MiB   0.0000 MiB        3240                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.7344 MiB   0.0000 MiB        3240                   if neighbor not in open_set_hash:
    77 139.7344 MiB   0.0000 MiB        3240                       count += 1
    78 139.7344 MiB   0.0000 MiB        3240                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.7344 MiB   0.0000 MiB        3240                       open_set_hash.add(neighbor)
    80                                                             
    81 139.7344 MiB   0.0000 MiB        2903           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.7344 MiB   0.0000 MiB        2903           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.7344 MiB 139.7344 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.7344 MiB   0.0000 MiB         257       for row in grid:
    32 139.7344 MiB   0.0000 MiB       65792           for spot in row:
    33 139.7344 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.7344 MiB   0.0000 MiB           1       count = 0
    36 139.7344 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.7344 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.7344 MiB   0.0000 MiB           1       came_from = {}
    39 139.7969 MiB   0.0625 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.7969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.7969 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.7969 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.7969 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.7969 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.7969 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.7969 MiB   0.0000 MiB        3082       while not open_set.empty():
    49 139.7969 MiB   0.0000 MiB        3082           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.7969 MiB   0.0000 MiB        3082           current = open_set.get()[2]
    55 139.7969 MiB   0.0000 MiB        3082           open_set_hash.remove(current)
    56                                         
    57 139.7969 MiB   0.0000 MiB        3082           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.7969 MiB   0.0000 MiB        3082           if current == end:
    62 139.7969 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.7969 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.7969 MiB   0.0000 MiB       27729           for neighbor in current.neighbors:
    67 139.7969 MiB   0.0000 MiB       24648               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.7969 MiB   0.0000 MiB       12324                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.7969 MiB   0.0000 MiB       12324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.7969 MiB   0.0000 MiB       24648               if temp_g_score < g_score[neighbor]:
    73 139.7969 MiB   0.0000 MiB        3398                   came_from[neighbor] = current
    74 139.7969 MiB   0.0000 MiB        3398                   g_score[neighbor] = temp_g_score
    75 139.7969 MiB   0.0000 MiB        3398                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.7969 MiB   0.0000 MiB        3398                   if neighbor not in open_set_hash:
    77 139.7969 MiB   0.0000 MiB        3398                       count += 1
    78 139.7969 MiB   0.0000 MiB        3398                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.7969 MiB   0.0000 MiB        3398                       open_set_hash.add(neighbor)
    80                                                             
    81 139.7969 MiB   0.0000 MiB        3081           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.7969 MiB   0.0000 MiB        3081           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.7969 MiB 139.7969 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.7969 MiB   0.0000 MiB         257       for row in grid:
    32 139.7969 MiB   0.0000 MiB       65792           for spot in row:
    33 139.7969 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.7969 MiB   0.0000 MiB           1       count = 0
    36 139.7969 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.7969 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.7969 MiB   0.0000 MiB           1       came_from = {}
    39 139.7969 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.7969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.7969 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.7969 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.7969 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.7969 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.7969 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.7969 MiB   0.0000 MiB          84       while not open_set.empty():
    49 139.7969 MiB   0.0000 MiB          84           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.7969 MiB   0.0000 MiB          84           current = open_set.get()[2]
    55 139.7969 MiB   0.0000 MiB          84           open_set_hash.remove(current)
    56                                         
    57 139.7969 MiB   0.0000 MiB          84           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.7969 MiB   0.0000 MiB          84           if current == end:
    62 139.7969 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.7969 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.7969 MiB   0.0000 MiB         747           for neighbor in current.neighbors:
    67 139.7969 MiB   0.0000 MiB         664               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.7969 MiB   0.0000 MiB         332                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.7969 MiB   0.0000 MiB         332                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.7969 MiB   0.0000 MiB         664               if temp_g_score < g_score[neighbor]:
    73 139.7969 MiB   0.0000 MiB         144                   came_from[neighbor] = current
    74 139.7969 MiB   0.0000 MiB         144                   g_score[neighbor] = temp_g_score
    75 139.7969 MiB   0.0000 MiB         144                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.7969 MiB   0.0000 MiB         144                   if neighbor not in open_set_hash:
    77 139.7969 MiB   0.0000 MiB         144                       count += 1
    78 139.7969 MiB   0.0000 MiB         144                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.7969 MiB   0.0000 MiB         144                       open_set_hash.add(neighbor)
    80                                                             
    81 139.7969 MiB   0.0000 MiB          83           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.7969 MiB   0.0000 MiB          83           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.7969 MiB 139.7969 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.7969 MiB   0.0000 MiB         257       for row in grid:
    32 139.7969 MiB   0.0000 MiB       65792           for spot in row:
    33 139.7969 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.7969 MiB   0.0000 MiB           1       count = 0
    36 139.7969 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.7969 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.7969 MiB   0.0000 MiB           1       came_from = {}
    39 139.7969 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.7969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.7969 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.7969 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.7969 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.7969 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.7969 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.8281 MiB   0.0000 MiB        7504       while not open_set.empty():
    49 139.8281 MiB   0.0000 MiB        7504           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.8281 MiB   0.0000 MiB        7504           current = open_set.get()[2]
    55 139.8281 MiB   0.0000 MiB        7504           open_set_hash.remove(current)
    56                                         
    57 139.8281 MiB   0.0000 MiB        7504           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.8281 MiB   0.0000 MiB        7504           if current == end:
    62 139.8281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.8281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.8281 MiB   0.0000 MiB       67527           for neighbor in current.neighbors:
    67 139.8281 MiB   0.0000 MiB       60024               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.8281 MiB   0.0000 MiB       30012                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.8281 MiB   0.0000 MiB       30012                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.8281 MiB   0.0000 MiB       60024               if temp_g_score < g_score[neighbor]:
    73 139.8281 MiB   0.0000 MiB        7994                   came_from[neighbor] = current
    74 139.8281 MiB   0.0000 MiB        7994                   g_score[neighbor] = temp_g_score
    75 139.8281 MiB   0.0000 MiB        7994                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.8281 MiB   0.0000 MiB        7994                   if neighbor not in open_set_hash:
    77 139.8281 MiB   0.0000 MiB        7994                       count += 1
    78 139.8281 MiB   0.0000 MiB        7994                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.8281 MiB   0.0312 MiB        7994                       open_set_hash.add(neighbor)
    80                                                             
    81 139.8281 MiB   0.0000 MiB        7503           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.8281 MiB   0.0000 MiB        7503           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.8281 MiB 139.8281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.8281 MiB   0.0000 MiB         257       for row in grid:
    32 139.8281 MiB   0.0000 MiB       65792           for spot in row:
    33 139.8281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.8281 MiB   0.0000 MiB           1       count = 0
    36 139.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.8281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.8281 MiB   0.0000 MiB           1       came_from = {}
    39 139.8281 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.8281 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.8281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.8281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.8281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.8281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.8281 MiB   0.0000 MiB        1540       while not open_set.empty():
    49 139.8281 MiB   0.0000 MiB        1540           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.8281 MiB   0.0000 MiB        1540           current = open_set.get()[2]
    55 139.8281 MiB   0.0000 MiB        1540           open_set_hash.remove(current)
    56                                         
    57 139.8281 MiB   0.0000 MiB        1540           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.8281 MiB   0.0000 MiB        1540           if current == end:
    62 139.8281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.8281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.8281 MiB   0.0000 MiB       13851           for neighbor in current.neighbors:
    67 139.8281 MiB   0.0000 MiB       12312               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.8281 MiB   0.0000 MiB        6156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.8281 MiB   0.0000 MiB        6156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.8281 MiB   0.0000 MiB       12312               if temp_g_score < g_score[neighbor]:
    73 139.8281 MiB   0.0000 MiB        1862                   came_from[neighbor] = current
    74 139.8281 MiB   0.0000 MiB        1862                   g_score[neighbor] = temp_g_score
    75 139.8281 MiB   0.0000 MiB        1862                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.8281 MiB   0.0000 MiB        1862                   if neighbor not in open_set_hash:
    77 139.8281 MiB   0.0000 MiB        1862                       count += 1
    78 139.8281 MiB   0.0000 MiB        1862                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.8281 MiB   0.0000 MiB        1862                       open_set_hash.add(neighbor)
    80                                                             
    81 139.8281 MiB   0.0000 MiB        1539           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.8281 MiB   0.0000 MiB        1539           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.8281 MiB 139.8281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.8281 MiB   0.0000 MiB         257       for row in grid:
    32 139.8281 MiB   0.0000 MiB       65792           for spot in row:
    33 139.8281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.8281 MiB   0.0000 MiB           1       count = 0
    36 139.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.8281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.8281 MiB   0.0000 MiB           1       came_from = {}
    39 139.8281 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.8281 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.8281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.8281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.8281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.8281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.8281 MiB   0.0000 MiB         459       while not open_set.empty():
    49 139.8281 MiB   0.0000 MiB         459           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.8281 MiB   0.0000 MiB         459           current = open_set.get()[2]
    55 139.8281 MiB   0.0000 MiB         459           open_set_hash.remove(current)
    56                                         
    57 139.8281 MiB   0.0000 MiB         459           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.8281 MiB   0.0000 MiB         459           if current == end:
    62 139.8281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.8281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.8281 MiB   0.0000 MiB        4122           for neighbor in current.neighbors:
    67 139.8281 MiB   0.0000 MiB        3664               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.8281 MiB   0.0000 MiB        1832                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.8281 MiB   0.0000 MiB        1832                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.8281 MiB   0.0000 MiB        3664               if temp_g_score < g_score[neighbor]:
    73 139.8281 MiB   0.0000 MiB         599                   came_from[neighbor] = current
    74 139.8281 MiB   0.0000 MiB         599                   g_score[neighbor] = temp_g_score
    75 139.8281 MiB   0.0000 MiB         599                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.8281 MiB   0.0000 MiB         599                   if neighbor not in open_set_hash:
    77 139.8281 MiB   0.0000 MiB         599                       count += 1
    78 139.8281 MiB   0.0000 MiB         599                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.8281 MiB   0.0000 MiB         599                       open_set_hash.add(neighbor)
    80                                                             
    81 139.8281 MiB   0.0000 MiB         458           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.8281 MiB   0.0000 MiB         458           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.8281 MiB 139.8281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.8281 MiB   0.0000 MiB         257       for row in grid:
    32 139.8281 MiB   0.0000 MiB       65792           for spot in row:
    33 139.8281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.8281 MiB   0.0000 MiB           1       count = 0
    36 139.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.8281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.8281 MiB   0.0000 MiB           1       came_from = {}
    39 139.8281 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.8281 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.8281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.8281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.8281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.8281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.8281 MiB   0.0000 MiB        5092       while not open_set.empty():
    49 139.8281 MiB   0.0000 MiB        5092           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.8281 MiB   0.0000 MiB        5092           current = open_set.get()[2]
    55 139.8281 MiB   0.0000 MiB        5092           open_set_hash.remove(current)
    56                                         
    57 139.8281 MiB   0.0000 MiB        5092           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.8281 MiB   0.0000 MiB        5092           if current == end:
    62 139.8281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.8281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.8281 MiB   0.0000 MiB       45819           for neighbor in current.neighbors:
    67 139.8281 MiB   0.0000 MiB       40728               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.8281 MiB   0.0000 MiB       20364                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.8281 MiB   0.0000 MiB       20364                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.8281 MiB   0.0000 MiB       40728               if temp_g_score < g_score[neighbor]:
    73 139.8281 MiB   0.0000 MiB        5702                   came_from[neighbor] = current
    74 139.8281 MiB   0.0000 MiB        5702                   g_score[neighbor] = temp_g_score
    75 139.8281 MiB   0.0000 MiB        5702                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.8281 MiB   0.0000 MiB        5702                   if neighbor not in open_set_hash:
    77 139.8281 MiB   0.0000 MiB        5702                       count += 1
    78 139.8281 MiB   0.0000 MiB        5702                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.8281 MiB   0.0000 MiB        5702                       open_set_hash.add(neighbor)
    80                                                             
    81 139.8281 MiB   0.0000 MiB        5091           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.8281 MiB   0.0000 MiB        5091           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.8281 MiB 139.8281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.8281 MiB   0.0000 MiB         257       for row in grid:
    32 139.8281 MiB   0.0000 MiB       65792           for spot in row:
    33 139.8281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.8281 MiB   0.0000 MiB           1       count = 0
    36 139.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.8281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.8281 MiB   0.0000 MiB           1       came_from = {}
    39 139.8281 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.8281 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.8281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.8281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.8281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.8281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.8281 MiB   0.0000 MiB        3094       while not open_set.empty():
    49 139.8281 MiB   0.0000 MiB        3094           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.8281 MiB   0.0000 MiB        3094           current = open_set.get()[2]
    55 139.8281 MiB   0.0000 MiB        3094           open_set_hash.remove(current)
    56                                         
    57 139.8281 MiB   0.0000 MiB        3094           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.8281 MiB   0.0000 MiB        3094           if current == end:
    62 139.8281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.8281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.8281 MiB   0.0000 MiB       27837           for neighbor in current.neighbors:
    67 139.8281 MiB   0.0000 MiB       24744               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.8281 MiB   0.0000 MiB       12372                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.8281 MiB   0.0000 MiB       12372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.8281 MiB   0.0000 MiB       24744               if temp_g_score < g_score[neighbor]:
    73 139.8281 MiB   0.0000 MiB        3434                   came_from[neighbor] = current
    74 139.8281 MiB   0.0000 MiB        3434                   g_score[neighbor] = temp_g_score
    75 139.8281 MiB   0.0000 MiB        3434                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.8281 MiB   0.0000 MiB        3434                   if neighbor not in open_set_hash:
    77 139.8281 MiB   0.0000 MiB        3434                       count += 1
    78 139.8281 MiB   0.0000 MiB        3434                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.8281 MiB   0.0000 MiB        3434                       open_set_hash.add(neighbor)
    80                                                             
    81 139.8281 MiB   0.0000 MiB        3093           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.8281 MiB   0.0000 MiB        3093           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 139.8281 MiB 139.8281 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 139.8281 MiB   0.0000 MiB         257       for row in grid:
    32 139.8281 MiB   0.0000 MiB       65792           for spot in row:
    33 139.8281 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 139.8281 MiB   0.0000 MiB           1       count = 0
    36 139.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 139.8281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 139.8281 MiB   0.0000 MiB           1       came_from = {}
    39 139.8281 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 139.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 139.8281 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 139.8281 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 139.8281 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 139.8281 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 139.8281 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 139.8281 MiB   0.0000 MiB        5499       while not open_set.empty():
    49 139.8281 MiB   0.0000 MiB        5499           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 139.8281 MiB   0.0000 MiB        5499           current = open_set.get()[2]
    55 139.8281 MiB   0.0000 MiB        5499           open_set_hash.remove(current)
    56                                         
    57 139.8281 MiB   0.0000 MiB        5499           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 139.8281 MiB   0.0000 MiB        5499           if current == end:
    62 139.8281 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 139.8281 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 139.8281 MiB   0.0000 MiB       49482           for neighbor in current.neighbors:
    67 139.8281 MiB   0.0000 MiB       43984               if current.row != neighbor.row and current.col != neighbor.col:
    68 139.8281 MiB   0.0000 MiB       21992                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 139.8281 MiB   0.0000 MiB       21992                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 139.8281 MiB   0.0000 MiB       43984               if temp_g_score < g_score[neighbor]:
    73 139.8281 MiB   0.0000 MiB        5935                   came_from[neighbor] = current
    74 139.8281 MiB   0.0000 MiB        5935                   g_score[neighbor] = temp_g_score
    75 139.8281 MiB   0.0000 MiB        5935                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 139.8281 MiB   0.0000 MiB        5935                   if neighbor not in open_set_hash:
    77 139.8281 MiB   0.0000 MiB        5935                       count += 1
    78 139.8281 MiB   0.0000 MiB        5935                       open_set.put((f_score[neighbor], count, neighbor))
    79 139.8281 MiB   0.0000 MiB        5935                       open_set_hash.add(neighbor)
    80                                                             
    81 139.8281 MiB   0.0000 MiB        5498           if draw is not None:
    82                                                     draw()
    83                                         
    84 139.8281 MiB   0.0000 MiB        5498           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 140.1719 MiB 140.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 140.1719 MiB   0.0000 MiB         257       for row in grid:
    32 140.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 140.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 140.1719 MiB   0.0000 MiB           1       count = 0
    36 140.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 140.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 140.1719 MiB   0.0000 MiB           1       came_from = {}
    39 140.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 140.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 140.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 140.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 140.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 140.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 140.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 140.1719 MiB   0.0000 MiB        3332       while not open_set.empty():
    49 140.1719 MiB   0.0000 MiB        3332           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 140.1719 MiB   0.0000 MiB        3332           current = open_set.get()[2]
    55 140.1719 MiB   0.0000 MiB        3332           open_set_hash.remove(current)
    56                                         
    57 140.1719 MiB   0.0000 MiB        3332           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 140.1719 MiB   0.0000 MiB        3332           if current == end:
    62 140.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 140.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 140.1719 MiB   0.0000 MiB       29979           for neighbor in current.neighbors:
    67 140.1719 MiB   0.0000 MiB       26648               if current.row != neighbor.row and current.col != neighbor.col:
    68 140.1719 MiB   0.0000 MiB       13324                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 140.1719 MiB   0.0000 MiB       13324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 140.1719 MiB   0.0000 MiB       26648               if temp_g_score < g_score[neighbor]:
    73 140.1719 MiB   0.0000 MiB        3862                   came_from[neighbor] = current
    74 140.1719 MiB   0.0000 MiB        3862                   g_score[neighbor] = temp_g_score
    75 140.1719 MiB   0.0000 MiB        3862                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 140.1719 MiB   0.0000 MiB        3862                   if neighbor not in open_set_hash:
    77 140.1719 MiB   0.0000 MiB        3862                       count += 1
    78 140.1719 MiB   0.0000 MiB        3862                       open_set.put((f_score[neighbor], count, neighbor))
    79 140.1719 MiB   0.0000 MiB        3862                       open_set_hash.add(neighbor)
    80                                                             
    81 140.1719 MiB   0.0000 MiB        3331           if draw is not None:
    82                                                     draw()
    83                                         
    84 140.1719 MiB   0.0000 MiB        3331           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 140.1719 MiB 140.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 140.1719 MiB   0.0000 MiB         257       for row in grid:
    32 140.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 140.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 140.1719 MiB   0.0000 MiB           1       count = 0
    36 140.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 140.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 140.1719 MiB   0.0000 MiB           1       came_from = {}
    39 140.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 140.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 140.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 140.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 140.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 140.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 140.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 140.1719 MiB   0.0000 MiB         325       while not open_set.empty():
    49 140.1719 MiB   0.0000 MiB         325           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 140.1719 MiB   0.0000 MiB         325           current = open_set.get()[2]
    55 140.1719 MiB   0.0000 MiB         325           open_set_hash.remove(current)
    56                                         
    57 140.1719 MiB   0.0000 MiB         325           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 140.1719 MiB   0.0000 MiB         325           if current == end:
    62 140.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 140.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 140.1719 MiB   0.0000 MiB        2916           for neighbor in current.neighbors:
    67 140.1719 MiB   0.0000 MiB        2592               if current.row != neighbor.row and current.col != neighbor.col:
    68 140.1719 MiB   0.0000 MiB        1296                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 140.1719 MiB   0.0000 MiB        1296                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 140.1719 MiB   0.0000 MiB        2592               if temp_g_score < g_score[neighbor]:
    73 140.1719 MiB   0.0000 MiB         473                   came_from[neighbor] = current
    74 140.1719 MiB   0.0000 MiB         473                   g_score[neighbor] = temp_g_score
    75 140.1719 MiB   0.0000 MiB         473                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 140.1719 MiB   0.0000 MiB         473                   if neighbor not in open_set_hash:
    77 140.1719 MiB   0.0000 MiB         473                       count += 1
    78 140.1719 MiB   0.0000 MiB         473                       open_set.put((f_score[neighbor], count, neighbor))
    79 140.1719 MiB   0.0000 MiB         473                       open_set_hash.add(neighbor)
    80                                                             
    81 140.1719 MiB   0.0000 MiB         324           if draw is not None:
    82                                                     draw()
    83                                         
    84 140.1719 MiB   0.0000 MiB         324           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 140.1719 MiB 140.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 140.1719 MiB   0.0000 MiB         257       for row in grid:
    32 140.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 140.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 140.1719 MiB   0.0000 MiB           1       count = 0
    36 140.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 140.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 140.1719 MiB   0.0000 MiB           1       came_from = {}
    39 140.2031 MiB   0.0312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 140.2031 MiB   0.0000 MiB           1       g_score[start] = 0
    41 140.2031 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 140.2031 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 140.2031 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 140.2031 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 140.2031 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 140.2031 MiB   0.0000 MiB        3648       while not open_set.empty():
    49 140.2031 MiB   0.0000 MiB        3648           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 140.2031 MiB   0.0000 MiB        3648           current = open_set.get()[2]
    55 140.2031 MiB   0.0000 MiB        3648           open_set_hash.remove(current)
    56                                         
    57 140.2031 MiB   0.0000 MiB        3648           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 140.2031 MiB   0.0000 MiB        3648           if current == end:
    62 140.2031 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 140.2031 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 140.2031 MiB   0.0000 MiB       32823           for neighbor in current.neighbors:
    67 140.2031 MiB   0.0000 MiB       29176               if current.row != neighbor.row and current.col != neighbor.col:
    68 140.2031 MiB   0.0000 MiB       14588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 140.2031 MiB   0.0000 MiB       14588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 140.2031 MiB   0.0000 MiB       29176               if temp_g_score < g_score[neighbor]:
    73 140.2031 MiB   0.0000 MiB        4002                   came_from[neighbor] = current
    74 140.2031 MiB   0.0000 MiB        4002                   g_score[neighbor] = temp_g_score
    75 140.2031 MiB   0.0000 MiB        4002                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 140.2031 MiB   0.0000 MiB        4002                   if neighbor not in open_set_hash:
    77 140.2031 MiB   0.0000 MiB        4002                       count += 1
    78 140.2031 MiB   0.0000 MiB        4002                       open_set.put((f_score[neighbor], count, neighbor))
    79 140.2031 MiB   0.0000 MiB        4002                       open_set_hash.add(neighbor)
    80                                                             
    81 140.2031 MiB   0.0000 MiB        3647           if draw is not None:
    82                                                     draw()
    83                                         
    84 140.2031 MiB   0.0000 MiB        3647           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 140.2031 MiB 140.2031 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 140.2031 MiB -1111.7344 MiB         257       for row in grid:
    32 140.2031 MiB -284425.6406 MiB       65792           for spot in row:
    33 140.2031 MiB -283322.0312 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.9531 MiB -11.2500 MiB           1       count = 0
    36 128.9531 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.9531 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.9531 MiB   0.0000 MiB           1       came_from = {}
    39 129.7812 MiB   0.8281 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.7812 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.9375 MiB   0.1562 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.9375 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.9375 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.9375 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.9375 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.9375 MiB   0.0000 MiB        2400       while not open_set.empty():
    49 129.9375 MiB   0.0000 MiB        2400           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.9375 MiB   0.0000 MiB        2400           current = open_set.get()[2]
    55 129.9375 MiB   0.0000 MiB        2400           open_set_hash.remove(current)
    56                                         
    57 129.9375 MiB   0.0000 MiB        2400           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.9375 MiB   0.0000 MiB        2400           if current == end:
    62 129.9375 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.9375 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.9375 MiB   0.0000 MiB       21591           for neighbor in current.neighbors:
    67 129.9375 MiB   0.0000 MiB       19192               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.9375 MiB   0.0000 MiB        9596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.9375 MiB   0.0000 MiB        9596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.9375 MiB   0.0000 MiB       19192               if temp_g_score < g_score[neighbor]:
    73 129.9375 MiB   0.0000 MiB        2690                   came_from[neighbor] = current
    74 129.9375 MiB   0.0000 MiB        2690                   g_score[neighbor] = temp_g_score
    75 129.9375 MiB   0.0000 MiB        2690                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.9375 MiB   0.0000 MiB        2690                   if neighbor not in open_set_hash:
    77 129.9375 MiB   0.0000 MiB        2690                       count += 1
    78 129.9375 MiB   0.0000 MiB        2690                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.9375 MiB   0.0000 MiB        2690                       open_set_hash.add(neighbor)
    80                                                             
    81 129.9375 MiB   0.0000 MiB        2399           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.9375 MiB   0.0000 MiB        2399           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.9375 MiB 129.9375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.9375 MiB   0.0000 MiB         257       for row in grid:
    32 129.9375 MiB   0.0000 MiB       65792           for spot in row:
    33 129.9375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.9375 MiB   0.0000 MiB           1       count = 0
    36 129.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.9375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.9375 MiB   0.0000 MiB           1       came_from = {}
    39 130.3281 MiB   0.3906 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 130.3281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 130.6719 MiB   0.3438 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 130.6719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 130.6719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 130.6719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 130.6719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 130.6719 MiB -1037.0625 MiB        1305       while not open_set.empty():
    49 130.6719 MiB -1037.1406 MiB        1305           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 130.6719 MiB -1037.2344 MiB        1305           current = open_set.get()[2]
    55 130.6719 MiB -1037.2969 MiB        1305           open_set_hash.remove(current)
    56                                         
    57 130.6719 MiB -1037.3125 MiB        1305           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 130.6719 MiB -1037.4219 MiB        1305           if current == end:
    62 128.7031 MiB  -1.9688 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.7031 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 130.6719 MiB -9328.1250 MiB       11736           for neighbor in current.neighbors:
    67 130.6719 MiB -8291.5469 MiB       10432               if current.row != neighbor.row and current.col != neighbor.col:
    68 130.6719 MiB -4147.4375 MiB        5216                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 130.6719 MiB -4144.3750 MiB        5216                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 130.6719 MiB -8292.0469 MiB       10432               if temp_g_score < g_score[neighbor]:
    73 130.6719 MiB -1311.1094 MiB        1681                   came_from[neighbor] = current
    74 130.6719 MiB -1311.1094 MiB        1681                   g_score[neighbor] = temp_g_score
    75 130.6719 MiB -1311.1094 MiB        1681                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 130.6719 MiB -1311.1094 MiB        1681                   if neighbor not in open_set_hash:
    77 130.6719 MiB -1311.1094 MiB        1681                       count += 1
    78 130.6719 MiB -1311.2188 MiB        1681                       open_set.put((f_score[neighbor], count, neighbor))
    79 130.6719 MiB -1311.3438 MiB        1681                       open_set_hash.add(neighbor)
    80                                                             
    81 130.6719 MiB -1036.9375 MiB        1304           if draw is not None:
    82                                                     draw()
    83                                         
    84 130.6719 MiB -1036.9844 MiB        1304           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.7031 MiB 128.7031 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.7031 MiB   0.0000 MiB         257       for row in grid:
    32 128.7031 MiB   0.0000 MiB       65792           for spot in row:
    33 128.7031 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.7031 MiB   0.0000 MiB           1       count = 0
    36 128.7031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.7031 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.7031 MiB   0.0000 MiB           1       came_from = {}
    39 128.7031 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.7031 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.7031 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.7031 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.7031 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.7031 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.7031 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.7031 MiB   0.0000 MiB        4440       while not open_set.empty():
    49 128.7031 MiB   0.0000 MiB        4440           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.7031 MiB   0.0000 MiB        4440           current = open_set.get()[2]
    55 128.7031 MiB   0.0000 MiB        4440           open_set_hash.remove(current)
    56                                         
    57 128.7031 MiB   0.0000 MiB        4440           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.7031 MiB   0.0000 MiB        4440           if current == end:
    62 128.7031 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.7031 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.7031 MiB   0.0000 MiB       39951           for neighbor in current.neighbors:
    67 128.7031 MiB   0.0000 MiB       35512               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.7031 MiB   0.0000 MiB       17756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.7031 MiB   0.0000 MiB       17756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.7031 MiB   0.0000 MiB       35512               if temp_g_score < g_score[neighbor]:
    73 128.7031 MiB   0.0000 MiB        4904                   came_from[neighbor] = current
    74 128.7031 MiB   0.0000 MiB        4904                   g_score[neighbor] = temp_g_score
    75 128.7031 MiB   0.0000 MiB        4904                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.7031 MiB   0.0000 MiB        4904                   if neighbor not in open_set_hash:
    77 128.7031 MiB   0.0000 MiB        4904                       count += 1
    78 128.7031 MiB   0.0000 MiB        4904                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.7031 MiB   0.0000 MiB        4904                       open_set_hash.add(neighbor)
    80                                                             
    81 128.7031 MiB   0.0000 MiB        4439           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.7031 MiB   0.0000 MiB        4439           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.7031 MiB 128.7031 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.7031 MiB   0.0000 MiB         257       for row in grid:
    32 128.7031 MiB   0.0000 MiB       65792           for spot in row:
    33 128.7031 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.7031 MiB   0.0000 MiB           1       count = 0
    36 128.7031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.7031 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.7031 MiB   0.0000 MiB           1       came_from = {}
    39 129.8281 MiB   1.1250 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.8281 MiB   0.0000 MiB           1       g_score[start] = 0
    41 130.0469 MiB   0.2188 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 130.0469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 130.0469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 130.0469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 130.0469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 130.0469 MiB   0.0000 MiB         159       while not open_set.empty():
    49 130.0469 MiB   0.0000 MiB         159           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 130.0469 MiB   0.0000 MiB         159           current = open_set.get()[2]
    55 130.0469 MiB   0.0000 MiB         159           open_set_hash.remove(current)
    56                                         
    57 130.0469 MiB   0.0000 MiB         159           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 130.0469 MiB   0.0000 MiB         159           if current == end:
    62 130.0469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 130.0469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 130.0469 MiB   0.0000 MiB        1422           for neighbor in current.neighbors:
    67 130.0469 MiB   0.0000 MiB        1264               if current.row != neighbor.row and current.col != neighbor.col:
    68 130.0469 MiB   0.0000 MiB         632                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 130.0469 MiB   0.0000 MiB         632                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 130.0469 MiB   0.0000 MiB        1264               if temp_g_score < g_score[neighbor]:
    73 130.0469 MiB   0.0000 MiB         275                   came_from[neighbor] = current
    74 130.0469 MiB   0.0000 MiB         275                   g_score[neighbor] = temp_g_score
    75 130.0469 MiB   0.0000 MiB         275                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 130.0469 MiB   0.0000 MiB         275                   if neighbor not in open_set_hash:
    77 130.0469 MiB   0.0000 MiB         275                       count += 1
    78 130.0469 MiB   0.0000 MiB         275                       open_set.put((f_score[neighbor], count, neighbor))
    79 130.0469 MiB   0.0000 MiB         275                       open_set_hash.add(neighbor)
    80                                                             
    81 130.0469 MiB   0.0000 MiB         158           if draw is not None:
    82                                                     draw()
    83                                         
    84 130.0469 MiB   0.0000 MiB         158           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 130.0469 MiB 130.0469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 130.0469 MiB   0.0000 MiB         257       for row in grid:
    32 130.0469 MiB   0.0000 MiB       65792           for spot in row:
    33 130.0469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 130.0469 MiB   0.0000 MiB           1       count = 0
    36 130.0469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 130.0469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 130.0469 MiB   0.0000 MiB           1       came_from = {}
    39 130.0469 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 130.0469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 130.0625 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 130.0625 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 130.0625 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 130.0625 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 130.0625 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 130.0625 MiB   0.0000 MiB         495       while not open_set.empty():
    49 130.0625 MiB   0.0000 MiB         495           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 130.0625 MiB   0.0000 MiB         495           current = open_set.get()[2]
    55 130.0625 MiB   0.0000 MiB         495           open_set_hash.remove(current)
    56                                         
    57 130.0625 MiB   0.0000 MiB         495           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 130.0625 MiB   0.0000 MiB         495           if current == end:
    62 130.0625 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 130.0625 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 130.0625 MiB   0.0000 MiB        4446           for neighbor in current.neighbors:
    67 130.0625 MiB   0.0000 MiB        3952               if current.row != neighbor.row and current.col != neighbor.col:
    68 130.0625 MiB   0.0000 MiB        1976                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 130.0625 MiB   0.0000 MiB        1976                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 130.0625 MiB   0.0000 MiB        3952               if temp_g_score < g_score[neighbor]:
    73 130.0625 MiB   0.0000 MiB         731                   came_from[neighbor] = current
    74 130.0625 MiB   0.0000 MiB         731                   g_score[neighbor] = temp_g_score
    75 130.0625 MiB   0.0000 MiB         731                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 130.0625 MiB   0.0000 MiB         731                   if neighbor not in open_set_hash:
    77 130.0625 MiB   0.0000 MiB         731                       count += 1
    78 130.0625 MiB   0.0000 MiB         731                       open_set.put((f_score[neighbor], count, neighbor))
    79 130.0625 MiB   0.0000 MiB         731                       open_set_hash.add(neighbor)
    80                                                             
    81 130.0625 MiB   0.0000 MiB         494           if draw is not None:
    82                                                     draw()
    83                                         
    84 130.0625 MiB   0.0000 MiB         494           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 130.0625 MiB 130.0625 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 130.0625 MiB   0.0000 MiB         257       for row in grid:
    32 130.0625 MiB   0.0000 MiB       65792           for spot in row:
    33 130.0625 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 130.0625 MiB   0.0000 MiB           1       count = 0
    36 130.0625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 130.0625 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 130.0625 MiB   0.0000 MiB           1       came_from = {}
    39 130.0625 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 130.0625 MiB   0.0000 MiB           1       g_score[start] = 0
    41 131.0781 MiB   1.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 131.0781 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 131.0781 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 131.0781 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 131.0781 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 131.0781 MiB   0.0000 MiB        7238       while not open_set.empty():
    49 131.0781 MiB   0.0000 MiB        7238           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 131.0781 MiB   0.0000 MiB        7238           current = open_set.get()[2]
    55 131.0781 MiB   0.0000 MiB        7238           open_set_hash.remove(current)
    56                                         
    57 131.0781 MiB   0.0000 MiB        7238           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 131.0781 MiB   0.0000 MiB        7238           if current == end:
    62 131.0781 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 131.0781 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 131.0781 MiB   0.0000 MiB       65133           for neighbor in current.neighbors:
    67 131.0781 MiB   0.0000 MiB       57896               if current.row != neighbor.row and current.col != neighbor.col:
    68 131.0781 MiB   0.0000 MiB       28948                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 131.0781 MiB   0.0000 MiB       28948                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 131.0781 MiB   0.0000 MiB       57896               if temp_g_score < g_score[neighbor]:
    73 131.0781 MiB   0.0000 MiB        7732                   came_from[neighbor] = current
    74 131.0781 MiB   0.0000 MiB        7732                   g_score[neighbor] = temp_g_score
    75 131.0781 MiB   0.0000 MiB        7732                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 131.0781 MiB   0.0000 MiB        7732                   if neighbor not in open_set_hash:
    77 131.0781 MiB   0.0000 MiB        7732                       count += 1
    78 131.0781 MiB   0.0000 MiB        7732                       open_set.put((f_score[neighbor], count, neighbor))
    79 131.0781 MiB   0.0000 MiB        7732                       open_set_hash.add(neighbor)
    80                                                             
    81 131.0781 MiB   0.0000 MiB        7237           if draw is not None:
    82                                                     draw()
    83                                         
    84 131.0781 MiB   0.0000 MiB        7237           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 131.0781 MiB 131.0781 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 131.0781 MiB   0.0000 MiB         257       for row in grid:
    32 131.0781 MiB   0.0000 MiB       65792           for spot in row:
    33 131.0781 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 131.0781 MiB   0.0000 MiB           1       count = 0
    36 131.0781 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 131.0781 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 131.0781 MiB   0.0000 MiB           1       came_from = {}
    39 131.0781 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 131.0781 MiB   0.0000 MiB           1       g_score[start] = 0
    41 132.3125 MiB   1.2344 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 132.3125 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 132.3125 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 132.3125 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 132.3125 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 132.3125 MiB   0.0000 MiB        3362       while not open_set.empty():
    49 132.3125 MiB   0.0000 MiB        3362           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 132.3125 MiB   0.0000 MiB        3362           current = open_set.get()[2]
    55 132.3125 MiB   0.0000 MiB        3362           open_set_hash.remove(current)
    56                                         
    57 132.3125 MiB   0.0000 MiB        3362           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 132.3125 MiB   0.0000 MiB        3362           if current == end:
    62 132.3125 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 132.3125 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 132.3125 MiB   0.0000 MiB       30249           for neighbor in current.neighbors:
    67 132.3125 MiB   0.0000 MiB       26888               if current.row != neighbor.row and current.col != neighbor.col:
    68 132.3125 MiB   0.0000 MiB       13444                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 132.3125 MiB   0.0000 MiB       13444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 132.3125 MiB   0.0000 MiB       26888               if temp_g_score < g_score[neighbor]:
    73 132.3125 MiB   0.0000 MiB        3688                   came_from[neighbor] = current
    74 132.3125 MiB   0.0000 MiB        3688                   g_score[neighbor] = temp_g_score
    75 132.3125 MiB   0.0000 MiB        3688                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 132.3125 MiB   0.0000 MiB        3688                   if neighbor not in open_set_hash:
    77 132.3125 MiB   0.0000 MiB        3688                       count += 1
    78 132.3125 MiB   0.0000 MiB        3688                       open_set.put((f_score[neighbor], count, neighbor))
    79 132.3125 MiB   0.0000 MiB        3688                       open_set_hash.add(neighbor)
    80                                                             
    81 132.3125 MiB   0.0000 MiB        3361           if draw is not None:
    82                                                     draw()
    83                                         
    84 132.3125 MiB   0.0000 MiB        3361           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 132.3125 MiB 132.3125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 132.3125 MiB   0.0000 MiB         257       for row in grid:
    32 132.3125 MiB   0.0000 MiB       65792           for spot in row:
    33 132.3125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 132.3125 MiB   0.0000 MiB           1       count = 0
    36 132.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 132.3125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 132.3125 MiB   0.0000 MiB           1       came_from = {}
    39 133.2188 MiB   0.9062 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.2188 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.1875 MiB   0.9688 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.1875 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.1875 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.1875 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.1875 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.1875 MiB   0.0000 MiB        5073       while not open_set.empty():
    49 134.1875 MiB   0.0000 MiB        5073           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.1875 MiB   0.0000 MiB        5073           current = open_set.get()[2]
    55 134.1875 MiB   0.0000 MiB        5073           open_set_hash.remove(current)
    56                                         
    57 134.1875 MiB   0.0000 MiB        5073           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.1875 MiB   0.0000 MiB        5073           if current == end:
    62 134.1875 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.1875 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.1875 MiB   0.0000 MiB       45648           for neighbor in current.neighbors:
    67 134.1875 MiB   0.0000 MiB       40576               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.1875 MiB   0.0000 MiB       20288                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.1875 MiB   0.0000 MiB       20288                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.1875 MiB   0.0000 MiB       40576               if temp_g_score < g_score[neighbor]:
    73 134.1875 MiB   0.0000 MiB        5541                   came_from[neighbor] = current
    74 134.1875 MiB   0.0000 MiB        5541                   g_score[neighbor] = temp_g_score
    75 134.1875 MiB   0.0000 MiB        5541                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.1875 MiB   0.0000 MiB        5541                   if neighbor not in open_set_hash:
    77 134.1875 MiB   0.0000 MiB        5541                       count += 1
    78 134.1875 MiB   0.0000 MiB        5541                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.1875 MiB   0.0000 MiB        5541                       open_set_hash.add(neighbor)
    80                                                             
    81 134.1875 MiB   0.0000 MiB        5072           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.1875 MiB   0.0000 MiB        5072           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.1875 MiB 134.1875 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.1875 MiB   0.0000 MiB         257       for row in grid:
    32 134.1875 MiB   0.0000 MiB       65792           for spot in row:
    33 134.1875 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.1875 MiB   0.0000 MiB           1       count = 0
    36 134.1875 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.1875 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.1875 MiB   0.0000 MiB           1       came_from = {}
    39 134.1875 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.1875 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.1875 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.1875 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.1875 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.1875 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.1875 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.1875 MiB   0.0000 MiB        3850       while not open_set.empty():
    49 134.1875 MiB   0.0000 MiB        3850           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.1875 MiB   0.0000 MiB        3850           current = open_set.get()[2]
    55 134.1875 MiB   0.0000 MiB        3850           open_set_hash.remove(current)
    56                                         
    57 134.1875 MiB   0.0000 MiB        3850           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.1875 MiB   0.0000 MiB        3850           if current == end:
    62 134.1875 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.1875 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.1875 MiB   0.0000 MiB       34641           for neighbor in current.neighbors:
    67 134.1875 MiB   0.0000 MiB       30792               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.1875 MiB   0.0000 MiB       15396                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.1875 MiB   0.0000 MiB       15396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.1875 MiB   0.0000 MiB       30792               if temp_g_score < g_score[neighbor]:
    73 134.1875 MiB   0.0000 MiB        4208                   came_from[neighbor] = current
    74 134.1875 MiB   0.0000 MiB        4208                   g_score[neighbor] = temp_g_score
    75 134.1875 MiB   0.0000 MiB        4208                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.1875 MiB   0.0000 MiB        4208                   if neighbor not in open_set_hash:
    77 134.1875 MiB   0.0000 MiB        4208                       count += 1
    78 134.1875 MiB   0.0000 MiB        4208                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.1875 MiB   0.0000 MiB        4208                       open_set_hash.add(neighbor)
    80                                                             
    81 134.1875 MiB   0.0000 MiB        3849           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.1875 MiB   0.0000 MiB        3849           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.1875 MiB 134.1875 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.1875 MiB   0.0000 MiB         257       for row in grid:
    32 134.1875 MiB   0.0000 MiB       65792           for spot in row:
    33 134.1875 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.1875 MiB   0.0000 MiB           1       count = 0
    36 134.1875 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.1875 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.1875 MiB   0.0000 MiB           1       came_from = {}
    39 134.1875 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.1875 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.0312 MiB   0.8438 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.0312 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.0312 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.0312 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.0312 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.0312 MiB   0.0000 MiB         147       while not open_set.empty():
    49 135.0312 MiB   0.0000 MiB         147           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.0312 MiB   0.0000 MiB         147           current = open_set.get()[2]
    55 135.0312 MiB   0.0000 MiB         147           open_set_hash.remove(current)
    56                                         
    57 135.0312 MiB   0.0000 MiB         147           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.0312 MiB   0.0000 MiB         147           if current == end:
    62 135.0312 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.0312 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.0312 MiB   0.0000 MiB        1314           for neighbor in current.neighbors:
    67 135.0312 MiB   0.0000 MiB        1168               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.0312 MiB   0.0000 MiB         584                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.0312 MiB   0.0000 MiB         584                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.0312 MiB   0.0000 MiB        1168               if temp_g_score < g_score[neighbor]:
    73 135.0312 MiB   0.0000 MiB         243                   came_from[neighbor] = current
    74 135.0312 MiB   0.0000 MiB         243                   g_score[neighbor] = temp_g_score
    75 135.0312 MiB   0.0000 MiB         243                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.0312 MiB   0.0000 MiB         243                   if neighbor not in open_set_hash:
    77 135.0312 MiB   0.0000 MiB         243                       count += 1
    78 135.0312 MiB   0.0000 MiB         243                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.0312 MiB   0.0000 MiB         243                       open_set_hash.add(neighbor)
    80                                                             
    81 135.0312 MiB   0.0000 MiB         146           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.0312 MiB   0.0000 MiB         146           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.0312 MiB 135.0312 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.0312 MiB   0.0000 MiB         257       for row in grid:
    32 135.0312 MiB   0.0000 MiB       65792           for spot in row:
    33 135.0312 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.0312 MiB   0.0000 MiB           1       count = 0
    36 135.0312 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.0312 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.0312 MiB   0.0000 MiB           1       came_from = {}
    39 135.0312 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.0312 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.0312 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.0312 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.0312 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.0312 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.0312 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.0312 MiB   0.0000 MiB         133       while not open_set.empty():
    49 135.0312 MiB   0.0000 MiB         133           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.0312 MiB   0.0000 MiB         133           current = open_set.get()[2]
    55 135.0312 MiB   0.0000 MiB         133           open_set_hash.remove(current)
    56                                         
    57 135.0312 MiB   0.0000 MiB         133           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.0312 MiB   0.0000 MiB         133           if current == end:
    62 135.0312 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.0312 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.0312 MiB   0.0000 MiB        1188           for neighbor in current.neighbors:
    67 135.0312 MiB   0.0000 MiB        1056               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.0312 MiB   0.0000 MiB         528                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.0312 MiB   0.0000 MiB         528                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.0312 MiB   0.0000 MiB        1056               if temp_g_score < g_score[neighbor]:
    73 135.0312 MiB   0.0000 MiB         197                   came_from[neighbor] = current
    74 135.0312 MiB   0.0000 MiB         197                   g_score[neighbor] = temp_g_score
    75 135.0312 MiB   0.0000 MiB         197                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.0312 MiB   0.0000 MiB         197                   if neighbor not in open_set_hash:
    77 135.0312 MiB   0.0000 MiB         197                       count += 1
    78 135.0312 MiB   0.0000 MiB         197                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.0312 MiB   0.0000 MiB         197                       open_set_hash.add(neighbor)
    80                                                             
    81 135.0312 MiB   0.0000 MiB         132           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.0312 MiB   0.0000 MiB         132           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.0312 MiB 135.0312 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.0312 MiB   0.0000 MiB         257       for row in grid:
    32 135.0312 MiB   0.0000 MiB       65792           for spot in row:
    33 135.0312 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.0312 MiB   0.0000 MiB           1       count = 0
    36 135.0312 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.0312 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.0312 MiB   0.0000 MiB           1       came_from = {}
    39 135.0312 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.0312 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.9219 MiB   0.8906 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.9219 MiB   0.0000 MiB         798       while not open_set.empty():
    49 135.9219 MiB   0.0000 MiB         798           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.9219 MiB   0.0000 MiB         798           current = open_set.get()[2]
    55 135.9219 MiB   0.0000 MiB         798           open_set_hash.remove(current)
    56                                         
    57 135.9219 MiB   0.0000 MiB         798           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.9219 MiB   0.0000 MiB         798           if current == end:
    62 135.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.9219 MiB   0.0000 MiB        7173           for neighbor in current.neighbors:
    67 135.9219 MiB   0.0000 MiB        6376               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.9219 MiB   0.0000 MiB        3188                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.9219 MiB   0.0000 MiB        3188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.9219 MiB   0.0000 MiB        6376               if temp_g_score < g_score[neighbor]:
    73 135.9219 MiB   0.0000 MiB         956                   came_from[neighbor] = current
    74 135.9219 MiB   0.0000 MiB         956                   g_score[neighbor] = temp_g_score
    75 135.9219 MiB   0.0000 MiB         956                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.9219 MiB   0.0000 MiB         956                   if neighbor not in open_set_hash:
    77 135.9219 MiB   0.0000 MiB         956                       count += 1
    78 135.9219 MiB   0.0000 MiB         956                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.9219 MiB   0.0000 MiB         956                       open_set_hash.add(neighbor)
    80                                                             
    81 135.9219 MiB   0.0000 MiB         797           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.9219 MiB   0.0000 MiB         797           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.9219 MiB 135.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.9219 MiB   0.0000 MiB         257       for row in grid:
    32 135.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 135.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.9219 MiB   0.0000 MiB           1       count = 0
    36 135.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.9219 MiB   0.0000 MiB           1       came_from = {}
    39 135.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.9219 MiB   0.0000 MiB         465       while not open_set.empty():
    49 135.9219 MiB   0.0000 MiB         465           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.9219 MiB   0.0000 MiB         465           current = open_set.get()[2]
    55 135.9219 MiB   0.0000 MiB         465           open_set_hash.remove(current)
    56                                         
    57 135.9219 MiB   0.0000 MiB         465           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.9219 MiB   0.0000 MiB         465           if current == end:
    62 135.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.9219 MiB   0.0000 MiB        4176           for neighbor in current.neighbors:
    67 135.9219 MiB   0.0000 MiB        3712               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.9219 MiB   0.0000 MiB        1856                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.9219 MiB   0.0000 MiB        1856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.9219 MiB   0.0000 MiB        3712               if temp_g_score < g_score[neighbor]:
    73 135.9219 MiB   0.0000 MiB         785                   came_from[neighbor] = current
    74 135.9219 MiB   0.0000 MiB         785                   g_score[neighbor] = temp_g_score
    75 135.9219 MiB   0.0000 MiB         785                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.9219 MiB   0.0000 MiB         785                   if neighbor not in open_set_hash:
    77 135.9219 MiB   0.0000 MiB         785                       count += 1
    78 135.9219 MiB   0.0000 MiB         785                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.9219 MiB   0.0000 MiB         785                       open_set_hash.add(neighbor)
    80                                                             
    81 135.9219 MiB   0.0000 MiB         464           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.9219 MiB   0.0000 MiB         464           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.9219 MiB 135.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.9219 MiB   0.0000 MiB         257       for row in grid:
    32 135.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 135.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.9219 MiB   0.0000 MiB           1       count = 0
    36 135.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.9219 MiB   0.0000 MiB           1       came_from = {}
    39 135.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.9219 MiB   0.0000 MiB        1548       while not open_set.empty():
    49 135.9219 MiB   0.0000 MiB        1548           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.9219 MiB   0.0000 MiB        1548           current = open_set.get()[2]
    55 135.9219 MiB   0.0000 MiB        1548           open_set_hash.remove(current)
    56                                         
    57 135.9219 MiB   0.0000 MiB        1548           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.9219 MiB   0.0000 MiB        1548           if current == end:
    62 135.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.9219 MiB   0.0000 MiB       13923           for neighbor in current.neighbors:
    67 135.9219 MiB   0.0000 MiB       12376               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.9219 MiB   0.0000 MiB        6188                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.9219 MiB   0.0000 MiB        6188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.9219 MiB   0.0000 MiB       12376               if temp_g_score < g_score[neighbor]:
    73 135.9219 MiB   0.0000 MiB        1790                   came_from[neighbor] = current
    74 135.9219 MiB   0.0000 MiB        1790                   g_score[neighbor] = temp_g_score
    75 135.9219 MiB   0.0000 MiB        1790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.9219 MiB   0.0000 MiB        1790                   if neighbor not in open_set_hash:
    77 135.9219 MiB   0.0000 MiB        1790                       count += 1
    78 135.9219 MiB   0.0000 MiB        1790                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.9219 MiB   0.0000 MiB        1790                       open_set_hash.add(neighbor)
    80                                                             
    81 135.9219 MiB   0.0000 MiB        1547           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.9219 MiB   0.0000 MiB        1547           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.9219 MiB 135.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.9219 MiB   0.0000 MiB         257       for row in grid:
    32 135.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 135.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.9219 MiB   0.0000 MiB           1       count = 0
    36 135.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.9219 MiB   0.0000 MiB           1       came_from = {}
    39 135.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.9219 MiB   0.0000 MiB        1200       while not open_set.empty():
    49 135.9219 MiB   0.0000 MiB        1200           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.9219 MiB   0.0000 MiB        1200           current = open_set.get()[2]
    55 135.9219 MiB   0.0000 MiB        1200           open_set_hash.remove(current)
    56                                         
    57 135.9219 MiB   0.0000 MiB        1200           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.9219 MiB   0.0000 MiB        1200           if current == end:
    62 135.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.9219 MiB   0.0000 MiB       10791           for neighbor in current.neighbors:
    67 135.9219 MiB   0.0000 MiB        9592               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.9219 MiB   0.0000 MiB        4796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.9219 MiB   0.0000 MiB        4796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.9219 MiB   0.0000 MiB        9592               if temp_g_score < g_score[neighbor]:
    73 135.9219 MiB   0.0000 MiB        1394                   came_from[neighbor] = current
    74 135.9219 MiB   0.0000 MiB        1394                   g_score[neighbor] = temp_g_score
    75 135.9219 MiB   0.0000 MiB        1394                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.9219 MiB   0.0000 MiB        1394                   if neighbor not in open_set_hash:
    77 135.9219 MiB   0.0000 MiB        1394                       count += 1
    78 135.9219 MiB   0.0000 MiB        1394                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.9219 MiB   0.0000 MiB        1394                       open_set_hash.add(neighbor)
    80                                                             
    81 135.9219 MiB   0.0000 MiB        1199           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.9219 MiB   0.0000 MiB        1199           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.9219 MiB 135.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.9219 MiB   0.0000 MiB         257       for row in grid:
    32 135.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 135.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.9219 MiB   0.0000 MiB           1       count = 0
    36 135.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.9219 MiB   0.0000 MiB           1       came_from = {}
    39 135.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.9219 MiB   0.0000 MiB         576       while not open_set.empty():
    49 135.9219 MiB   0.0000 MiB         576           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.9219 MiB   0.0000 MiB         576           current = open_set.get()[2]
    55 135.9219 MiB   0.0000 MiB         576           open_set_hash.remove(current)
    56                                         
    57 135.9219 MiB   0.0000 MiB         576           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.9219 MiB   0.0000 MiB         576           if current == end:
    62 135.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.9219 MiB   0.0000 MiB        5175           for neighbor in current.neighbors:
    67 135.9219 MiB   0.0000 MiB        4600               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.9219 MiB   0.0000 MiB        2300                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.9219 MiB   0.0000 MiB        2300                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.9219 MiB   0.0000 MiB        4600               if temp_g_score < g_score[neighbor]:
    73 135.9219 MiB   0.0000 MiB        1158                   came_from[neighbor] = current
    74 135.9219 MiB   0.0000 MiB        1158                   g_score[neighbor] = temp_g_score
    75 135.9219 MiB   0.0000 MiB        1158                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.9219 MiB   0.0000 MiB        1158                   if neighbor not in open_set_hash:
    77 135.9219 MiB   0.0000 MiB        1158                       count += 1
    78 135.9219 MiB   0.0000 MiB        1158                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.9219 MiB   0.0000 MiB        1158                       open_set_hash.add(neighbor)
    80                                                             
    81 135.9219 MiB   0.0000 MiB         575           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.9219 MiB   0.0000 MiB         575           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.9219 MiB 135.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.9219 MiB   0.0000 MiB         257       for row in grid:
    32 135.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 135.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.9219 MiB   0.0000 MiB           1       count = 0
    36 135.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.9219 MiB   0.0000 MiB           1       came_from = {}
    39 135.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.2500 MiB   1.3281 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.2500 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.2500 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.2500 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.2500 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.2500 MiB   0.0000 MiB        4824       while not open_set.empty():
    49 137.2500 MiB   0.0000 MiB        4824           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.2500 MiB   0.0000 MiB        4824           current = open_set.get()[2]
    55 137.2500 MiB   0.0000 MiB        4824           open_set_hash.remove(current)
    56                                         
    57 137.2500 MiB   0.0000 MiB        4824           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.2500 MiB   0.0000 MiB        4824           if current == end:
    62 137.2500 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.2500 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.2500 MiB   0.0000 MiB       43407           for neighbor in current.neighbors:
    67 137.2500 MiB   0.0000 MiB       38584               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.2500 MiB   0.0000 MiB       19292                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.2500 MiB   0.0000 MiB       19292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.2500 MiB   0.0000 MiB       38584               if temp_g_score < g_score[neighbor]:
    73 137.2500 MiB   0.0000 MiB        5244                   came_from[neighbor] = current
    74 137.2500 MiB   0.0000 MiB        5244                   g_score[neighbor] = temp_g_score
    75 137.2500 MiB   0.0000 MiB        5244                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.2500 MiB   0.0000 MiB        5244                   if neighbor not in open_set_hash:
    77 137.2500 MiB   0.0000 MiB        5244                       count += 1
    78 137.2500 MiB   0.0000 MiB        5244                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.2500 MiB   0.0000 MiB        5244                       open_set_hash.add(neighbor)
    80                                                             
    81 137.2500 MiB   0.0000 MiB        4823           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.2500 MiB   0.0000 MiB        4823           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.2500 MiB 137.2500 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.2500 MiB -491.5625 MiB         257       for row in grid:
    32 137.2500 MiB -125957.7656 MiB       65792           for spot in row:
    33 137.2500 MiB -125468.7500 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.8125 MiB  -3.4375 MiB           1       count = 0
    36 133.8125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.8125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.8125 MiB   0.0000 MiB           1       came_from = {}
    39 133.8594 MiB   0.0469 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.8594 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.9219 MiB   0.0625 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.9219 MiB   0.0000 MiB        5046       while not open_set.empty():
    49 133.9219 MiB   0.0000 MiB        5046           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.9219 MiB   0.0000 MiB        5046           current = open_set.get()[2]
    55 133.9219 MiB   0.0000 MiB        5046           open_set_hash.remove(current)
    56                                         
    57 133.9219 MiB   0.0000 MiB        5046           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.9219 MiB   0.0000 MiB        5046           if current == end:
    62 133.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.9219 MiB   0.0000 MiB       45405           for neighbor in current.neighbors:
    67 133.9219 MiB   0.0000 MiB       40360               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.9219 MiB   0.0000 MiB       20180                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.9219 MiB   0.0000 MiB       20180                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.9219 MiB   0.0000 MiB       40360               if temp_g_score < g_score[neighbor]:
    73 133.9219 MiB   0.0000 MiB        5798                   came_from[neighbor] = current
    74 133.9219 MiB   0.0000 MiB        5798                   g_score[neighbor] = temp_g_score
    75 133.9219 MiB   0.0000 MiB        5798                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.9219 MiB   0.0000 MiB        5798                   if neighbor not in open_set_hash:
    77 133.9219 MiB   0.0000 MiB        5798                       count += 1
    78 133.9219 MiB   0.0000 MiB        5798                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.9219 MiB   0.0000 MiB        5798                       open_set_hash.add(neighbor)
    80                                                             
    81 133.9219 MiB   0.0000 MiB        5045           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.9219 MiB   0.0000 MiB        5045           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.9219 MiB 133.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.9219 MiB   0.0000 MiB         257       for row in grid:
    32 133.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 133.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.9219 MiB   0.0000 MiB           1       count = 0
    36 133.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.9219 MiB   0.0000 MiB           1       came_from = {}
    39 134.2031 MiB   0.2812 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.2031 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.2031 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.2031 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.2031 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.2031 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.2031 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.2031 MiB   0.0000 MiB        4316       while not open_set.empty():
    49 134.2031 MiB   0.0000 MiB        4316           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.2031 MiB   0.0000 MiB        4316           current = open_set.get()[2]
    55 134.2031 MiB   0.0000 MiB        4316           open_set_hash.remove(current)
    56                                         
    57 134.2031 MiB   0.0000 MiB        4316           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.2031 MiB   0.0000 MiB        4316           if current == end:
    62 134.2031 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.2031 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.2031 MiB   0.0000 MiB       38835           for neighbor in current.neighbors:
    67 134.2031 MiB   0.0000 MiB       34520               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.2031 MiB   0.0000 MiB       17260                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.2031 MiB   0.0000 MiB       17260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.2031 MiB   0.0000 MiB       34520               if temp_g_score < g_score[neighbor]:
    73 134.2031 MiB   0.0000 MiB        4750                   came_from[neighbor] = current
    74 134.2031 MiB   0.0000 MiB        4750                   g_score[neighbor] = temp_g_score
    75 134.2031 MiB   0.0000 MiB        4750                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.2031 MiB   0.0000 MiB        4750                   if neighbor not in open_set_hash:
    77 134.2031 MiB   0.0000 MiB        4750                       count += 1
    78 134.2031 MiB   0.0000 MiB        4750                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.2031 MiB   0.0000 MiB        4750                       open_set_hash.add(neighbor)
    80                                                             
    81 134.2031 MiB   0.0000 MiB        4315           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.2031 MiB   0.0000 MiB        4315           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.2031 MiB 134.2031 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.2031 MiB   0.0000 MiB         257       for row in grid:
    32 134.2031 MiB   0.0000 MiB       65792           for spot in row:
    33 134.2031 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.2031 MiB   0.0000 MiB           1       count = 0
    36 134.2031 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.2031 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.2031 MiB   0.0000 MiB           1       came_from = {}
    39 134.2031 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.2031 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.2031 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.2031 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.2031 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.2031 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.2031 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.2031 MiB   0.0000 MiB        8645       while not open_set.empty():
    49 134.2031 MiB   0.0000 MiB        8645           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.2031 MiB   0.0000 MiB        8645           current = open_set.get()[2]
    55 134.2031 MiB   0.0000 MiB        8645           open_set_hash.remove(current)
    56                                         
    57 134.2031 MiB   0.0000 MiB        8645           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.2031 MiB   0.0000 MiB        8645           if current == end:
    62 134.2031 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.2031 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.2031 MiB   0.0000 MiB       77796           for neighbor in current.neighbors:
    67 134.2031 MiB   0.0000 MiB       69152               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.2031 MiB   0.0000 MiB       34576                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.2031 MiB   0.0000 MiB       34576                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.2031 MiB   0.0000 MiB       69152               if temp_g_score < g_score[neighbor]:
    73 134.2031 MiB   0.0000 MiB        9169                   came_from[neighbor] = current
    74 134.2031 MiB   0.0000 MiB        9169                   g_score[neighbor] = temp_g_score
    75 134.2031 MiB   0.0000 MiB        9169                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.2031 MiB   0.0000 MiB        9169                   if neighbor not in open_set_hash:
    77 134.2031 MiB   0.0000 MiB        9169                       count += 1
    78 134.2031 MiB   0.0000 MiB        9169                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.2031 MiB   0.0000 MiB        9169                       open_set_hash.add(neighbor)
    80                                                             
    81 134.2031 MiB   0.0000 MiB        8644           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.2031 MiB   0.0000 MiB        8644           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.6250 MiB 134.6250 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.6250 MiB   0.0000 MiB         257       for row in grid:
    32 134.6250 MiB   0.0000 MiB       65792           for spot in row:
    33 134.6250 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.6250 MiB   0.0000 MiB           1       count = 0
    36 134.6250 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.6250 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.6250 MiB   0.0000 MiB           1       came_from = {}
    39 134.6250 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.6250 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.6250 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.6250 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.6250 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.6250 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.6250 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.6250 MiB   0.0000 MiB        1071       while not open_set.empty():
    49 134.6250 MiB   0.0000 MiB        1071           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.6250 MiB   0.0000 MiB        1071           current = open_set.get()[2]
    55 134.6250 MiB   0.0000 MiB        1071           open_set_hash.remove(current)
    56                                         
    57 134.6250 MiB   0.0000 MiB        1071           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.6250 MiB   0.0000 MiB        1071           if current == end:
    62 134.6250 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.6250 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.6250 MiB   0.0000 MiB        9630           for neighbor in current.neighbors:
    67 134.6250 MiB   0.0000 MiB        8560               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.6250 MiB   0.0000 MiB        4280                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.6250 MiB   0.0000 MiB        4280                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.6250 MiB   0.0000 MiB        8560               if temp_g_score < g_score[neighbor]:
    73 134.6250 MiB   0.0000 MiB        1263                   came_from[neighbor] = current
    74 134.6250 MiB   0.0000 MiB        1263                   g_score[neighbor] = temp_g_score
    75 134.6250 MiB   0.0000 MiB        1263                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.6250 MiB   0.0000 MiB        1263                   if neighbor not in open_set_hash:
    77 134.6250 MiB   0.0000 MiB        1263                       count += 1
    78 134.6250 MiB   0.0000 MiB        1263                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.6250 MiB   0.0000 MiB        1263                       open_set_hash.add(neighbor)
    80                                                             
    81 134.6250 MiB   0.0000 MiB        1070           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.6250 MiB   0.0000 MiB        1070           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.6250 MiB 134.6250 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.6250 MiB   0.0000 MiB         257       for row in grid:
    32 134.6250 MiB   0.0000 MiB       65792           for spot in row:
    33 134.6250 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.6250 MiB   0.0000 MiB           1       count = 0
    36 134.6250 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.6250 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.6250 MiB   0.0000 MiB           1       came_from = {}
    39 134.6250 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.6250 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.6250 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.6250 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.6250 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.6250 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.6250 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.6250 MiB   0.0000 MiB         304       while not open_set.empty():
    49 134.6250 MiB   0.0000 MiB         304           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.6250 MiB   0.0000 MiB         304           current = open_set.get()[2]
    55 134.6250 MiB   0.0000 MiB         304           open_set_hash.remove(current)
    56                                         
    57 134.6250 MiB   0.0000 MiB         304           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.6250 MiB   0.0000 MiB         304           if current == end:
    62 134.6250 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.6250 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.6250 MiB   0.0000 MiB        2727           for neighbor in current.neighbors:
    67 134.6250 MiB   0.0000 MiB        2424               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.6250 MiB   0.0000 MiB        1212                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.6250 MiB   0.0000 MiB        1212                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.6250 MiB   0.0000 MiB        2424               if temp_g_score < g_score[neighbor]:
    73 134.6250 MiB   0.0000 MiB         410                   came_from[neighbor] = current
    74 134.6250 MiB   0.0000 MiB         410                   g_score[neighbor] = temp_g_score
    75 134.6250 MiB   0.0000 MiB         410                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.6250 MiB   0.0000 MiB         410                   if neighbor not in open_set_hash:
    77 134.6250 MiB   0.0000 MiB         410                       count += 1
    78 134.6250 MiB   0.0000 MiB         410                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.6250 MiB   0.0000 MiB         410                       open_set_hash.add(neighbor)
    80                                                             
    81 134.6250 MiB   0.0000 MiB         303           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.6250 MiB   0.0000 MiB         303           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.6250 MiB 134.6250 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.6250 MiB -2374.0938 MiB         257       for row in grid:
    32 134.6250 MiB -608477.6875 MiB       65792           for spot in row:
    33 134.6250 MiB -606111.6094 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 122.2500 MiB -12.3750 MiB           1       count = 0
    36 122.2500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 122.2500 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 122.2500 MiB   0.0000 MiB           1       came_from = {}
    39 122.5156 MiB   0.2656 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 122.5156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 122.5156 MiB -61754.4062 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 121.3438 MiB  -1.1719 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 121.3438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 121.3438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 121.3438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 121.3438 MiB -1875.1094 MiB        4464       while not open_set.empty():
    49 121.3438 MiB -1875.1250 MiB        4464           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 121.3438 MiB -1875.4844 MiB        4464           current = open_set.get()[2]
    55 121.3438 MiB -1875.5625 MiB        4464           open_set_hash.remove(current)
    56                                         
    57 121.3438 MiB -1875.6406 MiB        4464           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 121.3438 MiB -1875.8125 MiB        4464           if current == end:
    62 118.6875 MiB  -2.6562 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.6875 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 121.3438 MiB -16864.5938 MiB       40167           for neighbor in current.neighbors:
    67 121.3438 MiB -14990.1406 MiB       35704               if current.row != neighbor.row and current.col != neighbor.col:
    68 121.3438 MiB -7495.7969 MiB       17852                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 121.3438 MiB -7494.7656 MiB       17852                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 121.3438 MiB -14990.6719 MiB       35704               if temp_g_score < g_score[neighbor]:
    73 121.3438 MiB -2064.9688 MiB        4930                   came_from[neighbor] = current
    74 121.3438 MiB -2065.0156 MiB        4930                   g_score[neighbor] = temp_g_score
    75 121.3438 MiB -2065.1406 MiB        4930                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 121.3438 MiB -2065.1875 MiB        4930                   if neighbor not in open_set_hash:
    77 121.3438 MiB -2065.1875 MiB        4930                       count += 1
    78 121.3438 MiB -2065.2656 MiB        4930                       open_set.put((f_score[neighbor], count, neighbor))
    79 121.3438 MiB -2065.3906 MiB        4930                       open_set_hash.add(neighbor)
    80                                                             
    81 121.3438 MiB -1874.8750 MiB        4463           if draw is not None:
    82                                                     draw()
    83                                         
    84 121.3438 MiB -1875.0312 MiB        4463           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.6875 MiB 118.6875 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.6875 MiB   0.0000 MiB         257       for row in grid:
    32 118.6875 MiB   0.0000 MiB       65792           for spot in row:
    33 118.6875 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.6875 MiB   0.0000 MiB           1       count = 0
    36 118.6875 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.6875 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.6875 MiB   0.0000 MiB           1       came_from = {}
    39 119.4688 MiB   0.7812 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 119.4688 MiB   0.0000 MiB           1       g_score[start] = 0
    41 120.4219 MiB   0.9531 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 120.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 120.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 120.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 120.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 120.4219 MiB   0.0000 MiB          66       while not open_set.empty():
    49 120.4219 MiB   0.0000 MiB          66           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 120.4219 MiB   0.0000 MiB          66           current = open_set.get()[2]
    55 120.4219 MiB   0.0000 MiB          66           open_set_hash.remove(current)
    56                                         
    57 120.4219 MiB   0.0000 MiB          66           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 120.4219 MiB   0.0000 MiB          66           if current == end:
    62 120.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 120.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 120.4219 MiB   0.0000 MiB         585           for neighbor in current.neighbors:
    67 120.4219 MiB   0.0000 MiB         520               if current.row != neighbor.row and current.col != neighbor.col:
    68 120.4219 MiB   0.0000 MiB         260                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 120.4219 MiB   0.0000 MiB         260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 120.4219 MiB   0.0000 MiB         520               if temp_g_score < g_score[neighbor]:
    73 120.4219 MiB   0.0000 MiB         120                   came_from[neighbor] = current
    74 120.4219 MiB   0.0000 MiB         120                   g_score[neighbor] = temp_g_score
    75 120.4219 MiB   0.0000 MiB         120                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 120.4219 MiB   0.0000 MiB         120                   if neighbor not in open_set_hash:
    77 120.4219 MiB   0.0000 MiB         120                       count += 1
    78 120.4219 MiB   0.0000 MiB         120                       open_set.put((f_score[neighbor], count, neighbor))
    79 120.4219 MiB   0.0000 MiB         120                       open_set_hash.add(neighbor)
    80                                                             
    81 120.4219 MiB   0.0000 MiB          65           if draw is not None:
    82                                                     draw()
    83                                         
    84 120.4219 MiB   0.0000 MiB          65           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 120.4219 MiB 120.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 120.4219 MiB   0.0000 MiB         257       for row in grid:
    32 120.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 120.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 120.4219 MiB   0.0000 MiB           1       count = 0
    36 120.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 120.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 120.4219 MiB   0.0000 MiB           1       came_from = {}
    39 120.4219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 120.4219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 122.8594 MiB   2.4375 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 122.8594 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 122.8594 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 122.8594 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 122.8594 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 122.8594 MiB   0.0000 MiB         464       while not open_set.empty():
    49 122.8594 MiB   0.0000 MiB         464           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 122.8594 MiB   0.0000 MiB         464           current = open_set.get()[2]
    55 122.8594 MiB   0.0000 MiB         464           open_set_hash.remove(current)
    56                                         
    57 122.8594 MiB   0.0000 MiB         464           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 122.8594 MiB   0.0000 MiB         464           if current == end:
    62 122.8594 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 122.8594 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 122.8594 MiB   0.0000 MiB        4167           for neighbor in current.neighbors:
    67 122.8594 MiB   0.0000 MiB        3704               if current.row != neighbor.row and current.col != neighbor.col:
    68 122.8594 MiB   0.0000 MiB        1852                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 122.8594 MiB   0.0000 MiB        1852                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 122.8594 MiB   0.0000 MiB        3704               if temp_g_score < g_score[neighbor]:
    73 122.8594 MiB   0.0000 MiB         584                   came_from[neighbor] = current
    74 122.8594 MiB   0.0000 MiB         584                   g_score[neighbor] = temp_g_score
    75 122.8594 MiB   0.0000 MiB         584                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 122.8594 MiB   0.0000 MiB         584                   if neighbor not in open_set_hash:
    77 122.8594 MiB   0.0000 MiB         584                       count += 1
    78 122.8594 MiB   0.0000 MiB         584                       open_set.put((f_score[neighbor], count, neighbor))
    79 122.8594 MiB   0.0000 MiB         584                       open_set_hash.add(neighbor)
    80                                                             
    81 122.8594 MiB   0.0000 MiB         463           if draw is not None:
    82                                                     draw()
    83                                         
    84 122.8594 MiB   0.0000 MiB         463           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 122.8594 MiB 122.8594 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 122.8594 MiB   0.0000 MiB         257       for row in grid:
    32 122.8594 MiB   0.0000 MiB       65792           for spot in row:
    33 122.8594 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 122.8594 MiB   0.0000 MiB           1       count = 0
    36 122.8594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 122.8594 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 122.8594 MiB   0.0000 MiB           1       came_from = {}
    39 122.8594 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 122.8594 MiB   0.0000 MiB           1       g_score[start] = 0
    41 122.8594 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 122.8594 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 122.8594 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 122.8594 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 122.8594 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 122.8594 MiB   0.0000 MiB        1023       while not open_set.empty():
    49 122.8594 MiB   0.0000 MiB        1023           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 122.8594 MiB   0.0000 MiB        1023           current = open_set.get()[2]
    55 122.8594 MiB   0.0000 MiB        1023           open_set_hash.remove(current)
    56                                         
    57 122.8594 MiB   0.0000 MiB        1023           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 122.8594 MiB   0.0000 MiB        1023           if current == end:
    62 122.8594 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 122.8594 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 122.8594 MiB   0.0000 MiB        9198           for neighbor in current.neighbors:
    67 122.8594 MiB   0.0000 MiB        8176               if current.row != neighbor.row and current.col != neighbor.col:
    68 122.8594 MiB   0.0000 MiB        4088                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 122.8594 MiB   0.0000 MiB        4088                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 122.8594 MiB   0.0000 MiB        8176               if temp_g_score < g_score[neighbor]:
    73 122.8594 MiB   0.0000 MiB        1215                   came_from[neighbor] = current
    74 122.8594 MiB   0.0000 MiB        1215                   g_score[neighbor] = temp_g_score
    75 122.8594 MiB   0.0000 MiB        1215                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 122.8594 MiB   0.0000 MiB        1215                   if neighbor not in open_set_hash:
    77 122.8594 MiB   0.0000 MiB        1215                       count += 1
    78 122.8594 MiB   0.0000 MiB        1215                       open_set.put((f_score[neighbor], count, neighbor))
    79 122.8594 MiB   0.0000 MiB        1215                       open_set_hash.add(neighbor)
    80                                                             
    81 122.8594 MiB   0.0000 MiB        1022           if draw is not None:
    82                                                     draw()
    83                                         
    84 122.8594 MiB   0.0000 MiB        1022           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 122.8594 MiB 122.8594 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 122.8594 MiB   0.0000 MiB         257       for row in grid:
    32 122.8594 MiB   0.0000 MiB       65792           for spot in row:
    33 122.8594 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 122.8594 MiB   0.0000 MiB           1       count = 0
    36 122.8594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 122.8594 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 122.8594 MiB   0.0000 MiB           1       came_from = {}
    39 122.8594 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 122.8594 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.8594 MiB   1.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.8594 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.8594 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.8594 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.8594 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.8594 MiB   0.0000 MiB        2375       while not open_set.empty():
    49 123.8594 MiB   0.0000 MiB        2375           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.8594 MiB   0.0000 MiB        2375           current = open_set.get()[2]
    55 123.8594 MiB   0.0000 MiB        2375           open_set_hash.remove(current)
    56                                         
    57 123.8594 MiB   0.0000 MiB        2375           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.8594 MiB   0.0000 MiB        2375           if current == end:
    62 123.8594 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 123.8594 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.8594 MiB   0.0000 MiB       21366           for neighbor in current.neighbors:
    67 123.8594 MiB   0.0000 MiB       18992               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.8594 MiB   0.0000 MiB        9496                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.8594 MiB   0.0000 MiB        9496                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.8594 MiB   0.0000 MiB       18992               if temp_g_score < g_score[neighbor]:
    73 123.8594 MiB   0.0000 MiB        2663                   came_from[neighbor] = current
    74 123.8594 MiB   0.0000 MiB        2663                   g_score[neighbor] = temp_g_score
    75 123.8594 MiB   0.0000 MiB        2663                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.8594 MiB   0.0000 MiB        2663                   if neighbor not in open_set_hash:
    77 123.8594 MiB   0.0000 MiB        2663                       count += 1
    78 123.8594 MiB   0.0000 MiB        2663                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.8594 MiB   0.0000 MiB        2663                       open_set_hash.add(neighbor)
    80                                                             
    81 123.8594 MiB   0.0000 MiB        2374           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.8594 MiB   0.0000 MiB        2374           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 123.8594 MiB 123.8594 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 123.8594 MiB   0.0000 MiB         257       for row in grid:
    32 123.8594 MiB   0.0000 MiB       65792           for spot in row:
    33 123.8594 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 123.8594 MiB   0.0000 MiB           1       count = 0
    36 123.8594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 123.8594 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 123.8594 MiB   0.0000 MiB           1       came_from = {}
    39 123.8594 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 123.8594 MiB   0.0000 MiB           1       g_score[start] = 0
    41 123.8594 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 123.8594 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 123.8594 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 123.8594 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 123.8594 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 123.8594 MiB   0.0000 MiB         140       while not open_set.empty():
    49 123.8594 MiB   0.0000 MiB         140           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 123.8594 MiB   0.0000 MiB         140           current = open_set.get()[2]
    55 123.8594 MiB   0.0000 MiB         140           open_set_hash.remove(current)
    56                                         
    57 123.8594 MiB   0.0000 MiB         140           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 123.8594 MiB   0.0000 MiB         140           if current == end:
    62 123.8594 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 123.8594 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 123.8594 MiB   0.0000 MiB        1251           for neighbor in current.neighbors:
    67 123.8594 MiB   0.0000 MiB        1112               if current.row != neighbor.row and current.col != neighbor.col:
    68 123.8594 MiB   0.0000 MiB         556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 123.8594 MiB   0.0000 MiB         556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 123.8594 MiB   0.0000 MiB        1112               if temp_g_score < g_score[neighbor]:
    73 123.8594 MiB   0.0000 MiB         232                   came_from[neighbor] = current
    74 123.8594 MiB   0.0000 MiB         232                   g_score[neighbor] = temp_g_score
    75 123.8594 MiB   0.0000 MiB         232                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 123.8594 MiB   0.0000 MiB         232                   if neighbor not in open_set_hash:
    77 123.8594 MiB   0.0000 MiB         232                       count += 1
    78 123.8594 MiB   0.0000 MiB         232                       open_set.put((f_score[neighbor], count, neighbor))
    79 123.8594 MiB   0.0000 MiB         232                       open_set_hash.add(neighbor)
    80                                                             
    81 123.8594 MiB   0.0000 MiB         139           if draw is not None:
    82                                                     draw()
    83                                         
    84 123.8594 MiB   0.0000 MiB         139           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 123.8594 MiB 123.8594 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 123.8594 MiB   0.0000 MiB         257       for row in grid:
    32 123.8594 MiB   0.0000 MiB       65792           for spot in row:
    33 123.8594 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 123.8594 MiB   0.0000 MiB           1       count = 0
    36 123.8594 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 123.8594 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 123.8594 MiB   0.0000 MiB           1       came_from = {}
    39 126.3438 MiB   2.4844 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 126.3438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.2500 MiB   1.9062 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.2500 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.2500 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.2500 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.2500 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.2500 MiB   0.0000 MiB        1330       while not open_set.empty():
    49 128.2500 MiB   0.0000 MiB        1330           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.2500 MiB   0.0000 MiB        1330           current = open_set.get()[2]
    55 128.2500 MiB   0.0000 MiB        1330           open_set_hash.remove(current)
    56                                         
    57 128.2500 MiB   0.0000 MiB        1330           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.2500 MiB   0.0000 MiB        1330           if current == end:
    62 128.2500 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.2500 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.2500 MiB   0.0000 MiB       11961           for neighbor in current.neighbors:
    67 128.2500 MiB   0.0000 MiB       10632               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.2500 MiB   0.0000 MiB        5316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.2500 MiB   0.0000 MiB        5316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.2500 MiB   0.0000 MiB       10632               if temp_g_score < g_score[neighbor]:
    73 128.2500 MiB   0.0000 MiB        1574                   came_from[neighbor] = current
    74 128.2500 MiB   0.0000 MiB        1574                   g_score[neighbor] = temp_g_score
    75 128.2500 MiB   0.0000 MiB        1574                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.2500 MiB   0.0000 MiB        1574                   if neighbor not in open_set_hash:
    77 128.2500 MiB   0.0000 MiB        1574                       count += 1
    78 128.2500 MiB   0.0000 MiB        1574                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.2500 MiB   0.0000 MiB        1574                       open_set_hash.add(neighbor)
    80                                                             
    81 128.2500 MiB   0.0000 MiB        1329           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.2500 MiB   0.0000 MiB        1329           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.2500 MiB 128.2500 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.2500 MiB   0.0000 MiB         257       for row in grid:
    32 128.2500 MiB   0.0000 MiB       65792           for spot in row:
    33 128.2500 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.2500 MiB   0.0000 MiB           1       count = 0
    36 128.2500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.2500 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.2500 MiB   0.0000 MiB           1       came_from = {}
    39 128.2500 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.2500 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.2500 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.2500 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.2500 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.2500 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.2500 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.2500 MiB   0.0000 MiB        7040       while not open_set.empty():
    49 128.2500 MiB   0.0000 MiB        7040           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.2500 MiB   0.0000 MiB        7040           current = open_set.get()[2]
    55 128.2500 MiB   0.0000 MiB        7040           open_set_hash.remove(current)
    56                                         
    57 128.2500 MiB   0.0000 MiB        7040           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.2500 MiB   0.0000 MiB        7040           if current == end:
    62 128.2500 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.2500 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.2500 MiB   0.0000 MiB       63351           for neighbor in current.neighbors:
    67 128.2500 MiB   0.0000 MiB       56312               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.2500 MiB   0.0000 MiB       28156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.2500 MiB   0.0000 MiB       28156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.2500 MiB   0.0000 MiB       56312               if temp_g_score < g_score[neighbor]:
    73 128.2500 MiB   0.0000 MiB        7550                   came_from[neighbor] = current
    74 128.2500 MiB   0.0000 MiB        7550                   g_score[neighbor] = temp_g_score
    75 128.2500 MiB   0.0000 MiB        7550                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.2500 MiB   0.0000 MiB        7550                   if neighbor not in open_set_hash:
    77 128.2500 MiB   0.0000 MiB        7550                       count += 1
    78 128.2500 MiB   0.0000 MiB        7550                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.2500 MiB   0.0000 MiB        7550                       open_set_hash.add(neighbor)
    80                                                             
    81 128.2500 MiB   0.0000 MiB        7039           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.2500 MiB   0.0000 MiB        7039           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.2500 MiB 128.2500 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.2500 MiB   0.0000 MiB         257       for row in grid:
    32 128.2500 MiB   0.0000 MiB       65792           for spot in row:
    33 128.2500 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.2500 MiB   0.0000 MiB           1       count = 0
    36 128.2500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.2500 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.2500 MiB   0.0000 MiB           1       came_from = {}
    39 128.2656 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.2656 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.2812 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.2812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.2812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.2812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.2812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.2812 MiB   0.0000 MiB         950       while not open_set.empty():
    49 128.2812 MiB   0.0000 MiB         950           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.2812 MiB   0.0000 MiB         950           current = open_set.get()[2]
    55 128.2812 MiB   0.0000 MiB         950           open_set_hash.remove(current)
    56                                         
    57 128.2812 MiB   0.0000 MiB         950           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.2812 MiB   0.0000 MiB         950           if current == end:
    62 128.2812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.2812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.2812 MiB   0.0000 MiB        8541           for neighbor in current.neighbors:
    67 128.2812 MiB   0.0000 MiB        7592               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.2812 MiB   0.0000 MiB        3796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.2812 MiB   0.0000 MiB        3796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.2812 MiB   0.0000 MiB        7592               if temp_g_score < g_score[neighbor]:
    73 128.2812 MiB   0.0000 MiB        1186                   came_from[neighbor] = current
    74 128.2812 MiB   0.0000 MiB        1186                   g_score[neighbor] = temp_g_score
    75 128.2812 MiB   0.0000 MiB        1186                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.2812 MiB   0.0000 MiB        1186                   if neighbor not in open_set_hash:
    77 128.2812 MiB   0.0000 MiB        1186                       count += 1
    78 128.2812 MiB   0.0000 MiB        1186                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.2812 MiB   0.0000 MiB        1186                       open_set_hash.add(neighbor)
    80                                                             
    81 128.2812 MiB   0.0000 MiB         949           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.2812 MiB   0.0000 MiB         949           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.2812 MiB 128.2812 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.2812 MiB   0.0000 MiB         257       for row in grid:
    32 128.2812 MiB   0.0000 MiB       65792           for spot in row:
    33 128.2812 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.2812 MiB   0.0000 MiB           1       count = 0
    36 128.2812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.2812 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.2812 MiB   0.0000 MiB           1       came_from = {}
    39 128.2812 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.2812 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.3750 MiB   0.0938 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.3750 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.3750 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.3750 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.3750 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.3906 MiB   0.0000 MiB        1340       while not open_set.empty():
    49 128.3906 MiB   0.0000 MiB        1340           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.3906 MiB   0.0000 MiB        1340           current = open_set.get()[2]
    55 128.3906 MiB   0.0000 MiB        1340           open_set_hash.remove(current)
    56                                         
    57 128.3906 MiB   0.0000 MiB        1340           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.3906 MiB   0.0000 MiB        1340           if current == end:
    62 128.3906 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.3906 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.3906 MiB   0.0000 MiB       12051           for neighbor in current.neighbors:
    67 128.3906 MiB   0.0000 MiB       10712               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.3906 MiB   0.0000 MiB        5356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.3906 MiB   0.0000 MiB        5356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.3906 MiB   0.0000 MiB       10712               if temp_g_score < g_score[neighbor]:
    73 128.3906 MiB   0.0156 MiB        1646                   came_from[neighbor] = current
    74 128.3906 MiB   0.0000 MiB        1646                   g_score[neighbor] = temp_g_score
    75 128.3906 MiB   0.0000 MiB        1646                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.3906 MiB   0.0000 MiB        1646                   if neighbor not in open_set_hash:
    77 128.3906 MiB   0.0000 MiB        1646                       count += 1
    78 128.3906 MiB   0.0000 MiB        1646                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.3906 MiB   0.0000 MiB        1646                       open_set_hash.add(neighbor)
    80                                                             
    81 128.3906 MiB   0.0000 MiB        1339           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.3906 MiB   0.0000 MiB        1339           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.3906 MiB 128.3906 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.3906 MiB   0.0000 MiB         257       for row in grid:
    32 128.3906 MiB   0.0000 MiB       65792           for spot in row:
    33 128.3906 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.3906 MiB   0.0000 MiB           1       count = 0
    36 128.3906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.3906 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.3906 MiB   0.0000 MiB           1       came_from = {}
    39 128.3906 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.3906 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.3906 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.3906 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.3906 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.3906 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.3906 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.3906 MiB   0.0000 MiB        2400       while not open_set.empty():
    49 128.3906 MiB   0.0000 MiB        2400           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.3906 MiB   0.0000 MiB        2400           current = open_set.get()[2]
    55 128.3906 MiB   0.0000 MiB        2400           open_set_hash.remove(current)
    56                                         
    57 128.3906 MiB   0.0000 MiB        2400           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.3906 MiB   0.0000 MiB        2400           if current == end:
    62 128.3906 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.3906 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.3906 MiB   0.0000 MiB       21591           for neighbor in current.neighbors:
    67 128.3906 MiB   0.0000 MiB       19192               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.3906 MiB   0.0000 MiB        9596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.3906 MiB   0.0000 MiB        9596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.3906 MiB   0.0000 MiB       19192               if temp_g_score < g_score[neighbor]:
    73 128.3906 MiB   0.0000 MiB        2762                   came_from[neighbor] = current
    74 128.3906 MiB   0.0000 MiB        2762                   g_score[neighbor] = temp_g_score
    75 128.3906 MiB   0.0000 MiB        2762                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.3906 MiB   0.0000 MiB        2762                   if neighbor not in open_set_hash:
    77 128.3906 MiB   0.0000 MiB        2762                       count += 1
    78 128.3906 MiB   0.0000 MiB        2762                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.3906 MiB   0.0000 MiB        2762                       open_set_hash.add(neighbor)
    80                                                             
    81 128.3906 MiB   0.0000 MiB        2399           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.3906 MiB   0.0000 MiB        2399           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.3906 MiB 128.3906 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.3906 MiB   0.0000 MiB         257       for row in grid:
    32 128.3906 MiB   0.0000 MiB       65792           for spot in row:
    33 128.3906 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.3906 MiB   0.0000 MiB           1       count = 0
    36 128.3906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.3906 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.3906 MiB   0.0000 MiB           1       came_from = {}
    39 128.3906 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.3906 MiB   0.0000 MiB           1       g_score[start] = 0
    41 130.2656 MiB   1.8750 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 130.2656 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 130.2656 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 130.2656 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 130.2656 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 130.3125 MiB   0.0000 MiB        2610       while not open_set.empty():
    49 130.3125 MiB   0.0000 MiB        2610           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 130.3125 MiB   0.0000 MiB        2610           current = open_set.get()[2]
    55 130.3125 MiB   0.0000 MiB        2610           open_set_hash.remove(current)
    56                                         
    57 130.3125 MiB   0.0000 MiB        2610           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 130.3125 MiB   0.0000 MiB        2610           if current == end:
    62 130.3125 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 130.3125 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 130.3125 MiB   0.0000 MiB       23481           for neighbor in current.neighbors:
    67 130.3125 MiB   0.0000 MiB       20872               if current.row != neighbor.row and current.col != neighbor.col:
    68 130.3125 MiB   0.0000 MiB       10436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 130.3125 MiB   0.0000 MiB       10436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 130.3125 MiB   0.0000 MiB       20872               if temp_g_score < g_score[neighbor]:
    73 130.3125 MiB   0.0469 MiB        3026                   came_from[neighbor] = current
    74 130.3125 MiB   0.0000 MiB        3026                   g_score[neighbor] = temp_g_score
    75 130.3125 MiB   0.0000 MiB        3026                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 130.3125 MiB   0.0000 MiB        3026                   if neighbor not in open_set_hash:
    77 130.3125 MiB   0.0000 MiB        3026                       count += 1
    78 130.3125 MiB   0.0000 MiB        3026                       open_set.put((f_score[neighbor], count, neighbor))
    79 130.3125 MiB   0.0000 MiB        3026                       open_set_hash.add(neighbor)
    80                                                             
    81 130.3125 MiB   0.0000 MiB        2609           if draw is not None:
    82                                                     draw()
    83                                         
    84 130.3125 MiB   0.0000 MiB        2609           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 130.3125 MiB 130.3125 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 130.3125 MiB   0.0000 MiB         257       for row in grid:
    32 130.3125 MiB   0.0000 MiB       65792           for spot in row:
    33 130.3125 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 130.3125 MiB   0.0000 MiB           1       count = 0
    36 130.3125 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 130.3125 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 130.3125 MiB   0.0000 MiB           1       came_from = {}
    39 130.6562 MiB   0.3438 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 130.6562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 130.6562 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 130.6562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 130.6562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 130.6562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 130.6562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 130.6562 MiB   0.0000 MiB         646       while not open_set.empty():
    49 130.6562 MiB   0.0000 MiB         646           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 130.6562 MiB   0.0000 MiB         646           current = open_set.get()[2]
    55 130.6562 MiB   0.0000 MiB         646           open_set_hash.remove(current)
    56                                         
    57 130.6562 MiB   0.0000 MiB         646           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 130.6562 MiB   0.0000 MiB         646           if current == end:
    62 130.6562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 130.6562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 130.6562 MiB   0.0000 MiB        5805           for neighbor in current.neighbors:
    67 130.6562 MiB   0.0000 MiB        5160               if current.row != neighbor.row and current.col != neighbor.col:
    68 130.6562 MiB   0.0000 MiB        2580                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 130.6562 MiB   0.0000 MiB        2580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 130.6562 MiB   0.0000 MiB        5160               if temp_g_score < g_score[neighbor]:
    73 130.6562 MiB   0.0000 MiB         788                   came_from[neighbor] = current
    74 130.6562 MiB   0.0000 MiB         788                   g_score[neighbor] = temp_g_score
    75 130.6562 MiB   0.0000 MiB         788                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 130.6562 MiB   0.0000 MiB         788                   if neighbor not in open_set_hash:
    77 130.6562 MiB   0.0000 MiB         788                       count += 1
    78 130.6562 MiB   0.0000 MiB         788                       open_set.put((f_score[neighbor], count, neighbor))
    79 130.6562 MiB   0.0000 MiB         788                       open_set_hash.add(neighbor)
    80                                                             
    81 130.6562 MiB   0.0000 MiB         645           if draw is not None:
    82                                                     draw()
    83                                         
    84 130.6562 MiB   0.0000 MiB         645           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 130.6562 MiB 130.6562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 130.6562 MiB   0.0000 MiB         257       for row in grid:
    32 130.6562 MiB   0.0000 MiB       65792           for spot in row:
    33 130.6562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 130.6562 MiB   0.0000 MiB           1       count = 0
    36 130.6562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 130.6562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 130.6562 MiB   0.0000 MiB           1       came_from = {}
    39 131.1406 MiB   0.4844 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 131.1406 MiB   0.0000 MiB           1       g_score[start] = 0
    41 131.1562 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 131.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 131.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 131.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 131.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 131.1562 MiB   0.0000 MiB         121       while not open_set.empty():
    49 131.1562 MiB   0.0000 MiB         121           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 131.1562 MiB   0.0000 MiB         121           current = open_set.get()[2]
    55 131.1562 MiB   0.0000 MiB         121           open_set_hash.remove(current)
    56                                         
    57 131.1562 MiB   0.0000 MiB         121           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 131.1562 MiB   0.0000 MiB         121           if current == end:
    62 131.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 131.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 131.1562 MiB   0.0000 MiB        1080           for neighbor in current.neighbors:
    67 131.1562 MiB   0.0000 MiB         960               if current.row != neighbor.row and current.col != neighbor.col:
    68 131.1562 MiB   0.0000 MiB         480                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 131.1562 MiB   0.0000 MiB         480                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 131.1562 MiB   0.0000 MiB         960               if temp_g_score < g_score[neighbor]:
    73 131.1562 MiB   0.0000 MiB         185                   came_from[neighbor] = current
    74 131.1562 MiB   0.0000 MiB         185                   g_score[neighbor] = temp_g_score
    75 131.1562 MiB   0.0000 MiB         185                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 131.1562 MiB   0.0000 MiB         185                   if neighbor not in open_set_hash:
    77 131.1562 MiB   0.0000 MiB         185                       count += 1
    78 131.1562 MiB   0.0000 MiB         185                       open_set.put((f_score[neighbor], count, neighbor))
    79 131.1562 MiB   0.0000 MiB         185                       open_set_hash.add(neighbor)
    80                                                             
    81 131.1562 MiB   0.0000 MiB         120           if draw is not None:
    82                                                     draw()
    83                                         
    84 131.1562 MiB   0.0000 MiB         120           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 131.1562 MiB 131.1562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 131.1562 MiB   0.0000 MiB         257       for row in grid:
    32 131.1562 MiB   0.0000 MiB       65792           for spot in row:
    33 131.1562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 131.1562 MiB   0.0000 MiB           1       count = 0
    36 131.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 131.1562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 131.1562 MiB   0.0000 MiB           1       came_from = {}
    39 131.1719 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 131.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 131.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 131.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 131.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 131.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 131.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 131.1719 MiB   0.0000 MiB         132       while not open_set.empty():
    49 131.1719 MiB   0.0000 MiB         132           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 131.1719 MiB   0.0000 MiB         132           current = open_set.get()[2]
    55 131.1719 MiB   0.0000 MiB         132           open_set_hash.remove(current)
    56                                         
    57 131.1719 MiB   0.0000 MiB         132           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 131.1719 MiB   0.0000 MiB         132           if current == end:
    62 131.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 131.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 131.1719 MiB   0.0000 MiB        1179           for neighbor in current.neighbors:
    67 131.1719 MiB   0.0000 MiB        1048               if current.row != neighbor.row and current.col != neighbor.col:
    68 131.1719 MiB   0.0000 MiB         524                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 131.1719 MiB   0.0000 MiB         524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 131.1719 MiB   0.0000 MiB        1048               if temp_g_score < g_score[neighbor]:
    73 131.1719 MiB   0.0000 MiB         270                   came_from[neighbor] = current
    74 131.1719 MiB   0.0000 MiB         270                   g_score[neighbor] = temp_g_score
    75 131.1719 MiB   0.0000 MiB         270                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 131.1719 MiB   0.0000 MiB         270                   if neighbor not in open_set_hash:
    77 131.1719 MiB   0.0000 MiB         270                       count += 1
    78 131.1719 MiB   0.0000 MiB         270                       open_set.put((f_score[neighbor], count, neighbor))
    79 131.1719 MiB   0.0000 MiB         270                       open_set_hash.add(neighbor)
    80                                                             
    81 131.1719 MiB   0.0000 MiB         131           if draw is not None:
    82                                                     draw()
    83                                         
    84 131.1719 MiB   0.0000 MiB         131           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 131.1719 MiB 131.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 131.1719 MiB   0.0000 MiB         257       for row in grid:
    32 131.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 131.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 131.1719 MiB   0.0000 MiB           1       count = 0
    36 131.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 131.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 131.1719 MiB   0.0000 MiB           1       came_from = {}
    39 131.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 131.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 131.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 131.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 131.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 131.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 131.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 131.1875 MiB   0.0000 MiB        7332       while not open_set.empty():
    49 131.1875 MiB   0.0000 MiB        7332           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 131.1875 MiB   0.0000 MiB        7332           current = open_set.get()[2]
    55 131.1875 MiB   0.0000 MiB        7332           open_set_hash.remove(current)
    56                                         
    57 131.1875 MiB   0.0000 MiB        7332           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 131.1875 MiB   0.0000 MiB        7332           if current == end:
    62 131.1875 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 131.1875 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 131.1875 MiB   0.0000 MiB       65979           for neighbor in current.neighbors:
    67 131.1875 MiB   0.0000 MiB       58648               if current.row != neighbor.row and current.col != neighbor.col:
    68 131.1875 MiB   0.0000 MiB       29324                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 131.1875 MiB   0.0000 MiB       29324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 131.1875 MiB   0.0000 MiB       58648               if temp_g_score < g_score[neighbor]:
    73 131.1875 MiB   0.0000 MiB        7830                   came_from[neighbor] = current
    74 131.1875 MiB   0.0000 MiB        7830                   g_score[neighbor] = temp_g_score
    75 131.1875 MiB   0.0000 MiB        7830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 131.1875 MiB   0.0000 MiB        7830                   if neighbor not in open_set_hash:
    77 131.1875 MiB   0.0000 MiB        7830                       count += 1
    78 131.1875 MiB   0.0156 MiB        7830                       open_set.put((f_score[neighbor], count, neighbor))
    79 131.1875 MiB   0.0000 MiB        7830                       open_set_hash.add(neighbor)
    80                                                             
    81 131.1875 MiB   0.0000 MiB        7331           if draw is not None:
    82                                                     draw()
    83                                         
    84 131.1875 MiB   0.0000 MiB        7331           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 131.1875 MiB 131.1875 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 131.1875 MiB   0.0000 MiB         257       for row in grid:
    32 131.1875 MiB   0.0000 MiB       65792           for spot in row:
    33 131.1875 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 131.1875 MiB   0.0000 MiB           1       count = 0
    36 131.1875 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 131.1875 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 131.1875 MiB   0.0000 MiB           1       came_from = {}
    39 131.1875 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 131.1875 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.1719 MiB   2.9844 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.1719 MiB   0.0000 MiB        4860       while not open_set.empty():
    49 134.1719 MiB   0.0000 MiB        4860           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.1719 MiB   0.0000 MiB        4860           current = open_set.get()[2]
    55 134.1719 MiB   0.0000 MiB        4860           open_set_hash.remove(current)
    56                                         
    57 134.1719 MiB   0.0000 MiB        4860           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.1719 MiB   0.0000 MiB        4860           if current == end:
    62 134.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.1719 MiB   0.0000 MiB       43731           for neighbor in current.neighbors:
    67 134.1719 MiB   0.0000 MiB       38872               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.1719 MiB   0.0000 MiB       19436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.1719 MiB   0.0000 MiB       19436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.1719 MiB   0.0000 MiB       38872               if temp_g_score < g_score[neighbor]:
    73 134.1719 MiB   0.0000 MiB        5326                   came_from[neighbor] = current
    74 134.1719 MiB   0.0000 MiB        5326                   g_score[neighbor] = temp_g_score
    75 134.1719 MiB   0.0000 MiB        5326                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.1719 MiB   0.0000 MiB        5326                   if neighbor not in open_set_hash:
    77 134.1719 MiB   0.0000 MiB        5326                       count += 1
    78 134.1719 MiB   0.0000 MiB        5326                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.1719 MiB   0.0000 MiB        5326                       open_set_hash.add(neighbor)
    80                                                             
    81 134.1719 MiB   0.0000 MiB        4859           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.1719 MiB   0.0000 MiB        4859           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.1719 MiB 134.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.1719 MiB   0.0000 MiB         257       for row in grid:
    32 134.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 134.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.1719 MiB   0.0000 MiB           1       count = 0
    36 134.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.1719 MiB   0.0000 MiB           1       came_from = {}
    39 134.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.1719 MiB   0.0000 MiB         232       while not open_set.empty():
    49 134.1719 MiB   0.0000 MiB         232           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.1719 MiB   0.0000 MiB         232           current = open_set.get()[2]
    55 134.1719 MiB   0.0000 MiB         232           open_set_hash.remove(current)
    56                                         
    57 134.1719 MiB   0.0000 MiB         232           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.1719 MiB   0.0000 MiB         232           if current == end:
    62 134.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.1719 MiB   0.0000 MiB        2079           for neighbor in current.neighbors:
    67 134.1719 MiB   0.0000 MiB        1848               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.1719 MiB   0.0000 MiB         924                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.1719 MiB   0.0000 MiB         924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.1719 MiB   0.0000 MiB        1848               if temp_g_score < g_score[neighbor]:
    73 134.1719 MiB   0.0000 MiB         362                   came_from[neighbor] = current
    74 134.1719 MiB   0.0000 MiB         362                   g_score[neighbor] = temp_g_score
    75 134.1719 MiB   0.0000 MiB         362                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.1719 MiB   0.0000 MiB         362                   if neighbor not in open_set_hash:
    77 134.1719 MiB   0.0000 MiB         362                       count += 1
    78 134.1719 MiB   0.0000 MiB         362                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.1719 MiB   0.0000 MiB         362                       open_set_hash.add(neighbor)
    80                                                             
    81 134.1719 MiB   0.0000 MiB         231           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.1719 MiB   0.0000 MiB         231           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.1719 MiB 134.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.1719 MiB   0.0000 MiB         257       for row in grid:
    32 134.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 134.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.1719 MiB   0.0000 MiB           1       count = 0
    36 134.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.1719 MiB   0.0000 MiB           1       came_from = {}
    39 134.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.1719 MiB   0.0000 MiB          98       while not open_set.empty():
    49 134.1719 MiB   0.0000 MiB          98           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.1719 MiB   0.0000 MiB          98           current = open_set.get()[2]
    55 134.1719 MiB   0.0000 MiB          98           open_set_hash.remove(current)
    56                                         
    57 134.1719 MiB   0.0000 MiB          98           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.1719 MiB   0.0000 MiB          98           if current == end:
    62 134.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.1719 MiB   0.0000 MiB         873           for neighbor in current.neighbors:
    67 134.1719 MiB   0.0000 MiB         776               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.1719 MiB   0.0000 MiB         388                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.1719 MiB   0.0000 MiB         388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.1719 MiB   0.0000 MiB         776               if temp_g_score < g_score[neighbor]:
    73 134.1719 MiB   0.0000 MiB         296                   came_from[neighbor] = current
    74 134.1719 MiB   0.0000 MiB         296                   g_score[neighbor] = temp_g_score
    75 134.1719 MiB   0.0000 MiB         296                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.1719 MiB   0.0000 MiB         296                   if neighbor not in open_set_hash:
    77 134.1719 MiB   0.0000 MiB         296                       count += 1
    78 134.1719 MiB   0.0000 MiB         296                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.1719 MiB   0.0000 MiB         296                       open_set_hash.add(neighbor)
    80                                                             
    81 134.1719 MiB   0.0000 MiB          97           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.1719 MiB   0.0000 MiB          97           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.1719 MiB 134.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.1719 MiB   0.0000 MiB         257       for row in grid:
    32 134.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 134.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.1719 MiB   0.0000 MiB           1       count = 0
    36 134.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.1719 MiB   0.0000 MiB           1       came_from = {}
    39 134.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.1719 MiB   0.0000 MiB         154       while not open_set.empty():
    49 134.1719 MiB   0.0000 MiB         154           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.1719 MiB   0.0000 MiB         154           current = open_set.get()[2]
    55 134.1719 MiB   0.0000 MiB         154           open_set_hash.remove(current)
    56                                         
    57 134.1719 MiB   0.0000 MiB         154           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.1719 MiB   0.0000 MiB         154           if current == end:
    62 134.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.1719 MiB   0.0000 MiB        1377           for neighbor in current.neighbors:
    67 134.1719 MiB   0.0000 MiB        1224               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.1719 MiB   0.0000 MiB         612                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.1719 MiB   0.0000 MiB         612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.1719 MiB   0.0000 MiB        1224               if temp_g_score < g_score[neighbor]:
    73 134.1719 MiB   0.0000 MiB         230                   came_from[neighbor] = current
    74 134.1719 MiB   0.0000 MiB         230                   g_score[neighbor] = temp_g_score
    75 134.1719 MiB   0.0000 MiB         230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.1719 MiB   0.0000 MiB         230                   if neighbor not in open_set_hash:
    77 134.1719 MiB   0.0000 MiB         230                       count += 1
    78 134.1719 MiB   0.0000 MiB         230                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.1719 MiB   0.0000 MiB         230                       open_set_hash.add(neighbor)
    80                                                             
    81 134.1719 MiB   0.0000 MiB         153           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.1719 MiB   0.0000 MiB         153           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.1719 MiB 134.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.1719 MiB   0.0000 MiB         257       for row in grid:
    32 134.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 134.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.1719 MiB   0.0000 MiB           1       count = 0
    36 134.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.1719 MiB   0.0000 MiB           1       came_from = {}
    39 134.4531 MiB   0.2812 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.4531 MiB   0.0000 MiB           1       g_score[start] = 0
    41 134.4531 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 134.4531 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 134.4531 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 134.4531 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 134.4531 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.4531 MiB -2319.9375 MiB        6517       while not open_set.empty():
    49 134.4531 MiB -2320.1562 MiB        6517           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.4531 MiB -2320.7344 MiB        6517           current = open_set.get()[2]
    55 134.4531 MiB -2320.9375 MiB        6517           open_set_hash.remove(current)
    56                                         
    57 134.4531 MiB -2321.1562 MiB        6517           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.4531 MiB -2321.4062 MiB        6517           if current == end:
    62 128.7969 MiB  -5.6562 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.7969 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.4531 MiB -20858.3594 MiB       58644           for neighbor in current.neighbors:
    67 134.4531 MiB -18539.6094 MiB       52128               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.4531 MiB -9273.3594 MiB       26064                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.4531 MiB -9266.8594 MiB       26064                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.4531 MiB -18540.8750 MiB       52128               if temp_g_score < g_score[neighbor]:
    73 134.4531 MiB -2607.6406 MiB        6977                   came_from[neighbor] = current
    74 134.4531 MiB -2607.8594 MiB        6977                   g_score[neighbor] = temp_g_score
    75 134.4531 MiB -2608.1094 MiB        6977                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.4531 MiB -2608.2656 MiB        6977                   if neighbor not in open_set_hash:
    77 134.4531 MiB -2608.2656 MiB        6977                       count += 1
    78 134.4531 MiB -2608.2656 MiB        6977                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.4531 MiB -2608.2656 MiB        6977                       open_set_hash.add(neighbor)
    80                                                             
    81 134.4531 MiB -2319.5312 MiB        6516           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.4531 MiB -2319.6562 MiB        6516           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.7969 MiB 128.7969 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.7969 MiB -67.8125 MiB         257       for row in grid:
    32 128.7969 MiB -17344.8906 MiB       65792           for spot in row:
    33 128.7969 MiB -17277.6406 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 127.8281 MiB  -0.9688 MiB           1       count = 0
    36 127.8281 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 127.8281 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 127.8281 MiB   0.0000 MiB           1       came_from = {}
    39 128.1562 MiB   0.3281 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.1562 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1562 MiB   0.0000 MiB          90       while not open_set.empty():
    49 128.1562 MiB   0.0000 MiB          90           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1562 MiB   0.0000 MiB          90           current = open_set.get()[2]
    55 128.1562 MiB   0.0000 MiB          90           open_set_hash.remove(current)
    56                                         
    57 128.1562 MiB   0.0000 MiB          90           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1562 MiB   0.0000 MiB          90           if current == end:
    62 128.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1562 MiB   0.0000 MiB         801           for neighbor in current.neighbors:
    67 128.1562 MiB   0.0000 MiB         712               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1562 MiB   0.0000 MiB         356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1562 MiB   0.0000 MiB         356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1562 MiB   0.0000 MiB         712               if temp_g_score < g_score[neighbor]:
    73 128.1562 MiB   0.0000 MiB         142                   came_from[neighbor] = current
    74 128.1562 MiB   0.0000 MiB         142                   g_score[neighbor] = temp_g_score
    75 128.1562 MiB   0.0000 MiB         142                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1562 MiB   0.0000 MiB         142                   if neighbor not in open_set_hash:
    77 128.1562 MiB   0.0000 MiB         142                       count += 1
    78 128.1562 MiB   0.0000 MiB         142                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1562 MiB   0.0000 MiB         142                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1562 MiB   0.0000 MiB          89           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1562 MiB   0.0000 MiB          89           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.1562 MiB 128.1562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.1562 MiB   0.0000 MiB         257       for row in grid:
    32 128.1562 MiB   0.0000 MiB       65792           for spot in row:
    33 128.1562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.1562 MiB   0.0000 MiB           1       count = 0
    36 128.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.1562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.1562 MiB   0.0000 MiB           1       came_from = {}
    39 128.1562 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.1562 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1562 MiB   0.0000 MiB        6355       while not open_set.empty():
    49 128.1562 MiB   0.0000 MiB        6355           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1562 MiB   0.0000 MiB        6355           current = open_set.get()[2]
    55 128.1562 MiB   0.0000 MiB        6355           open_set_hash.remove(current)
    56                                         
    57 128.1562 MiB   0.0000 MiB        6355           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1562 MiB   0.0000 MiB        6355           if current == end:
    62 128.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1562 MiB   0.0000 MiB       57186           for neighbor in current.neighbors:
    67 128.1562 MiB   0.0000 MiB       50832               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1562 MiB   0.0000 MiB       25416                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1562 MiB   0.0000 MiB       25416                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1562 MiB   0.0000 MiB       50832               if temp_g_score < g_score[neighbor]:
    73 128.1562 MiB   0.0000 MiB        6827                   came_from[neighbor] = current
    74 128.1562 MiB   0.0000 MiB        6827                   g_score[neighbor] = temp_g_score
    75 128.1562 MiB   0.0000 MiB        6827                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1562 MiB   0.0000 MiB        6827                   if neighbor not in open_set_hash:
    77 128.1562 MiB   0.0000 MiB        6827                       count += 1
    78 128.1562 MiB   0.0000 MiB        6827                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1562 MiB   0.0000 MiB        6827                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1562 MiB   0.0000 MiB        6354           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1562 MiB   0.0000 MiB        6354           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.1562 MiB 128.1562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.1562 MiB   0.0000 MiB         257       for row in grid:
    32 128.1562 MiB   0.0000 MiB       65792           for spot in row:
    33 128.1562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.1562 MiB   0.0000 MiB           1       count = 0
    36 128.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.1562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.1562 MiB   0.0000 MiB           1       came_from = {}
    39 128.1562 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.1562 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1562 MiB -238.6719 MiB        2862       while not open_set.empty():
    49 128.1562 MiB -238.6719 MiB        2862           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1562 MiB -238.7344 MiB        2862           current = open_set.get()[2]
    55 128.1562 MiB -238.8125 MiB        2862           open_set_hash.remove(current)
    56                                         
    57 128.1562 MiB -238.8125 MiB        2862           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1562 MiB -238.8125 MiB        2862           if current == end:
    62 127.8906 MiB  -0.2656 MiB           1               if draw:
    63                                                         end.make_end()
    64 127.8906 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1562 MiB -2147.9688 MiB       25749           for neighbor in current.neighbors:
    67 128.1562 MiB -1909.3750 MiB       22888               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1562 MiB -954.6875 MiB       11444                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1562 MiB -954.6875 MiB       11444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1562 MiB -1909.3750 MiB       22888               if temp_g_score < g_score[neighbor]:
    73 128.1562 MiB -262.5781 MiB        3180                   came_from[neighbor] = current
    74 128.1562 MiB -262.5781 MiB        3180                   g_score[neighbor] = temp_g_score
    75 128.1562 MiB -262.5781 MiB        3180                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1562 MiB -262.5781 MiB        3180                   if neighbor not in open_set_hash:
    77 128.1562 MiB -262.5781 MiB        3180                       count += 1
    78 128.1562 MiB -262.5781 MiB        3180                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1562 MiB -262.5781 MiB        3180                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1562 MiB -238.6719 MiB        2861           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1562 MiB -238.6719 MiB        2861           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 123.7188 MiB 123.7188 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 123.7188 MiB -480.2656 MiB         257       for row in grid:
    32 123.7188 MiB -123217.7500 MiB       65792           for spot in row:
    33 123.7188 MiB -122739.6719 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 120.7188 MiB  -3.0000 MiB           1       count = 0
    36 120.7188 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 120.7188 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 120.7188 MiB   0.0000 MiB           1       came_from = {}
    39 124.1562 MiB   3.4375 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 124.1562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 124.1875 MiB -108689.3281 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 120.7812 MiB  -3.4062 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 120.7812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 120.7812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 120.7812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 120.7812 MiB   0.0000 MiB         435       while not open_set.empty():
    49 120.7812 MiB   0.0000 MiB         435           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 120.7812 MiB   0.0000 MiB         435           current = open_set.get()[2]
    55 120.7812 MiB   0.0000 MiB         435           open_set_hash.remove(current)
    56                                         
    57 120.7812 MiB   0.0000 MiB         435           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 120.7812 MiB   0.0000 MiB         435           if current == end:
    62 120.7812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 120.7812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 120.7812 MiB   0.0000 MiB        3906           for neighbor in current.neighbors:
    67 120.7812 MiB   0.0000 MiB        3472               if current.row != neighbor.row and current.col != neighbor.col:
    68 120.7812 MiB   0.0000 MiB        1736                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 120.7812 MiB   0.0000 MiB        1736                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 120.7812 MiB   0.0000 MiB        3472               if temp_g_score < g_score[neighbor]:
    73 120.7812 MiB   0.0000 MiB         791                   came_from[neighbor] = current
    74 120.7812 MiB   0.0000 MiB         791                   g_score[neighbor] = temp_g_score
    75 120.7812 MiB   0.0000 MiB         791                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 120.7812 MiB   0.0000 MiB         791                   if neighbor not in open_set_hash:
    77 120.7812 MiB   0.0000 MiB         791                       count += 1
    78 120.7812 MiB   0.0000 MiB         791                       open_set.put((f_score[neighbor], count, neighbor))
    79 120.7812 MiB   0.0000 MiB         791                       open_set_hash.add(neighbor)
    80                                                             
    81 120.7812 MiB   0.0000 MiB         434           if draw is not None:
    82                                                     draw()
    83                                         
    84 120.7812 MiB   0.0000 MiB         434           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 120.7812 MiB 120.7812 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 120.7812 MiB -128.7969 MiB         257       for row in grid:
    32 120.7812 MiB -32283.4219 MiB       65792           for spot in row:
    33 120.7812 MiB -32158.6875 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 115.0938 MiB  -5.6875 MiB           1       count = 0
    36 115.0938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 115.0938 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 115.0938 MiB   0.0000 MiB           1       came_from = {}
    39 115.1250 MiB   0.0312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 115.1250 MiB   0.0000 MiB           1       g_score[start] = 0
    41 116.3750 MiB   1.2500 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 116.3750 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 116.3750 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 116.3750 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 116.3750 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 116.4062 MiB   0.0000 MiB       11368       while not open_set.empty():
    49 116.4062 MiB   0.0000 MiB       11368           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 116.4062 MiB   0.0000 MiB       11368           current = open_set.get()[2]
    55 116.4062 MiB   0.0000 MiB       11368           open_set_hash.remove(current)
    56                                         
    57 116.4062 MiB   0.0000 MiB       11368           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 116.4062 MiB   0.0000 MiB       11368           if current == end:
    62 116.4062 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 116.4062 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 116.4062 MiB   0.0000 MiB      102303           for neighbor in current.neighbors:
    67 116.4062 MiB   0.0000 MiB       90936               if current.row != neighbor.row and current.col != neighbor.col:
    68 116.4062 MiB   0.0000 MiB       45468                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 116.4062 MiB   0.0000 MiB       45468                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 116.4062 MiB   0.0000 MiB       90936               if temp_g_score < g_score[neighbor]:
    73 116.4062 MiB   0.0312 MiB       12026                   came_from[neighbor] = current
    74 116.4062 MiB   0.0000 MiB       12026                   g_score[neighbor] = temp_g_score
    75 116.4062 MiB   0.0000 MiB       12026                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 116.4062 MiB   0.0000 MiB       12026                   if neighbor not in open_set_hash:
    77 116.4062 MiB   0.0000 MiB       12026                       count += 1
    78 116.4062 MiB   0.0000 MiB       12026                       open_set.put((f_score[neighbor], count, neighbor))
    79 116.4062 MiB   0.0000 MiB       12026                       open_set_hash.add(neighbor)
    80                                                             
    81 116.4062 MiB   0.0000 MiB       11367           if draw is not None:
    82                                                     draw()
    83                                         
    84 116.4062 MiB   0.0000 MiB       11367           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 116.4062 MiB 116.4062 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 116.4062 MiB   0.0000 MiB         257       for row in grid:
    32 116.4062 MiB   0.0000 MiB       65792           for spot in row:
    33 116.4062 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 116.4062 MiB   0.0000 MiB           1       count = 0
    36 116.4062 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 116.4062 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 116.4062 MiB   0.0000 MiB           1       came_from = {}
    39 116.7188 MiB   0.3125 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 116.7188 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.4219 MiB   1.7031 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.4219 MiB   0.0000 MiB        1938       while not open_set.empty():
    49 118.4219 MiB   0.0000 MiB        1938           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.4219 MiB   0.0000 MiB        1938           current = open_set.get()[2]
    55 118.4219 MiB   0.0000 MiB        1938           open_set_hash.remove(current)
    56                                         
    57 118.4219 MiB   0.0000 MiB        1938           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.4219 MiB   0.0000 MiB        1938           if current == end:
    62 118.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.4219 MiB   0.0000 MiB       17433           for neighbor in current.neighbors:
    67 118.4219 MiB   0.0000 MiB       15496               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.4219 MiB   0.0000 MiB        7748                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.4219 MiB   0.0000 MiB        7748                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.4219 MiB   0.0000 MiB       15496               if temp_g_score < g_score[neighbor]:
    73 118.4219 MiB   0.0000 MiB        2190                   came_from[neighbor] = current
    74 118.4219 MiB   0.0000 MiB        2190                   g_score[neighbor] = temp_g_score
    75 118.4219 MiB   0.0000 MiB        2190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.4219 MiB   0.0000 MiB        2190                   if neighbor not in open_set_hash:
    77 118.4219 MiB   0.0000 MiB        2190                       count += 1
    78 118.4219 MiB   0.0000 MiB        2190                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.4219 MiB   0.0000 MiB        2190                       open_set_hash.add(neighbor)
    80                                                             
    81 118.4219 MiB   0.0000 MiB        1937           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.4219 MiB   0.0000 MiB        1937           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.4219 MiB 118.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.4219 MiB   0.0000 MiB         257       for row in grid:
    32 118.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 118.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.4219 MiB   0.0000 MiB           1       count = 0
    36 118.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.4219 MiB   0.0000 MiB           1       came_from = {}
    39 118.4375 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 118.4375 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.7812 MiB   0.3438 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.7812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.7812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.7812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.7812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.7812 MiB   0.0000 MiB         996       while not open_set.empty():
    49 118.7812 MiB   0.0000 MiB         996           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.7812 MiB   0.0000 MiB         996           current = open_set.get()[2]
    55 118.7812 MiB   0.0000 MiB         996           open_set_hash.remove(current)
    56                                         
    57 118.7812 MiB   0.0000 MiB         996           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.7812 MiB   0.0000 MiB         996           if current == end:
    62 118.7812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.7812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.7812 MiB   0.0000 MiB        8955           for neighbor in current.neighbors:
    67 118.7812 MiB   0.0000 MiB        7960               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.7812 MiB   0.0000 MiB        3980                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.7812 MiB   0.0000 MiB        3980                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.7812 MiB   0.0000 MiB        7960               if temp_g_score < g_score[neighbor]:
    73 118.7812 MiB   0.0000 MiB        1208                   came_from[neighbor] = current
    74 118.7812 MiB   0.0000 MiB        1208                   g_score[neighbor] = temp_g_score
    75 118.7812 MiB   0.0000 MiB        1208                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.7812 MiB   0.0000 MiB        1208                   if neighbor not in open_set_hash:
    77 118.7812 MiB   0.0000 MiB        1208                       count += 1
    78 118.7812 MiB   0.0000 MiB        1208                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.7812 MiB   0.0000 MiB        1208                       open_set_hash.add(neighbor)
    80                                                             
    81 118.7812 MiB   0.0000 MiB         995           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.7812 MiB   0.0000 MiB         995           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.7812 MiB 118.7812 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.7812 MiB   0.0000 MiB         257       for row in grid:
    32 118.7812 MiB   0.0000 MiB       65792           for spot in row:
    33 118.7812 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.7812 MiB   0.0000 MiB           1       count = 0
    36 118.7812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.7812 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.7812 MiB   0.0000 MiB           1       came_from = {}
    39 118.7812 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 118.7812 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.7812 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.7812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.7812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.7812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.7812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.7812 MiB   0.0000 MiB        3150       while not open_set.empty():
    49 118.7812 MiB   0.0000 MiB        3150           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.7812 MiB   0.0000 MiB        3150           current = open_set.get()[2]
    55 118.7812 MiB   0.0000 MiB        3150           open_set_hash.remove(current)
    56                                         
    57 118.7812 MiB   0.0000 MiB        3150           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.7812 MiB   0.0000 MiB        3150           if current == end:
    62 118.7812 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.7812 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.7812 MiB   0.0000 MiB       28341           for neighbor in current.neighbors:
    67 118.7812 MiB   0.0000 MiB       25192               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.7812 MiB   0.0000 MiB       12596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.7812 MiB   0.0000 MiB       12596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.7812 MiB   0.0000 MiB       25192               if temp_g_score < g_score[neighbor]:
    73 118.7812 MiB   0.0000 MiB        3468                   came_from[neighbor] = current
    74 118.7812 MiB   0.0000 MiB        3468                   g_score[neighbor] = temp_g_score
    75 118.7812 MiB   0.0000 MiB        3468                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.7812 MiB   0.0000 MiB        3468                   if neighbor not in open_set_hash:
    77 118.7812 MiB   0.0000 MiB        3468                       count += 1
    78 118.7812 MiB   0.0000 MiB        3468                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.7812 MiB   0.0000 MiB        3468                       open_set_hash.add(neighbor)
    80                                                             
    81 118.7812 MiB   0.0000 MiB        3149           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.7812 MiB   0.0000 MiB        3149           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.7812 MiB 118.7812 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.7812 MiB   0.0000 MiB         257       for row in grid:
    32 118.7812 MiB   0.0000 MiB       65792           for spot in row:
    33 118.7812 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.7812 MiB   0.0000 MiB           1       count = 0
    36 118.7812 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.7812 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.7812 MiB   0.0000 MiB           1       came_from = {}
    39 119.0938 MiB   0.3125 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 119.0938 MiB   0.0000 MiB           1       g_score[start] = 0
    41 119.0938 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 119.0938 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 119.0938 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 119.0938 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 119.0938 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 119.0938 MiB -2709.6250 MiB        5724       while not open_set.empty():
    49 119.0938 MiB -2709.6250 MiB        5724           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 119.0938 MiB -2709.6406 MiB        5724           current = open_set.get()[2]
    55 119.0938 MiB -2709.7500 MiB        5724           open_set_hash.remove(current)
    56                                         
    57 119.0938 MiB -2709.8281 MiB        5724           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 119.0938 MiB -2709.8594 MiB        5724           if current == end:
    62 118.2656 MiB  -0.8281 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.2656 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 119.0938 MiB -24052.3125 MiB       50874           for neighbor in current.neighbors:
    67 119.0938 MiB -21342.9375 MiB       45151               if current.row != neighbor.row and current.col != neighbor.col:
    68 119.0938 MiB -10616.5625 MiB       22470                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 119.0938 MiB -10726.3750 MiB       22681                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 119.0938 MiB -21343.0781 MiB       45151               if temp_g_score < g_score[neighbor]:
    73 119.0938 MiB -2818.9375 MiB        6041                   came_from[neighbor] = current
    74 119.0938 MiB -2818.9375 MiB        6041                   g_score[neighbor] = temp_g_score
    75 119.0938 MiB -2818.9375 MiB        6041                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 119.0938 MiB -2818.9375 MiB        6041                   if neighbor not in open_set_hash:
    77 119.0938 MiB -2818.9375 MiB        6041                       count += 1
    78 119.0938 MiB -2818.9375 MiB        6041                       open_set.put((f_score[neighbor], count, neighbor))
    79 119.0938 MiB -2818.9375 MiB        6041                       open_set_hash.add(neighbor)
    80                                                             
    81 119.0938 MiB -2709.6250 MiB        5723           if draw is not None:
    82                                                     draw()
    83                                         
    84 119.0938 MiB -2709.6250 MiB        5723           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.2656 MiB 118.2656 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.2656 MiB  -2.8281 MiB         257       for row in grid:
    32 118.2656 MiB -726.7656 MiB       65792           for spot in row:
    33 118.2656 MiB -723.9531 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.2500 MiB  -0.0156 MiB           1       count = 0
    36 118.2500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.2500 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.2500 MiB   0.0000 MiB           1       came_from = {}
    39 118.2500 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 118.2500 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.8438 MiB   0.5938 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.8438 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.8438 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.8438 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.8438 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.8438 MiB   0.0000 MiB          23       while not open_set.empty():
    49 118.8438 MiB   0.0000 MiB          23           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.8438 MiB   0.0000 MiB          23           current = open_set.get()[2]
    55 118.8438 MiB   0.0000 MiB          23           open_set_hash.remove(current)
    56                                         
    57 118.8438 MiB   0.0000 MiB          23           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.8438 MiB   0.0000 MiB          23           if current == end:
    62 118.8438 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.8438 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.8438 MiB   0.0000 MiB         198           for neighbor in current.neighbors:
    67 118.8438 MiB   0.0000 MiB         176               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.8438 MiB   0.0000 MiB          88                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.8438 MiB   0.0000 MiB          88                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.8438 MiB   0.0000 MiB         176               if temp_g_score < g_score[neighbor]:
    73 118.8438 MiB   0.0000 MiB         113                   came_from[neighbor] = current
    74 118.8438 MiB   0.0000 MiB         113                   g_score[neighbor] = temp_g_score
    75 118.8438 MiB   0.0000 MiB         113                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.8438 MiB   0.0000 MiB         113                   if neighbor not in open_set_hash:
    77 118.8438 MiB   0.0000 MiB         113                       count += 1
    78 118.8438 MiB   0.0000 MiB         113                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.8438 MiB   0.0000 MiB         113                       open_set_hash.add(neighbor)
    80                                                             
    81 118.8438 MiB   0.0000 MiB          22           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.8438 MiB   0.0000 MiB          22           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.8438 MiB 118.8438 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.8438 MiB   0.0000 MiB         257       for row in grid:
    32 118.8438 MiB   0.0000 MiB       65792           for spot in row:
    33 118.8438 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.8438 MiB   0.0000 MiB           1       count = 0
    36 118.8438 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.8438 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.8438 MiB   0.0000 MiB           1       came_from = {}
    39 118.8438 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 118.8438 MiB   0.0000 MiB           1       g_score[start] = 0
    41 118.8594 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 118.8594 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 118.8594 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 118.8594 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 118.8594 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 118.8594 MiB   0.0000 MiB        2379       while not open_set.empty():
    49 118.8594 MiB   0.0000 MiB        2379           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 118.8594 MiB   0.0000 MiB        2379           current = open_set.get()[2]
    55 118.8594 MiB   0.0000 MiB        2379           open_set_hash.remove(current)
    56                                         
    57 118.8594 MiB   0.0000 MiB        2379           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 118.8594 MiB   0.0000 MiB        2379           if current == end:
    62 118.8594 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.8594 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 118.8594 MiB   0.0000 MiB       21402           for neighbor in current.neighbors:
    67 118.8594 MiB   0.0000 MiB       19024               if current.row != neighbor.row and current.col != neighbor.col:
    68 118.8594 MiB   0.0000 MiB        9512                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 118.8594 MiB   0.0000 MiB        9512                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 118.8594 MiB   0.0000 MiB       19024               if temp_g_score < g_score[neighbor]:
    73 118.8594 MiB   0.0000 MiB        2655                   came_from[neighbor] = current
    74 118.8594 MiB   0.0000 MiB        2655                   g_score[neighbor] = temp_g_score
    75 118.8594 MiB   0.0000 MiB        2655                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 118.8594 MiB   0.0000 MiB        2655                   if neighbor not in open_set_hash:
    77 118.8594 MiB   0.0000 MiB        2655                       count += 1
    78 118.8594 MiB   0.0000 MiB        2655                       open_set.put((f_score[neighbor], count, neighbor))
    79 118.8594 MiB   0.0000 MiB        2655                       open_set_hash.add(neighbor)
    80                                                             
    81 118.8594 MiB   0.0000 MiB        2378           if draw is not None:
    82                                                     draw()
    83                                         
    84 118.8594 MiB   0.0000 MiB        2378           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.8594 MiB 118.8594 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.8594 MiB -41.8750 MiB         257       for row in grid:
    32 118.8594 MiB -10717.2188 MiB       65792           for spot in row:
    33 118.8594 MiB -10675.6094 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 118.5469 MiB  -0.3125 MiB           1       count = 0
    36 118.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 118.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 118.5469 MiB   0.0000 MiB           1       came_from = {}
    39 118.8594 MiB   0.3125 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 118.8594 MiB   0.0000 MiB           1       g_score[start] = 0
    41 120.0312 MiB   1.1719 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 120.0312 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 120.0312 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 120.0312 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 120.0312 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 120.0312 MiB   0.0000 MiB          36       while not open_set.empty():
    49 120.0312 MiB   0.0000 MiB          36           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 120.0312 MiB   0.0000 MiB          36           current = open_set.get()[2]
    55 120.0312 MiB   0.0000 MiB          36           open_set_hash.remove(current)
    56                                         
    57 120.0312 MiB   0.0000 MiB          36           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 120.0312 MiB   0.0000 MiB          36           if current == end:
    62 120.0312 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 120.0312 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 120.0312 MiB   0.0000 MiB         315           for neighbor in current.neighbors:
    67 120.0312 MiB   0.0000 MiB         280               if current.row != neighbor.row and current.col != neighbor.col:
    68 120.0312 MiB   0.0000 MiB         140                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 120.0312 MiB   0.0000 MiB         140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 120.0312 MiB   0.0000 MiB         280               if temp_g_score < g_score[neighbor]:
    73 120.0312 MiB   0.0000 MiB          88                   came_from[neighbor] = current
    74 120.0312 MiB   0.0000 MiB          88                   g_score[neighbor] = temp_g_score
    75 120.0312 MiB   0.0000 MiB          88                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 120.0312 MiB   0.0000 MiB          88                   if neighbor not in open_set_hash:
    77 120.0312 MiB   0.0000 MiB          88                       count += 1
    78 120.0312 MiB   0.0000 MiB          88                       open_set.put((f_score[neighbor], count, neighbor))
    79 120.0312 MiB   0.0000 MiB          88                       open_set_hash.add(neighbor)
    80                                                             
    81 120.0312 MiB   0.0000 MiB          35           if draw is not None:
    82                                                     draw()
    83                                         
    84 120.0312 MiB   0.0000 MiB          35           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 120.0312 MiB 120.0312 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 120.0312 MiB   0.0000 MiB         257       for row in grid:
    32 120.0312 MiB   0.0000 MiB       65792           for spot in row:
    33 120.0312 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 120.0312 MiB   0.0000 MiB           1       count = 0
    36 120.0312 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 120.0312 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 120.0312 MiB   0.0000 MiB           1       came_from = {}
    39 120.0312 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 120.0312 MiB   0.0000 MiB           1       g_score[start] = 0
    41 121.9688 MiB   1.9375 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 121.9688 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 121.9688 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 121.9688 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 121.9688 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 121.9688 MiB   0.0000 MiB        1560       while not open_set.empty():
    49 121.9688 MiB   0.0000 MiB        1560           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 121.9688 MiB   0.0000 MiB        1560           current = open_set.get()[2]
    55 121.9688 MiB   0.0000 MiB        1560           open_set_hash.remove(current)
    56                                         
    57 121.9688 MiB   0.0000 MiB        1560           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 121.9688 MiB   0.0000 MiB        1560           if current == end:
    62 121.9688 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 121.9688 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 121.9688 MiB   0.0000 MiB       14031           for neighbor in current.neighbors:
    67 121.9688 MiB   0.0000 MiB       12472               if current.row != neighbor.row and current.col != neighbor.col:
    68 121.9688 MiB   0.0000 MiB        6236                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 121.9688 MiB   0.0000 MiB        6236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 121.9688 MiB   0.0000 MiB       12472               if temp_g_score < g_score[neighbor]:
    73 121.9688 MiB   0.0000 MiB        1782                   came_from[neighbor] = current
    74 121.9688 MiB   0.0000 MiB        1782                   g_score[neighbor] = temp_g_score
    75 121.9688 MiB   0.0000 MiB        1782                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 121.9688 MiB   0.0000 MiB        1782                   if neighbor not in open_set_hash:
    77 121.9688 MiB   0.0000 MiB        1782                       count += 1
    78 121.9688 MiB   0.0000 MiB        1782                       open_set.put((f_score[neighbor], count, neighbor))
    79 121.9688 MiB   0.0000 MiB        1782                       open_set_hash.add(neighbor)
    80                                                             
    81 121.9688 MiB   0.0000 MiB        1559           if draw is not None:
    82                                                     draw()
    83                                         
    84 121.9688 MiB   0.0000 MiB        1559           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 121.9688 MiB 121.9688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 121.9688 MiB   0.0000 MiB         257       for row in grid:
    32 121.9688 MiB   0.0000 MiB       65792           for spot in row:
    33 121.9688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 121.9688 MiB   0.0000 MiB           1       count = 0
    36 121.9688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 121.9688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 121.9688 MiB   0.0000 MiB           1       came_from = {}
    39 121.9688 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 121.9688 MiB   0.0000 MiB           1       g_score[start] = 0
    41 121.9688 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 121.9688 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 121.9688 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 121.9688 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 121.9688 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 121.9688 MiB   0.0000 MiB         649       while not open_set.empty():
    49 121.9688 MiB   0.0000 MiB         649           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 121.9688 MiB   0.0000 MiB         649           current = open_set.get()[2]
    55 121.9688 MiB   0.0000 MiB         649           open_set_hash.remove(current)
    56                                         
    57 121.9688 MiB   0.0000 MiB         649           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 121.9688 MiB   0.0000 MiB         649           if current == end:
    62 121.9688 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 121.9688 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 121.9688 MiB   0.0000 MiB        5832           for neighbor in current.neighbors:
    67 121.9688 MiB   0.0000 MiB        5184               if current.row != neighbor.row and current.col != neighbor.col:
    68 121.9688 MiB   0.0000 MiB        2592                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 121.9688 MiB   0.0000 MiB        2592                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 121.9688 MiB   0.0000 MiB        5184               if temp_g_score < g_score[neighbor]:
    73 121.9688 MiB   0.0000 MiB         905                   came_from[neighbor] = current
    74 121.9688 MiB   0.0000 MiB         905                   g_score[neighbor] = temp_g_score
    75 121.9688 MiB   0.0000 MiB         905                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 121.9688 MiB   0.0000 MiB         905                   if neighbor not in open_set_hash:
    77 121.9688 MiB   0.0000 MiB         905                       count += 1
    78 121.9688 MiB   0.0000 MiB         905                       open_set.put((f_score[neighbor], count, neighbor))
    79 121.9688 MiB   0.0000 MiB         905                       open_set_hash.add(neighbor)
    80                                                             
    81 121.9688 MiB   0.0000 MiB         648           if draw is not None:
    82                                                     draw()
    83                                         
    84 121.9688 MiB   0.0000 MiB         648           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 121.9688 MiB 121.9688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 121.9688 MiB   0.0000 MiB         257       for row in grid:
    32 121.9688 MiB   0.0000 MiB       65792           for spot in row:
    33 121.9688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 121.9688 MiB   0.0000 MiB           1       count = 0
    36 121.9688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 121.9688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 121.9688 MiB   0.0000 MiB           1       came_from = {}
    39 121.9688 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 121.9688 MiB   0.0000 MiB           1       g_score[start] = 0
    41 121.9688 MiB -15128.7656 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 121.7188 MiB  -0.2500 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 121.7188 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 121.7188 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 121.7188 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 121.7188 MiB -7920.5625 MiB        3053       while not open_set.empty():
    49 121.7188 MiB -7920.6875 MiB        3053           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 121.7188 MiB -7920.9219 MiB        3053           current = open_set.get()[2]
    55 121.7188 MiB -7921.0469 MiB        3053           open_set_hash.remove(current)
    56                                         
    57 121.7188 MiB -7921.1719 MiB        3053           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 121.7188 MiB -7921.2969 MiB        3053           if current == end:
    62 118.2500 MiB  -3.4688 MiB           1               if draw:
    63                                                         end.make_end()
    64 118.2500 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 121.7188 MiB -71269.6875 MiB       27468           for neighbor in current.neighbors:
    67 121.7188 MiB -63350.0781 MiB       24416               if current.row != neighbor.row and current.col != neighbor.col:
    68 121.7188 MiB -31677.4844 MiB       12208                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 121.7188 MiB -31673.1094 MiB       12208                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 121.7188 MiB -63350.9688 MiB       24416               if temp_g_score < g_score[neighbor]:
    73 121.7188 MiB -8655.3594 MiB        3421                   came_from[neighbor] = current
    74 121.7188 MiB -8655.3594 MiB        3421                   g_score[neighbor] = temp_g_score
    75 121.7188 MiB -8655.3750 MiB        3421                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 121.7188 MiB -8655.4219 MiB        3421                   if neighbor not in open_set_hash:
    77 121.7188 MiB -8655.4531 MiB        3421                       count += 1
    78 121.7188 MiB -8655.4531 MiB        3421                       open_set.put((f_score[neighbor], count, neighbor))
    79 121.7188 MiB -8655.4531 MiB        3421                       open_set_hash.add(neighbor)
    80                                                             
    81 121.7188 MiB -7920.3125 MiB        3052           if draw is not None:
    82                                                     draw()
    83                                         
    84 121.7188 MiB -7920.4375 MiB        3052           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 118.2500 MiB 118.2500 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 118.2500 MiB  -7.2969 MiB         257       for row in grid:
    32 118.2500 MiB -1299.5312 MiB       65792           for spot in row:
    33 118.2500 MiB -1294.9219 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 114.4219 MiB  -3.8281 MiB           1       count = 0
    36 114.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 114.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 114.4219 MiB   0.0000 MiB           1       came_from = {}
    39 116.2969 MiB   1.8750 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 116.2969 MiB   0.0000 MiB           1       g_score[start] = 0
    41 119.4688 MiB   3.1719 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 119.4688 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 119.4688 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 119.4688 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 119.4688 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 119.4688 MiB   0.0000 MiB         882       while not open_set.empty():
    49 119.4688 MiB   0.0000 MiB         882           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 119.4688 MiB   0.0000 MiB         882           current = open_set.get()[2]
    55 119.4688 MiB   0.0000 MiB         882           open_set_hash.remove(current)
    56                                         
    57 119.4688 MiB   0.0000 MiB         882           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 119.4688 MiB   0.0000 MiB         882           if current == end:
    62 119.4688 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 119.4688 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 119.4688 MiB   0.0000 MiB        7929           for neighbor in current.neighbors:
    67 119.4688 MiB   0.0000 MiB        7048               if current.row != neighbor.row and current.col != neighbor.col:
    68 119.4688 MiB   0.0000 MiB        3524                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 119.4688 MiB   0.0000 MiB        3524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 119.4688 MiB   0.0000 MiB        7048               if temp_g_score < g_score[neighbor]:
    73 119.4688 MiB   0.0000 MiB        1398                   came_from[neighbor] = current
    74 119.4688 MiB   0.0000 MiB        1398                   g_score[neighbor] = temp_g_score
    75 119.4688 MiB   0.0000 MiB        1398                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 119.4688 MiB   0.0000 MiB        1398                   if neighbor not in open_set_hash:
    77 119.4688 MiB   0.0000 MiB        1398                       count += 1
    78 119.4688 MiB   0.0000 MiB        1398                       open_set.put((f_score[neighbor], count, neighbor))
    79 119.4688 MiB   0.0000 MiB        1398                       open_set_hash.add(neighbor)
    80                                                             
    81 119.4688 MiB   0.0000 MiB         881           if draw is not None:
    82                                                     draw()
    83                                         
    84 119.4688 MiB   0.0000 MiB         881           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 119.4688 MiB 119.4688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 119.4688 MiB   0.0000 MiB         257       for row in grid:
    32 119.4688 MiB   0.0000 MiB       65792           for spot in row:
    33 119.4688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 119.4688 MiB   0.0000 MiB           1       count = 0
    36 119.4688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 119.4688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 119.4688 MiB   0.0000 MiB           1       came_from = {}
    39 119.5938 MiB   0.1250 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 119.5938 MiB   0.0000 MiB           1       g_score[start] = 0
    41 119.5938 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 119.5938 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 119.5938 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 119.5938 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 119.5938 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 119.5938 MiB   0.0000 MiB        1710       while not open_set.empty():
    49 119.5938 MiB   0.0000 MiB        1710           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 119.5938 MiB   0.0000 MiB        1710           current = open_set.get()[2]
    55 119.5938 MiB   0.0000 MiB        1710           open_set_hash.remove(current)
    56                                         
    57 119.5938 MiB   0.0000 MiB        1710           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 119.5938 MiB   0.0000 MiB        1710           if current == end:
    62 119.5938 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 119.5938 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 119.5938 MiB   0.0000 MiB       15381           for neighbor in current.neighbors:
    67 119.5938 MiB   0.0000 MiB       13672               if current.row != neighbor.row and current.col != neighbor.col:
    68 119.5938 MiB   0.0000 MiB        6836                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 119.5938 MiB   0.0000 MiB        6836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 119.5938 MiB   0.0000 MiB       13672               if temp_g_score < g_score[neighbor]:
    73 119.5938 MiB   0.0000 MiB        2106                   came_from[neighbor] = current
    74 119.5938 MiB   0.0000 MiB        2106                   g_score[neighbor] = temp_g_score
    75 119.5938 MiB   0.0000 MiB        2106                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 119.5938 MiB   0.0000 MiB        2106                   if neighbor not in open_set_hash:
    77 119.5938 MiB   0.0000 MiB        2106                       count += 1
    78 119.5938 MiB   0.0000 MiB        2106                       open_set.put((f_score[neighbor], count, neighbor))
    79 119.5938 MiB   0.0000 MiB        2106                       open_set_hash.add(neighbor)
    80                                                             
    81 119.5938 MiB   0.0000 MiB        1709           if draw is not None:
    82                                                     draw()
    83                                         
    84 119.5938 MiB   0.0000 MiB        1709           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 119.5938 MiB 119.5938 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 119.5938 MiB   0.0000 MiB         257       for row in grid:
    32 119.5938 MiB   0.0000 MiB       65792           for spot in row:
    33 119.5938 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 119.5938 MiB   0.0000 MiB           1       count = 0
    36 119.5938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 119.5938 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 119.5938 MiB   0.0000 MiB           1       came_from = {}
    39 120.7344 MiB   1.1406 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 120.7344 MiB   0.0000 MiB           1       g_score[start] = 0
    41 120.7500 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 120.7500 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 120.7500 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 120.7500 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 120.7500 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 120.7500 MiB   0.0000 MiB        2821       while not open_set.empty():
    49 120.7500 MiB   0.0000 MiB        2821           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 120.7500 MiB   0.0000 MiB        2821           current = open_set.get()[2]
    55 120.7500 MiB   0.0000 MiB        2821           open_set_hash.remove(current)
    56                                         
    57 120.7500 MiB   0.0000 MiB        2821           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 120.7500 MiB   0.0000 MiB        2821           if current == end:
    62 120.7500 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 120.7500 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 120.7500 MiB   0.0000 MiB       25380           for neighbor in current.neighbors:
    67 120.7500 MiB   0.0000 MiB       22560               if current.row != neighbor.row and current.col != neighbor.col:
    68 120.7500 MiB   0.0000 MiB       11280                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 120.7500 MiB   0.0000 MiB       11280                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 120.7500 MiB   0.0000 MiB       22560               if temp_g_score < g_score[neighbor]:
    73 120.7500 MiB   0.0000 MiB        3125                   came_from[neighbor] = current
    74 120.7500 MiB   0.0000 MiB        3125                   g_score[neighbor] = temp_g_score
    75 120.7500 MiB   0.0000 MiB        3125                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 120.7500 MiB   0.0000 MiB        3125                   if neighbor not in open_set_hash:
    77 120.7500 MiB   0.0000 MiB        3125                       count += 1
    78 120.7500 MiB   0.0000 MiB        3125                       open_set.put((f_score[neighbor], count, neighbor))
    79 120.7500 MiB   0.0000 MiB        3125                       open_set_hash.add(neighbor)
    80                                                             
    81 120.7500 MiB   0.0000 MiB        2820           if draw is not None:
    82                                                     draw()
    83                                         
    84 120.7500 MiB   0.0000 MiB        2820           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 120.7500 MiB 120.7500 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 120.7500 MiB   0.0000 MiB         257       for row in grid:
    32 120.7500 MiB   0.0000 MiB       65792           for spot in row:
    33 120.7500 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 120.7500 MiB   0.0000 MiB           1       count = 0
    36 120.7500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 120.7500 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 120.7500 MiB   0.0000 MiB           1       came_from = {}
    39 121.8594 MiB   1.1094 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 121.8594 MiB   0.0000 MiB           1       g_score[start] = 0
    41 121.8594 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 121.8594 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 121.8594 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 121.8594 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 121.8594 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 121.8594 MiB   0.0000 MiB         684       while not open_set.empty():
    49 121.8594 MiB   0.0000 MiB         684           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 121.8594 MiB   0.0000 MiB         684           current = open_set.get()[2]
    55 121.8594 MiB   0.0000 MiB         684           open_set_hash.remove(current)
    56                                         
    57 121.8594 MiB   0.0000 MiB         684           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 121.8594 MiB   0.0000 MiB         684           if current == end:
    62 121.8594 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 121.8594 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 121.8594 MiB   0.0000 MiB        6147           for neighbor in current.neighbors:
    67 121.8594 MiB   0.0000 MiB        5464               if current.row != neighbor.row and current.col != neighbor.col:
    68 121.8594 MiB   0.0000 MiB        2732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 121.8594 MiB   0.0000 MiB        2732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 121.8594 MiB   0.0000 MiB        5464               if temp_g_score < g_score[neighbor]:
    73 121.8594 MiB   0.0000 MiB         830                   came_from[neighbor] = current
    74 121.8594 MiB   0.0000 MiB         830                   g_score[neighbor] = temp_g_score
    75 121.8594 MiB   0.0000 MiB         830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 121.8594 MiB   0.0000 MiB         830                   if neighbor not in open_set_hash:
    77 121.8594 MiB   0.0000 MiB         830                       count += 1
    78 121.8594 MiB   0.0000 MiB         830                       open_set.put((f_score[neighbor], count, neighbor))
    79 121.8594 MiB   0.0000 MiB         830                       open_set_hash.add(neighbor)
    80                                                             
    81 121.8594 MiB   0.0000 MiB         683           if draw is not None:
    82                                                     draw()
    83                                         
    84 121.8594 MiB   0.0000 MiB         683           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 122.0781 MiB 122.0781 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 122.0781 MiB   0.0000 MiB         257       for row in grid:
    32 122.0781 MiB   0.0000 MiB       65792           for spot in row:
    33 122.0781 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 122.0781 MiB   0.0000 MiB           1       count = 0
    36 122.0781 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 122.0781 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 122.0781 MiB   0.0000 MiB           1       came_from = {}
    39 122.0938 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 122.0938 MiB   0.0000 MiB           1       g_score[start] = 0
    41 122.4219 MiB   0.3281 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 122.4219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 122.4219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 122.4219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 122.4219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 122.4219 MiB   0.0000 MiB        4437       while not open_set.empty():
    49 122.4219 MiB   0.0000 MiB        4437           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 122.4219 MiB   0.0000 MiB        4437           current = open_set.get()[2]
    55 122.4219 MiB   0.0000 MiB        4437           open_set_hash.remove(current)
    56                                         
    57 122.4219 MiB   0.0000 MiB        4437           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 122.4219 MiB   0.0000 MiB        4437           if current == end:
    62 122.4219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 122.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 122.4219 MiB   0.0000 MiB       39924           for neighbor in current.neighbors:
    67 122.4219 MiB   0.0000 MiB       35488               if current.row != neighbor.row and current.col != neighbor.col:
    68 122.4219 MiB   0.0000 MiB       17744                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 122.4219 MiB   0.0000 MiB       17744                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 122.4219 MiB   0.0000 MiB       35488               if temp_g_score < g_score[neighbor]:
    73 122.4219 MiB   0.0000 MiB        4857                   came_from[neighbor] = current
    74 122.4219 MiB   0.0000 MiB        4857                   g_score[neighbor] = temp_g_score
    75 122.4219 MiB   0.0000 MiB        4857                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 122.4219 MiB   0.0000 MiB        4857                   if neighbor not in open_set_hash:
    77 122.4219 MiB   0.0000 MiB        4857                       count += 1
    78 122.4219 MiB   0.0000 MiB        4857                       open_set.put((f_score[neighbor], count, neighbor))
    79 122.4219 MiB   0.0000 MiB        4857                       open_set_hash.add(neighbor)
    80                                                             
    81 122.4219 MiB   0.0000 MiB        4436           if draw is not None:
    82                                                     draw()
    83                                         
    84 122.4219 MiB   0.0000 MiB        4436           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 122.4219 MiB 122.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 122.4219 MiB   0.0000 MiB         257       for row in grid:
    32 122.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 122.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 122.4219 MiB   0.0000 MiB           1       count = 0
    36 122.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 122.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 122.4219 MiB   0.0000 MiB           1       came_from = {}
    39 123.0156 MiB   0.5938 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 123.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 125.5312 MiB   2.5156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 125.5312 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 125.5312 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 125.5312 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 125.5312 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 125.6562 MiB   0.0000 MiB        2450       while not open_set.empty():
    49 125.6562 MiB   0.0000 MiB        2450           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 125.6562 MiB   0.0000 MiB        2450           current = open_set.get()[2]
    55 125.6562 MiB   0.0000 MiB        2450           open_set_hash.remove(current)
    56                                         
    57 125.6562 MiB   0.0000 MiB        2450           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 125.6562 MiB   0.0000 MiB        2450           if current == end:
    62 125.6562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 125.6562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 125.6562 MiB   0.0000 MiB       22041           for neighbor in current.neighbors:
    67 125.6562 MiB   0.0000 MiB       19592               if current.row != neighbor.row and current.col != neighbor.col:
    68 125.6562 MiB   0.0000 MiB        9796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 125.6562 MiB   0.0000 MiB        9796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 125.6562 MiB   0.0000 MiB       19592               if temp_g_score < g_score[neighbor]:
    73 125.6562 MiB   0.1250 MiB        2746                   came_from[neighbor] = current
    74 125.6562 MiB   0.0000 MiB        2746                   g_score[neighbor] = temp_g_score
    75 125.6562 MiB   0.0000 MiB        2746                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 125.6562 MiB   0.0000 MiB        2746                   if neighbor not in open_set_hash:
    77 125.6562 MiB   0.0000 MiB        2746                       count += 1
    78 125.6562 MiB   0.0000 MiB        2746                       open_set.put((f_score[neighbor], count, neighbor))
    79 125.6562 MiB   0.0000 MiB        2746                       open_set_hash.add(neighbor)
    80                                                             
    81 125.6562 MiB   0.0000 MiB        2449           if draw is not None:
    82                                                     draw()
    83                                         
    84 125.6562 MiB   0.0000 MiB        2449           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 125.6562 MiB 125.6562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 125.6562 MiB   0.0000 MiB         257       for row in grid:
    32 125.6562 MiB   0.0000 MiB       65792           for spot in row:
    33 125.6562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 125.6562 MiB   0.0000 MiB           1       count = 0
    36 125.6562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 125.6562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 125.6562 MiB   0.0000 MiB           1       came_from = {}
    39 128.1719 MiB   2.5156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 128.1719 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 128.1719 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 128.1719 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 128.1719 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 128.1719 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 128.1719 MiB   0.0000 MiB        3264       while not open_set.empty():
    49 128.1719 MiB   0.0000 MiB        3264           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 128.1719 MiB   0.0000 MiB        3264           current = open_set.get()[2]
    55 128.1719 MiB   0.0000 MiB        3264           open_set_hash.remove(current)
    56                                         
    57 128.1719 MiB   0.0000 MiB        3264           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 128.1719 MiB   0.0000 MiB        3264           if current == end:
    62 128.1719 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 128.1719 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 128.1719 MiB   0.0000 MiB       29367           for neighbor in current.neighbors:
    67 128.1719 MiB   0.0000 MiB       26104               if current.row != neighbor.row and current.col != neighbor.col:
    68 128.1719 MiB   0.0000 MiB       13052                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 128.1719 MiB   0.0000 MiB       13052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 128.1719 MiB   0.0000 MiB       26104               if temp_g_score < g_score[neighbor]:
    73 128.1719 MiB   0.0000 MiB        3630                   came_from[neighbor] = current
    74 128.1719 MiB   0.0000 MiB        3630                   g_score[neighbor] = temp_g_score
    75 128.1719 MiB   0.0000 MiB        3630                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 128.1719 MiB   0.0000 MiB        3630                   if neighbor not in open_set_hash:
    77 128.1719 MiB   0.0000 MiB        3630                       count += 1
    78 128.1719 MiB   0.0000 MiB        3630                       open_set.put((f_score[neighbor], count, neighbor))
    79 128.1719 MiB   0.0000 MiB        3630                       open_set_hash.add(neighbor)
    80                                                             
    81 128.1719 MiB   0.0000 MiB        3263           if draw is not None:
    82                                                     draw()
    83                                         
    84 128.1719 MiB   0.0000 MiB        3263           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 128.1719 MiB 128.1719 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 128.1719 MiB   0.0000 MiB         257       for row in grid:
    32 128.1719 MiB   0.0000 MiB       65792           for spot in row:
    33 128.1719 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 128.1719 MiB   0.0000 MiB           1       count = 0
    36 128.1719 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 128.1719 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 128.1719 MiB   0.0000 MiB           1       came_from = {}
    39 128.1719 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 128.1719 MiB   0.0000 MiB           1       g_score[start] = 0
    41 129.3906 MiB   1.2188 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 129.3906 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 129.3906 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 129.3906 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 129.3906 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 129.3906 MiB   0.0000 MiB        4770       while not open_set.empty():
    49 129.3906 MiB   0.0000 MiB        4770           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 129.3906 MiB   0.0000 MiB        4770           current = open_set.get()[2]
    55 129.3906 MiB   0.0000 MiB        4770           open_set_hash.remove(current)
    56                                         
    57 129.3906 MiB   0.0000 MiB        4770           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 129.3906 MiB   0.0000 MiB        4770           if current == end:
    62 129.3906 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 129.3906 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 129.3906 MiB   0.0000 MiB       42921           for neighbor in current.neighbors:
    67 129.3906 MiB   0.0000 MiB       38152               if current.row != neighbor.row and current.col != neighbor.col:
    68 129.3906 MiB   0.0000 MiB       19076                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 129.3906 MiB   0.0000 MiB       19076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 129.3906 MiB   0.0000 MiB       38152               if temp_g_score < g_score[neighbor]:
    73 129.3906 MiB   0.0000 MiB        5234                   came_from[neighbor] = current
    74 129.3906 MiB   0.0000 MiB        5234                   g_score[neighbor] = temp_g_score
    75 129.3906 MiB   0.0000 MiB        5234                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 129.3906 MiB   0.0000 MiB        5234                   if neighbor not in open_set_hash:
    77 129.3906 MiB   0.0000 MiB        5234                       count += 1
    78 129.3906 MiB   0.0000 MiB        5234                       open_set.put((f_score[neighbor], count, neighbor))
    79 129.3906 MiB   0.0000 MiB        5234                       open_set_hash.add(neighbor)
    80                                                             
    81 129.3906 MiB   0.0000 MiB        4769           if draw is not None:
    82                                                     draw()
    83                                         
    84 129.3906 MiB   0.0000 MiB        4769           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 129.3906 MiB 129.3906 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 129.3906 MiB   0.0000 MiB         257       for row in grid:
    32 129.3906 MiB   0.0000 MiB       65792           for spot in row:
    33 129.3906 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 129.3906 MiB   0.0000 MiB           1       count = 0
    36 129.3906 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 129.3906 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 129.3906 MiB   0.0000 MiB           1       came_from = {}
    39 129.3906 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 129.3906 MiB   0.0000 MiB           1       g_score[start] = 0
    41 131.9219 MiB   2.5312 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 131.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 131.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 131.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 131.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 131.9219 MiB   0.0000 MiB        4480       while not open_set.empty():
    49 131.9219 MiB   0.0000 MiB        4480           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 131.9219 MiB   0.0000 MiB        4480           current = open_set.get()[2]
    55 131.9219 MiB   0.0000 MiB        4480           open_set_hash.remove(current)
    56                                         
    57 131.9219 MiB   0.0000 MiB        4480           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 131.9219 MiB   0.0000 MiB        4480           if current == end:
    62 131.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 131.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 131.9219 MiB   0.0000 MiB       40311           for neighbor in current.neighbors:
    67 131.9219 MiB   0.0000 MiB       35832               if current.row != neighbor.row and current.col != neighbor.col:
    68 131.9219 MiB   0.0000 MiB       17916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 131.9219 MiB   0.0000 MiB       17916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 131.9219 MiB   0.0000 MiB       35832               if temp_g_score < g_score[neighbor]:
    73 131.9219 MiB   0.0000 MiB        4886                   came_from[neighbor] = current
    74 131.9219 MiB   0.0000 MiB        4886                   g_score[neighbor] = temp_g_score
    75 131.9219 MiB   0.0000 MiB        4886                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 131.9219 MiB   0.0000 MiB        4886                   if neighbor not in open_set_hash:
    77 131.9219 MiB   0.0000 MiB        4886                       count += 1
    78 131.9219 MiB   0.0000 MiB        4886                       open_set.put((f_score[neighbor], count, neighbor))
    79 131.9219 MiB   0.0000 MiB        4886                       open_set_hash.add(neighbor)
    80                                                             
    81 131.9219 MiB   0.0000 MiB        4479           if draw is not None:
    82                                                     draw()
    83                                         
    84 131.9219 MiB   0.0000 MiB        4479           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 131.9219 MiB 131.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 131.9219 MiB   0.0000 MiB         257       for row in grid:
    32 131.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 131.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 131.9219 MiB   0.0000 MiB           1       count = 0
    36 131.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 131.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 131.9219 MiB   0.0000 MiB           1       came_from = {}
    39 133.0781 MiB   1.1562 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.0781 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.0781 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.0781 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.0781 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.0781 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.0781 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 133.0781 MiB   0.0000 MiB         336       while not open_set.empty():
    49 133.0781 MiB   0.0000 MiB         336           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 133.0781 MiB   0.0000 MiB         336           current = open_set.get()[2]
    55 133.0781 MiB   0.0000 MiB         336           open_set_hash.remove(current)
    56                                         
    57 133.0781 MiB   0.0000 MiB         336           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 133.0781 MiB   0.0000 MiB         336           if current == end:
    62 133.0781 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 133.0781 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 133.0781 MiB   0.0000 MiB        3015           for neighbor in current.neighbors:
    67 133.0781 MiB   0.0000 MiB        2680               if current.row != neighbor.row and current.col != neighbor.col:
    68 133.0781 MiB   0.0000 MiB        1340                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 133.0781 MiB   0.0000 MiB        1340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 133.0781 MiB   0.0000 MiB        2680               if temp_g_score < g_score[neighbor]:
    73 133.0781 MiB   0.0000 MiB         570                   came_from[neighbor] = current
    74 133.0781 MiB   0.0000 MiB         570                   g_score[neighbor] = temp_g_score
    75 133.0781 MiB   0.0000 MiB         570                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 133.0781 MiB   0.0000 MiB         570                   if neighbor not in open_set_hash:
    77 133.0781 MiB   0.0000 MiB         570                       count += 1
    78 133.0781 MiB   0.0000 MiB         570                       open_set.put((f_score[neighbor], count, neighbor))
    79 133.0781 MiB   0.0000 MiB         570                       open_set_hash.add(neighbor)
    80                                                             
    81 133.0781 MiB   0.0000 MiB         335           if draw is not None:
    82                                                     draw()
    83                                         
    84 133.0781 MiB   0.0000 MiB         335           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 133.0781 MiB 133.0781 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 133.0781 MiB   0.0000 MiB         257       for row in grid:
    32 133.0781 MiB   0.0000 MiB       65792           for spot in row:
    33 133.0781 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 133.0781 MiB   0.0000 MiB           1       count = 0
    36 133.0781 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 133.0781 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 133.0781 MiB   0.0000 MiB           1       came_from = {}
    39 133.6562 MiB   0.5781 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 133.6562 MiB   0.0000 MiB           1       g_score[start] = 0
    41 133.6562 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 133.6562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 133.6562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 133.6562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 133.6562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 134.0000 MiB   0.0000 MiB        4940       while not open_set.empty():
    49 134.0000 MiB   0.0000 MiB        4940           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 134.0000 MiB   0.0000 MiB        4940           current = open_set.get()[2]
    55 134.0000 MiB   0.0000 MiB        4940           open_set_hash.remove(current)
    56                                         
    57 134.0000 MiB   0.0000 MiB        4940           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 134.0000 MiB   0.0000 MiB        4940           if current == end:
    62 134.0000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.0000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 134.0000 MiB   0.0000 MiB       44451           for neighbor in current.neighbors:
    67 134.0000 MiB   0.0000 MiB       39512               if current.row != neighbor.row and current.col != neighbor.col:
    68 134.0000 MiB   0.0000 MiB       19756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 134.0000 MiB   0.0000 MiB       19756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 134.0000 MiB   0.0000 MiB       39512               if temp_g_score < g_score[neighbor]:
    73 134.0000 MiB   0.2812 MiB        5534                   came_from[neighbor] = current
    74 134.0000 MiB   0.0000 MiB        5534                   g_score[neighbor] = temp_g_score
    75 134.0000 MiB   0.0000 MiB        5534                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 134.0000 MiB   0.0000 MiB        5534                   if neighbor not in open_set_hash:
    77 134.0000 MiB   0.0000 MiB        5534                       count += 1
    78 134.0000 MiB   0.0000 MiB        5534                       open_set.put((f_score[neighbor], count, neighbor))
    79 134.0000 MiB   0.0625 MiB        5534                       open_set_hash.add(neighbor)
    80                                                             
    81 134.0000 MiB   0.0000 MiB        4939           if draw is not None:
    82                                                     draw()
    83                                         
    84 134.0000 MiB   0.0000 MiB        4939           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.0156 MiB 134.0156 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.0156 MiB   0.0000 MiB         257       for row in grid:
    32 134.0156 MiB   0.0000 MiB       65792           for spot in row:
    33 134.0156 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.0156 MiB   0.0000 MiB           1       count = 0
    36 134.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.0156 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.0156 MiB   0.0000 MiB           1       came_from = {}
    39 134.0156 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.8906 MiB   1.8750 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.8906 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.8906 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.8906 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.8906 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.8906 MiB   0.0000 MiB        3168       while not open_set.empty():
    49 135.8906 MiB   0.0000 MiB        3168           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.8906 MiB   0.0000 MiB        3168           current = open_set.get()[2]
    55 135.8906 MiB   0.0000 MiB        3168           open_set_hash.remove(current)
    56                                         
    57 135.8906 MiB   0.0000 MiB        3168           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.8906 MiB   0.0000 MiB        3168           if current == end:
    62 135.8906 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.8906 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.8906 MiB   0.0000 MiB       28503           for neighbor in current.neighbors:
    67 135.8906 MiB   0.0000 MiB       25336               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.8906 MiB   0.0000 MiB       12668                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.8906 MiB   0.0000 MiB       12668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.8906 MiB   0.0000 MiB       25336               if temp_g_score < g_score[neighbor]:
    73 135.8906 MiB   0.0000 MiB        3490                   came_from[neighbor] = current
    74 135.8906 MiB   0.0000 MiB        3490                   g_score[neighbor] = temp_g_score
    75 135.8906 MiB   0.0000 MiB        3490                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.8906 MiB   0.0000 MiB        3490                   if neighbor not in open_set_hash:
    77 135.8906 MiB   0.0000 MiB        3490                       count += 1
    78 135.8906 MiB   0.0000 MiB        3490                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.8906 MiB   0.0000 MiB        3490                       open_set_hash.add(neighbor)
    80                                                             
    81 135.8906 MiB   0.0000 MiB        3167           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.8906 MiB   0.0000 MiB        3167           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.0156 MiB 136.0156 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.0156 MiB   0.0000 MiB         257       for row in grid:
    32 136.0156 MiB   0.0000 MiB       65792           for spot in row:
    33 136.0156 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.0156 MiB   0.0000 MiB           1       count = 0
    36 136.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.0156 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.0156 MiB   0.0000 MiB           1       came_from = {}
    39 136.0156 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.0156 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.0156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.0156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.0156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.0156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.0156 MiB   0.0000 MiB         216       while not open_set.empty():
    49 136.0156 MiB   0.0000 MiB         216           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.0156 MiB   0.0000 MiB         216           current = open_set.get()[2]
    55 136.0156 MiB   0.0000 MiB         216           open_set_hash.remove(current)
    56                                         
    57 136.0156 MiB   0.0000 MiB         216           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.0156 MiB   0.0000 MiB         216           if current == end:
    62 136.0156 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.0156 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.0156 MiB   0.0000 MiB        1935           for neighbor in current.neighbors:
    67 136.0156 MiB   0.0000 MiB        1720               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.0156 MiB   0.0000 MiB         860                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.0156 MiB   0.0000 MiB         860                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.0156 MiB   0.0000 MiB        1720               if temp_g_score < g_score[neighbor]:
    73 136.0156 MiB   0.0000 MiB         508                   came_from[neighbor] = current
    74 136.0156 MiB   0.0000 MiB         508                   g_score[neighbor] = temp_g_score
    75 136.0156 MiB   0.0000 MiB         508                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.0156 MiB   0.0000 MiB         508                   if neighbor not in open_set_hash:
    77 136.0156 MiB   0.0000 MiB         508                       count += 1
    78 136.0156 MiB   0.0000 MiB         508                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.0156 MiB   0.0000 MiB         508                       open_set_hash.add(neighbor)
    80                                                             
    81 136.0156 MiB   0.0000 MiB         215           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.0156 MiB   0.0000 MiB         215           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.0156 MiB 136.0156 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.0156 MiB   0.0000 MiB         257       for row in grid:
    32 136.0156 MiB   0.0000 MiB       65792           for spot in row:
    33 136.0156 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.0156 MiB   0.0000 MiB           1       count = 0
    36 136.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.0156 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.0156 MiB   0.0000 MiB           1       came_from = {}
    39 136.0156 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.0156 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.0156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.0156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.0156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.0156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.0156 MiB   0.0000 MiB       10201       while not open_set.empty():
    49 136.0156 MiB   0.0000 MiB       10201           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.0156 MiB   0.0000 MiB       10201           current = open_set.get()[2]
    55 136.0156 MiB   0.0000 MiB       10201           open_set_hash.remove(current)
    56                                         
    57 136.0156 MiB   0.0000 MiB       10201           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.0156 MiB   0.0000 MiB       10201           if current == end:
    62 136.0156 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.0156 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.0156 MiB   0.0000 MiB       91800           for neighbor in current.neighbors:
    67 136.0156 MiB   0.0000 MiB       81600               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.0156 MiB   0.0000 MiB       40800                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.0156 MiB   0.0000 MiB       40800                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.0156 MiB   0.0000 MiB       81600               if temp_g_score < g_score[neighbor]:
    73 136.0156 MiB   0.0000 MiB       10805                   came_from[neighbor] = current
    74 136.0156 MiB   0.0000 MiB       10805                   g_score[neighbor] = temp_g_score
    75 136.0156 MiB   0.0000 MiB       10805                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.0156 MiB   0.0000 MiB       10805                   if neighbor not in open_set_hash:
    77 136.0156 MiB   0.0000 MiB       10805                       count += 1
    78 136.0156 MiB   0.0000 MiB       10805                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.0156 MiB   0.0000 MiB       10805                       open_set_hash.add(neighbor)
    80                                                             
    81 136.0156 MiB   0.0000 MiB       10200           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.0156 MiB   0.0000 MiB       10200           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.0156 MiB 136.0156 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.0156 MiB   0.0000 MiB         257       for row in grid:
    32 136.0156 MiB   0.0000 MiB       65792           for spot in row:
    33 136.0156 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.0156 MiB   0.0000 MiB           1       count = 0
    36 136.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.0156 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.0156 MiB   0.0000 MiB           1       came_from = {}
    39 136.0156 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.0156 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.0156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.0156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.0156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.0156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.0156 MiB   0.0000 MiB          84       while not open_set.empty():
    49 136.0156 MiB   0.0000 MiB          84           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.0156 MiB   0.0000 MiB          84           current = open_set.get()[2]
    55 136.0156 MiB   0.0000 MiB          84           open_set_hash.remove(current)
    56                                         
    57 136.0156 MiB   0.0000 MiB          84           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.0156 MiB   0.0000 MiB          84           if current == end:
    62 136.0156 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.0156 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.0156 MiB   0.0000 MiB         747           for neighbor in current.neighbors:
    67 136.0156 MiB   0.0000 MiB         664               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.0156 MiB   0.0000 MiB         332                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.0156 MiB   0.0000 MiB         332                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.0156 MiB   0.0000 MiB         664               if temp_g_score < g_score[neighbor]:
    73 136.0156 MiB   0.0000 MiB         174                   came_from[neighbor] = current
    74 136.0156 MiB   0.0000 MiB         174                   g_score[neighbor] = temp_g_score
    75 136.0156 MiB   0.0000 MiB         174                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.0156 MiB   0.0000 MiB         174                   if neighbor not in open_set_hash:
    77 136.0156 MiB   0.0000 MiB         174                       count += 1
    78 136.0156 MiB   0.0000 MiB         174                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.0156 MiB   0.0000 MiB         174                       open_set_hash.add(neighbor)
    80                                                             
    81 136.0156 MiB   0.0000 MiB          83           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.0156 MiB   0.0000 MiB          83           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.0156 MiB 136.0156 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.0156 MiB   0.0000 MiB         257       for row in grid:
    32 136.0156 MiB   0.0000 MiB       65792           for spot in row:
    33 136.0156 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.0156 MiB   0.0000 MiB           1       count = 0
    36 136.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.0156 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.0156 MiB   0.0000 MiB           1       came_from = {}
    39 136.0156 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.0156 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.0156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.0156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.0156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.0156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.0156 MiB   0.0000 MiB         684       while not open_set.empty():
    49 136.0156 MiB   0.0000 MiB         684           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.0156 MiB   0.0000 MiB         684           current = open_set.get()[2]
    55 136.0156 MiB   0.0000 MiB         684           open_set_hash.remove(current)
    56                                         
    57 136.0156 MiB   0.0000 MiB         684           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.0156 MiB   0.0000 MiB         684           if current == end:
    62 136.0156 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.0156 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.0156 MiB   0.0000 MiB        6147           for neighbor in current.neighbors:
    67 136.0156 MiB   0.0000 MiB        5464               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.0156 MiB   0.0000 MiB        2732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.0156 MiB   0.0000 MiB        2732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.0156 MiB   0.0000 MiB        5464               if temp_g_score < g_score[neighbor]:
    73 136.0156 MiB   0.0000 MiB        1004                   came_from[neighbor] = current
    74 136.0156 MiB   0.0000 MiB        1004                   g_score[neighbor] = temp_g_score
    75 136.0156 MiB   0.0000 MiB        1004                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.0156 MiB   0.0000 MiB        1004                   if neighbor not in open_set_hash:
    77 136.0156 MiB   0.0000 MiB        1004                       count += 1
    78 136.0156 MiB   0.0000 MiB        1004                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.0156 MiB   0.0000 MiB        1004                       open_set_hash.add(neighbor)
    80                                                             
    81 136.0156 MiB   0.0000 MiB         683           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.0156 MiB   0.0000 MiB         683           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.0156 MiB 136.0156 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.0156 MiB   0.0000 MiB         257       for row in grid:
    32 136.0156 MiB   0.0000 MiB       65792           for spot in row:
    33 136.0156 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.0156 MiB   0.0000 MiB           1       count = 0
    36 136.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.0156 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.0156 MiB   0.0000 MiB           1       came_from = {}
    39 136.0156 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.0156 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.0156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.0156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.0156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.0156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.0156 MiB   0.0000 MiB        4087       while not open_set.empty():
    49 136.0156 MiB   0.0000 MiB        4087           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.0156 MiB   0.0000 MiB        4087           current = open_set.get()[2]
    55 136.0156 MiB   0.0000 MiB        4087           open_set_hash.remove(current)
    56                                         
    57 136.0156 MiB   0.0000 MiB        4087           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.0156 MiB   0.0000 MiB        4087           if current == end:
    62 136.0156 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.0156 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.0156 MiB   0.0000 MiB       36774           for neighbor in current.neighbors:
    67 136.0156 MiB   0.0000 MiB       32688               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.0156 MiB   0.0000 MiB       16344                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.0156 MiB   0.0000 MiB       16344                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.0156 MiB   0.0000 MiB       32688               if temp_g_score < g_score[neighbor]:
    73 136.0156 MiB   0.0000 MiB        4463                   came_from[neighbor] = current
    74 136.0156 MiB   0.0000 MiB        4463                   g_score[neighbor] = temp_g_score
    75 136.0156 MiB   0.0000 MiB        4463                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.0156 MiB   0.0000 MiB        4463                   if neighbor not in open_set_hash:
    77 136.0156 MiB   0.0000 MiB        4463                       count += 1
    78 136.0156 MiB   0.0000 MiB        4463                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.0156 MiB   0.0000 MiB        4463                       open_set_hash.add(neighbor)
    80                                                             
    81 136.0156 MiB   0.0000 MiB        4086           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.0156 MiB   0.0000 MiB        4086           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.0156 MiB 136.0156 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.0156 MiB   0.0000 MiB         257       for row in grid:
    32 136.0156 MiB   0.0000 MiB       65792           for spot in row:
    33 136.0156 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.0156 MiB   0.0000 MiB           1       count = 0
    36 136.0156 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.0156 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.0156 MiB   0.0000 MiB           1       came_from = {}
    39 136.0156 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.0156 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.0156 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.0156 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.0156 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.0156 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.0156 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.0625 MiB   0.0000 MiB         900       while not open_set.empty():
    49 136.0625 MiB   0.0000 MiB         900           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.0625 MiB   0.0000 MiB         900           current = open_set.get()[2]
    55 136.0625 MiB   0.0000 MiB         900           open_set_hash.remove(current)
    56                                         
    57 136.0625 MiB   0.0000 MiB         900           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.0625 MiB   0.0000 MiB         900           if current == end:
    62 136.0625 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.0625 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.0625 MiB   0.0000 MiB        8091           for neighbor in current.neighbors:
    67 136.0625 MiB   0.0000 MiB        7192               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.0625 MiB   0.0000 MiB        3596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.0625 MiB   0.0000 MiB        3596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.0625 MiB   0.0000 MiB        7192               if temp_g_score < g_score[neighbor]:
    73 136.0625 MiB   0.0469 MiB        1222                   came_from[neighbor] = current
    74 136.0625 MiB   0.0000 MiB        1222                   g_score[neighbor] = temp_g_score
    75 136.0625 MiB   0.0000 MiB        1222                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.0625 MiB   0.0000 MiB        1222                   if neighbor not in open_set_hash:
    77 136.0625 MiB   0.0000 MiB        1222                       count += 1
    78 136.0625 MiB   0.0000 MiB        1222                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.0625 MiB   0.0000 MiB        1222                       open_set_hash.add(neighbor)
    80                                                             
    81 136.0625 MiB   0.0000 MiB         899           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.0625 MiB   0.0000 MiB         899           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.0938 MiB 136.0938 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.0938 MiB   0.0000 MiB         257       for row in grid:
    32 136.0938 MiB   0.0000 MiB       65792           for spot in row:
    33 136.0938 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.0938 MiB   0.0000 MiB           1       count = 0
    36 136.0938 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.0938 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.0938 MiB   0.0000 MiB           1       came_from = {}
    39 136.0938 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.0938 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.0938 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.0938 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.0938 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.0938 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.0938 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.0938 MiB   0.0000 MiB        5890       while not open_set.empty():
    49 136.0938 MiB   0.0000 MiB        5890           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.0938 MiB   0.0000 MiB        5890           current = open_set.get()[2]
    55 136.0938 MiB   0.0000 MiB        5890           open_set_hash.remove(current)
    56                                         
    57 136.0938 MiB   0.0000 MiB        5890           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.0938 MiB   0.0000 MiB        5890           if current == end:
    62 136.0938 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.0938 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.0938 MiB   0.0000 MiB       53001           for neighbor in current.neighbors:
    67 136.0938 MiB   0.0000 MiB       47112               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.0938 MiB   0.0000 MiB       23556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.0938 MiB   0.0000 MiB       23556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.0938 MiB   0.0000 MiB       47112               if temp_g_score < g_score[neighbor]:
    73 136.0938 MiB   0.0000 MiB        6392                   came_from[neighbor] = current
    74 136.0938 MiB   0.0000 MiB        6392                   g_score[neighbor] = temp_g_score
    75 136.0938 MiB   0.0000 MiB        6392                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.0938 MiB   0.0000 MiB        6392                   if neighbor not in open_set_hash:
    77 136.0938 MiB   0.0000 MiB        6392                       count += 1
    78 136.0938 MiB   0.0000 MiB        6392                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.0938 MiB   0.0000 MiB        6392                       open_set_hash.add(neighbor)
    80                                                             
    81 136.0938 MiB   0.0000 MiB        5889           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.0938 MiB   0.0000 MiB        5889           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.2500 MiB 136.2500 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.2500 MiB   0.0000 MiB         257       for row in grid:
    32 136.2500 MiB   0.0000 MiB       65792           for spot in row:
    33 136.2500 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.2500 MiB   0.0000 MiB           1       count = 0
    36 136.2500 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.2500 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.2500 MiB   0.0000 MiB           1       came_from = {}
    39 136.2500 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.2500 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.2500 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.2500 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.2500 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.2500 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.2500 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.2500 MiB   0.0000 MiB       14336       while not open_set.empty():
    49 136.2500 MiB   0.0000 MiB       14336           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.2500 MiB   0.0000 MiB       14336           current = open_set.get()[2]
    55 136.2500 MiB   0.0000 MiB       14336           open_set_hash.remove(current)
    56                                         
    57 136.2500 MiB   0.0000 MiB       14336           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.2500 MiB   0.0000 MiB       14336           if current == end:
    62 136.2500 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.2500 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.2500 MiB   0.0000 MiB      129015           for neighbor in current.neighbors:
    67 136.2500 MiB   0.0000 MiB      114680               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.2500 MiB   0.0000 MiB       57340                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.2500 MiB   0.0000 MiB       57340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.2500 MiB   0.0000 MiB      114680               if temp_g_score < g_score[neighbor]:
    73 136.2500 MiB   0.0000 MiB       15070                   came_from[neighbor] = current
    74 136.2500 MiB   0.0000 MiB       15070                   g_score[neighbor] = temp_g_score
    75 136.2500 MiB   0.0000 MiB       15070                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.2500 MiB   0.0000 MiB       15070                   if neighbor not in open_set_hash:
    77 136.2500 MiB   0.0000 MiB       15070                       count += 1
    78 136.2500 MiB   0.0000 MiB       15070                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.2500 MiB   0.0000 MiB       15070                       open_set_hash.add(neighbor)
    80                                                             
    81 136.2500 MiB   0.0000 MiB       14335           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.2500 MiB   0.0000 MiB       14335           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.2656 MiB 136.2656 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.2656 MiB   0.0000 MiB         257       for row in grid:
    32 136.2656 MiB   0.0000 MiB       65792           for spot in row:
    33 136.2656 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.2656 MiB   0.0000 MiB           1       count = 0
    36 136.2656 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.2656 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.2656 MiB   0.0000 MiB           1       came_from = {}
    39 136.2656 MiB -56325.8281 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.9688 MiB  -1.2969 MiB           1       g_score[start] = 0
    41 135.2812 MiB   0.3125 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.2812 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.2812 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.2812 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.2812 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.2812 MiB -199.7500 MiB         567       while not open_set.empty():
    49 135.2812 MiB -199.7500 MiB         567           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.2812 MiB -199.7500 MiB         567           current = open_set.get()[2]
    55 135.2812 MiB -199.7500 MiB         567           open_set_hash.remove(current)
    56                                         
    57 135.2812 MiB -199.7500 MiB         567           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.2812 MiB -199.7500 MiB         567           if current == end:
    62 134.7656 MiB  -0.5156 MiB           1               if draw:
    63                                                         end.make_end()
    64 134.7656 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.2812 MiB -1794.8594 MiB        5094           for neighbor in current.neighbors:
    67 135.2812 MiB -1595.2031 MiB        4528               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.2812 MiB -798.3750 MiB        2264                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.2812 MiB -796.9375 MiB        2264                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.2812 MiB -1595.3125 MiB        4528               if temp_g_score < g_score[neighbor]:
    73 135.2812 MiB -236.7500 MiB         715                   came_from[neighbor] = current
    74 135.2812 MiB -236.8750 MiB         715                   g_score[neighbor] = temp_g_score
    75 135.2812 MiB -236.8750 MiB         715                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.2812 MiB -236.8750 MiB         715                   if neighbor not in open_set_hash:
    77 135.2812 MiB -236.8750 MiB         715                       count += 1
    78 135.2812 MiB -236.8750 MiB         715                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.2812 MiB -236.8750 MiB         715                       open_set_hash.add(neighbor)
    80                                                             
    81 135.2812 MiB -199.7500 MiB         566           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.2812 MiB -199.7500 MiB         566           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 134.7656 MiB 134.7656 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 134.7656 MiB   0.0000 MiB         257       for row in grid:
    32 134.7656 MiB   0.0000 MiB       65792           for spot in row:
    33 134.7656 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 134.7656 MiB   0.0000 MiB           1       count = 0
    36 134.7656 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 134.7656 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 134.7656 MiB   0.0000 MiB           1       came_from = {}
    39 134.9531 MiB   0.1875 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 134.9531 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.1562 MiB   0.2031 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.1562 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.1562 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.1562 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.1562 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.1562 MiB   0.0000 MiB        5846       while not open_set.empty():
    49 135.1562 MiB   0.0000 MiB        5846           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.1562 MiB   0.0000 MiB        5846           current = open_set.get()[2]
    55 135.1562 MiB   0.0000 MiB        5846           open_set_hash.remove(current)
    56                                         
    57 135.1562 MiB   0.0000 MiB        5846           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.1562 MiB   0.0000 MiB        5846           if current == end:
    62 135.1562 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.1562 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.1562 MiB   0.0000 MiB       52605           for neighbor in current.neighbors:
    67 135.1562 MiB   0.0000 MiB       46760               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.1562 MiB   0.0000 MiB       23380                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.1562 MiB   0.0000 MiB       23380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.1562 MiB   0.0000 MiB       46760               if temp_g_score < g_score[neighbor]:
    73 135.1562 MiB   0.0000 MiB        6308                   came_from[neighbor] = current
    74 135.1562 MiB   0.0000 MiB        6308                   g_score[neighbor] = temp_g_score
    75 135.1562 MiB   0.0000 MiB        6308                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.1562 MiB   0.0000 MiB        6308                   if neighbor not in open_set_hash:
    77 135.1562 MiB   0.0000 MiB        6308                       count += 1
    78 135.1562 MiB   0.0000 MiB        6308                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.1562 MiB   0.0000 MiB        6308                       open_set_hash.add(neighbor)
    80                                                             
    81 135.1562 MiB   0.0000 MiB        5845           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.1562 MiB   0.0000 MiB        5845           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.1562 MiB 135.1562 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.1562 MiB   0.0000 MiB         257       for row in grid:
    32 135.1562 MiB   0.0000 MiB       65792           for spot in row:
    33 135.1562 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.1562 MiB   0.0000 MiB           1       count = 0
    36 135.1562 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.1562 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.1562 MiB   0.0000 MiB           1       came_from = {}
    39 135.4531 MiB   0.2969 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.4531 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.4531 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.4531 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.4531 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.4531 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.4531 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.4531 MiB -53.5938 MiB        2001       while not open_set.empty():
    49 135.4531 MiB -53.5938 MiB        2001           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.4531 MiB -53.5938 MiB        2001           current = open_set.get()[2]
    55 135.4531 MiB -53.5938 MiB        2001           open_set_hash.remove(current)
    56                                         
    57 135.4531 MiB -53.5938 MiB        2001           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.4531 MiB -53.5938 MiB        2001           if current == end:
    62 135.4219 MiB  -0.0312 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.4219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.4531 MiB -482.2812 MiB       18000           for neighbor in current.neighbors:
    67 135.4531 MiB -428.7031 MiB       16000               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.4531 MiB -214.3750 MiB        8000                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.4531 MiB -214.3438 MiB        8000                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.4531 MiB -428.7188 MiB       16000               if temp_g_score < g_score[neighbor]:
    73 135.4531 MiB -58.4688 MiB        2253                   came_from[neighbor] = current
    74 135.4531 MiB -58.4688 MiB        2253                   g_score[neighbor] = temp_g_score
    75 135.4531 MiB -58.4688 MiB        2253                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.4531 MiB -58.4688 MiB        2253                   if neighbor not in open_set_hash:
    77 135.4531 MiB -58.4688 MiB        2253                       count += 1
    78 135.4531 MiB -58.4688 MiB        2253                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.4531 MiB -58.4688 MiB        2253                       open_set_hash.add(neighbor)
    80                                                             
    81 135.4531 MiB -53.5938 MiB        2000           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.4531 MiB -53.5938 MiB        2000           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.4219 MiB 135.4219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.4219 MiB   0.0000 MiB         257       for row in grid:
    32 135.4219 MiB   0.0000 MiB       65792           for spot in row:
    33 135.4219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.4219 MiB   0.0000 MiB           1       count = 0
    36 135.4219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.4219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.4219 MiB   0.0000 MiB           1       came_from = {}
    39 135.4531 MiB   0.0312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.4531 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.4688 MiB   0.0156 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.4688 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.4688 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.4688 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.4688 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.4688 MiB   0.0000 MiB        7396       while not open_set.empty():
    49 135.4688 MiB   0.0000 MiB        7396           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.4688 MiB   0.0000 MiB        7396           current = open_set.get()[2]
    55 135.4688 MiB   0.0000 MiB        7396           open_set_hash.remove(current)
    56                                         
    57 135.4688 MiB   0.0000 MiB        7396           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.4688 MiB   0.0000 MiB        7396           if current == end:
    62 135.4688 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.4688 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.4688 MiB   0.0000 MiB       66555           for neighbor in current.neighbors:
    67 135.4688 MiB   0.0000 MiB       59160               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.4688 MiB   0.0000 MiB       29580                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.4688 MiB   0.0000 MiB       29580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.4688 MiB   0.0000 MiB       59160               if temp_g_score < g_score[neighbor]:
    73 135.4688 MiB   0.0000 MiB        7910                   came_from[neighbor] = current
    74 135.4688 MiB   0.0000 MiB        7910                   g_score[neighbor] = temp_g_score
    75 135.4688 MiB   0.0000 MiB        7910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.4688 MiB   0.0000 MiB        7910                   if neighbor not in open_set_hash:
    77 135.4688 MiB   0.0000 MiB        7910                       count += 1
    78 135.4688 MiB   0.0000 MiB        7910                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.4688 MiB   0.0000 MiB        7910                       open_set_hash.add(neighbor)
    80                                                             
    81 135.4688 MiB   0.0000 MiB        7395           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.4688 MiB   0.0000 MiB        7395           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.4688 MiB 135.4688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.4688 MiB   0.0000 MiB         257       for row in grid:
    32 135.4688 MiB   0.0000 MiB       65792           for spot in row:
    33 135.4688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.4688 MiB   0.0000 MiB           1       count = 0
    36 135.4688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.4688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.4688 MiB   0.0000 MiB           1       came_from = {}
    39 135.4688 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 135.4688 MiB   0.0000 MiB           1       g_score[start] = 0
    41 135.4688 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 135.4688 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 135.4688 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 135.4688 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 135.4688 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 135.4688 MiB   0.0000 MiB        3230       while not open_set.empty():
    49 135.4688 MiB   0.0000 MiB        3230           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 135.4688 MiB   0.0000 MiB        3230           current = open_set.get()[2]
    55 135.4688 MiB   0.0000 MiB        3230           open_set_hash.remove(current)
    56                                         
    57 135.4688 MiB   0.0000 MiB        3230           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 135.4688 MiB   0.0000 MiB        3230           if current == end:
    62 135.4688 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 135.4688 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 135.4688 MiB   0.0000 MiB       29061           for neighbor in current.neighbors:
    67 135.4688 MiB   0.0000 MiB       25832               if current.row != neighbor.row and current.col != neighbor.col:
    68 135.4688 MiB   0.0000 MiB       12916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 135.4688 MiB   0.0000 MiB       12916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 135.4688 MiB   0.0000 MiB       25832               if temp_g_score < g_score[neighbor]:
    73 135.4688 MiB   0.0000 MiB        3550                   came_from[neighbor] = current
    74 135.4688 MiB   0.0000 MiB        3550                   g_score[neighbor] = temp_g_score
    75 135.4688 MiB   0.0000 MiB        3550                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 135.4688 MiB   0.0000 MiB        3550                   if neighbor not in open_set_hash:
    77 135.4688 MiB   0.0000 MiB        3550                       count += 1
    78 135.4688 MiB   0.0000 MiB        3550                       open_set.put((f_score[neighbor], count, neighbor))
    79 135.4688 MiB   0.0000 MiB        3550                       open_set_hash.add(neighbor)
    80                                                             
    81 135.4688 MiB   0.0000 MiB        3229           if draw is not None:
    82                                                     draw()
    83                                         
    84 135.4688 MiB   0.0000 MiB        3229           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 135.4688 MiB 135.4688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 135.4688 MiB   0.0000 MiB         257       for row in grid:
    32 135.4688 MiB   0.0000 MiB       65792           for spot in row:
    33 135.4688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 135.4688 MiB   0.0000 MiB           1       count = 0
    36 135.4688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 135.4688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 135.4688 MiB   0.0000 MiB           1       came_from = {}
    39 136.5469 MiB   1.0781 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.5469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 136.7344 MiB   0.1875 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 136.7344 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 136.7344 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 136.7344 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 136.7344 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 136.7344 MiB   0.0000 MiB         306       while not open_set.empty():
    49 136.7344 MiB   0.0000 MiB         306           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 136.7344 MiB   0.0000 MiB         306           current = open_set.get()[2]
    55 136.7344 MiB   0.0000 MiB         306           open_set_hash.remove(current)
    56                                         
    57 136.7344 MiB   0.0000 MiB         306           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 136.7344 MiB   0.0000 MiB         306           if current == end:
    62 136.7344 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 136.7344 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 136.7344 MiB   0.0000 MiB        2745           for neighbor in current.neighbors:
    67 136.7344 MiB   0.0000 MiB        2440               if current.row != neighbor.row and current.col != neighbor.col:
    68 136.7344 MiB   0.0000 MiB        1220                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 136.7344 MiB   0.0000 MiB        1220                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 136.7344 MiB   0.0000 MiB        2440               if temp_g_score < g_score[neighbor]:
    73 136.7344 MiB   0.0000 MiB         408                   came_from[neighbor] = current
    74 136.7344 MiB   0.0000 MiB         408                   g_score[neighbor] = temp_g_score
    75 136.7344 MiB   0.0000 MiB         408                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 136.7344 MiB   0.0000 MiB         408                   if neighbor not in open_set_hash:
    77 136.7344 MiB   0.0000 MiB         408                       count += 1
    78 136.7344 MiB   0.0000 MiB         408                       open_set.put((f_score[neighbor], count, neighbor))
    79 136.7344 MiB   0.0000 MiB         408                       open_set_hash.add(neighbor)
    80                                                             
    81 136.7344 MiB   0.0000 MiB         305           if draw is not None:
    82                                                     draw()
    83                                         
    84 136.7344 MiB   0.0000 MiB         305           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 136.7344 MiB 136.7344 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 136.7344 MiB   0.0000 MiB         257       for row in grid:
    32 136.7344 MiB   0.0000 MiB       65792           for spot in row:
    33 136.7344 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 136.7344 MiB   0.0000 MiB           1       count = 0
    36 136.7344 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 136.7344 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 136.7344 MiB   0.0000 MiB           1       came_from = {}
    39 136.7344 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 136.7344 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.4844 MiB   0.7500 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.4844 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.4844 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.4844 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.4844 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.4844 MiB   0.0000 MiB        7776       while not open_set.empty():
    49 137.4844 MiB   0.0000 MiB        7776           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.4844 MiB   0.0000 MiB        7776           current = open_set.get()[2]
    55 137.4844 MiB   0.0000 MiB        7776           open_set_hash.remove(current)
    56                                         
    57 137.4844 MiB   0.0000 MiB        7776           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.4844 MiB   0.0000 MiB        7776           if current == end:
    62 137.4844 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.4844 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.4844 MiB   0.0000 MiB       69975           for neighbor in current.neighbors:
    67 137.4844 MiB   0.0000 MiB       62200               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.4844 MiB   0.0000 MiB       31100                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.4844 MiB   0.0000 MiB       31100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.4844 MiB   0.0000 MiB       62200               if temp_g_score < g_score[neighbor]:
    73 137.4844 MiB   0.0000 MiB        8278                   came_from[neighbor] = current
    74 137.4844 MiB   0.0000 MiB        8278                   g_score[neighbor] = temp_g_score
    75 137.4844 MiB   0.0000 MiB        8278                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.4844 MiB   0.0000 MiB        8278                   if neighbor not in open_set_hash:
    77 137.4844 MiB   0.0000 MiB        8278                       count += 1
    78 137.4844 MiB   0.0000 MiB        8278                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.4844 MiB   0.0000 MiB        8278                       open_set_hash.add(neighbor)
    80                                                             
    81 137.4844 MiB   0.0000 MiB        7775           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.4844 MiB   0.0000 MiB        7775           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.4844 MiB 137.4844 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.4844 MiB   0.0000 MiB         257       for row in grid:
    32 137.4844 MiB   0.0000 MiB       65792           for spot in row:
    33 137.4844 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.4844 MiB   0.0000 MiB           1       count = 0
    36 137.4844 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.4844 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.4844 MiB   0.0000 MiB           1       came_from = {}
    39 137.5000 MiB   0.0156 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5000 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5000 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5000 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5000 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5000 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5000 MiB   0.0000 MiB        1740       while not open_set.empty():
    49 137.5000 MiB   0.0000 MiB        1740           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5000 MiB   0.0000 MiB        1740           current = open_set.get()[2]
    55 137.5000 MiB   0.0000 MiB        1740           open_set_hash.remove(current)
    56                                         
    57 137.5000 MiB   0.0000 MiB        1740           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5000 MiB   0.0000 MiB        1740           if current == end:
    62 137.5000 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5000 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5000 MiB   0.0000 MiB       15651           for neighbor in current.neighbors:
    67 137.5000 MiB   0.0000 MiB       13912               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5000 MiB   0.0000 MiB        6956                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5000 MiB   0.0000 MiB        6956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5000 MiB   0.0000 MiB       13912               if temp_g_score < g_score[neighbor]:
    73 137.5000 MiB   0.0000 MiB        2076                   came_from[neighbor] = current
    74 137.5000 MiB   0.0000 MiB        2076                   g_score[neighbor] = temp_g_score
    75 137.5000 MiB   0.0000 MiB        2076                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5000 MiB   0.0000 MiB        2076                   if neighbor not in open_set_hash:
    77 137.5000 MiB   0.0000 MiB        2076                       count += 1
    78 137.5000 MiB   0.0000 MiB        2076                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5000 MiB   0.0000 MiB        2076                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5000 MiB   0.0000 MiB        1739           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5000 MiB   0.0000 MiB        1739           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5000 MiB 137.5000 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5000 MiB   0.0000 MiB         257       for row in grid:
    32 137.5000 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5000 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5000 MiB   0.0000 MiB           1       count = 0
    36 137.5000 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5000 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5000 MiB   0.0000 MiB           1       came_from = {}
    39 137.5000 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5000 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5469 MiB   0.0469 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5469 MiB   0.0000 MiB         790       while not open_set.empty():
    49 137.5469 MiB   0.0000 MiB         790           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5469 MiB   0.0000 MiB         790           current = open_set.get()[2]
    55 137.5469 MiB   0.0000 MiB         790           open_set_hash.remove(current)
    56                                         
    57 137.5469 MiB   0.0000 MiB         790           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5469 MiB   0.0000 MiB         790           if current == end:
    62 137.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5469 MiB   0.0000 MiB        7101           for neighbor in current.neighbors:
    67 137.5469 MiB   0.0000 MiB        6312               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5469 MiB   0.0000 MiB        3156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5469 MiB   0.0000 MiB        3156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5469 MiB   0.0000 MiB        6312               if temp_g_score < g_score[neighbor]:
    73 137.5469 MiB   0.0000 MiB        1124                   came_from[neighbor] = current
    74 137.5469 MiB   0.0000 MiB        1124                   g_score[neighbor] = temp_g_score
    75 137.5469 MiB   0.0000 MiB        1124                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5469 MiB   0.0000 MiB        1124                   if neighbor not in open_set_hash:
    77 137.5469 MiB   0.0000 MiB        1124                       count += 1
    78 137.5469 MiB   0.0000 MiB        1124                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5469 MiB   0.0000 MiB        1124                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5469 MiB   0.0000 MiB         789           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5469 MiB   0.0000 MiB         789           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5469 MiB 137.5469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5469 MiB   0.0000 MiB         257       for row in grid:
    32 137.5469 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5469 MiB   0.0000 MiB           1       count = 0
    36 137.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5469 MiB   0.0000 MiB           1       came_from = {}
    39 137.5469 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5469 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5469 MiB   0.0000 MiB          24       while not open_set.empty():
    49 137.5469 MiB   0.0000 MiB          24           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5469 MiB   0.0000 MiB          24           current = open_set.get()[2]
    55 137.5469 MiB   0.0000 MiB          24           open_set_hash.remove(current)
    56                                         
    57 137.5469 MiB   0.0000 MiB          24           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5469 MiB   0.0000 MiB          24           if current == end:
    62 137.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5469 MiB   0.0000 MiB         207           for neighbor in current.neighbors:
    67 137.5469 MiB   0.0000 MiB         184               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5469 MiB   0.0000 MiB          92                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5469 MiB   0.0000 MiB          92                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5469 MiB   0.0000 MiB         184               if temp_g_score < g_score[neighbor]:
    73 137.5469 MiB   0.0000 MiB          74                   came_from[neighbor] = current
    74 137.5469 MiB   0.0000 MiB          74                   g_score[neighbor] = temp_g_score
    75 137.5469 MiB   0.0000 MiB          74                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5469 MiB   0.0000 MiB          74                   if neighbor not in open_set_hash:
    77 137.5469 MiB   0.0000 MiB          74                       count += 1
    78 137.5469 MiB   0.0000 MiB          74                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5469 MiB   0.0000 MiB          74                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5469 MiB   0.0000 MiB          23           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5469 MiB   0.0000 MiB          23           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5469 MiB 137.5469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5469 MiB   0.0000 MiB         257       for row in grid:
    32 137.5469 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5469 MiB   0.0000 MiB           1       count = 0
    36 137.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5469 MiB   0.0000 MiB           1       came_from = {}
    39 137.5469 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5469 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5469 MiB   0.0000 MiB        6096       while not open_set.empty():
    49 137.5469 MiB   0.0000 MiB        6096           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5469 MiB   0.0000 MiB        6096           current = open_set.get()[2]
    55 137.5469 MiB   0.0000 MiB        6096           open_set_hash.remove(current)
    56                                         
    57 137.5469 MiB   0.0000 MiB        6096           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5469 MiB   0.0000 MiB        6096           if current == end:
    62 137.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5469 MiB   0.0000 MiB       54855           for neighbor in current.neighbors:
    67 137.5469 MiB   0.0000 MiB       48760               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5469 MiB   0.0000 MiB       24380                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5469 MiB   0.0000 MiB       24380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5469 MiB   0.0000 MiB       48760               if temp_g_score < g_score[neighbor]:
    73 137.5469 MiB   0.0000 MiB        6540                   came_from[neighbor] = current
    74 137.5469 MiB   0.0000 MiB        6540                   g_score[neighbor] = temp_g_score
    75 137.5469 MiB   0.0000 MiB        6540                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5469 MiB   0.0000 MiB        6540                   if neighbor not in open_set_hash:
    77 137.5469 MiB   0.0000 MiB        6540                       count += 1
    78 137.5469 MiB   0.0000 MiB        6540                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5469 MiB   0.0000 MiB        6540                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5469 MiB   0.0000 MiB        6095           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5469 MiB   0.0000 MiB        6095           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5469 MiB 137.5469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5469 MiB   0.0000 MiB         257       for row in grid:
    32 137.5469 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5469 MiB   0.0000 MiB           1       count = 0
    36 137.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5469 MiB   0.0000 MiB           1       came_from = {}
    39 137.5469 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5469 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5469 MiB   0.0000 MiB        6664       while not open_set.empty():
    49 137.5469 MiB   0.0000 MiB        6664           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5469 MiB   0.0000 MiB        6664           current = open_set.get()[2]
    55 137.5469 MiB   0.0000 MiB        6664           open_set_hash.remove(current)
    56                                         
    57 137.5469 MiB   0.0000 MiB        6664           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5469 MiB   0.0000 MiB        6664           if current == end:
    62 137.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5469 MiB   0.0000 MiB       59967           for neighbor in current.neighbors:
    67 137.5469 MiB   0.0000 MiB       53304               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5469 MiB   0.0000 MiB       26652                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5469 MiB   0.0000 MiB       26652                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5469 MiB   0.0000 MiB       53304               if temp_g_score < g_score[neighbor]:
    73 137.5469 MiB   0.0000 MiB        7130                   came_from[neighbor] = current
    74 137.5469 MiB   0.0000 MiB        7130                   g_score[neighbor] = temp_g_score
    75 137.5469 MiB   0.0000 MiB        7130                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5469 MiB   0.0000 MiB        7130                   if neighbor not in open_set_hash:
    77 137.5469 MiB   0.0000 MiB        7130                       count += 1
    78 137.5469 MiB   0.0000 MiB        7130                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5469 MiB   0.0000 MiB        7130                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5469 MiB   0.0000 MiB        6663           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5469 MiB   0.0000 MiB        6663           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5469 MiB 137.5469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5469 MiB   0.0000 MiB         257       for row in grid:
    32 137.5469 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5469 MiB   0.0000 MiB           1       count = 0
    36 137.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5469 MiB   0.0000 MiB           1       came_from = {}
    39 137.5469 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5469 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5469 MiB   0.0000 MiB        2356       while not open_set.empty():
    49 137.5469 MiB   0.0000 MiB        2356           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5469 MiB   0.0000 MiB        2356           current = open_set.get()[2]
    55 137.5469 MiB   0.0000 MiB        2356           open_set_hash.remove(current)
    56                                         
    57 137.5469 MiB   0.0000 MiB        2356           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5469 MiB   0.0000 MiB        2356           if current == end:
    62 137.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5469 MiB   0.0000 MiB       21195           for neighbor in current.neighbors:
    67 137.5469 MiB   0.0000 MiB       18840               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5469 MiB   0.0000 MiB        9420                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5469 MiB   0.0000 MiB        9420                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5469 MiB   0.0000 MiB       18840               if temp_g_score < g_score[neighbor]:
    73 137.5469 MiB   0.0000 MiB        2720                   came_from[neighbor] = current
    74 137.5469 MiB   0.0000 MiB        2720                   g_score[neighbor] = temp_g_score
    75 137.5469 MiB   0.0000 MiB        2720                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5469 MiB   0.0000 MiB        2720                   if neighbor not in open_set_hash:
    77 137.5469 MiB   0.0000 MiB        2720                       count += 1
    78 137.5469 MiB   0.0000 MiB        2720                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5469 MiB   0.0000 MiB        2720                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5469 MiB   0.0000 MiB        2355           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5469 MiB   0.0000 MiB        2355           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5469 MiB 137.5469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5469 MiB   0.0000 MiB         257       for row in grid:
    32 137.5469 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5469 MiB   0.0000 MiB           1       count = 0
    36 137.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5469 MiB   0.0000 MiB           1       came_from = {}
    39 137.5469 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5469 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5469 MiB   0.0000 MiB        5256       while not open_set.empty():
    49 137.5469 MiB   0.0000 MiB        5256           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5469 MiB   0.0000 MiB        5256           current = open_set.get()[2]
    55 137.5469 MiB   0.0000 MiB        5256           open_set_hash.remove(current)
    56                                         
    57 137.5469 MiB   0.0000 MiB        5256           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5469 MiB   0.0000 MiB        5256           if current == end:
    62 137.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5469 MiB   0.0000 MiB       47295           for neighbor in current.neighbors:
    67 137.5469 MiB   0.0000 MiB       42040               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5469 MiB   0.0000 MiB       21020                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5469 MiB   0.0000 MiB       21020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5469 MiB   0.0000 MiB       42040               if temp_g_score < g_score[neighbor]:
    73 137.5469 MiB   0.0000 MiB        5910                   came_from[neighbor] = current
    74 137.5469 MiB   0.0000 MiB        5910                   g_score[neighbor] = temp_g_score
    75 137.5469 MiB   0.0000 MiB        5910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5469 MiB   0.0000 MiB        5910                   if neighbor not in open_set_hash:
    77 137.5469 MiB   0.0000 MiB        5910                       count += 1
    78 137.5469 MiB   0.0000 MiB        5910                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5469 MiB   0.0000 MiB        5910                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5469 MiB   0.0000 MiB        5255           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5469 MiB   0.0000 MiB        5255           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5469 MiB 137.5469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5469 MiB   0.0000 MiB         257       for row in grid:
    32 137.5469 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5469 MiB   0.0000 MiB           1       count = 0
    36 137.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5469 MiB   0.0000 MiB           1       came_from = {}
    39 137.5469 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5469 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5469 MiB   0.0000 MiB        1372       while not open_set.empty():
    49 137.5469 MiB   0.0000 MiB        1372           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5469 MiB   0.0000 MiB        1372           current = open_set.get()[2]
    55 137.5469 MiB   0.0000 MiB        1372           open_set_hash.remove(current)
    56                                         
    57 137.5469 MiB   0.0000 MiB        1372           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5469 MiB   0.0000 MiB        1372           if current == end:
    62 137.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5469 MiB   0.0000 MiB       12192           for neighbor in current.neighbors:
    67 137.5469 MiB   0.0000 MiB       10821               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5469 MiB   0.0000 MiB        5386                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5469 MiB   0.0000 MiB        5435                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5469 MiB   0.0000 MiB       10821               if temp_g_score < g_score[neighbor]:
    73 137.5469 MiB   0.0000 MiB        1529                   came_from[neighbor] = current
    74 137.5469 MiB   0.0000 MiB        1529                   g_score[neighbor] = temp_g_score
    75 137.5469 MiB   0.0000 MiB        1529                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5469 MiB   0.0000 MiB        1529                   if neighbor not in open_set_hash:
    77 137.5469 MiB   0.0000 MiB        1529                       count += 1
    78 137.5469 MiB   0.0000 MiB        1529                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5469 MiB   0.0000 MiB        1529                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5469 MiB   0.0000 MiB        1371           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5469 MiB   0.0000 MiB        1371           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5469 MiB 137.5469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5469 MiB   0.0000 MiB         257       for row in grid:
    32 137.5469 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5469 MiB   0.0000 MiB           1       count = 0
    36 137.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5469 MiB   0.0000 MiB           1       came_from = {}
    39 137.5469 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5469 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5469 MiB   0.0000 MiB         722       while not open_set.empty():
    49 137.5469 MiB   0.0000 MiB         722           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5469 MiB   0.0000 MiB         722           current = open_set.get()[2]
    55 137.5469 MiB   0.0000 MiB         722           open_set_hash.remove(current)
    56                                         
    57 137.5469 MiB   0.0000 MiB         722           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5469 MiB   0.0000 MiB         722           if current == end:
    62 137.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5469 MiB   0.0000 MiB        6489           for neighbor in current.neighbors:
    67 137.5469 MiB   0.0000 MiB        5768               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5469 MiB   0.0000 MiB        2884                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5469 MiB   0.0000 MiB        2884                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5469 MiB   0.0000 MiB        5768               if temp_g_score < g_score[neighbor]:
    73 137.5469 MiB   0.0000 MiB         872                   came_from[neighbor] = current
    74 137.5469 MiB   0.0000 MiB         872                   g_score[neighbor] = temp_g_score
    75 137.5469 MiB   0.0000 MiB         872                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5469 MiB   0.0000 MiB         872                   if neighbor not in open_set_hash:
    77 137.5469 MiB   0.0000 MiB         872                       count += 1
    78 137.5469 MiB   0.0000 MiB         872                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5469 MiB   0.0000 MiB         872                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5469 MiB   0.0000 MiB         721           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5469 MiB   0.0000 MiB         721           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5469 MiB 137.5469 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5469 MiB   0.0000 MiB         257       for row in grid:
    32 137.5469 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5469 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5469 MiB   0.0000 MiB           1       count = 0
    36 137.5469 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5469 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5469 MiB   0.0000 MiB           1       came_from = {}
    39 137.5469 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5469 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.5469 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.5469 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.5469 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.5469 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.5469 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.5469 MiB   0.0000 MiB         282       while not open_set.empty():
    49 137.5469 MiB   0.0000 MiB         282           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.5469 MiB   0.0000 MiB         282           current = open_set.get()[2]
    55 137.5469 MiB   0.0000 MiB         282           open_set_hash.remove(current)
    56                                         
    57 137.5469 MiB   0.0000 MiB         282           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.5469 MiB   0.0000 MiB         282           if current == end:
    62 137.5469 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.5469 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.5469 MiB   0.0000 MiB        2529           for neighbor in current.neighbors:
    67 137.5469 MiB   0.0000 MiB        2248               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.5469 MiB   0.0000 MiB        1124                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.5469 MiB   0.0000 MiB        1124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.5469 MiB   0.0000 MiB        2248               if temp_g_score < g_score[neighbor]:
    73 137.5469 MiB   0.0000 MiB         570                   came_from[neighbor] = current
    74 137.5469 MiB   0.0000 MiB         570                   g_score[neighbor] = temp_g_score
    75 137.5469 MiB   0.0000 MiB         570                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.5469 MiB   0.0000 MiB         570                   if neighbor not in open_set_hash:
    77 137.5469 MiB   0.0000 MiB         570                       count += 1
    78 137.5469 MiB   0.0000 MiB         570                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.5469 MiB   0.0000 MiB         570                       open_set_hash.add(neighbor)
    80                                                             
    81 137.5469 MiB   0.0000 MiB         281           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.5469 MiB   0.0000 MiB         281           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.5625 MiB 137.5625 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.5625 MiB   0.0000 MiB         257       for row in grid:
    32 137.5625 MiB   0.0000 MiB       65792           for spot in row:
    33 137.5625 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.5625 MiB   0.0000 MiB           1       count = 0
    36 137.5625 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.5625 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.5625 MiB   0.0000 MiB           1       came_from = {}
    39 137.5625 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.5625 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.8750 MiB   0.3125 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.8750 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.8750 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.8750 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.8750 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.8750 MiB   0.0000 MiB        8160       while not open_set.empty():
    49 137.8750 MiB   0.0000 MiB        8160           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.8750 MiB   0.0000 MiB        8160           current = open_set.get()[2]
    55 137.8750 MiB   0.0000 MiB        8160           open_set_hash.remove(current)
    56                                         
    57 137.8750 MiB   0.0000 MiB        8160           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.8750 MiB   0.0000 MiB        8160           if current == end:
    62 137.8750 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.8750 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.8750 MiB   0.0000 MiB       73431           for neighbor in current.neighbors:
    67 137.8750 MiB   0.0000 MiB       65272               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.8750 MiB   0.0000 MiB       32636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.8750 MiB   0.0000 MiB       32636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.8750 MiB   0.0000 MiB       65272               if temp_g_score < g_score[neighbor]:
    73 137.8750 MiB   0.0000 MiB        8726                   came_from[neighbor] = current
    74 137.8750 MiB   0.0000 MiB        8726                   g_score[neighbor] = temp_g_score
    75 137.8750 MiB   0.0000 MiB        8726                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.8750 MiB   0.0000 MiB        8726                   if neighbor not in open_set_hash:
    77 137.8750 MiB   0.0000 MiB        8726                       count += 1
    78 137.8750 MiB   0.0000 MiB        8726                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.8750 MiB   0.0000 MiB        8726                       open_set_hash.add(neighbor)
    80                                                             
    81 137.8750 MiB   0.0000 MiB        8159           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.8750 MiB   0.0000 MiB        8159           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.8750 MiB 137.8750 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.8750 MiB   0.0000 MiB         257       for row in grid:
    32 137.8750 MiB   0.0000 MiB       65792           for spot in row:
    33 137.8750 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.8750 MiB   0.0000 MiB           1       count = 0
    36 137.8750 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.8750 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.8750 MiB   0.0000 MiB           1       came_from = {}
    39 137.9219 MiB   0.0469 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9219 MiB   0.0000 MiB         574       while not open_set.empty():
    49 137.9219 MiB   0.0000 MiB         574           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9219 MiB   0.0000 MiB         574           current = open_set.get()[2]
    55 137.9219 MiB   0.0000 MiB         574           open_set_hash.remove(current)
    56                                         
    57 137.9219 MiB   0.0000 MiB         574           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9219 MiB   0.0000 MiB         574           if current == end:
    62 137.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9219 MiB   0.0000 MiB        5157           for neighbor in current.neighbors:
    67 137.9219 MiB   0.0000 MiB        4584               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9219 MiB   0.0000 MiB        2292                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9219 MiB   0.0000 MiB        2292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9219 MiB   0.0000 MiB        4584               if temp_g_score < g_score[neighbor]:
    73 137.9219 MiB   0.0000 MiB         764                   came_from[neighbor] = current
    74 137.9219 MiB   0.0000 MiB         764                   g_score[neighbor] = temp_g_score
    75 137.9219 MiB   0.0000 MiB         764                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9219 MiB   0.0000 MiB         764                   if neighbor not in open_set_hash:
    77 137.9219 MiB   0.0000 MiB         764                       count += 1
    78 137.9219 MiB   0.0000 MiB         764                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9219 MiB   0.0000 MiB         764                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9219 MiB   0.0000 MiB         573           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9219 MiB   0.0000 MiB         573           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9219 MiB 137.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9219 MiB   0.0000 MiB         257       for row in grid:
    32 137.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9219 MiB   0.0000 MiB           1       count = 0
    36 137.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9219 MiB   0.0000 MiB           1       came_from = {}
    39 137.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9219 MiB   0.0000 MiB           6       while not open_set.empty():
    49 137.9219 MiB   0.0000 MiB           6           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9219 MiB   0.0000 MiB           6           current = open_set.get()[2]
    55 137.9219 MiB   0.0000 MiB           6           open_set_hash.remove(current)
    56                                         
    57 137.9219 MiB   0.0000 MiB           6           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9219 MiB   0.0000 MiB           6           if current == end:
    62 137.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9219 MiB   0.0000 MiB          45           for neighbor in current.neighbors:
    67 137.9219 MiB   0.0000 MiB          40               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9219 MiB   0.0000 MiB          20                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9219 MiB   0.0000 MiB          20                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9219 MiB   0.0000 MiB          40               if temp_g_score < g_score[neighbor]:
    73 137.9219 MiB   0.0000 MiB          18                   came_from[neighbor] = current
    74 137.9219 MiB   0.0000 MiB          18                   g_score[neighbor] = temp_g_score
    75 137.9219 MiB   0.0000 MiB          18                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9219 MiB   0.0000 MiB          18                   if neighbor not in open_set_hash:
    77 137.9219 MiB   0.0000 MiB          18                       count += 1
    78 137.9219 MiB   0.0000 MiB          18                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9219 MiB   0.0000 MiB          18                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9219 MiB   0.0000 MiB           5           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9219 MiB   0.0000 MiB           5           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9219 MiB 137.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9219 MiB   0.0000 MiB         257       for row in grid:
    32 137.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9219 MiB   0.0000 MiB           1       count = 0
    36 137.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9219 MiB   0.0000 MiB           1       came_from = {}
    39 137.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9219 MiB   0.0000 MiB        1720       while not open_set.empty():
    49 137.9219 MiB   0.0000 MiB        1720           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9219 MiB   0.0000 MiB        1720           current = open_set.get()[2]
    55 137.9219 MiB   0.0000 MiB        1720           open_set_hash.remove(current)
    56                                         
    57 137.9219 MiB   0.0000 MiB        1720           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9219 MiB   0.0000 MiB        1720           if current == end:
    62 137.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9219 MiB   0.0000 MiB       15471           for neighbor in current.neighbors:
    67 137.9219 MiB   0.0000 MiB       13752               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9219 MiB   0.0000 MiB        6876                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9219 MiB   0.0000 MiB        6876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9219 MiB   0.0000 MiB       13752               if temp_g_score < g_score[neighbor]:
    73 137.9219 MiB   0.0000 MiB        2102                   came_from[neighbor] = current
    74 137.9219 MiB   0.0000 MiB        2102                   g_score[neighbor] = temp_g_score
    75 137.9219 MiB   0.0000 MiB        2102                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9219 MiB   0.0000 MiB        2102                   if neighbor not in open_set_hash:
    77 137.9219 MiB   0.0000 MiB        2102                       count += 1
    78 137.9219 MiB   0.0000 MiB        2102                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9219 MiB   0.0000 MiB        2102                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9219 MiB   0.0000 MiB        1719           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9219 MiB   0.0000 MiB        1719           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9219 MiB 137.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9219 MiB   0.0000 MiB         257       for row in grid:
    32 137.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9219 MiB   0.0000 MiB           1       count = 0
    36 137.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9219 MiB   0.0000 MiB           1       came_from = {}
    39 137.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9219 MiB   0.0000 MiB       14847       while not open_set.empty():
    49 137.9219 MiB   0.0000 MiB       14847           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9219 MiB   0.0000 MiB       14847           current = open_set.get()[2]
    55 137.9219 MiB   0.0000 MiB       14847           open_set_hash.remove(current)
    56                                         
    57 137.9219 MiB   0.0000 MiB       14847           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9219 MiB   0.0000 MiB       14847           if current == end:
    62 137.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9219 MiB   0.0000 MiB      133614           for neighbor in current.neighbors:
    67 137.9219 MiB   0.0000 MiB      118768               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9219 MiB   0.0000 MiB       59384                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9219 MiB   0.0000 MiB       59384                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9219 MiB   0.0000 MiB      118768               if temp_g_score < g_score[neighbor]:
    73 137.9219 MiB   0.0000 MiB       15543                   came_from[neighbor] = current
    74 137.9219 MiB   0.0000 MiB       15543                   g_score[neighbor] = temp_g_score
    75 137.9219 MiB   0.0000 MiB       15543                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9219 MiB   0.0000 MiB       15543                   if neighbor not in open_set_hash:
    77 137.9219 MiB   0.0000 MiB       15543                       count += 1
    78 137.9219 MiB   0.0000 MiB       15543                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9219 MiB   0.0000 MiB       15543                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9219 MiB   0.0000 MiB       14846           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9219 MiB   0.0000 MiB       14846           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9219 MiB 137.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9219 MiB   0.0000 MiB         257       for row in grid:
    32 137.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9219 MiB   0.0000 MiB           1       count = 0
    36 137.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9219 MiB   0.0000 MiB           1       came_from = {}
    39 137.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9219 MiB   0.0000 MiB          90       while not open_set.empty():
    49 137.9219 MiB   0.0000 MiB          90           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9219 MiB   0.0000 MiB          90           current = open_set.get()[2]
    55 137.9219 MiB   0.0000 MiB          90           open_set_hash.remove(current)
    56                                         
    57 137.9219 MiB   0.0000 MiB          90           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9219 MiB   0.0000 MiB          90           if current == end:
    62 137.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9219 MiB   0.0000 MiB         801           for neighbor in current.neighbors:
    67 137.9219 MiB   0.0000 MiB         712               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9219 MiB   0.0000 MiB         356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9219 MiB   0.0000 MiB         356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9219 MiB   0.0000 MiB         712               if temp_g_score < g_score[neighbor]:
    73 137.9219 MiB   0.0000 MiB         146                   came_from[neighbor] = current
    74 137.9219 MiB   0.0000 MiB         146                   g_score[neighbor] = temp_g_score
    75 137.9219 MiB   0.0000 MiB         146                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9219 MiB   0.0000 MiB         146                   if neighbor not in open_set_hash:
    77 137.9219 MiB   0.0000 MiB         146                       count += 1
    78 137.9219 MiB   0.0000 MiB         146                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9219 MiB   0.0000 MiB         146                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9219 MiB   0.0000 MiB          89           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9219 MiB   0.0000 MiB          89           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9219 MiB 137.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9219 MiB   0.0000 MiB         257       for row in grid:
    32 137.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9219 MiB   0.0000 MiB           1       count = 0
    36 137.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9219 MiB   0.0000 MiB           1       came_from = {}
    39 137.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9219 MiB   0.0000 MiB        1325       while not open_set.empty():
    49 137.9219 MiB   0.0000 MiB        1325           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9219 MiB   0.0000 MiB        1325           current = open_set.get()[2]
    55 137.9219 MiB   0.0000 MiB        1325           open_set_hash.remove(current)
    56                                         
    57 137.9219 MiB   0.0000 MiB        1325           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9219 MiB   0.0000 MiB        1325           if current == end:
    62 137.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9219 MiB   0.0000 MiB       11916           for neighbor in current.neighbors:
    67 137.9219 MiB   0.0000 MiB       10592               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9219 MiB   0.0000 MiB        5296                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9219 MiB   0.0000 MiB        5296                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9219 MiB   0.0000 MiB       10592               if temp_g_score < g_score[neighbor]:
    73 137.9219 MiB   0.0000 MiB        1585                   came_from[neighbor] = current
    74 137.9219 MiB   0.0000 MiB        1585                   g_score[neighbor] = temp_g_score
    75 137.9219 MiB   0.0000 MiB        1585                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9219 MiB   0.0000 MiB        1585                   if neighbor not in open_set_hash:
    77 137.9219 MiB   0.0000 MiB        1585                       count += 1
    78 137.9219 MiB   0.0000 MiB        1585                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9219 MiB   0.0000 MiB        1585                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9219 MiB   0.0000 MiB        1324           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9219 MiB   0.0000 MiB        1324           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9219 MiB 137.9219 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9219 MiB   0.0000 MiB         257       for row in grid:
    32 137.9219 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9219 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9219 MiB   0.0000 MiB           1       count = 0
    36 137.9219 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9219 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9219 MiB   0.0000 MiB           1       came_from = {}
    39 137.9219 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9219 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9219 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9219 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9219 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9219 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9219 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9219 MiB   0.0000 MiB        7056       while not open_set.empty():
    49 137.9219 MiB   0.0000 MiB        7056           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9219 MiB   0.0000 MiB        7056           current = open_set.get()[2]
    55 137.9219 MiB   0.0000 MiB        7056           open_set_hash.remove(current)
    56                                         
    57 137.9219 MiB   0.0000 MiB        7056           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9219 MiB   0.0000 MiB        7056           if current == end:
    62 137.9219 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9219 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9219 MiB   0.0000 MiB       63495           for neighbor in current.neighbors:
    67 137.9219 MiB   0.0000 MiB       56440               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9219 MiB   0.0000 MiB       28220                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9219 MiB   0.0000 MiB       28220                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9219 MiB   0.0000 MiB       56440               if temp_g_score < g_score[neighbor]:
    73 137.9219 MiB   0.0000 MiB        7538                   came_from[neighbor] = current
    74 137.9219 MiB   0.0000 MiB        7538                   g_score[neighbor] = temp_g_score
    75 137.9219 MiB   0.0000 MiB        7538                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9219 MiB   0.0000 MiB        7538                   if neighbor not in open_set_hash:
    77 137.9219 MiB   0.0000 MiB        7538                       count += 1
    78 137.9219 MiB   0.0000 MiB        7538                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9219 MiB   0.0000 MiB        7538                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9219 MiB   0.0000 MiB        7055           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9219 MiB   0.0000 MiB        7055           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9375 MiB 137.9375 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9375 MiB   0.0000 MiB         257       for row in grid:
    32 137.9375 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9375 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9375 MiB   0.0000 MiB           1       count = 0
    36 137.9375 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9375 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9375 MiB   0.0000 MiB           1       came_from = {}
    39 137.9688 MiB   0.0312 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9688 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9688 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9688 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9688 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9688 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9688 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9688 MiB   0.0000 MiB        3780       while not open_set.empty():
    49 137.9688 MiB   0.0000 MiB        3780           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9688 MiB   0.0000 MiB        3780           current = open_set.get()[2]
    55 137.9688 MiB   0.0000 MiB        3780           open_set_hash.remove(current)
    56                                         
    57 137.9688 MiB   0.0000 MiB        3780           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9688 MiB   0.0000 MiB        3780           if current == end:
    62 137.9688 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9688 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9688 MiB   0.0000 MiB       34011           for neighbor in current.neighbors:
    67 137.9688 MiB   0.0000 MiB       30232               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9688 MiB   0.0000 MiB       15116                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9688 MiB   0.0000 MiB       15116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9688 MiB   0.0000 MiB       30232               if temp_g_score < g_score[neighbor]:
    73 137.9688 MiB   0.0000 MiB        4134                   came_from[neighbor] = current
    74 137.9688 MiB   0.0000 MiB        4134                   g_score[neighbor] = temp_g_score
    75 137.9688 MiB   0.0000 MiB        4134                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9688 MiB   0.0000 MiB        4134                   if neighbor not in open_set_hash:
    77 137.9688 MiB   0.0000 MiB        4134                       count += 1
    78 137.9688 MiB   0.0000 MiB        4134                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9688 MiB   0.0000 MiB        4134                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9688 MiB   0.0000 MiB        3779           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9688 MiB   0.0000 MiB        3779           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9688 MiB 137.9688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9688 MiB   0.0000 MiB         257       for row in grid:
    32 137.9688 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9688 MiB   0.0000 MiB           1       count = 0
    36 137.9688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9688 MiB   0.0000 MiB           1       came_from = {}
    39 137.9688 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9688 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9688 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9688 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9688 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9688 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9688 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9688 MiB   0.0000 MiB         234       while not open_set.empty():
    49 137.9688 MiB   0.0000 MiB         234           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9688 MiB   0.0000 MiB         234           current = open_set.get()[2]
    55 137.9688 MiB   0.0000 MiB         234           open_set_hash.remove(current)
    56                                         
    57 137.9688 MiB   0.0000 MiB         234           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9688 MiB   0.0000 MiB         234           if current == end:
    62 137.9688 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9688 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9688 MiB   0.0000 MiB        2097           for neighbor in current.neighbors:
    67 137.9688 MiB   0.0000 MiB        1864               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9688 MiB   0.0000 MiB         932                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9688 MiB   0.0000 MiB         932                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9688 MiB   0.0000 MiB        1864               if temp_g_score < g_score[neighbor]:
    73 137.9688 MiB   0.0000 MiB         320                   came_from[neighbor] = current
    74 137.9688 MiB   0.0000 MiB         320                   g_score[neighbor] = temp_g_score
    75 137.9688 MiB   0.0000 MiB         320                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9688 MiB   0.0000 MiB         320                   if neighbor not in open_set_hash:
    77 137.9688 MiB   0.0000 MiB         320                       count += 1
    78 137.9688 MiB   0.0000 MiB         320                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9688 MiB   0.0000 MiB         320                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9688 MiB   0.0000 MiB         233           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9688 MiB   0.0000 MiB         233           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9688 MiB 137.9688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9688 MiB   0.0000 MiB         257       for row in grid:
    32 137.9688 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9688 MiB   0.0000 MiB           1       count = 0
    36 137.9688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9688 MiB   0.0000 MiB           1       came_from = {}
    39 137.9688 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9688 MiB   0.0000 MiB           1       g_score[start] = 0
    41 137.9688 MiB   0.0000 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 137.9688 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 137.9688 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 137.9688 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 137.9688 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 137.9688 MiB   0.0000 MiB        5922       while not open_set.empty():
    49 137.9688 MiB   0.0000 MiB        5922           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 137.9688 MiB   0.0000 MiB        5922           current = open_set.get()[2]
    55 137.9688 MiB   0.0000 MiB        5922           open_set_hash.remove(current)
    56                                         
    57 137.9688 MiB   0.0000 MiB        5922           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 137.9688 MiB   0.0000 MiB        5922           if current == end:
    62 137.9688 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 137.9688 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 137.9688 MiB   0.0000 MiB       53289           for neighbor in current.neighbors:
    67 137.9688 MiB   0.0000 MiB       47368               if current.row != neighbor.row and current.col != neighbor.col:
    68 137.9688 MiB   0.0000 MiB       23684                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 137.9688 MiB   0.0000 MiB       23684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 137.9688 MiB   0.0000 MiB       47368               if temp_g_score < g_score[neighbor]:
    73 137.9688 MiB   0.0000 MiB        6422                   came_from[neighbor] = current
    74 137.9688 MiB   0.0000 MiB        6422                   g_score[neighbor] = temp_g_score
    75 137.9688 MiB   0.0000 MiB        6422                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 137.9688 MiB   0.0000 MiB        6422                   if neighbor not in open_set_hash:
    77 137.9688 MiB   0.0000 MiB        6422                       count += 1
    78 137.9688 MiB   0.0000 MiB        6422                       open_set.put((f_score[neighbor], count, neighbor))
    79 137.9688 MiB   0.0000 MiB        6422                       open_set_hash.add(neighbor)
    80                                                             
    81 137.9688 MiB   0.0000 MiB        5921           if draw is not None:
    82                                                     draw()
    83                                         
    84 137.9688 MiB   0.0000 MiB        5921           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28 137.9688 MiB 137.9688 MiB           1   @profile(precision=4, stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31 137.9688 MiB   0.0000 MiB         257       for row in grid:
    32 137.9688 MiB   0.0000 MiB       65792           for spot in row:
    33 137.9688 MiB   0.0000 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35 137.9688 MiB   0.0000 MiB           1       count = 0
    36 137.9688 MiB   0.0000 MiB           1       open_set = PriorityQueue()
    37 137.9688 MiB   0.0000 MiB           1       open_set.put((0, count, start))
    38 137.9688 MiB   0.0000 MiB           1       came_from = {}
    39 137.9688 MiB   0.0000 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40 137.9688 MiB   0.0000 MiB           1       g_score[start] = 0
    41 138.1875 MiB   0.2188 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42 138.1875 MiB   0.0000 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43 138.1875 MiB   0.0000 MiB           1       open_set_hash = {start}
    44                                         
    45 138.1875 MiB   0.0000 MiB           1       cost_diagonal = 14
    46 138.1875 MiB   0.0000 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48 138.1875 MiB   0.0000 MiB         636       while not open_set.empty():
    49 138.1875 MiB   0.0000 MiB         636           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54 138.1875 MiB   0.0000 MiB         636           current = open_set.get()[2]
    55 138.1875 MiB   0.0000 MiB         636           open_set_hash.remove(current)
    56                                         
    57 138.1875 MiB   0.0000 MiB         636           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61 138.1875 MiB   0.0000 MiB         636           if current == end:
    62 138.1875 MiB   0.0000 MiB           1               if draw:
    63                                                         end.make_end()
    64 138.1875 MiB   0.0000 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66 138.1875 MiB   0.0000 MiB        5715           for neighbor in current.neighbors:
    67 138.1875 MiB   0.0000 MiB        5080               if current.row != neighbor.row and current.col != neighbor.col:
    68 138.1875 MiB   0.0000 MiB        2540                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70 138.1875 MiB   0.0000 MiB        2540                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72 138.1875 MiB   0.0000 MiB        5080               if temp_g_score < g_score[neighbor]:
    73 138.1875 MiB   0.0000 MiB         870                   came_from[neighbor] = current
    74 138.1875 MiB   0.0000 MiB         870                   g_score[neighbor] = temp_g_score
    75 138.1875 MiB   0.0000 MiB         870                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76 138.1875 MiB   0.0000 MiB         870                   if neighbor not in open_set_hash:
    77 138.1875 MiB   0.0000 MiB         870                       count += 1
    78 138.1875 MiB   0.0000 MiB         870                       open_set.put((f_score[neighbor], count, neighbor))
    79 138.1875 MiB   0.0000 MiB         870                       open_set_hash.add(neighbor)
    80                                                             
    81 138.1875 MiB   0.0000 MiB         635           if draw is not None:
    82                                                     draw()
    83                                         
    84 138.1875 MiB   0.0000 MiB         635           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


