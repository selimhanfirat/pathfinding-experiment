Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.3 MiB     67.3 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     71.2 MiB      0.0 MiB         257       for row in grid:
    30     71.2 MiB      0.0 MiB       65792           for spot in row:
    31     71.2 MiB      3.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.2 MiB      0.0 MiB           1       count = 0
    34     71.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.2 MiB      0.0 MiB           1       came_from = {}
    37     78.0 MiB      6.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     78.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     83.8 MiB      5.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     83.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     83.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     83.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     83.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     83.9 MiB      0.0 MiB         558       while not open_set.empty():
    47     83.9 MiB      0.0 MiB         558           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     83.9 MiB      0.0 MiB         558           current = open_set.get()[2]
    53     83.9 MiB      0.0 MiB         558           open_set_hash.remove(current)
    54                                         
    55     83.9 MiB      0.0 MiB         558           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     83.9 MiB      0.0 MiB         558           if current == end:
    60     83.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     83.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     83.9 MiB      0.0 MiB        5013           for neighbor in current.neighbors:
    65     83.9 MiB      0.0 MiB        4456               if current.row != neighbor.row and current.col != neighbor.col:
    66     83.9 MiB      0.0 MiB        2228                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     83.9 MiB      0.0 MiB        2228                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     83.9 MiB      0.0 MiB        4456               if temp_g_score < g_score[neighbor]:
    71     83.9 MiB      0.0 MiB         690                   came_from[neighbor] = current
    72     83.9 MiB      0.0 MiB         690                   g_score[neighbor] = temp_g_score
    73     83.9 MiB      0.0 MiB         690                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     83.9 MiB      0.0 MiB         690                   if neighbor not in open_set_hash:
    75     83.9 MiB      0.0 MiB         690                       count += 1
    76     83.9 MiB      0.0 MiB         690                       open_set.put((f_score[neighbor], count, neighbor))
    77     83.9 MiB      0.0 MiB         690                       open_set_hash.add(neighbor)
    78                                                             
    79     83.9 MiB      0.0 MiB         557           if draw is not None:
    80                                                     draw()
    81                                         
    82     83.9 MiB      0.0 MiB         557           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.5 MiB    100.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.5 MiB      0.0 MiB         257       for row in grid:
    30    104.5 MiB      0.0 MiB       65792           for spot in row:
    31    104.5 MiB      4.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.5 MiB      0.0 MiB           1       count = 0
    34    104.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.5 MiB      0.0 MiB           1       came_from = {}
    37    109.1 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.6 MiB      4.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.6 MiB      0.0 MiB         114       while not open_set.empty():
    47    113.6 MiB      0.0 MiB         114           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.6 MiB      0.0 MiB         114           current = open_set.get()[2]
    53    113.6 MiB      0.0 MiB         114           open_set_hash.remove(current)
    54                                         
    55    113.6 MiB      0.0 MiB         114           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.6 MiB      0.0 MiB         114           if current == end:
    60    113.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    113.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.6 MiB      0.0 MiB        1017           for neighbor in current.neighbors:
    65    113.6 MiB      0.0 MiB         904               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.6 MiB      0.0 MiB         452                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.6 MiB      0.0 MiB         452                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.6 MiB      0.0 MiB         904               if temp_g_score < g_score[neighbor]:
    71    113.6 MiB      0.0 MiB         234                   came_from[neighbor] = current
    72    113.6 MiB      0.0 MiB         234                   g_score[neighbor] = temp_g_score
    73    113.6 MiB      0.0 MiB         234                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.6 MiB      0.0 MiB         234                   if neighbor not in open_set_hash:
    75    113.6 MiB      0.0 MiB         234                       count += 1
    76    113.6 MiB      0.0 MiB         234                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.6 MiB      0.0 MiB         234                       open_set_hash.add(neighbor)
    78                                                             
    79    113.6 MiB      0.0 MiB         113           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.6 MiB      0.0 MiB         113           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.5 MiB    110.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.5 MiB      0.0 MiB         257       for row in grid:
    30    110.5 MiB      0.0 MiB       65792           for spot in row:
    31    110.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.5 MiB      0.0 MiB           1       count = 0
    34    110.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.5 MiB      0.0 MiB           1       came_from = {}
    37    113.5 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.6 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.6 MiB      0.0 MiB        9116       while not open_set.empty():
    47    115.6 MiB      0.0 MiB        9116           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.6 MiB      0.0 MiB        9116           current = open_set.get()[2]
    53    115.6 MiB      0.0 MiB        9116           open_set_hash.remove(current)
    54                                         
    55    115.6 MiB      0.0 MiB        9116           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.6 MiB      0.0 MiB        9116           if current == end:
    60    115.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.6 MiB      0.0 MiB       82035           for neighbor in current.neighbors:
    65    115.6 MiB      0.0 MiB       72920               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.6 MiB      0.0 MiB       36460                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.6 MiB      0.0 MiB       36460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.6 MiB      0.0 MiB       72920               if temp_g_score < g_score[neighbor]:
    71    115.6 MiB      0.0 MiB        9670                   came_from[neighbor] = current
    72    115.6 MiB      0.0 MiB        9670                   g_score[neighbor] = temp_g_score
    73    115.6 MiB      0.0 MiB        9670                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.6 MiB      0.0 MiB        9670                   if neighbor not in open_set_hash:
    75    115.6 MiB      0.0 MiB        9670                       count += 1
    76    115.6 MiB      0.0 MiB        9670                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.6 MiB      0.0 MiB        9670                       open_set_hash.add(neighbor)
    78                                                             
    79    115.6 MiB      0.0 MiB        9115           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.6 MiB      0.0 MiB        9115           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.4 MiB    118.4 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.4 MiB      0.0 MiB         257       for row in grid:
    30    118.4 MiB      0.0 MiB       65792           for spot in row:
    31    118.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    118.4 MiB      0.0 MiB           1       count = 0
    34    118.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    118.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    118.4 MiB      0.0 MiB           1       came_from = {}
    37    120.9 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    120.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    121.2 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    121.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    121.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    121.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    121.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    121.2 MiB      0.0 MiB        1372       while not open_set.empty():
    47    121.2 MiB      0.0 MiB        1372           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    121.2 MiB      0.0 MiB        1372           current = open_set.get()[2]
    53    121.2 MiB      0.0 MiB        1372           open_set_hash.remove(current)
    54                                         
    55    121.2 MiB      0.0 MiB        1372           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    121.2 MiB      0.0 MiB        1372           if current == end:
    60    121.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    121.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    121.2 MiB      0.0 MiB       12339           for neighbor in current.neighbors:
    65    121.2 MiB      0.0 MiB       10968               if current.row != neighbor.row and current.col != neighbor.col:
    66    121.2 MiB      0.0 MiB        5484                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    121.2 MiB      0.0 MiB        5484                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    121.2 MiB      0.0 MiB       10968               if temp_g_score < g_score[neighbor]:
    71    121.2 MiB      0.0 MiB        1790                   came_from[neighbor] = current
    72    121.2 MiB      0.0 MiB        1790                   g_score[neighbor] = temp_g_score
    73    121.2 MiB      0.0 MiB        1790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    121.2 MiB      0.0 MiB        1790                   if neighbor not in open_set_hash:
    75    121.2 MiB      0.0 MiB        1790                       count += 1
    76    121.2 MiB      0.0 MiB        1790                       open_set.put((f_score[neighbor], count, neighbor))
    77    121.2 MiB      0.0 MiB        1790                       open_set_hash.add(neighbor)
    78                                                             
    79    121.2 MiB      0.0 MiB        1371           if draw is not None:
    80                                                     draw()
    81                                         
    82    121.2 MiB      0.0 MiB        1371           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    122.2 MiB    122.2 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    122.2 MiB      0.0 MiB         257       for row in grid:
    30    122.2 MiB      0.0 MiB       65792           for spot in row:
    31    122.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    122.2 MiB      0.0 MiB           1       count = 0
    34    122.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    122.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    122.2 MiB      0.0 MiB           1       came_from = {}
    37    122.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    122.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    124.7 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    124.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    124.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    124.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    124.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    124.7 MiB      0.0 MiB        1840       while not open_set.empty():
    47    124.7 MiB      0.0 MiB        1840           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    124.7 MiB      0.0 MiB        1840           current = open_set.get()[2]
    53    124.7 MiB      0.0 MiB        1840           open_set_hash.remove(current)
    54                                         
    55    124.7 MiB      0.0 MiB        1840           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    124.7 MiB      0.0 MiB        1840           if current == end:
    60    124.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    124.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    124.7 MiB      0.0 MiB       16551           for neighbor in current.neighbors:
    65    124.7 MiB      0.0 MiB       14712               if current.row != neighbor.row and current.col != neighbor.col:
    66    124.7 MiB      0.0 MiB        7356                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    124.7 MiB      0.0 MiB        7356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    124.7 MiB      0.0 MiB       14712               if temp_g_score < g_score[neighbor]:
    71    124.7 MiB      0.0 MiB        2204                   came_from[neighbor] = current
    72    124.7 MiB      0.0 MiB        2204                   g_score[neighbor] = temp_g_score
    73    124.7 MiB      0.0 MiB        2204                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    124.7 MiB      0.0 MiB        2204                   if neighbor not in open_set_hash:
    75    124.7 MiB      0.0 MiB        2204                       count += 1
    76    124.7 MiB      0.0 MiB        2204                       open_set.put((f_score[neighbor], count, neighbor))
    77    124.7 MiB      0.0 MiB        2204                       open_set_hash.add(neighbor)
    78                                                             
    79    124.7 MiB      0.0 MiB        1839           if draw is not None:
    80                                                     draw()
    81                                         
    82    124.7 MiB      0.0 MiB        1839           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    124.7 MiB    124.7 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    124.7 MiB      0.0 MiB         257       for row in grid:
    30    124.7 MiB      0.0 MiB       65792           for spot in row:
    31    124.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    124.7 MiB      0.0 MiB           1       count = 0
    34    124.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    124.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    124.7 MiB      0.0 MiB           1       came_from = {}
    37    124.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    124.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    127.2 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    127.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    127.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    127.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    127.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    127.2 MiB      0.0 MiB        2754       while not open_set.empty():
    47    127.2 MiB      0.0 MiB        2754           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    127.2 MiB      0.0 MiB        2754           current = open_set.get()[2]
    53    127.2 MiB      0.0 MiB        2754           open_set_hash.remove(current)
    54                                         
    55    127.2 MiB      0.0 MiB        2754           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    127.2 MiB      0.0 MiB        2754           if current == end:
    60    127.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    127.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    127.2 MiB      0.0 MiB       24777           for neighbor in current.neighbors:
    65    127.2 MiB      0.0 MiB       22024               if current.row != neighbor.row and current.col != neighbor.col:
    66    127.2 MiB      0.0 MiB       11012                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    127.2 MiB      0.0 MiB       11012                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    127.2 MiB      0.0 MiB       22024               if temp_g_score < g_score[neighbor]:
    71    127.2 MiB      0.0 MiB        3050                   came_from[neighbor] = current
    72    127.2 MiB      0.0 MiB        3050                   g_score[neighbor] = temp_g_score
    73    127.2 MiB      0.0 MiB        3050                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    127.2 MiB      0.0 MiB        3050                   if neighbor not in open_set_hash:
    75    127.2 MiB      0.0 MiB        3050                       count += 1
    76    127.2 MiB      0.0 MiB        3050                       open_set.put((f_score[neighbor], count, neighbor))
    77    127.2 MiB      0.0 MiB        3050                       open_set_hash.add(neighbor)
    78                                                             
    79    127.2 MiB      0.0 MiB        2753           if draw is not None:
    80                                                     draw()
    81                                         
    82    127.2 MiB      0.0 MiB        2753           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    127.9 MiB    127.9 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    127.9 MiB      0.0 MiB         257       for row in grid:
    30    127.9 MiB      0.0 MiB       65792           for spot in row:
    31    127.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    127.9 MiB      0.0 MiB           1       count = 0
    34    127.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    127.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    127.9 MiB      0.0 MiB           1       came_from = {}
    37    127.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    127.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    130.4 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    130.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    130.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    130.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    130.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    130.4 MiB      0.0 MiB        1428       while not open_set.empty():
    47    130.4 MiB      0.0 MiB        1428           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    130.4 MiB      0.0 MiB        1428           current = open_set.get()[2]
    53    130.4 MiB      0.0 MiB        1428           open_set_hash.remove(current)
    54                                         
    55    130.4 MiB      0.0 MiB        1428           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    130.4 MiB      0.0 MiB        1428           if current == end:
    60    130.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    130.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    130.4 MiB      0.0 MiB       12843           for neighbor in current.neighbors:
    65    130.4 MiB      0.0 MiB       11416               if current.row != neighbor.row and current.col != neighbor.col:
    66    130.4 MiB      0.0 MiB        5708                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    130.4 MiB      0.0 MiB        5708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    130.4 MiB      0.0 MiB       11416               if temp_g_score < g_score[neighbor]:
    71    130.4 MiB      0.0 MiB        1796                   came_from[neighbor] = current
    72    130.4 MiB      0.0 MiB        1796                   g_score[neighbor] = temp_g_score
    73    130.4 MiB      0.0 MiB        1796                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    130.4 MiB      0.0 MiB        1796                   if neighbor not in open_set_hash:
    75    130.4 MiB      0.0 MiB        1796                       count += 1
    76    130.4 MiB      0.0 MiB        1796                       open_set.put((f_score[neighbor], count, neighbor))
    77    130.4 MiB      0.0 MiB        1796                       open_set_hash.add(neighbor)
    78                                                             
    79    130.4 MiB      0.0 MiB        1427           if draw is not None:
    80                                                     draw()
    81                                         
    82    130.4 MiB      0.0 MiB        1427           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    130.4 MiB    130.4 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    130.4 MiB   -918.7 MiB         257       for row in grid:
    30    130.4 MiB -235102.8 MiB       65792           for spot in row:
    31    130.4 MiB -234191.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    120.0 MiB    -10.4 MiB           1       count = 0
    34    120.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    120.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    120.0 MiB      0.0 MiB           1       came_from = {}
    37    123.5 MiB      3.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    123.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    124.0 MiB -88359.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    121.1 MiB     -2.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    121.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    121.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    121.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    121.1 MiB  -1289.4 MiB         506       while not open_set.empty():
    47    121.1 MiB  -1289.4 MiB         506           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    121.1 MiB  -1289.4 MiB         506           current = open_set.get()[2]
    53    121.1 MiB  -1289.4 MiB         506           open_set_hash.remove(current)
    54                                         
    55    121.1 MiB  -1289.4 MiB         506           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    121.1 MiB  -1289.4 MiB         506           if current == end:
    60    118.3 MiB     -2.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    118.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    121.1 MiB -11585.9 MiB        4545           for neighbor in current.neighbors:
    65    121.1 MiB -10297.1 MiB        4040               if current.row != neighbor.row and current.col != neighbor.col:
    66    121.1 MiB  -5150.8 MiB        2020                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    121.1 MiB  -5146.2 MiB        2020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    121.1 MiB -10299.3 MiB        4040               if temp_g_score < g_score[neighbor]:
    71    121.1 MiB  -1559.6 MiB         640                   came_from[neighbor] = current
    72    121.1 MiB  -1559.7 MiB         640                   g_score[neighbor] = temp_g_score
    73    121.1 MiB  -1559.7 MiB         640                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    121.1 MiB  -1559.7 MiB         640                   if neighbor not in open_set_hash:
    75    121.1 MiB  -1559.7 MiB         640                       count += 1
    76    121.1 MiB  -1559.7 MiB         640                       open_set.put((f_score[neighbor], count, neighbor))
    77    121.1 MiB  -1559.7 MiB         640                       open_set_hash.add(neighbor)
    78                                                             
    79    121.1 MiB  -1289.1 MiB         505           if draw is not None:
    80                                                     draw()
    81                                         
    82    121.1 MiB  -1289.4 MiB         505           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.4 MiB    118.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.4 MiB      0.0 MiB         257       for row in grid:
    30    118.4 MiB      0.0 MiB       65792           for spot in row:
    31    118.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    118.4 MiB      0.0 MiB           1       count = 0
    34    118.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    118.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    118.4 MiB      0.0 MiB           1       came_from = {}
    37    120.6 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    120.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    121.7 MiB -27742.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    120.8 MiB     -0.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    120.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    120.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    120.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    120.8 MiB      0.0 MiB        1020       while not open_set.empty():
    47    120.8 MiB      0.0 MiB        1020           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    120.8 MiB      0.0 MiB        1020           current = open_set.get()[2]
    53    120.8 MiB      0.0 MiB        1020           open_set_hash.remove(current)
    54                                         
    55    120.8 MiB      0.0 MiB        1020           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    120.8 MiB      0.0 MiB        1020           if current == end:
    60    120.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    120.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    120.8 MiB      0.0 MiB        9171           for neighbor in current.neighbors:
    65    120.8 MiB      0.0 MiB        8152               if current.row != neighbor.row and current.col != neighbor.col:
    66    120.8 MiB      0.0 MiB        4076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    120.8 MiB      0.0 MiB        4076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    120.8 MiB      0.0 MiB        8152               if temp_g_score < g_score[neighbor]:
    71    120.8 MiB      0.0 MiB        1446                   came_from[neighbor] = current
    72    120.8 MiB      0.0 MiB        1446                   g_score[neighbor] = temp_g_score
    73    120.8 MiB      0.0 MiB        1446                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    120.8 MiB      0.0 MiB        1446                   if neighbor not in open_set_hash:
    75    120.8 MiB      0.0 MiB        1446                       count += 1
    76    120.8 MiB      0.0 MiB        1446                       open_set.put((f_score[neighbor], count, neighbor))
    77    120.8 MiB      0.0 MiB        1446                       open_set_hash.add(neighbor)
    78                                                             
    79    120.8 MiB      0.0 MiB        1019           if draw is not None:
    80                                                     draw()
    81                                         
    82    120.8 MiB      0.0 MiB        1019           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    120.8 MiB    120.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    120.8 MiB      0.0 MiB         257       for row in grid:
    30    120.8 MiB      0.0 MiB       65792           for spot in row:
    31    120.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    120.8 MiB      0.0 MiB           1       count = 0
    34    120.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    120.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    120.8 MiB      0.0 MiB           1       came_from = {}
    37    122.5 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    122.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    122.7 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    122.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    122.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    122.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    122.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    122.7 MiB      0.0 MiB        1002       while not open_set.empty():
    47    122.7 MiB      0.0 MiB        1002           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    122.7 MiB      0.0 MiB        1002           current = open_set.get()[2]
    53    122.7 MiB      0.0 MiB        1002           open_set_hash.remove(current)
    54                                         
    55    122.7 MiB      0.0 MiB        1002           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    122.7 MiB      0.0 MiB        1002           if current == end:
    60    122.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    122.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    122.7 MiB      0.0 MiB        9009           for neighbor in current.neighbors:
    65    122.7 MiB      0.0 MiB        8008               if current.row != neighbor.row and current.col != neighbor.col:
    66    122.7 MiB      0.0 MiB        4004                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    122.7 MiB      0.0 MiB        4004                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    122.7 MiB      0.0 MiB        8008               if temp_g_score < g_score[neighbor]:
    71    122.7 MiB      0.0 MiB        1358                   came_from[neighbor] = current
    72    122.7 MiB      0.0 MiB        1358                   g_score[neighbor] = temp_g_score
    73    122.7 MiB      0.0 MiB        1358                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    122.7 MiB      0.0 MiB        1358                   if neighbor not in open_set_hash:
    75    122.7 MiB      0.0 MiB        1358                       count += 1
    76    122.7 MiB      0.0 MiB        1358                       open_set.put((f_score[neighbor], count, neighbor))
    77    122.7 MiB      0.0 MiB        1358                       open_set_hash.add(neighbor)
    78                                                             
    79    122.7 MiB      0.0 MiB        1001           if draw is not None:
    80                                                     draw()
    81                                         
    82    122.7 MiB      0.0 MiB        1001           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    122.7 MiB    122.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    122.7 MiB      0.0 MiB         257       for row in grid:
    30    122.7 MiB      0.0 MiB       65792           for spot in row:
    31    122.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    122.7 MiB      0.0 MiB           1       count = 0
    34    122.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    122.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    122.7 MiB      0.0 MiB           1       came_from = {}
    37    122.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    122.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    123.3 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    123.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    123.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    123.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    123.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    123.3 MiB      0.0 MiB          25       while not open_set.empty():
    47    123.3 MiB      0.0 MiB          25           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    123.3 MiB      0.0 MiB          25           current = open_set.get()[2]
    53    123.3 MiB      0.0 MiB          25           open_set_hash.remove(current)
    54                                         
    55    123.3 MiB      0.0 MiB          25           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    123.3 MiB      0.0 MiB          25           if current == end:
    60    123.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    123.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    123.3 MiB      0.0 MiB         216           for neighbor in current.neighbors:
    65    123.3 MiB      0.0 MiB         192               if current.row != neighbor.row and current.col != neighbor.col:
    66    123.3 MiB      0.0 MiB          96                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    123.3 MiB      0.0 MiB          96                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    123.3 MiB      0.0 MiB         192               if temp_g_score < g_score[neighbor]:
    71    123.3 MiB      0.0 MiB          53                   came_from[neighbor] = current
    72    123.3 MiB      0.0 MiB          53                   g_score[neighbor] = temp_g_score
    73    123.3 MiB      0.0 MiB          53                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    123.3 MiB      0.0 MiB          53                   if neighbor not in open_set_hash:
    75    123.3 MiB      0.0 MiB          53                       count += 1
    76    123.3 MiB      0.0 MiB          53                       open_set.put((f_score[neighbor], count, neighbor))
    77    123.3 MiB      0.0 MiB          53                       open_set_hash.add(neighbor)
    78                                                             
    79    123.3 MiB      0.0 MiB          24           if draw is not None:
    80                                                     draw()
    81                                         
    82    123.3 MiB      0.0 MiB          24           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    123.3 MiB    123.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    123.3 MiB      0.0 MiB         257       for row in grid:
    30    123.3 MiB      0.0 MiB       65792           for spot in row:
    31    123.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    123.3 MiB      0.0 MiB           1       count = 0
    34    123.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    123.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    123.3 MiB      0.0 MiB           1       came_from = {}
    37    123.7 MiB      0.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    123.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    123.8 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    123.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    123.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    123.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    123.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    123.9 MiB      0.0 MiB        5450       while not open_set.empty():
    47    123.9 MiB      0.0 MiB        5450           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    123.9 MiB      0.0 MiB        5450           current = open_set.get()[2]
    53    123.9 MiB      0.0 MiB        5450           open_set_hash.remove(current)
    54                                         
    55    123.9 MiB      0.0 MiB        5450           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    123.9 MiB      0.0 MiB        5450           if current == end:
    60    123.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    123.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    123.9 MiB      0.0 MiB       49041           for neighbor in current.neighbors:
    65    123.9 MiB      0.0 MiB       43592               if current.row != neighbor.row and current.col != neighbor.col:
    66    123.9 MiB      0.0 MiB       21796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    123.9 MiB      0.0 MiB       21796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    123.9 MiB      0.0 MiB       43592               if temp_g_score < g_score[neighbor]:
    71    123.9 MiB      0.2 MiB        5984                   came_from[neighbor] = current
    72    123.9 MiB      0.0 MiB        5984                   g_score[neighbor] = temp_g_score
    73    123.9 MiB      0.0 MiB        5984                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    123.9 MiB      0.0 MiB        5984                   if neighbor not in open_set_hash:
    75    123.9 MiB      0.0 MiB        5984                       count += 1
    76    123.9 MiB      0.0 MiB        5984                       open_set.put((f_score[neighbor], count, neighbor))
    77    123.9 MiB      0.0 MiB        5984                       open_set_hash.add(neighbor)
    78                                                             
    79    123.9 MiB      0.0 MiB        5449           if draw is not None:
    80                                                     draw()
    81                                         
    82    123.9 MiB      0.0 MiB        5449           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    124.9 MiB    124.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    124.9 MiB      0.0 MiB         257       for row in grid:
    30    124.9 MiB      0.0 MiB       65792           for spot in row:
    31    124.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    124.9 MiB      0.0 MiB           1       count = 0
    34    124.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    124.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    124.9 MiB      0.0 MiB           1       came_from = {}
    37    124.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    124.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    124.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    124.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    124.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    124.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    124.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    124.9 MiB      0.0 MiB         308       while not open_set.empty():
    47    124.9 MiB      0.0 MiB         308           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    124.9 MiB      0.0 MiB         308           current = open_set.get()[2]
    53    124.9 MiB      0.0 MiB         308           open_set_hash.remove(current)
    54                                         
    55    124.9 MiB      0.0 MiB         308           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    124.9 MiB      0.0 MiB         308           if current == end:
    60    124.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    124.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    124.9 MiB      0.0 MiB        2763           for neighbor in current.neighbors:
    65    124.9 MiB      0.0 MiB        2456               if current.row != neighbor.row and current.col != neighbor.col:
    66    124.9 MiB      0.0 MiB        1228                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    124.9 MiB      0.0 MiB        1228                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    124.9 MiB      0.0 MiB        2456               if temp_g_score < g_score[neighbor]:
    71    124.9 MiB      0.0 MiB         422                   came_from[neighbor] = current
    72    124.9 MiB      0.0 MiB         422                   g_score[neighbor] = temp_g_score
    73    124.9 MiB      0.0 MiB         422                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    124.9 MiB      0.0 MiB         422                   if neighbor not in open_set_hash:
    75    124.9 MiB      0.0 MiB         422                       count += 1
    76    124.9 MiB      0.0 MiB         422                       open_set.put((f_score[neighbor], count, neighbor))
    77    124.9 MiB      0.0 MiB         422                       open_set_hash.add(neighbor)
    78                                                             
    79    124.9 MiB      0.0 MiB         307           if draw is not None:
    80                                                     draw()
    81                                         
    82    124.9 MiB      0.0 MiB         307           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    125.4 MiB    125.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    125.4 MiB      0.0 MiB         257       for row in grid:
    30    125.4 MiB      0.0 MiB       65792           for spot in row:
    31    125.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    125.4 MiB      0.0 MiB           1       count = 0
    34    125.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    125.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    125.4 MiB      0.0 MiB           1       came_from = {}
    37    125.6 MiB      0.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    125.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    125.7 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    125.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    125.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    125.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    125.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    125.7 MiB      0.0 MiB        3960       while not open_set.empty():
    47    125.7 MiB      0.0 MiB        3960           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    125.7 MiB      0.0 MiB        3960           current = open_set.get()[2]
    53    125.7 MiB      0.0 MiB        3960           open_set_hash.remove(current)
    54                                         
    55    125.7 MiB      0.0 MiB        3960           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    125.7 MiB      0.0 MiB        3960           if current == end:
    60    125.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    125.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    125.7 MiB      0.0 MiB       35631           for neighbor in current.neighbors:
    65    125.7 MiB      0.0 MiB       31672               if current.row != neighbor.row and current.col != neighbor.col:
    66    125.7 MiB      0.0 MiB       15836                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    125.7 MiB      0.0 MiB       15836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    125.7 MiB      0.0 MiB       31672               if temp_g_score < g_score[neighbor]:
    71    125.7 MiB      0.0 MiB        4406                   came_from[neighbor] = current
    72    125.7 MiB      0.0 MiB        4406                   g_score[neighbor] = temp_g_score
    73    125.7 MiB      0.0 MiB        4406                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    125.7 MiB      0.0 MiB        4406                   if neighbor not in open_set_hash:
    75    125.7 MiB      0.0 MiB        4406                       count += 1
    76    125.7 MiB      0.0 MiB        4406                       open_set.put((f_score[neighbor], count, neighbor))
    77    125.7 MiB      0.0 MiB        4406                       open_set_hash.add(neighbor)
    78                                                             
    79    125.7 MiB      0.0 MiB        3959           if draw is not None:
    80                                                     draw()
    81                                         
    82    125.7 MiB      0.0 MiB        3959           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    125.7 MiB    125.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    125.7 MiB  -2088.8 MiB         257       for row in grid:
    30    125.7 MiB -534080.3 MiB       65792           for spot in row:
    31    125.7 MiB -532007.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.5 MiB    -20.2 MiB           1       count = 0
    34    105.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.5 MiB      0.0 MiB           1       came_from = {}
    37    109.0 MiB  -4305.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.1 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.1 MiB      0.0 MiB         132       while not open_set.empty():
    47    111.1 MiB      0.0 MiB         132           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.1 MiB      0.0 MiB         132           current = open_set.get()[2]
    53    111.1 MiB      0.0 MiB         132           open_set_hash.remove(current)
    54                                         
    55    111.1 MiB      0.0 MiB         132           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.1 MiB      0.0 MiB         132           if current == end:
    60    111.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.1 MiB      0.0 MiB        1179           for neighbor in current.neighbors:
    65    111.1 MiB      0.0 MiB        1048               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.1 MiB      0.0 MiB         524                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.1 MiB      0.0 MiB         524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.1 MiB      0.0 MiB        1048               if temp_g_score < g_score[neighbor]:
    71    111.1 MiB      0.0 MiB         270                   came_from[neighbor] = current
    72    111.1 MiB      0.0 MiB         270                   g_score[neighbor] = temp_g_score
    73    111.1 MiB      0.0 MiB         270                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.1 MiB      0.0 MiB         270                   if neighbor not in open_set_hash:
    75    111.1 MiB      0.0 MiB         270                       count += 1
    76    111.1 MiB      0.0 MiB         270                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.1 MiB      0.0 MiB         270                       open_set_hash.add(neighbor)
    78                                                             
    79    111.1 MiB      0.0 MiB         131           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.1 MiB      0.0 MiB         131           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.1 MiB    111.1 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.1 MiB      0.0 MiB         257       for row in grid:
    30    111.1 MiB      0.0 MiB       65792           for spot in row:
    31    111.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.1 MiB      0.0 MiB           1       count = 0
    34    111.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.1 MiB      0.0 MiB           1       came_from = {}
    37    115.4 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    117.0 MiB      1.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    117.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    117.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    117.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    117.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    117.0 MiB      0.0 MiB         828       while not open_set.empty():
    47    117.0 MiB      0.0 MiB         828           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    117.0 MiB      0.0 MiB         828           current = open_set.get()[2]
    53    117.0 MiB      0.0 MiB         828           open_set_hash.remove(current)
    54                                         
    55    117.0 MiB      0.0 MiB         828           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    117.0 MiB      0.0 MiB         828           if current == end:
    60    117.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    117.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    117.0 MiB      0.0 MiB        7443           for neighbor in current.neighbors:
    65    117.0 MiB      0.0 MiB        6616               if current.row != neighbor.row and current.col != neighbor.col:
    66    117.0 MiB      0.0 MiB        3308                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    117.0 MiB      0.0 MiB        3308                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    117.0 MiB      0.0 MiB        6616               if temp_g_score < g_score[neighbor]:
    71    117.0 MiB      0.0 MiB        1212                   came_from[neighbor] = current
    72    117.0 MiB      0.0 MiB        1212                   g_score[neighbor] = temp_g_score
    73    117.0 MiB      0.0 MiB        1212                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    117.0 MiB      0.0 MiB        1212                   if neighbor not in open_set_hash:
    75    117.0 MiB      0.0 MiB        1212                       count += 1
    76    117.0 MiB      0.0 MiB        1212                       open_set.put((f_score[neighbor], count, neighbor))
    77    117.0 MiB      0.0 MiB        1212                       open_set_hash.add(neighbor)
    78                                                             
    79    117.0 MiB      0.0 MiB         827           if draw is not None:
    80                                                     draw()
    81                                         
    82    117.0 MiB      0.0 MiB         827           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    117.0 MiB    117.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    117.0 MiB      0.0 MiB         257       for row in grid:
    30    117.0 MiB      0.0 MiB       65792           for spot in row:
    31    117.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    117.0 MiB      0.0 MiB           1       count = 0
    34    117.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    117.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    117.0 MiB      0.0 MiB           1       came_from = {}
    37    117.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    117.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    119.3 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    119.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    119.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    119.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    119.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    119.3 MiB      0.0 MiB         576       while not open_set.empty():
    47    119.3 MiB      0.0 MiB         576           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    119.3 MiB      0.0 MiB         576           current = open_set.get()[2]
    53    119.3 MiB      0.0 MiB         576           open_set_hash.remove(current)
    54                                         
    55    119.3 MiB      0.0 MiB         576           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    119.3 MiB      0.0 MiB         576           if current == end:
    60    119.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    119.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    119.3 MiB      0.0 MiB        5172           for neighbor in current.neighbors:
    65    119.3 MiB      0.0 MiB        4597               if current.row != neighbor.row and current.col != neighbor.col:
    66    119.3 MiB      0.0 MiB        2298                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    119.3 MiB      0.0 MiB        2299                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    119.3 MiB      0.0 MiB        4597               if temp_g_score < g_score[neighbor]:
    71    119.3 MiB      0.0 MiB         735                   came_from[neighbor] = current
    72    119.3 MiB      0.0 MiB         735                   g_score[neighbor] = temp_g_score
    73    119.3 MiB      0.0 MiB         735                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    119.3 MiB      0.0 MiB         735                   if neighbor not in open_set_hash:
    75    119.3 MiB      0.0 MiB         735                       count += 1
    76    119.3 MiB      0.0 MiB         735                       open_set.put((f_score[neighbor], count, neighbor))
    77    119.3 MiB      0.0 MiB         735                       open_set_hash.add(neighbor)
    78                                                             
    79    119.3 MiB      0.0 MiB         575           if draw is not None:
    80                                                     draw()
    81                                         
    82    119.3 MiB      0.0 MiB         575           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    119.3 MiB    119.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    119.3 MiB      0.0 MiB         257       for row in grid:
    30    119.3 MiB      0.0 MiB       65792           for spot in row:
    31    119.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    119.3 MiB      0.0 MiB           1       count = 0
    34    119.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    119.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    119.3 MiB      0.0 MiB           1       came_from = {}
    37    121.4 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    121.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    123.8 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    123.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    123.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    123.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    123.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    124.0 MiB      0.0 MiB        2422       while not open_set.empty():
    47    124.0 MiB      0.0 MiB        2422           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    124.0 MiB      0.0 MiB        2422           current = open_set.get()[2]
    53    124.0 MiB      0.0 MiB        2422           open_set_hash.remove(current)
    54                                         
    55    124.0 MiB      0.0 MiB        2422           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    124.0 MiB      0.0 MiB        2422           if current == end:
    60    124.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    124.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    124.0 MiB      0.0 MiB       21789           for neighbor in current.neighbors:
    65    124.0 MiB      0.0 MiB       19368               if current.row != neighbor.row and current.col != neighbor.col:
    66    124.0 MiB      0.0 MiB        9684                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    124.0 MiB      0.0 MiB        9684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    124.0 MiB      0.0 MiB       19368               if temp_g_score < g_score[neighbor]:
    71    124.0 MiB      0.2 MiB        2822                   came_from[neighbor] = current
    72    124.0 MiB      0.0 MiB        2822                   g_score[neighbor] = temp_g_score
    73    124.0 MiB      0.0 MiB        2822                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    124.0 MiB      0.0 MiB        2822                   if neighbor not in open_set_hash:
    75    124.0 MiB      0.0 MiB        2822                       count += 1
    76    124.0 MiB      0.0 MiB        2822                       open_set.put((f_score[neighbor], count, neighbor))
    77    124.0 MiB      0.0 MiB        2822                       open_set_hash.add(neighbor)
    78                                                             
    79    124.0 MiB      0.0 MiB        2421           if draw is not None:
    80                                                     draw()
    81                                         
    82    124.0 MiB      0.0 MiB        2421           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    124.2 MiB    124.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    124.2 MiB      0.0 MiB         257       for row in grid:
    30    124.2 MiB      0.0 MiB       65792           for spot in row:
    31    124.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    124.2 MiB      0.0 MiB           1       count = 0
    34    124.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    124.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    124.2 MiB      0.0 MiB           1       came_from = {}
    37    124.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    124.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    124.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    124.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    124.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    124.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    124.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    124.2 MiB      0.0 MiB        4018       while not open_set.empty():
    47    124.2 MiB      0.0 MiB        4018           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    124.2 MiB      0.0 MiB        4018           current = open_set.get()[2]
    53    124.2 MiB      0.0 MiB        4018           open_set_hash.remove(current)
    54                                         
    55    124.2 MiB      0.0 MiB        4018           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    124.2 MiB      0.0 MiB        4018           if current == end:
    60    124.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    124.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    124.2 MiB      0.0 MiB       36153           for neighbor in current.neighbors:
    65    124.2 MiB      0.0 MiB       32136               if current.row != neighbor.row and current.col != neighbor.col:
    66    124.2 MiB      0.0 MiB       16068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    124.2 MiB      0.0 MiB       16068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    124.2 MiB      0.0 MiB       32136               if temp_g_score < g_score[neighbor]:
    71    124.2 MiB      0.0 MiB        4376                   came_from[neighbor] = current
    72    124.2 MiB      0.0 MiB        4376                   g_score[neighbor] = temp_g_score
    73    124.2 MiB      0.0 MiB        4376                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    124.2 MiB      0.0 MiB        4376                   if neighbor not in open_set_hash:
    75    124.2 MiB      0.0 MiB        4376                       count += 1
    76    124.2 MiB      0.0 MiB        4376                       open_set.put((f_score[neighbor], count, neighbor))
    77    124.2 MiB      0.0 MiB        4376                       open_set_hash.add(neighbor)
    78                                                             
    79    124.2 MiB      0.0 MiB        4017           if draw is not None:
    80                                                     draw()
    81                                         
    82    124.2 MiB      0.0 MiB        4017           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    124.2 MiB    124.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    124.2 MiB      0.0 MiB         257       for row in grid:
    30    124.2 MiB      0.0 MiB       65792           for spot in row:
    31    124.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    124.2 MiB      0.0 MiB           1       count = 0
    34    124.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    124.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    124.2 MiB      0.0 MiB           1       came_from = {}
    37    124.3 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    124.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    126.8 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    126.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    126.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    126.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    126.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    127.1 MiB -10207.7 MiB       12150       while not open_set.empty():
    47    127.1 MiB -10207.7 MiB       12150           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    127.1 MiB -10207.7 MiB       12150           current = open_set.get()[2]
    53    127.1 MiB -10207.7 MiB       12150           open_set_hash.remove(current)
    54                                         
    55    127.1 MiB -10207.7 MiB       12150           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    127.1 MiB -10207.7 MiB       12150           if current == end:
    60    125.2 MiB     -2.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    125.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    127.1 MiB -91856.1 MiB      109341           for neighbor in current.neighbors:
    65    127.1 MiB -81648.8 MiB       97192               if current.row != neighbor.row and current.col != neighbor.col:
    66    127.1 MiB -40826.3 MiB       48596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    127.1 MiB -40822.8 MiB       48596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    127.1 MiB -81649.4 MiB       97192               if temp_g_score < g_score[neighbor]:
    71    127.1 MiB -10707.4 MiB       12910                   came_from[neighbor] = current
    72    127.1 MiB -10707.8 MiB       12910                   g_score[neighbor] = temp_g_score
    73    127.1 MiB -10708.1 MiB       12910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    127.1 MiB -10708.2 MiB       12910                   if neighbor not in open_set_hash:
    75    127.1 MiB -10708.4 MiB       12910                       count += 1
    76    127.1 MiB -10708.5 MiB       12910                       open_set.put((f_score[neighbor], count, neighbor))
    77    127.1 MiB -10708.5 MiB       12910                       open_set_hash.add(neighbor)
    78                                                             
    79    127.1 MiB -10207.7 MiB       12149           if draw is not None:
    80                                                     draw()
    81                                         
    82    127.1 MiB -10207.7 MiB       12149           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    126.2 MiB    126.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    126.2 MiB      0.0 MiB         257       for row in grid:
    30    126.2 MiB      0.0 MiB       65792           for spot in row:
    31    126.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    126.2 MiB      0.0 MiB           1       count = 0
    34    126.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    126.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    126.2 MiB      0.0 MiB           1       came_from = {}
    37    126.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    126.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    126.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    126.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    126.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    126.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    126.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    126.3 MiB      0.0 MiB        1152       while not open_set.empty():
    47    126.3 MiB      0.0 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    126.3 MiB      0.0 MiB        1152           current = open_set.get()[2]
    53    126.3 MiB      0.0 MiB        1152           open_set_hash.remove(current)
    54                                         
    55    126.3 MiB      0.0 MiB        1152           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    126.3 MiB      0.0 MiB        1152           if current == end:
    60    126.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    126.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    126.3 MiB      0.0 MiB       10359           for neighbor in current.neighbors:
    65    126.3 MiB      0.0 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    66    126.3 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    126.3 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    126.3 MiB      0.0 MiB        9208               if temp_g_score < g_score[neighbor]:
    71    126.3 MiB      0.1 MiB        1390                   came_from[neighbor] = current
    72    126.3 MiB      0.0 MiB        1390                   g_score[neighbor] = temp_g_score
    73    126.3 MiB      0.0 MiB        1390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    126.3 MiB      0.0 MiB        1390                   if neighbor not in open_set_hash:
    75    126.3 MiB      0.0 MiB        1390                       count += 1
    76    126.3 MiB      0.0 MiB        1390                       open_set.put((f_score[neighbor], count, neighbor))
    77    126.3 MiB      0.0 MiB        1390                       open_set_hash.add(neighbor)
    78                                                             
    79    126.3 MiB      0.0 MiB        1151           if draw is not None:
    80                                                     draw()
    81                                         
    82    126.3 MiB      0.0 MiB        1151           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    126.3 MiB    126.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    126.3 MiB      0.0 MiB         257       for row in grid:
    30    126.3 MiB      0.0 MiB       65792           for spot in row:
    31    126.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    126.3 MiB      0.0 MiB           1       count = 0
    34    126.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    126.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    126.3 MiB      0.0 MiB           1       came_from = {}
    37    128.4 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    128.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    130.1 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    130.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    130.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    130.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    130.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    130.1 MiB      0.0 MiB         141       while not open_set.empty():
    47    130.1 MiB      0.0 MiB         141           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    130.1 MiB      0.0 MiB         141           current = open_set.get()[2]
    53    130.1 MiB      0.0 MiB         141           open_set_hash.remove(current)
    54                                         
    55    130.1 MiB      0.0 MiB         141           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    130.1 MiB      0.0 MiB         141           if current == end:
    60    130.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    130.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    130.1 MiB      0.0 MiB        1260           for neighbor in current.neighbors:
    65    130.1 MiB      0.0 MiB        1120               if current.row != neighbor.row and current.col != neighbor.col:
    66    130.1 MiB      0.0 MiB         560                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    130.1 MiB      0.0 MiB         560                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    130.1 MiB      0.0 MiB        1120               if temp_g_score < g_score[neighbor]:
    71    130.1 MiB      0.0 MiB         425                   came_from[neighbor] = current
    72    130.1 MiB      0.0 MiB         425                   g_score[neighbor] = temp_g_score
    73    130.1 MiB      0.0 MiB         425                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    130.1 MiB      0.0 MiB         425                   if neighbor not in open_set_hash:
    75    130.1 MiB      0.0 MiB         425                       count += 1
    76    130.1 MiB      0.0 MiB         425                       open_set.put((f_score[neighbor], count, neighbor))
    77    130.1 MiB      0.0 MiB         425                       open_set_hash.add(neighbor)
    78                                                             
    79    130.1 MiB      0.0 MiB         140           if draw is not None:
    80                                                     draw()
    81                                         
    82    130.1 MiB      0.0 MiB         140           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    130.1 MiB    130.1 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    130.1 MiB      0.0 MiB         257       for row in grid:
    30    130.1 MiB      0.0 MiB       65792           for spot in row:
    31    130.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    130.1 MiB      0.0 MiB           1       count = 0
    34    130.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    130.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    130.1 MiB      0.0 MiB           1       came_from = {}
    37    131.0 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    131.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    131.6 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    131.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    131.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    131.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    131.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    131.6 MiB  -5252.5 MiB        2650       while not open_set.empty():
    47    131.6 MiB  -5252.5 MiB        2650           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    131.6 MiB  -5252.5 MiB        2650           current = open_set.get()[2]
    53    131.6 MiB  -5252.5 MiB        2650           open_set_hash.remove(current)
    54                                         
    55    131.6 MiB  -5252.7 MiB        2650           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    131.6 MiB  -5252.8 MiB        2650           if current == end:
    60    125.4 MiB     -6.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    125.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    131.6 MiB -47238.7 MiB       23841           for neighbor in current.neighbors:
    65    131.6 MiB -41987.6 MiB       21192               if current.row != neighbor.row and current.col != neighbor.col:
    66    131.6 MiB -20999.1 MiB       10596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    131.6 MiB -20989.6 MiB       10596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    131.6 MiB -41989.6 MiB       21192               if temp_g_score < g_score[neighbor]:
    71    131.6 MiB  -5796.8 MiB        2960                   came_from[neighbor] = current
    72    131.6 MiB  -5797.0 MiB        2960                   g_score[neighbor] = temp_g_score
    73    131.6 MiB  -5797.4 MiB        2960                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    131.6 MiB  -5797.7 MiB        2960                   if neighbor not in open_set_hash:
    75    131.6 MiB  -5797.7 MiB        2960                       count += 1
    76    131.6 MiB  -5797.8 MiB        2960                       open_set.put((f_score[neighbor], count, neighbor))
    77    131.6 MiB  -5798.0 MiB        2960                       open_set_hash.add(neighbor)
    78                                                             
    79    131.6 MiB  -5252.5 MiB        2649           if draw is not None:
    80                                                     draw()
    81                                         
    82    131.6 MiB  -5252.5 MiB        2649           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    125.4 MiB    125.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    125.4 MiB   -303.2 MiB         257       for row in grid:
    30    125.4 MiB -77678.8 MiB       65792           for spot in row:
    31    125.4 MiB -77376.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    124.1 MiB     -1.3 MiB           1       count = 0
    34    124.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    124.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    124.1 MiB      0.0 MiB           1       came_from = {}
    37    125.1 MiB  -5877.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    125.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    125.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    125.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    125.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    125.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    125.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    125.2 MiB      0.0 MiB         960       while not open_set.empty():
    47    125.2 MiB      0.0 MiB         960           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    125.2 MiB      0.0 MiB         960           current = open_set.get()[2]
    53    125.2 MiB      0.0 MiB         960           open_set_hash.remove(current)
    54                                         
    55    125.2 MiB      0.0 MiB         960           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    125.2 MiB      0.0 MiB         960           if current == end:
    60    125.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    125.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    125.2 MiB      0.0 MiB        8631           for neighbor in current.neighbors:
    65    125.2 MiB      0.0 MiB        7672               if current.row != neighbor.row and current.col != neighbor.col:
    66    125.2 MiB      0.0 MiB        3836                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    125.2 MiB      0.0 MiB        3836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    125.2 MiB      0.0 MiB        7672               if temp_g_score < g_score[neighbor]:
    71    125.2 MiB      0.1 MiB        1454                   came_from[neighbor] = current
    72    125.2 MiB      0.0 MiB        1454                   g_score[neighbor] = temp_g_score
    73    125.2 MiB      0.0 MiB        1454                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    125.2 MiB      0.0 MiB        1454                   if neighbor not in open_set_hash:
    75    125.2 MiB      0.0 MiB        1454                       count += 1
    76    125.2 MiB      0.0 MiB        1454                       open_set.put((f_score[neighbor], count, neighbor))
    77    125.2 MiB      0.0 MiB        1454                       open_set_hash.add(neighbor)
    78                                                             
    79    125.2 MiB      0.0 MiB         959           if draw is not None:
    80                                                     draw()
    81                                         
    82    125.2 MiB      0.0 MiB         959           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    125.2 MiB    125.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    125.2 MiB   -309.1 MiB         257       for row in grid:
    30    125.2 MiB -78589.8 MiB       65792           for spot in row:
    31    125.2 MiB -78284.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    120.3 MiB     -4.9 MiB           1       count = 0
    34    120.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    120.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    120.3 MiB      0.0 MiB           1       came_from = {}
    37    120.3 MiB -64877.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    120.2 MiB     -0.0 MiB           1       g_score[start] = 0
    39    123.0 MiB      2.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    123.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    123.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    123.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    123.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    123.0 MiB      0.0 MiB        7452       while not open_set.empty():
    47    123.0 MiB      0.0 MiB        7452           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    123.0 MiB      0.0 MiB        7452           current = open_set.get()[2]
    53    123.0 MiB      0.0 MiB        7452           open_set_hash.remove(current)
    54                                         
    55    123.0 MiB      0.0 MiB        7452           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    123.0 MiB      0.0 MiB        7452           if current == end:
    60    123.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    123.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    123.0 MiB      0.0 MiB       67059           for neighbor in current.neighbors:
    65    123.0 MiB      0.0 MiB       59608               if current.row != neighbor.row and current.col != neighbor.col:
    66    123.0 MiB      0.0 MiB       29804                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    123.0 MiB      0.0 MiB       29804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    123.0 MiB      0.0 MiB       59608               if temp_g_score < g_score[neighbor]:
    71    123.0 MiB      0.0 MiB        7958                   came_from[neighbor] = current
    72    123.0 MiB      0.0 MiB        7958                   g_score[neighbor] = temp_g_score
    73    123.0 MiB      0.0 MiB        7958                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    123.0 MiB      0.0 MiB        7958                   if neighbor not in open_set_hash:
    75    123.0 MiB      0.0 MiB        7958                       count += 1
    76    123.0 MiB      0.0 MiB        7958                       open_set.put((f_score[neighbor], count, neighbor))
    77    123.0 MiB      0.0 MiB        7958                       open_set_hash.add(neighbor)
    78                                                             
    79    123.0 MiB      0.0 MiB        7451           if draw is not None:
    80                                                     draw()
    81                                         
    82    123.0 MiB      0.0 MiB        7451           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    123.0 MiB    123.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    123.0 MiB   -440.4 MiB         257       for row in grid:
    30    123.0 MiB -112548.5 MiB       65792           for spot in row:
    31    123.0 MiB -112110.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    120.3 MiB     -2.7 MiB           1       count = 0
    34    120.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    120.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    120.3 MiB      0.0 MiB           1       came_from = {}
    37    120.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    120.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    121.1 MiB  -1004.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    121.0 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    121.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    121.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    121.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    121.0 MiB      0.0 MiB         303       while not open_set.empty():
    47    121.0 MiB      0.0 MiB         303           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    121.0 MiB      0.0 MiB         303           current = open_set.get()[2]
    53    121.0 MiB      0.0 MiB         303           open_set_hash.remove(current)
    54                                         
    55    121.0 MiB      0.0 MiB         303           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    121.0 MiB      0.0 MiB         303           if current == end:
    60    121.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    121.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    121.0 MiB      0.0 MiB        2718           for neighbor in current.neighbors:
    65    121.0 MiB      0.0 MiB        2416               if current.row != neighbor.row and current.col != neighbor.col:
    66    121.0 MiB      0.0 MiB        1208                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    121.0 MiB      0.0 MiB        1208                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    121.0 MiB      0.0 MiB        2416               if temp_g_score < g_score[neighbor]:
    71    121.0 MiB      0.0 MiB         515                   came_from[neighbor] = current
    72    121.0 MiB      0.0 MiB         515                   g_score[neighbor] = temp_g_score
    73    121.0 MiB      0.0 MiB         515                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    121.0 MiB      0.0 MiB         515                   if neighbor not in open_set_hash:
    75    121.0 MiB      0.0 MiB         515                       count += 1
    76    121.0 MiB      0.0 MiB         515                       open_set.put((f_score[neighbor], count, neighbor))
    77    121.0 MiB      0.0 MiB         515                       open_set_hash.add(neighbor)
    78                                                             
    79    121.0 MiB      0.0 MiB         302           if draw is not None:
    80                                                     draw()
    81                                         
    82    121.0 MiB      0.0 MiB         302           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    121.0 MiB    121.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    121.0 MiB  -1416.8 MiB         257       for row in grid:
    30    121.0 MiB -363381.1 MiB       65792           for spot in row:
    31    121.0 MiB -361968.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.8 MiB     -6.2 MiB           1       count = 0
    34    114.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.8 MiB      0.0 MiB           1       came_from = {}
    37    114.8 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    118.6 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.6 MiB      0.0 MiB        1425       while not open_set.empty():
    47    118.6 MiB      0.0 MiB        1425           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.6 MiB      0.0 MiB        1425           current = open_set.get()[2]
    53    118.6 MiB      0.0 MiB        1425           open_set_hash.remove(current)
    54                                         
    55    118.6 MiB      0.0 MiB        1425           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.6 MiB      0.0 MiB        1425           if current == end:
    60    118.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    118.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.6 MiB      0.0 MiB       12816           for neighbor in current.neighbors:
    65    118.6 MiB      0.0 MiB       11392               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.6 MiB      0.0 MiB        5696                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.6 MiB      0.0 MiB        5696                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.6 MiB      0.0 MiB       11392               if temp_g_score < g_score[neighbor]:
    71    118.6 MiB      0.0 MiB        1649                   came_from[neighbor] = current
    72    118.6 MiB      0.0 MiB        1649                   g_score[neighbor] = temp_g_score
    73    118.6 MiB      0.0 MiB        1649                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.6 MiB      0.0 MiB        1649                   if neighbor not in open_set_hash:
    75    118.6 MiB      0.0 MiB        1649                       count += 1
    76    118.6 MiB      0.0 MiB        1649                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.6 MiB      0.0 MiB        1649                       open_set_hash.add(neighbor)
    78                                                             
    79    118.6 MiB      0.0 MiB        1424           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.6 MiB      0.0 MiB        1424           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.6 MiB    118.6 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.6 MiB      0.0 MiB         257       for row in grid:
    30    118.6 MiB      0.0 MiB       65792           for spot in row:
    31    118.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    118.6 MiB      0.0 MiB           1       count = 0
    34    118.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    118.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    118.6 MiB      0.0 MiB           1       came_from = {}
    37    118.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    118.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    119.2 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    119.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    119.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    119.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    119.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    119.2 MiB      0.0 MiB        2058       while not open_set.empty():
    47    119.2 MiB      0.0 MiB        2058           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    119.2 MiB      0.0 MiB        2058           current = open_set.get()[2]
    53    119.2 MiB      0.0 MiB        2058           open_set_hash.remove(current)
    54                                         
    55    119.2 MiB      0.0 MiB        2058           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    119.2 MiB      0.0 MiB        2058           if current == end:
    60    119.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    119.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    119.2 MiB      0.0 MiB       18513           for neighbor in current.neighbors:
    65    119.2 MiB      0.0 MiB       16456               if current.row != neighbor.row and current.col != neighbor.col:
    66    119.2 MiB      0.0 MiB        8228                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    119.2 MiB      0.0 MiB        8228                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    119.2 MiB      0.0 MiB       16456               if temp_g_score < g_score[neighbor]:
    71    119.2 MiB      0.0 MiB        2336                   came_from[neighbor] = current
    72    119.2 MiB      0.0 MiB        2336                   g_score[neighbor] = temp_g_score
    73    119.2 MiB      0.0 MiB        2336                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    119.2 MiB      0.0 MiB        2336                   if neighbor not in open_set_hash:
    75    119.2 MiB      0.0 MiB        2336                       count += 1
    76    119.2 MiB      0.0 MiB        2336                       open_set.put((f_score[neighbor], count, neighbor))
    77    119.2 MiB      0.0 MiB        2336                       open_set_hash.add(neighbor)
    78                                                             
    79    119.2 MiB      0.0 MiB        2057           if draw is not None:
    80                                                     draw()
    81                                         
    82    119.2 MiB      0.0 MiB        2057           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    119.2 MiB    119.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    119.2 MiB      0.0 MiB         257       for row in grid:
    30    119.2 MiB      0.0 MiB       65792           for spot in row:
    31    119.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    119.2 MiB      0.0 MiB           1       count = 0
    34    119.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    119.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    119.2 MiB      0.0 MiB           1       came_from = {}
    37    119.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    119.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    119.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    119.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    119.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    119.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    119.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    119.2 MiB      0.0 MiB         224       while not open_set.empty():
    47    119.2 MiB      0.0 MiB         224           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    119.2 MiB      0.0 MiB         224           current = open_set.get()[2]
    53    119.2 MiB      0.0 MiB         224           open_set_hash.remove(current)
    54                                         
    55    119.2 MiB      0.0 MiB         224           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    119.2 MiB      0.0 MiB         224           if current == end:
    60    119.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    119.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    119.2 MiB      0.0 MiB        2007           for neighbor in current.neighbors:
    65    119.2 MiB      0.0 MiB        1784               if current.row != neighbor.row and current.col != neighbor.col:
    66    119.2 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    119.2 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    119.2 MiB      0.0 MiB        1784               if temp_g_score < g_score[neighbor]:
    71    119.2 MiB      0.0 MiB         454                   came_from[neighbor] = current
    72    119.2 MiB      0.0 MiB         454                   g_score[neighbor] = temp_g_score
    73    119.2 MiB      0.0 MiB         454                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    119.2 MiB      0.0 MiB         454                   if neighbor not in open_set_hash:
    75    119.2 MiB      0.0 MiB         454                       count += 1
    76    119.2 MiB      0.0 MiB         454                       open_set.put((f_score[neighbor], count, neighbor))
    77    119.2 MiB      0.0 MiB         454                       open_set_hash.add(neighbor)
    78                                                             
    79    119.2 MiB      0.0 MiB         223           if draw is not None:
    80                                                     draw()
    81                                         
    82    119.2 MiB      0.0 MiB         223           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    119.6 MiB    119.6 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    119.6 MiB      0.0 MiB         257       for row in grid:
    30    119.6 MiB      0.0 MiB       65792           for spot in row:
    31    119.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    119.6 MiB      0.0 MiB           1       count = 0
    34    119.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    119.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    119.6 MiB      0.0 MiB           1       came_from = {}
    37    121.7 MiB      2.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    121.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    126.2 MiB      4.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    126.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    126.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    126.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    126.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    126.2 MiB  -8114.8 MiB        6567       while not open_set.empty():
    47    126.2 MiB  -8114.8 MiB        6567           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    126.2 MiB  -8114.8 MiB        6567           current = open_set.get()[2]
    53    126.2 MiB  -8114.8 MiB        6567           open_set_hash.remove(current)
    54                                         
    55    126.2 MiB  -8114.8 MiB        6567           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    126.2 MiB  -8114.8 MiB        6567           if current == end:
    60    124.0 MiB     -2.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    124.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    126.2 MiB -73022.0 MiB       59094           for neighbor in current.neighbors:
    65    126.2 MiB -64907.5 MiB       52528               if current.row != neighbor.row and current.col != neighbor.col:
    66    126.2 MiB -32456.5 MiB       26264                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    126.2 MiB -32451.3 MiB       26264                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    126.2 MiB -64908.2 MiB       52528               if temp_g_score < g_score[neighbor]:
    71    126.2 MiB  -9092.7 MiB        7427                   came_from[neighbor] = current
    72    126.2 MiB  -9092.8 MiB        7427                   g_score[neighbor] = temp_g_score
    73    126.2 MiB  -9093.0 MiB        7427                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    126.2 MiB  -9093.1 MiB        7427                   if neighbor not in open_set_hash:
    75    126.2 MiB  -9093.2 MiB        7427                       count += 1
    76    126.2 MiB  -9093.2 MiB        7427                       open_set.put((f_score[neighbor], count, neighbor))
    77    126.2 MiB  -9093.2 MiB        7427                       open_set_hash.add(neighbor)
    78                                                             
    79    126.2 MiB  -8114.8 MiB        6566           if draw is not None:
    80                                                     draw()
    81                                         
    82    126.2 MiB  -8114.8 MiB        6566           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    119.4 MiB    119.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    119.4 MiB  -1499.0 MiB         257       for row in grid:
    30    119.4 MiB -384006.5 MiB       65792           for spot in row:
    31    119.4 MiB -382516.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    106.3 MiB    -13.1 MiB           1       count = 0
    34    106.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    106.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    106.3 MiB      0.0 MiB           1       came_from = {}
    37    109.5 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    109.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.7 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.7 MiB      0.0 MiB        2759       while not open_set.empty():
    47    111.7 MiB      0.0 MiB        2759           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.7 MiB      0.0 MiB        2759           current = open_set.get()[2]
    53    111.7 MiB      0.0 MiB        2759           open_set_hash.remove(current)
    54                                         
    55    111.7 MiB      0.0 MiB        2759           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.7 MiB      0.0 MiB        2759           if current == end:
    60    111.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.7 MiB      0.0 MiB       24822           for neighbor in current.neighbors:
    65    111.7 MiB      0.0 MiB       22064               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.7 MiB      0.0 MiB       11032                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.7 MiB      0.0 MiB       11032                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.7 MiB      0.0 MiB       22064               if temp_g_score < g_score[neighbor]:
    71    111.7 MiB      0.0 MiB        3175                   came_from[neighbor] = current
    72    111.7 MiB      0.0 MiB        3175                   g_score[neighbor] = temp_g_score
    73    111.7 MiB      0.0 MiB        3175                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.7 MiB      0.0 MiB        3175                   if neighbor not in open_set_hash:
    75    111.7 MiB      0.0 MiB        3175                       count += 1
    76    111.7 MiB      0.0 MiB        3175                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.7 MiB      0.0 MiB        3175                       open_set_hash.add(neighbor)
    78                                                             
    79    111.7 MiB      0.0 MiB        2758           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.7 MiB      0.0 MiB        2758           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.7 MiB    111.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.7 MiB      0.0 MiB         257       for row in grid:
    30    111.7 MiB      0.0 MiB       65792           for spot in row:
    31    111.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    111.7 MiB      0.0 MiB           1       count = 0
    34    111.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    111.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    111.7 MiB      0.0 MiB           1       came_from = {}
    37    114.1 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.1 MiB      0.0 MiB       10057       while not open_set.empty():
    47    114.1 MiB      0.0 MiB       10057           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.1 MiB      0.0 MiB       10057           current = open_set.get()[2]
    53    114.1 MiB      0.0 MiB       10057           open_set_hash.remove(current)
    54                                         
    55    114.1 MiB      0.0 MiB       10057           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.1 MiB      0.0 MiB       10057           if current == end:
    60    114.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.1 MiB      0.0 MiB       90504           for neighbor in current.neighbors:
    65    114.1 MiB      0.0 MiB       80448               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.1 MiB      0.0 MiB       40224                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.1 MiB      0.0 MiB       40224                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.1 MiB      0.0 MiB       80448               if temp_g_score < g_score[neighbor]:
    71    114.1 MiB      0.0 MiB       10685                   came_from[neighbor] = current
    72    114.1 MiB      0.0 MiB       10685                   g_score[neighbor] = temp_g_score
    73    114.1 MiB      0.0 MiB       10685                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.1 MiB      0.0 MiB       10685                   if neighbor not in open_set_hash:
    75    114.1 MiB      0.0 MiB       10685                       count += 1
    76    114.1 MiB      0.0 MiB       10685                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.1 MiB      0.0 MiB       10685                       open_set_hash.add(neighbor)
    78                                                             
    79    114.1 MiB      0.0 MiB       10056           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.1 MiB      0.0 MiB       10056           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    114.2 MiB    114.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    114.2 MiB      0.0 MiB         257       for row in grid:
    30    114.2 MiB      0.0 MiB       65792           for spot in row:
    31    114.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    114.2 MiB      0.0 MiB           1       count = 0
    34    114.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    114.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    114.2 MiB      0.0 MiB           1       came_from = {}
    37    114.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    114.4 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    114.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    114.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    114.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    114.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    114.4 MiB      0.0 MiB         780       while not open_set.empty():
    47    114.4 MiB      0.0 MiB         780           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    114.4 MiB      0.0 MiB         780           current = open_set.get()[2]
    53    114.4 MiB      0.0 MiB         780           open_set_hash.remove(current)
    54                                         
    55    114.4 MiB      0.0 MiB         780           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    114.4 MiB      0.0 MiB         780           if current == end:
    60    114.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    114.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    114.4 MiB      0.0 MiB        7011           for neighbor in current.neighbors:
    65    114.4 MiB      0.0 MiB        6232               if current.row != neighbor.row and current.col != neighbor.col:
    66    114.4 MiB      0.0 MiB        3116                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    114.4 MiB      0.0 MiB        3116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    114.4 MiB      0.0 MiB        6232               if temp_g_score < g_score[neighbor]:
    71    114.4 MiB      0.0 MiB         942                   came_from[neighbor] = current
    72    114.4 MiB      0.0 MiB         942                   g_score[neighbor] = temp_g_score
    73    114.4 MiB      0.0 MiB         942                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    114.4 MiB      0.0 MiB         942                   if neighbor not in open_set_hash:
    75    114.4 MiB      0.0 MiB         942                       count += 1
    76    114.4 MiB      0.0 MiB         942                       open_set.put((f_score[neighbor], count, neighbor))
    77    114.4 MiB      0.0 MiB         942                       open_set_hash.add(neighbor)
    78                                                             
    79    114.4 MiB      0.0 MiB         779           if draw is not None:
    80                                                     draw()
    81                                         
    82    114.4 MiB      0.0 MiB         779           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.5 MiB    108.5 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.5 MiB      0.0 MiB         257       for row in grid:
    30    108.5 MiB      0.0 MiB       65792           for spot in row:
    31    108.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    108.5 MiB      0.0 MiB           1       count = 0
    34    108.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    108.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    108.5 MiB      0.0 MiB           1       came_from = {}
    37    111.0 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.8 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.8 MiB    -75.3 MiB         510       while not open_set.empty():
    47    112.8 MiB    -75.3 MiB         510           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.8 MiB    -75.3 MiB         510           current = open_set.get()[2]
    53    112.8 MiB    -75.3 MiB         510           open_set_hash.remove(current)
    54                                         
    55    112.8 MiB    -75.3 MiB         510           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.8 MiB    -75.3 MiB         510           if current == end:
    60    112.6 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.8 MiB   -676.8 MiB        4581           for neighbor in current.neighbors:
    65    112.8 MiB   -601.6 MiB        4072               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.8 MiB   -301.1 MiB        2036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.8 MiB   -300.4 MiB        2036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.8 MiB   -601.7 MiB        4072               if temp_g_score < g_score[neighbor]:
    71    112.8 MiB   -105.5 MiB         732                   came_from[neighbor] = current
    72    112.8 MiB   -105.5 MiB         732                   g_score[neighbor] = temp_g_score
    73    112.8 MiB   -105.5 MiB         732                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.8 MiB   -105.5 MiB         732                   if neighbor not in open_set_hash:
    75    112.8 MiB   -105.5 MiB         732                       count += 1
    76    112.8 MiB   -105.5 MiB         732                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.8 MiB   -105.5 MiB         732                       open_set_hash.add(neighbor)
    78                                                             
    79    112.8 MiB    -75.3 MiB         509           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.8 MiB    -75.3 MiB         509           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.6 MiB    112.6 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.6 MiB      0.0 MiB         257       for row in grid:
    30    112.6 MiB      0.0 MiB       65792           for spot in row:
    31    112.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.6 MiB      0.0 MiB           1       count = 0
    34    112.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.6 MiB      0.0 MiB           1       came_from = {}
    37    115.1 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    116.4 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    116.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    116.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    116.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    116.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    116.4 MiB      0.0 MiB         255       while not open_set.empty():
    47    116.4 MiB      0.0 MiB         255           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    116.4 MiB      0.0 MiB         255           current = open_set.get()[2]
    53    116.4 MiB      0.0 MiB         255           open_set_hash.remove(current)
    54                                         
    55    116.4 MiB      0.0 MiB         255           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    116.4 MiB      0.0 MiB         255           if current == end:
    60    116.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    116.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    116.4 MiB      0.0 MiB        2286           for neighbor in current.neighbors:
    65    116.4 MiB      0.0 MiB        2032               if current.row != neighbor.row and current.col != neighbor.col:
    66    116.4 MiB      0.0 MiB        1016                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    116.4 MiB      0.0 MiB        1016                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    116.4 MiB      0.0 MiB        2032               if temp_g_score < g_score[neighbor]:
    71    116.4 MiB      0.0 MiB         351                   came_from[neighbor] = current
    72    116.4 MiB      0.0 MiB         351                   g_score[neighbor] = temp_g_score
    73    116.4 MiB      0.0 MiB         351                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    116.4 MiB      0.0 MiB         351                   if neighbor not in open_set_hash:
    75    116.4 MiB      0.0 MiB         351                       count += 1
    76    116.4 MiB      0.0 MiB         351                       open_set.put((f_score[neighbor], count, neighbor))
    77    116.4 MiB      0.0 MiB         351                       open_set_hash.add(neighbor)
    78                                                             
    79    116.4 MiB      0.0 MiB         254           if draw is not None:
    80                                                     draw()
    81                                         
    82    116.4 MiB      0.0 MiB         254           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    116.4 MiB    116.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    116.4 MiB      0.0 MiB         257       for row in grid:
    30    116.4 MiB      0.0 MiB       65792           for spot in row:
    31    116.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    116.4 MiB      0.0 MiB           1       count = 0
    34    116.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    116.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    116.4 MiB      0.0 MiB           1       came_from = {}
    37    116.9 MiB      0.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    116.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    120.7 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    120.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    120.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    120.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    120.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    120.7 MiB  -7546.1 MiB       10670       while not open_set.empty():
    47    120.7 MiB  -7546.1 MiB       10670           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    120.7 MiB  -7546.1 MiB       10670           current = open_set.get()[2]
    53    120.7 MiB  -7546.1 MiB       10670           open_set_hash.remove(current)
    54                                         
    55    120.7 MiB  -7546.1 MiB       10670           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    120.7 MiB  -7546.1 MiB       10670           if current == end:
    60    119.5 MiB     -1.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    119.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    120.7 MiB -67910.1 MiB       96021           for neighbor in current.neighbors:
    65    120.7 MiB -60364.4 MiB       85352               if current.row != neighbor.row and current.col != neighbor.col:
    66    120.7 MiB -30183.7 MiB       42676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    120.7 MiB -30180.9 MiB       42676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    120.7 MiB -60364.9 MiB       85352               if temp_g_score < g_score[neighbor]:
    71    120.7 MiB  -7825.0 MiB       11276                   came_from[neighbor] = current
    72    120.7 MiB  -7825.0 MiB       11276                   g_score[neighbor] = temp_g_score
    73    120.7 MiB  -7825.0 MiB       11276                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    120.7 MiB  -7825.0 MiB       11276                   if neighbor not in open_set_hash:
    75    120.7 MiB  -7825.0 MiB       11276                       count += 1
    76    120.7 MiB  -7825.0 MiB       11276                       open_set.put((f_score[neighbor], count, neighbor))
    77    120.7 MiB  -7825.0 MiB       11276                       open_set_hash.add(neighbor)
    78                                                             
    79    120.7 MiB  -7546.1 MiB       10669           if draw is not None:
    80                                                     draw()
    81                                         
    82    120.7 MiB  -7546.1 MiB       10669           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    119.5 MiB    119.5 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    119.5 MiB      0.0 MiB         257       for row in grid:
    30    119.5 MiB      0.0 MiB       65792           for spot in row:
    31    119.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    119.5 MiB      0.0 MiB           1       count = 0
    34    119.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    119.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    119.5 MiB      0.0 MiB           1       came_from = {}
    37    119.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    119.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    121.0 MiB      1.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    121.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    121.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    121.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    121.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    121.0 MiB      0.0 MiB        1608       while not open_set.empty():
    47    121.0 MiB      0.0 MiB        1608           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    121.0 MiB      0.0 MiB        1608           current = open_set.get()[2]
    53    121.0 MiB      0.0 MiB        1608           open_set_hash.remove(current)
    54                                         
    55    121.0 MiB      0.0 MiB        1608           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    121.0 MiB      0.0 MiB        1608           if current == end:
    60    121.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    121.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    121.0 MiB      0.0 MiB       14463           for neighbor in current.neighbors:
    65    121.0 MiB      0.0 MiB       12856               if current.row != neighbor.row and current.col != neighbor.col:
    66    121.0 MiB      0.0 MiB        6428                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    121.0 MiB      0.0 MiB        6428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    121.0 MiB      0.0 MiB       12856               if temp_g_score < g_score[neighbor]:
    71    121.0 MiB      0.0 MiB        1836                   came_from[neighbor] = current
    72    121.0 MiB      0.0 MiB        1836                   g_score[neighbor] = temp_g_score
    73    121.0 MiB      0.0 MiB        1836                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    121.0 MiB      0.0 MiB        1836                   if neighbor not in open_set_hash:
    75    121.0 MiB      0.0 MiB        1836                       count += 1
    76    121.0 MiB      0.0 MiB        1836                       open_set.put((f_score[neighbor], count, neighbor))
    77    121.0 MiB      0.0 MiB        1836                       open_set_hash.add(neighbor)
    78                                                             
    79    121.0 MiB      0.0 MiB        1607           if draw is not None:
    80                                                     draw()
    81                                         
    82    121.0 MiB      0.0 MiB        1607           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    121.1 MiB    121.1 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    121.1 MiB   -148.0 MiB         257       for row in grid:
    30    121.1 MiB -37987.3 MiB       65792           for spot in row:
    31    121.1 MiB -37839.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    120.5 MiB     -0.6 MiB           1       count = 0
    34    120.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    120.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    120.5 MiB      0.0 MiB           1       came_from = {}
    37    120.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    120.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    120.5 MiB -137259.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    118.4 MiB     -2.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    118.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    118.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    118.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    118.4 MiB      0.0 MiB         665       while not open_set.empty():
    47    118.4 MiB      0.0 MiB         665           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    118.4 MiB      0.0 MiB         665           current = open_set.get()[2]
    53    118.4 MiB      0.0 MiB         665           open_set_hash.remove(current)
    54                                         
    55    118.4 MiB      0.0 MiB         665           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    118.4 MiB      0.0 MiB         665           if current == end:
    60    118.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    118.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    118.4 MiB      0.0 MiB        5976           for neighbor in current.neighbors:
    65    118.4 MiB      0.0 MiB        5312               if current.row != neighbor.row and current.col != neighbor.col:
    66    118.4 MiB      0.0 MiB        2656                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    118.4 MiB      0.0 MiB        2656                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    118.4 MiB      0.0 MiB        5312               if temp_g_score < g_score[neighbor]:
    71    118.4 MiB      0.0 MiB         881                   came_from[neighbor] = current
    72    118.4 MiB      0.0 MiB         881                   g_score[neighbor] = temp_g_score
    73    118.4 MiB      0.0 MiB         881                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    118.4 MiB      0.0 MiB         881                   if neighbor not in open_set_hash:
    75    118.4 MiB      0.0 MiB         881                       count += 1
    76    118.4 MiB      0.0 MiB         881                       open_set.put((f_score[neighbor], count, neighbor))
    77    118.4 MiB      0.0 MiB         881                       open_set_hash.add(neighbor)
    78                                                             
    79    118.4 MiB      0.0 MiB         664           if draw is not None:
    80                                                     draw()
    81                                         
    82    118.4 MiB      0.0 MiB         664           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.4 MiB    118.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.4 MiB   -124.2 MiB         257       for row in grid:
    30    118.4 MiB -30544.0 MiB       65792           for spot in row:
    31    118.4 MiB -30425.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.7 MiB     -7.8 MiB           1       count = 0
    34    110.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.7 MiB      0.0 MiB           1       came_from = {}
    37    113.5 MiB      2.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    113.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    115.1 MiB      1.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    115.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    115.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    115.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    115.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    115.3 MiB      0.0 MiB        4026       while not open_set.empty():
    47    115.3 MiB      0.0 MiB        4026           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    115.3 MiB      0.0 MiB        4026           current = open_set.get()[2]
    53    115.3 MiB      0.0 MiB        4026           open_set_hash.remove(current)
    54                                         
    55    115.3 MiB      0.0 MiB        4026           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    115.3 MiB      0.0 MiB        4026           if current == end:
    60    115.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    115.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    115.3 MiB      0.0 MiB       36222           for neighbor in current.neighbors:
    65    115.3 MiB      0.0 MiB       32197               if current.row != neighbor.row and current.col != neighbor.col:
    66    115.3 MiB      0.0 MiB       16098                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    115.3 MiB      0.0 MiB       16099                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    115.3 MiB      0.0 MiB       32197               if temp_g_score < g_score[neighbor]:
    71    115.3 MiB      0.2 MiB        4407                   came_from[neighbor] = current
    72    115.3 MiB      0.0 MiB        4407                   g_score[neighbor] = temp_g_score
    73    115.3 MiB      0.0 MiB        4407                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    115.3 MiB      0.0 MiB        4407                   if neighbor not in open_set_hash:
    75    115.3 MiB      0.0 MiB        4407                       count += 1
    76    115.3 MiB      0.0 MiB        4407                       open_set.put((f_score[neighbor], count, neighbor))
    77    115.3 MiB      0.0 MiB        4407                       open_set_hash.add(neighbor)
    78                                                             
    79    115.3 MiB      0.0 MiB        4025           if draw is not None:
    80                                                     draw()
    81                                         
    82    115.3 MiB      0.0 MiB        4025           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    115.5 MiB    115.5 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    115.5 MiB      0.0 MiB         257       for row in grid:
    30    115.5 MiB      0.0 MiB       65792           for spot in row:
    31    115.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    115.5 MiB      0.0 MiB           1       count = 0
    34    115.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    115.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    115.5 MiB      0.0 MiB           1       came_from = {}
    37    118.0 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    118.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    120.3 MiB      2.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    120.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    120.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    120.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    120.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    120.3 MiB      0.0 MiB        2652       while not open_set.empty():
    47    120.3 MiB      0.0 MiB        2652           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    120.3 MiB      0.0 MiB        2652           current = open_set.get()[2]
    53    120.3 MiB      0.0 MiB        2652           open_set_hash.remove(current)
    54                                         
    55    120.3 MiB      0.0 MiB        2652           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    120.3 MiB      0.0 MiB        2652           if current == end:
    60    120.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    120.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    120.3 MiB      0.0 MiB       23859           for neighbor in current.neighbors:
    65    120.3 MiB      0.0 MiB       21208               if current.row != neighbor.row and current.col != neighbor.col:
    66    120.3 MiB      0.0 MiB       10604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    120.3 MiB      0.0 MiB       10604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    120.3 MiB      0.0 MiB       21208               if temp_g_score < g_score[neighbor]:
    71    120.3 MiB      0.0 MiB        2960                   came_from[neighbor] = current
    72    120.3 MiB      0.0 MiB        2960                   g_score[neighbor] = temp_g_score
    73    120.3 MiB      0.0 MiB        2960                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    120.3 MiB      0.0 MiB        2960                   if neighbor not in open_set_hash:
    75    120.3 MiB      0.0 MiB        2960                       count += 1
    76    120.3 MiB      0.0 MiB        2960                       open_set.put((f_score[neighbor], count, neighbor))
    77    120.3 MiB      0.0 MiB        2960                       open_set_hash.add(neighbor)
    78                                                             
    79    120.3 MiB      0.0 MiB        2651           if draw is not None:
    80                                                     draw()
    81                                         
    82    120.3 MiB      0.0 MiB        2651           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    120.3 MiB    120.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    120.3 MiB   -463.9 MiB         257       for row in grid:
    30    120.3 MiB -119111.0 MiB       65792           for spot in row:
    31    120.3 MiB -118648.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    118.2 MiB     -2.1 MiB           1       count = 0
    34    118.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    118.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    118.2 MiB      0.0 MiB           1       came_from = {}
    37    118.9 MiB      0.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    118.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    119.5 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    119.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    119.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    119.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    119.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    119.5 MiB  -7960.5 MiB        6634       while not open_set.empty():
    47    119.5 MiB  -7960.5 MiB        6634           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    119.5 MiB  -7960.5 MiB        6634           current = open_set.get()[2]
    53    119.5 MiB  -7960.5 MiB        6634           open_set_hash.remove(current)
    54                                         
    55    119.5 MiB  -7960.5 MiB        6634           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    119.5 MiB  -7960.5 MiB        6634           if current == end:
    60    118.0 MiB     -1.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    118.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    119.5 MiB -71641.0 MiB       59697           for neighbor in current.neighbors:
    65    119.5 MiB -63680.7 MiB       53064               if current.row != neighbor.row and current.col != neighbor.col:
    66    119.5 MiB -31842.0 MiB       26532                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    119.5 MiB -31838.9 MiB       26532                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    119.5 MiB -63681.0 MiB       53064               if temp_g_score < g_score[neighbor]:
    71    119.5 MiB  -8475.0 MiB        7184                   came_from[neighbor] = current
    72    119.5 MiB  -8475.0 MiB        7184                   g_score[neighbor] = temp_g_score
    73    119.5 MiB  -8475.0 MiB        7184                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    119.5 MiB  -8475.1 MiB        7184                   if neighbor not in open_set_hash:
    75    119.5 MiB  -8475.3 MiB        7184                       count += 1
    76    119.5 MiB  -8475.7 MiB        7184                       open_set.put((f_score[neighbor], count, neighbor))
    77    119.5 MiB  -8475.9 MiB        7184                       open_set_hash.add(neighbor)
    78                                                             
    79    119.5 MiB  -7960.5 MiB        6633           if draw is not None:
    80                                                     draw()
    81                                         
    82    119.5 MiB  -7960.5 MiB        6633           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    118.0 MiB    118.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    118.0 MiB      0.0 MiB         257       for row in grid:
    30    118.0 MiB      0.0 MiB       65792           for spot in row:
    31    118.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    118.0 MiB      0.0 MiB           1       count = 0
    34    118.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    118.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    118.0 MiB      0.0 MiB           1       came_from = {}
    37    119.5 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    119.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    121.9 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    121.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    121.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    121.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    121.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    121.9 MiB      0.0 MiB        2403       while not open_set.empty():
    47    121.9 MiB      0.0 MiB        2403           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    121.9 MiB      0.0 MiB        2403           current = open_set.get()[2]
    53    121.9 MiB      0.0 MiB        2403           open_set_hash.remove(current)
    54                                         
    55    121.9 MiB      0.0 MiB        2403           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    121.9 MiB      0.0 MiB        2403           if current == end:
    60    121.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    121.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    121.9 MiB      0.0 MiB       21618           for neighbor in current.neighbors:
    65    121.9 MiB      0.0 MiB       19216               if current.row != neighbor.row and current.col != neighbor.col:
    66    121.9 MiB      0.0 MiB        9608                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    121.9 MiB      0.0 MiB        9608                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    121.9 MiB      0.0 MiB       19216               if temp_g_score < g_score[neighbor]:
    71    121.9 MiB      0.0 MiB        2687                   came_from[neighbor] = current
    72    121.9 MiB      0.0 MiB        2687                   g_score[neighbor] = temp_g_score
    73    121.9 MiB      0.0 MiB        2687                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    121.9 MiB      0.0 MiB        2687                   if neighbor not in open_set_hash:
    75    121.9 MiB      0.0 MiB        2687                       count += 1
    76    121.9 MiB      0.0 MiB        2687                       open_set.put((f_score[neighbor], count, neighbor))
    77    121.9 MiB      0.0 MiB        2687                       open_set_hash.add(neighbor)
    78                                                             
    79    121.9 MiB      0.0 MiB        2402           if draw is not None:
    80                                                     draw()
    81                                         
    82    121.9 MiB      0.0 MiB        2402           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    121.9 MiB    121.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    121.9 MiB      0.0 MiB         257       for row in grid:
    30    121.9 MiB      0.0 MiB       65792           for spot in row:
    31    121.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    121.9 MiB      0.0 MiB           1       count = 0
    34    121.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    121.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    121.9 MiB      0.0 MiB           1       came_from = {}
    37    123.0 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    123.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    123.2 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    123.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    123.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    123.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    123.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    123.2 MiB      0.0 MiB         588       while not open_set.empty():
    47    123.2 MiB      0.0 MiB         588           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    123.2 MiB      0.0 MiB         588           current = open_set.get()[2]
    53    123.2 MiB      0.0 MiB         588           open_set_hash.remove(current)
    54                                         
    55    123.2 MiB      0.0 MiB         588           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    123.2 MiB      0.0 MiB         588           if current == end:
    60    123.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    123.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    123.2 MiB      0.0 MiB        5283           for neighbor in current.neighbors:
    65    123.2 MiB      0.0 MiB        4696               if current.row != neighbor.row and current.col != neighbor.col:
    66    123.2 MiB      0.0 MiB        2348                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    123.2 MiB      0.0 MiB        2348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    123.2 MiB      0.0 MiB        4696               if temp_g_score < g_score[neighbor]:
    71    123.2 MiB      0.0 MiB         726                   came_from[neighbor] = current
    72    123.2 MiB      0.0 MiB         726                   g_score[neighbor] = temp_g_score
    73    123.2 MiB      0.0 MiB         726                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    123.2 MiB      0.0 MiB         726                   if neighbor not in open_set_hash:
    75    123.2 MiB      0.0 MiB         726                       count += 1
    76    123.2 MiB      0.0 MiB         726                       open_set.put((f_score[neighbor], count, neighbor))
    77    123.2 MiB      0.0 MiB         726                       open_set_hash.add(neighbor)
    78                                                             
    79    123.2 MiB      0.0 MiB         587           if draw is not None:
    80                                                     draw()
    81                                         
    82    123.2 MiB      0.0 MiB         587           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    123.2 MiB    123.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    123.2 MiB   -407.8 MiB         257       for row in grid:
    30    123.2 MiB -103454.8 MiB       65792           for spot in row:
    31    123.2 MiB -103055.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    110.7 MiB    -12.5 MiB           1       count = 0
    34    110.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    110.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    110.7 MiB      0.0 MiB           1       came_from = {}
    37    111.7 MiB      1.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.8 MiB      1.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.8 MiB      0.0 MiB        4995       while not open_set.empty():
    47    112.8 MiB      0.0 MiB        4995           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.8 MiB      0.0 MiB        4995           current = open_set.get()[2]
    53    112.8 MiB      0.0 MiB        4995           open_set_hash.remove(current)
    54                                         
    55    112.8 MiB      0.0 MiB        4995           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.8 MiB      0.0 MiB        4995           if current == end:
    60    112.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    112.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.8 MiB      0.0 MiB       44946           for neighbor in current.neighbors:
    65    112.8 MiB      0.0 MiB       39952               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.8 MiB      0.0 MiB       19976                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.8 MiB      0.0 MiB       19976                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.8 MiB      0.0 MiB       39952               if temp_g_score < g_score[neighbor]:
    71    112.8 MiB      0.0 MiB        5607                   came_from[neighbor] = current
    72    112.8 MiB      0.0 MiB        5607                   g_score[neighbor] = temp_g_score
    73    112.8 MiB      0.0 MiB        5607                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.8 MiB      0.0 MiB        5607                   if neighbor not in open_set_hash:
    75    112.8 MiB      0.0 MiB        5607                       count += 1
    76    112.8 MiB      0.0 MiB        5607                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.8 MiB      0.0 MiB        5607                       open_set_hash.add(neighbor)
    78                                                             
    79    112.8 MiB      0.0 MiB        4994           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.8 MiB      0.0 MiB        4994           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.9 MiB    112.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.9 MiB      0.0 MiB         257       for row in grid:
    30    112.9 MiB      0.0 MiB       65792           for spot in row:
    31    112.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    112.9 MiB      0.0 MiB           1       count = 0
    34    112.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    112.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    112.9 MiB      0.0 MiB           1       came_from = {}
    37    117.1 MiB      4.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    117.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    120.9 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    120.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    120.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    120.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    120.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    120.9 MiB      0.0 MiB        4256       while not open_set.empty():
    47    120.9 MiB      0.0 MiB        4256           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    120.9 MiB      0.0 MiB        4256           current = open_set.get()[2]
    53    120.9 MiB      0.0 MiB        4256           open_set_hash.remove(current)
    54                                         
    55    120.9 MiB      0.0 MiB        4256           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    120.9 MiB      0.0 MiB        4256           if current == end:
    60    120.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    120.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    120.9 MiB      0.0 MiB       38295           for neighbor in current.neighbors:
    65    120.9 MiB      0.0 MiB       34040               if current.row != neighbor.row and current.col != neighbor.col:
    66    120.9 MiB      0.0 MiB       17020                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    120.9 MiB      0.0 MiB       17020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    120.9 MiB      0.0 MiB       34040               if temp_g_score < g_score[neighbor]:
    71    120.9 MiB      0.0 MiB        4918                   came_from[neighbor] = current
    72    120.9 MiB      0.0 MiB        4918                   g_score[neighbor] = temp_g_score
    73    120.9 MiB      0.0 MiB        4918                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    120.9 MiB      0.0 MiB        4918                   if neighbor not in open_set_hash:
    75    120.9 MiB      0.0 MiB        4918                       count += 1
    76    120.9 MiB      0.0 MiB        4918                       open_set.put((f_score[neighbor], count, neighbor))
    77    120.9 MiB      0.0 MiB        4918                       open_set_hash.add(neighbor)
    78                                                             
    79    120.9 MiB      0.0 MiB        4255           if draw is not None:
    80                                                     draw()
    81                                         
    82    120.9 MiB      0.0 MiB        4255           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    120.9 MiB    120.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    120.9 MiB      0.0 MiB         257       for row in grid:
    30    120.9 MiB      0.0 MiB       65792           for spot in row:
    31    120.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    120.9 MiB      0.0 MiB           1       count = 0
    34    120.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    120.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    120.9 MiB      0.0 MiB           1       came_from = {}
    37    121.1 MiB      0.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    121.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    123.0 MiB -21812.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    123.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    123.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    123.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    123.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    123.0 MiB      0.0 MiB        5952       while not open_set.empty():
    47    123.0 MiB      0.0 MiB        5952           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    123.0 MiB      0.0 MiB        5952           current = open_set.get()[2]
    53    123.0 MiB      0.0 MiB        5952           open_set_hash.remove(current)
    54                                         
    55    123.0 MiB      0.0 MiB        5952           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    123.0 MiB      0.0 MiB        5952           if current == end:
    60    123.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    123.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    123.0 MiB      0.0 MiB       53559           for neighbor in current.neighbors:
    65    123.0 MiB      0.0 MiB       47608               if current.row != neighbor.row and current.col != neighbor.col:
    66    123.0 MiB      0.0 MiB       23804                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    123.0 MiB      0.0 MiB       23804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    123.0 MiB      0.0 MiB       47608               if temp_g_score < g_score[neighbor]:
    71    123.0 MiB      0.0 MiB        6450                   came_from[neighbor] = current
    72    123.0 MiB      0.0 MiB        6450                   g_score[neighbor] = temp_g_score
    73    123.0 MiB      0.0 MiB        6450                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    123.0 MiB      0.0 MiB        6450                   if neighbor not in open_set_hash:
    75    123.0 MiB      0.0 MiB        6450                       count += 1
    76    123.0 MiB      0.0 MiB        6450                       open_set.put((f_score[neighbor], count, neighbor))
    77    123.0 MiB      0.0 MiB        6450                       open_set_hash.add(neighbor)
    78                                                             
    79    123.0 MiB      0.0 MiB        5951           if draw is not None:
    80                                                     draw()
    81                                         
    82    123.0 MiB      0.0 MiB        5951           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    123.0 MiB    123.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    123.0 MiB      0.0 MiB         257       for row in grid:
    30    123.0 MiB      0.0 MiB       65792           for spot in row:
    31    123.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    123.0 MiB      0.0 MiB           1       count = 0
    34    123.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    123.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    123.0 MiB      0.0 MiB           1       came_from = {}
    37    125.2 MiB      2.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    125.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    129.0 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    129.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    129.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    129.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    129.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    129.0 MiB      0.0 MiB        6930       while not open_set.empty():
    47    129.0 MiB      0.0 MiB        6930           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    129.0 MiB      0.0 MiB        6930           current = open_set.get()[2]
    53    129.0 MiB      0.0 MiB        6930           open_set_hash.remove(current)
    54                                         
    55    129.0 MiB      0.0 MiB        6930           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    129.0 MiB      0.0 MiB        6930           if current == end:
    60    129.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    129.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    129.0 MiB      0.0 MiB       62361           for neighbor in current.neighbors:
    65    129.0 MiB      0.0 MiB       55432               if current.row != neighbor.row and current.col != neighbor.col:
    66    129.0 MiB      0.0 MiB       27716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    129.0 MiB      0.0 MiB       27716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    129.0 MiB      0.0 MiB       55432               if temp_g_score < g_score[neighbor]:
    71    129.0 MiB      0.0 MiB        7402                   came_from[neighbor] = current
    72    129.0 MiB      0.0 MiB        7402                   g_score[neighbor] = temp_g_score
    73    129.0 MiB      0.0 MiB        7402                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    129.0 MiB      0.0 MiB        7402                   if neighbor not in open_set_hash:
    75    129.0 MiB      0.0 MiB        7402                       count += 1
    76    129.0 MiB      0.0 MiB        7402                       open_set.put((f_score[neighbor], count, neighbor))
    77    129.0 MiB      0.0 MiB        7402                       open_set_hash.add(neighbor)
    78                                                             
    79    129.0 MiB      0.0 MiB        6929           if draw is not None:
    80                                                     draw()
    81                                         
    82    129.0 MiB      0.0 MiB        6929           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    129.4 MiB    129.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    129.4 MiB      0.0 MiB         257       for row in grid:
    30    129.4 MiB      0.0 MiB       65792           for spot in row:
    31    129.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    129.4 MiB      0.0 MiB           1       count = 0
    34    129.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    129.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    129.4 MiB      0.0 MiB           1       came_from = {}
    37    129.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    129.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    131.8 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    131.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    131.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    131.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    131.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    131.8 MiB      0.0 MiB        2208       while not open_set.empty():
    47    131.8 MiB      0.0 MiB        2208           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    131.8 MiB      0.0 MiB        2208           current = open_set.get()[2]
    53    131.8 MiB      0.0 MiB        2208           open_set_hash.remove(current)
    54                                         
    55    131.8 MiB      0.0 MiB        2208           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    131.8 MiB      0.0 MiB        2208           if current == end:
    60    131.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    131.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    131.8 MiB      0.0 MiB       19863           for neighbor in current.neighbors:
    65    131.8 MiB      0.0 MiB       17656               if current.row != neighbor.row and current.col != neighbor.col:
    66    131.8 MiB      0.0 MiB        8828                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    131.8 MiB      0.0 MiB        8828                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    131.8 MiB      0.0 MiB       17656               if temp_g_score < g_score[neighbor]:
    71    131.8 MiB      0.0 MiB        2622                   came_from[neighbor] = current
    72    131.8 MiB      0.0 MiB        2622                   g_score[neighbor] = temp_g_score
    73    131.8 MiB      0.0 MiB        2622                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    131.8 MiB      0.0 MiB        2622                   if neighbor not in open_set_hash:
    75    131.8 MiB      0.0 MiB        2622                       count += 1
    76    131.8 MiB      0.0 MiB        2622                       open_set.put((f_score[neighbor], count, neighbor))
    77    131.8 MiB      0.0 MiB        2622                       open_set_hash.add(neighbor)
    78                                                             
    79    131.8 MiB      0.0 MiB        2207           if draw is not None:
    80                                                     draw()
    81                                         
    82    131.8 MiB      0.0 MiB        2207           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    132.1 MiB    132.1 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    132.1 MiB      0.0 MiB         257       for row in grid:
    30    132.1 MiB      0.0 MiB       65792           for spot in row:
    31    132.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    132.1 MiB      0.0 MiB           1       count = 0
    34    132.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    132.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    132.1 MiB      0.0 MiB           1       came_from = {}
    37    132.1 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    132.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    132.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    132.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    132.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    132.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    132.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    132.2 MiB      0.0 MiB        5074       while not open_set.empty():
    47    132.2 MiB      0.0 MiB        5074           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    132.2 MiB      0.0 MiB        5074           current = open_set.get()[2]
    53    132.2 MiB      0.0 MiB        5074           open_set_hash.remove(current)
    54                                         
    55    132.2 MiB      0.0 MiB        5074           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    132.2 MiB      0.0 MiB        5074           if current == end:
    60    132.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    132.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    132.2 MiB      0.0 MiB       45657           for neighbor in current.neighbors:
    65    132.2 MiB      0.0 MiB       40584               if current.row != neighbor.row and current.col != neighbor.col:
    66    132.2 MiB      0.0 MiB       20292                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    132.2 MiB      0.0 MiB       20292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    132.2 MiB      0.0 MiB       40584               if temp_g_score < g_score[neighbor]:
    71    132.2 MiB      0.0 MiB        5630                   came_from[neighbor] = current
    72    132.2 MiB      0.0 MiB        5630                   g_score[neighbor] = temp_g_score
    73    132.2 MiB      0.0 MiB        5630                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    132.2 MiB      0.0 MiB        5630                   if neighbor not in open_set_hash:
    75    132.2 MiB      0.0 MiB        5630                       count += 1
    76    132.2 MiB      0.0 MiB        5630                       open_set.put((f_score[neighbor], count, neighbor))
    77    132.2 MiB      0.0 MiB        5630                       open_set_hash.add(neighbor)
    78                                                             
    79    132.2 MiB      0.0 MiB        5073           if draw is not None:
    80                                                     draw()
    81                                         
    82    132.2 MiB      0.0 MiB        5073           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    132.5 MiB    132.5 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    132.5 MiB      0.0 MiB         257       for row in grid:
    30    132.5 MiB      0.0 MiB       65792           for spot in row:
    31    132.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    132.5 MiB      0.0 MiB           1       count = 0
    34    132.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    132.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    132.5 MiB      0.0 MiB           1       came_from = {}
    37    132.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    132.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    132.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    132.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    132.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    132.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    132.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    132.5 MiB      0.0 MiB        2352       while not open_set.empty():
    47    132.5 MiB      0.0 MiB        2352           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    132.5 MiB      0.0 MiB        2352           current = open_set.get()[2]
    53    132.5 MiB      0.0 MiB        2352           open_set_hash.remove(current)
    54                                         
    55    132.5 MiB      0.0 MiB        2352           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    132.5 MiB      0.0 MiB        2352           if current == end:
    60    132.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    132.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    132.5 MiB      0.0 MiB       21159           for neighbor in current.neighbors:
    65    132.5 MiB      0.0 MiB       18808               if current.row != neighbor.row and current.col != neighbor.col:
    66    132.5 MiB      0.0 MiB        9404                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    132.5 MiB      0.0 MiB        9404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    132.5 MiB      0.0 MiB       18808               if temp_g_score < g_score[neighbor]:
    71    132.5 MiB      0.0 MiB        2640                   came_from[neighbor] = current
    72    132.5 MiB      0.0 MiB        2640                   g_score[neighbor] = temp_g_score
    73    132.5 MiB      0.0 MiB        2640                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    132.5 MiB      0.0 MiB        2640                   if neighbor not in open_set_hash:
    75    132.5 MiB      0.0 MiB        2640                       count += 1
    76    132.5 MiB      0.0 MiB        2640                       open_set.put((f_score[neighbor], count, neighbor))
    77    132.5 MiB      0.0 MiB        2640                       open_set_hash.add(neighbor)
    78                                                             
    79    132.5 MiB      0.0 MiB        2351           if draw is not None:
    80                                                     draw()
    81                                         
    82    132.5 MiB      0.0 MiB        2351           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


