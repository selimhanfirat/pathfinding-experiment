Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     52.0 MiB     52.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     53.0 MiB      0.0 MiB         129       for row in grid:
    30     53.0 MiB      0.0 MiB       16512           for spot in row:
    31     53.0 MiB      0.9 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     53.0 MiB      0.0 MiB           1       count = 0
    34     53.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     53.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     53.0 MiB      0.0 MiB           1       came_from = {}
    37     54.4 MiB      1.4 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     54.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     55.8 MiB      1.4 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     55.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     55.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     55.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     55.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.8 MiB      0.0 MiB          40       while not open_set.empty():
    47     55.8 MiB      0.0 MiB          40           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.8 MiB      0.0 MiB          40           current = open_set.get()[2]
    53     55.8 MiB      0.0 MiB          40           open_set_hash.remove(current)
    54                                         
    55     55.8 MiB      0.0 MiB          40           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.8 MiB      0.0 MiB          40           if current == end:
    60     55.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.8 MiB      0.0 MiB         351           for neighbor in current.neighbors:
    65     55.8 MiB      0.0 MiB         312               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.8 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.8 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.8 MiB      0.0 MiB         312               if temp_g_score < g_score[neighbor]:
    71     55.8 MiB      0.0 MiB          86                   came_from[neighbor] = current
    72     55.8 MiB      0.0 MiB          86                   g_score[neighbor] = temp_g_score
    73     55.8 MiB      0.0 MiB          86                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.8 MiB      0.0 MiB          86                   if neighbor not in open_set_hash:
    75     55.8 MiB      0.0 MiB          86                       count += 1
    76     55.8 MiB      0.0 MiB          86                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.8 MiB      0.0 MiB          86                       open_set_hash.add(neighbor)
    78                                                             
    79     55.8 MiB      0.0 MiB          39           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.8 MiB      0.0 MiB          39           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     59.8 MiB     59.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     60.8 MiB      0.0 MiB         129       for row in grid:
    30     60.8 MiB      0.0 MiB       16512           for spot in row:
    31     60.8 MiB      1.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     60.8 MiB      0.0 MiB           1       count = 0
    34     60.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     60.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     60.8 MiB      0.0 MiB           1       came_from = {}
    37     61.8 MiB      1.1 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     61.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     62.4 MiB      0.5 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.4 MiB      0.0 MiB         108       while not open_set.empty():
    47     62.4 MiB      0.0 MiB         108           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.4 MiB      0.0 MiB         108           current = open_set.get()[2]
    53     62.4 MiB      0.0 MiB         108           open_set_hash.remove(current)
    54                                         
    55     62.4 MiB      0.0 MiB         108           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.4 MiB      0.0 MiB         108           if current == end:
    60     62.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.4 MiB      0.0 MiB         963           for neighbor in current.neighbors:
    65     62.4 MiB      0.0 MiB         856               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.4 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.4 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.4 MiB      0.0 MiB         856               if temp_g_score < g_score[neighbor]:
    71     62.4 MiB      0.0 MiB         166                   came_from[neighbor] = current
    72     62.4 MiB      0.0 MiB         166                   g_score[neighbor] = temp_g_score
    73     62.4 MiB      0.0 MiB         166                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.4 MiB      0.0 MiB         166                   if neighbor not in open_set_hash:
    75     62.4 MiB      0.0 MiB         166                       count += 1
    76     62.4 MiB      0.0 MiB         166                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.4 MiB      0.0 MiB         166                       open_set_hash.add(neighbor)
    78                                                             
    79     62.4 MiB      0.0 MiB         107           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.4 MiB      0.0 MiB         107           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     63.5 MiB     63.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     63.5 MiB      0.0 MiB         129       for row in grid:
    30     63.5 MiB      0.0 MiB       16512           for spot in row:
    31     63.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     63.5 MiB      0.0 MiB           1       count = 0
    34     63.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     63.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     63.5 MiB      0.0 MiB           1       came_from = {}
    37     63.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     64.5 MiB      1.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     64.5 MiB      0.0 MiB        1014       while not open_set.empty():
    47     64.5 MiB      0.0 MiB        1014           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     64.5 MiB      0.0 MiB        1014           current = open_set.get()[2]
    53     64.5 MiB      0.0 MiB        1014           open_set_hash.remove(current)
    54                                         
    55     64.5 MiB      0.0 MiB        1014           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     64.5 MiB      0.0 MiB        1014           if current == end:
    60     64.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     64.5 MiB      0.0 MiB        9117           for neighbor in current.neighbors:
    65     64.5 MiB      0.0 MiB        8104               if current.row != neighbor.row and current.col != neighbor.col:
    66     64.5 MiB      0.0 MiB        4052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     64.5 MiB      0.0 MiB        4052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     64.5 MiB      0.0 MiB        8104               if temp_g_score < g_score[neighbor]:
    71     64.5 MiB      0.0 MiB        1220                   came_from[neighbor] = current
    72     64.5 MiB      0.0 MiB        1220                   g_score[neighbor] = temp_g_score
    73     64.5 MiB      0.0 MiB        1220                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     64.5 MiB      0.0 MiB        1220                   if neighbor not in open_set_hash:
    75     64.5 MiB      0.0 MiB        1220                       count += 1
    76     64.5 MiB      0.0 MiB        1220                       open_set.put((f_score[neighbor], count, neighbor))
    77     64.5 MiB      0.0 MiB        1220                       open_set_hash.add(neighbor)
    78                                                             
    79     64.5 MiB      0.0 MiB        1013           if draw is not None:
    80                                                     draw()
    81                                         
    82     64.5 MiB      0.0 MiB        1013           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.3 MiB     67.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.3 MiB      0.0 MiB         129       for row in grid:
    30     68.3 MiB      0.0 MiB       16512           for spot in row:
    31     68.3 MiB      1.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     68.3 MiB      0.0 MiB           1       count = 0
    34     68.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     68.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     68.3 MiB      0.0 MiB           1       came_from = {}
    37     68.8 MiB      0.5 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.2 MiB      1.4 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.2 MiB      0.0 MiB         224       while not open_set.empty():
    47     70.2 MiB      0.0 MiB         224           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.2 MiB      0.0 MiB         224           current = open_set.get()[2]
    53     70.2 MiB      0.0 MiB         224           open_set_hash.remove(current)
    54                                         
    55     70.2 MiB      0.0 MiB         224           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.2 MiB      0.0 MiB         224           if current == end:
    60     70.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.2 MiB      0.0 MiB        2007           for neighbor in current.neighbors:
    65     70.2 MiB      0.0 MiB        1784               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.2 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.2 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.2 MiB      0.0 MiB        1784               if temp_g_score < g_score[neighbor]:
    71     70.2 MiB      0.0 MiB         310                   came_from[neighbor] = current
    72     70.2 MiB      0.0 MiB         310                   g_score[neighbor] = temp_g_score
    73     70.2 MiB      0.0 MiB         310                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.2 MiB      0.0 MiB         310                   if neighbor not in open_set_hash:
    75     70.2 MiB      0.0 MiB         310                       count += 1
    76     70.2 MiB      0.0 MiB         310                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.2 MiB      0.0 MiB         310                       open_set_hash.add(neighbor)
    78                                                             
    79     70.2 MiB      0.0 MiB         223           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.2 MiB      0.0 MiB         223           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.5 MiB     69.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.5 MiB      0.0 MiB         129       for row in grid:
    30     69.5 MiB      0.0 MiB       16512           for spot in row:
    31     69.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     69.5 MiB      0.0 MiB           1       count = 0
    34     69.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     69.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     69.5 MiB      0.0 MiB           1       came_from = {}
    37     69.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     69.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     69.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.5 MiB      0.0 MiB         225       while not open_set.empty():
    47     69.5 MiB      0.0 MiB         225           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.5 MiB      0.0 MiB         225           current = open_set.get()[2]
    53     69.5 MiB      0.0 MiB         225           open_set_hash.remove(current)
    54                                         
    55     69.5 MiB      0.0 MiB         225           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.5 MiB      0.0 MiB         225           if current == end:
    60     69.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.5 MiB      0.0 MiB        2016           for neighbor in current.neighbors:
    65     69.5 MiB      0.0 MiB        1792               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.5 MiB      0.0 MiB         896                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.5 MiB      0.0 MiB         896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.5 MiB      0.0 MiB        1792               if temp_g_score < g_score[neighbor]:
    71     69.5 MiB      0.0 MiB         529                   came_from[neighbor] = current
    72     69.5 MiB      0.0 MiB         529                   g_score[neighbor] = temp_g_score
    73     69.5 MiB      0.0 MiB         529                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.5 MiB      0.0 MiB         529                   if neighbor not in open_set_hash:
    75     69.5 MiB      0.0 MiB         529                       count += 1
    76     69.5 MiB      0.0 MiB         529                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.5 MiB      0.0 MiB         529                       open_set_hash.add(neighbor)
    78                                                             
    79     69.5 MiB      0.0 MiB         224           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.5 MiB      0.0 MiB         224           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     69.6 MiB     69.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.6 MiB      0.0 MiB         129       for row in grid:
    30     69.6 MiB      0.0 MiB       16512           for spot in row:
    31     69.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     69.6 MiB      0.0 MiB           1       count = 0
    34     69.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     69.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     69.6 MiB      0.0 MiB           1       came_from = {}
    37     70.4 MiB      0.9 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.9 MiB      0.5 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.9 MiB      0.0 MiB        1408       while not open_set.empty():
    47     70.9 MiB      0.0 MiB        1408           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.9 MiB      0.0 MiB        1408           current = open_set.get()[2]
    53     70.9 MiB      0.0 MiB        1408           open_set_hash.remove(current)
    54                                         
    55     70.9 MiB      0.0 MiB        1408           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.9 MiB      0.0 MiB        1408           if current == end:
    60     70.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.9 MiB      0.0 MiB       12663           for neighbor in current.neighbors:
    65     70.9 MiB      0.0 MiB       11256               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.9 MiB      0.0 MiB        5628                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.9 MiB      0.0 MiB        5628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.9 MiB      0.0 MiB       11256               if temp_g_score < g_score[neighbor]:
    71     70.9 MiB      0.0 MiB        1646                   came_from[neighbor] = current
    72     70.9 MiB      0.0 MiB        1646                   g_score[neighbor] = temp_g_score
    73     70.9 MiB      0.0 MiB        1646                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.9 MiB      0.0 MiB        1646                   if neighbor not in open_set_hash:
    75     70.9 MiB      0.0 MiB        1646                       count += 1
    76     70.9 MiB      0.0 MiB        1646                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.9 MiB      0.0 MiB        1646                       open_set_hash.add(neighbor)
    78                                                             
    79     70.9 MiB      0.0 MiB        1407           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.9 MiB      0.0 MiB        1407           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.2 MiB     70.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     70.2 MiB      0.0 MiB         129       for row in grid:
    30     70.2 MiB      0.0 MiB       16512           for spot in row:
    31     70.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     70.2 MiB      0.0 MiB           1       count = 0
    34     70.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     70.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     70.2 MiB      0.0 MiB           1       came_from = {}
    37     70.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.2 MiB      0.0 MiB         648       while not open_set.empty():
    47     70.2 MiB      0.0 MiB         648           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.2 MiB      0.0 MiB         648           current = open_set.get()[2]
    53     70.2 MiB      0.0 MiB         648           open_set_hash.remove(current)
    54                                         
    55     70.2 MiB      0.0 MiB         648           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.2 MiB      0.0 MiB         648           if current == end:
    60     70.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.2 MiB      0.0 MiB        5823           for neighbor in current.neighbors:
    65     70.2 MiB      0.0 MiB        5176               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.2 MiB      0.0 MiB        2588                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.2 MiB      0.0 MiB        2588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.2 MiB      0.0 MiB        5176               if temp_g_score < g_score[neighbor]:
    71     70.2 MiB      0.0 MiB         986                   came_from[neighbor] = current
    72     70.2 MiB      0.0 MiB         986                   g_score[neighbor] = temp_g_score
    73     70.2 MiB      0.0 MiB         986                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.2 MiB      0.0 MiB         986                   if neighbor not in open_set_hash:
    75     70.2 MiB      0.0 MiB         986                       count += 1
    76     70.2 MiB      0.0 MiB         986                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.2 MiB      0.0 MiB         986                       open_set_hash.add(neighbor)
    78                                                             
    79     70.2 MiB      0.0 MiB         647           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.2 MiB      0.0 MiB         647           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.2 MiB     70.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     70.2 MiB      0.0 MiB         129       for row in grid:
    30     70.2 MiB      0.0 MiB       16512           for spot in row:
    31     70.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     70.2 MiB      0.0 MiB           1       count = 0
    34     70.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     70.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     70.2 MiB      0.0 MiB           1       came_from = {}
    37     70.5 MiB      0.3 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     71.0 MiB      0.5 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.0 MiB      0.0 MiB         288       while not open_set.empty():
    47     71.0 MiB      0.0 MiB         288           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.0 MiB      0.0 MiB         288           current = open_set.get()[2]
    53     71.0 MiB      0.0 MiB         288           open_set_hash.remove(current)
    54                                         
    55     71.0 MiB      0.0 MiB         288           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.0 MiB      0.0 MiB         288           if current == end:
    60     71.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.0 MiB      0.0 MiB        2583           for neighbor in current.neighbors:
    65     71.0 MiB      0.0 MiB        2296               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.0 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.0 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.0 MiB      0.0 MiB        2296               if temp_g_score < g_score[neighbor]:
    71     71.0 MiB      0.0 MiB         382                   came_from[neighbor] = current
    72     71.0 MiB      0.0 MiB         382                   g_score[neighbor] = temp_g_score
    73     71.0 MiB      0.0 MiB         382                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.0 MiB      0.0 MiB         382                   if neighbor not in open_set_hash:
    75     71.0 MiB      0.0 MiB         382                       count += 1
    76     71.0 MiB      0.0 MiB         382                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.0 MiB      0.0 MiB         382                       open_set_hash.add(neighbor)
    78                                                             
    79     71.0 MiB      0.0 MiB         287           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.0 MiB      0.0 MiB         287           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.3 MiB     70.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     70.3 MiB      0.0 MiB         129       for row in grid:
    30     70.3 MiB      0.0 MiB       16512           for spot in row:
    31     70.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     70.3 MiB      0.0 MiB           1       count = 0
    34     70.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     70.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     70.3 MiB      0.0 MiB           1       came_from = {}
    37     70.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.3 MiB      0.0 MiB        1482       while not open_set.empty():
    47     70.3 MiB      0.0 MiB        1482           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.3 MiB      0.0 MiB        1482           current = open_set.get()[2]
    53     70.3 MiB      0.0 MiB        1482           open_set_hash.remove(current)
    54                                         
    55     70.3 MiB      0.0 MiB        1482           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.3 MiB      0.0 MiB        1482           if current == end:
    60     70.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.3 MiB      0.0 MiB       13329           for neighbor in current.neighbors:
    65     70.3 MiB      0.0 MiB       11848               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.3 MiB      0.0 MiB        5924                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.3 MiB      0.0 MiB        5924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.3 MiB      0.0 MiB       11848               if temp_g_score < g_score[neighbor]:
    71     70.3 MiB      0.0 MiB        1712                   came_from[neighbor] = current
    72     70.3 MiB      0.0 MiB        1712                   g_score[neighbor] = temp_g_score
    73     70.3 MiB      0.0 MiB        1712                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.3 MiB      0.0 MiB        1712                   if neighbor not in open_set_hash:
    75     70.3 MiB      0.0 MiB        1712                       count += 1
    76     70.3 MiB      0.0 MiB        1712                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.3 MiB      0.0 MiB        1712                       open_set_hash.add(neighbor)
    78                                                             
    79     70.3 MiB      0.0 MiB        1481           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.3 MiB      0.0 MiB        1481           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     70.3 MiB     70.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     70.3 MiB      0.0 MiB         129       for row in grid:
    30     70.3 MiB      0.0 MiB       16512           for spot in row:
    31     70.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     70.3 MiB      0.0 MiB           1       count = 0
    34     70.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     70.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     70.3 MiB      0.0 MiB           1       came_from = {}
    37     70.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     70.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     70.9 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.9 MiB      0.0 MiB         204       while not open_set.empty():
    47     70.9 MiB      0.0 MiB         204           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.9 MiB      0.0 MiB         204           current = open_set.get()[2]
    53     70.9 MiB      0.0 MiB         204           open_set_hash.remove(current)
    54                                         
    55     70.9 MiB      0.0 MiB         204           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.9 MiB      0.0 MiB         204           if current == end:
    60     70.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.9 MiB      0.0 MiB        1827           for neighbor in current.neighbors:
    65     70.9 MiB      0.0 MiB        1624               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.9 MiB      0.0 MiB         812                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.9 MiB      0.0 MiB         812                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.9 MiB      0.0 MiB        1624               if temp_g_score < g_score[neighbor]:
    71     70.9 MiB      0.0 MiB         294                   came_from[neighbor] = current
    72     70.9 MiB      0.0 MiB         294                   g_score[neighbor] = temp_g_score
    73     70.9 MiB      0.0 MiB         294                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.9 MiB      0.0 MiB         294                   if neighbor not in open_set_hash:
    75     70.9 MiB      0.0 MiB         294                       count += 1
    76     70.9 MiB      0.0 MiB         294                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.9 MiB      0.0 MiB         294                       open_set_hash.add(neighbor)
    78                                                             
    79     70.9 MiB      0.0 MiB         203           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.9 MiB      0.0 MiB         203           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     71.0 MiB     71.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     71.0 MiB      0.0 MiB         129       for row in grid:
    30     71.0 MiB      0.0 MiB       16512           for spot in row:
    31     71.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     71.0 MiB      0.0 MiB           1       count = 0
    34     71.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     71.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     71.0 MiB      0.0 MiB           1       came_from = {}
    37     71.3 MiB      0.3 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     72.6 MiB      1.4 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.6 MiB      0.0 MiB         450       while not open_set.empty():
    47     72.6 MiB      0.0 MiB         450           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.6 MiB      0.0 MiB         450           current = open_set.get()[2]
    53     72.6 MiB      0.0 MiB         450           open_set_hash.remove(current)
    54                                         
    55     72.6 MiB      0.0 MiB         450           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.6 MiB      0.0 MiB         450           if current == end:
    60     72.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.6 MiB      0.0 MiB        4041           for neighbor in current.neighbors:
    65     72.6 MiB      0.0 MiB        3592               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.6 MiB      0.0 MiB        1796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.6 MiB      0.0 MiB        1796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.6 MiB      0.0 MiB        3592               if temp_g_score < g_score[neighbor]:
    71     72.6 MiB      0.0 MiB         622                   came_from[neighbor] = current
    72     72.6 MiB      0.0 MiB         622                   g_score[neighbor] = temp_g_score
    73     72.6 MiB      0.0 MiB         622                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.6 MiB      0.0 MiB         622                   if neighbor not in open_set_hash:
    75     72.6 MiB      0.0 MiB         622                       count += 1
    76     72.6 MiB      0.0 MiB         622                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.6 MiB      0.0 MiB         622                       open_set_hash.add(neighbor)
    78                                                             
    79     72.6 MiB      0.0 MiB         449           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.6 MiB      0.0 MiB         449           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.5 MiB     75.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.5 MiB      0.0 MiB         129       for row in grid:
    30     75.5 MiB      0.0 MiB       16512           for spot in row:
    31     75.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.5 MiB      0.0 MiB           1       count = 0
    34     75.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.5 MiB      0.0 MiB           1       came_from = {}
    37     75.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.9 MiB      0.3 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.9 MiB      0.0 MiB        1836       while not open_set.empty():
    47     75.9 MiB      0.0 MiB        1836           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.9 MiB      0.0 MiB        1836           current = open_set.get()[2]
    53     75.9 MiB      0.0 MiB        1836           open_set_hash.remove(current)
    54                                         
    55     75.9 MiB      0.0 MiB        1836           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.9 MiB      0.0 MiB        1836           if current == end:
    60     75.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.9 MiB      0.0 MiB       16515           for neighbor in current.neighbors:
    65     75.9 MiB      0.0 MiB       14680               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.9 MiB      0.0 MiB        7340                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.9 MiB      0.0 MiB        7340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.9 MiB      0.0 MiB       14680               if temp_g_score < g_score[neighbor]:
    71     75.9 MiB      0.0 MiB        2080                   came_from[neighbor] = current
    72     75.9 MiB      0.0 MiB        2080                   g_score[neighbor] = temp_g_score
    73     75.9 MiB      0.0 MiB        2080                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.9 MiB      0.0 MiB        2080                   if neighbor not in open_set_hash:
    75     75.9 MiB      0.0 MiB        2080                       count += 1
    76     75.9 MiB      0.0 MiB        2080                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.9 MiB      0.0 MiB        2080                       open_set_hash.add(neighbor)
    78                                                             
    79     75.9 MiB      0.0 MiB        1835           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.9 MiB      0.0 MiB        1835           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.9 MiB     75.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.9 MiB      0.0 MiB         129       for row in grid:
    30     75.9 MiB      0.0 MiB       16512           for spot in row:
    31     75.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.9 MiB      0.0 MiB           1       count = 0
    34     75.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.9 MiB      0.0 MiB           1       came_from = {}
    37     75.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.9 MiB      0.0 MiB           6       while not open_set.empty():
    47     75.9 MiB      0.0 MiB           6           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.9 MiB      0.0 MiB           6           current = open_set.get()[2]
    53     75.9 MiB      0.0 MiB           6           open_set_hash.remove(current)
    54                                         
    55     75.9 MiB      0.0 MiB           6           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.9 MiB      0.0 MiB           6           if current == end:
    60     75.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.9 MiB      0.0 MiB          45           for neighbor in current.neighbors:
    65     75.9 MiB      0.0 MiB          40               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.9 MiB      0.0 MiB          20                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.9 MiB      0.0 MiB          20                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.9 MiB      0.0 MiB          40               if temp_g_score < g_score[neighbor]:
    71     75.9 MiB      0.0 MiB          20                   came_from[neighbor] = current
    72     75.9 MiB      0.0 MiB          20                   g_score[neighbor] = temp_g_score
    73     75.9 MiB      0.0 MiB          20                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.9 MiB      0.0 MiB          20                   if neighbor not in open_set_hash:
    75     75.9 MiB      0.0 MiB          20                       count += 1
    76     75.9 MiB      0.0 MiB          20                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.9 MiB      0.0 MiB          20                       open_set_hash.add(neighbor)
    78                                                             
    79     75.9 MiB      0.0 MiB           5           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.9 MiB      0.0 MiB           5           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.9 MiB     75.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.9 MiB      0.0 MiB         129       for row in grid:
    30     75.9 MiB      0.0 MiB       16512           for spot in row:
    31     75.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.9 MiB      0.0 MiB           1       count = 0
    34     75.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.9 MiB      0.0 MiB           1       came_from = {}
    37     75.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.9 MiB      0.0 MiB           8       while not open_set.empty():
    47     75.9 MiB      0.0 MiB           8           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.9 MiB      0.0 MiB           8           current = open_set.get()[2]
    53     75.9 MiB      0.0 MiB           8           open_set_hash.remove(current)
    54                                         
    55     75.9 MiB      0.0 MiB           8           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.9 MiB      0.0 MiB           8           if current == end:
    60     75.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.9 MiB      0.0 MiB          63           for neighbor in current.neighbors:
    65     75.9 MiB      0.0 MiB          56               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.9 MiB      0.0 MiB          28                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.9 MiB      0.0 MiB          28                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.9 MiB      0.0 MiB          56               if temp_g_score < g_score[neighbor]:
    71     75.9 MiB      0.0 MiB          26                   came_from[neighbor] = current
    72     75.9 MiB      0.0 MiB          26                   g_score[neighbor] = temp_g_score
    73     75.9 MiB      0.0 MiB          26                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.9 MiB      0.0 MiB          26                   if neighbor not in open_set_hash:
    75     75.9 MiB      0.0 MiB          26                       count += 1
    76     75.9 MiB      0.0 MiB          26                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.9 MiB      0.0 MiB          26                       open_set_hash.add(neighbor)
    78                                                             
    79     75.9 MiB      0.0 MiB           7           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.9 MiB      0.0 MiB           7           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.9 MiB     75.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.9 MiB      0.0 MiB         129       for row in grid:
    30     75.9 MiB      0.0 MiB       16512           for spot in row:
    31     75.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.9 MiB      0.0 MiB           1       count = 0
    34     75.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.9 MiB      0.0 MiB           1       came_from = {}
    37     75.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.9 MiB      0.0 MiB          72       while not open_set.empty():
    47     75.9 MiB      0.0 MiB          72           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.9 MiB      0.0 MiB          72           current = open_set.get()[2]
    53     75.9 MiB      0.0 MiB          72           open_set_hash.remove(current)
    54                                         
    55     75.9 MiB      0.0 MiB          72           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.9 MiB      0.0 MiB          72           if current == end:
    60     75.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.9 MiB      0.0 MiB         639           for neighbor in current.neighbors:
    65     75.9 MiB      0.0 MiB         568               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.9 MiB      0.0 MiB         284                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.9 MiB      0.0 MiB         284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.9 MiB      0.0 MiB         568               if temp_g_score < g_score[neighbor]:
    71     75.9 MiB      0.0 MiB         118                   came_from[neighbor] = current
    72     75.9 MiB      0.0 MiB         118                   g_score[neighbor] = temp_g_score
    73     75.9 MiB      0.0 MiB         118                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.9 MiB      0.0 MiB         118                   if neighbor not in open_set_hash:
    75     75.9 MiB      0.0 MiB         118                       count += 1
    76     75.9 MiB      0.0 MiB         118                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.9 MiB      0.0 MiB         118                       open_set_hash.add(neighbor)
    78                                                             
    79     75.9 MiB      0.0 MiB          71           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.9 MiB      0.0 MiB          71           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.9 MiB     75.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.9 MiB      0.0 MiB         129       for row in grid:
    30     75.9 MiB      0.0 MiB       16512           for spot in row:
    31     75.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.9 MiB      0.0 MiB           1       count = 0
    34     75.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.9 MiB      0.0 MiB           1       came_from = {}
    37     75.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.9 MiB      0.0 MiB        1817       while not open_set.empty():
    47     75.9 MiB      0.0 MiB        1817           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.9 MiB      0.0 MiB        1817           current = open_set.get()[2]
    53     75.9 MiB      0.0 MiB        1817           open_set_hash.remove(current)
    54                                         
    55     75.9 MiB      0.0 MiB        1817           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.9 MiB      0.0 MiB        1817           if current == end:
    60     75.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.9 MiB      0.0 MiB       16344           for neighbor in current.neighbors:
    65     75.9 MiB      0.0 MiB       14528               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.9 MiB      0.0 MiB        7264                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.9 MiB      0.0 MiB        7264                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.9 MiB      0.0 MiB       14528               if temp_g_score < g_score[neighbor]:
    71     75.9 MiB      0.0 MiB        2065                   came_from[neighbor] = current
    72     75.9 MiB      0.0 MiB        2065                   g_score[neighbor] = temp_g_score
    73     75.9 MiB      0.0 MiB        2065                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.9 MiB      0.0 MiB        2065                   if neighbor not in open_set_hash:
    75     75.9 MiB      0.0 MiB        2065                       count += 1
    76     75.9 MiB      0.0 MiB        2065                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.9 MiB      0.0 MiB        2065                       open_set_hash.add(neighbor)
    78                                                             
    79     75.9 MiB      0.0 MiB        1816           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.9 MiB      0.0 MiB        1816           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.9 MiB     75.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.9 MiB      0.0 MiB         129       for row in grid:
    30     75.9 MiB      0.0 MiB       16512           for spot in row:
    31     75.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.9 MiB      0.0 MiB           1       count = 0
    34     75.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.9 MiB      0.0 MiB           1       came_from = {}
    37     75.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.9 MiB      0.0 MiB         675       while not open_set.empty():
    47     75.9 MiB      0.0 MiB         675           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.9 MiB      0.0 MiB         675           current = open_set.get()[2]
    53     75.9 MiB      0.0 MiB         675           open_set_hash.remove(current)
    54                                         
    55     75.9 MiB      0.0 MiB         675           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.9 MiB      0.0 MiB         675           if current == end:
    60     75.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.9 MiB      0.0 MiB        6066           for neighbor in current.neighbors:
    65     75.9 MiB      0.0 MiB        5392               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.9 MiB      0.0 MiB        2696                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.9 MiB      0.0 MiB        2696                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.9 MiB      0.0 MiB        5392               if temp_g_score < g_score[neighbor]:
    71     75.9 MiB      0.0 MiB         827                   came_from[neighbor] = current
    72     75.9 MiB      0.0 MiB         827                   g_score[neighbor] = temp_g_score
    73     75.9 MiB      0.0 MiB         827                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.9 MiB      0.0 MiB         827                   if neighbor not in open_set_hash:
    75     75.9 MiB      0.0 MiB         827                       count += 1
    76     75.9 MiB      0.0 MiB         827                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.9 MiB      0.0 MiB         827                       open_set_hash.add(neighbor)
    78                                                             
    79     75.9 MiB      0.0 MiB         674           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.9 MiB      0.0 MiB         674           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.9 MiB     75.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.9 MiB      0.0 MiB         129       for row in grid:
    30     75.9 MiB      0.0 MiB       16512           for spot in row:
    31     75.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.9 MiB      0.0 MiB           1       count = 0
    34     75.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.9 MiB      0.0 MiB           1       came_from = {}
    37     75.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB        1848       while not open_set.empty():
    47     76.0 MiB      0.0 MiB        1848           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB        1848           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB        1848           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB        1848           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB        1848           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB       16623           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB       14776               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        7388                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        7388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB       14776               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB        2106                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB        2106                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB        2106                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB        2106                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB        2106                       count += 1
    76     76.0 MiB      0.0 MiB        2106                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB        2106                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB        1847           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB        1847           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         468       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         468           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         468           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         468           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         468           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         468           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        4203           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        3736               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        1868                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        1868                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        3736               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         606                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         606                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         606                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         606                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         606                       count += 1
    76     76.0 MiB      0.0 MiB         606                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         606                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         467           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         467           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         837       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         837           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         837           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         837           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         837           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         837           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        7524           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        6688               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        3344                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        3344                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        6688               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB        1013                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB        1013                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB        1013                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB        1013                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB        1013                       count += 1
    76     76.0 MiB      0.0 MiB        1013                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB        1013                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         836           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         836           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         522       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         522           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         522           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         522           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         522           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         522           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        4689           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        4168               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        2084                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        2084                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        4168               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         650                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         650                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         650                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         650                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         650                       count += 1
    76     76.0 MiB      0.0 MiB         650                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         650                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         521           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         521           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB        1344       while not open_set.empty():
    47     76.0 MiB      0.0 MiB        1344           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB        1344           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB        1344           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB        1344           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB        1344           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB       12087           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB       10744               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        5372                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        5372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB       10744               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB        1574                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB        1574                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB        1574                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB        1574                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB        1574                       count += 1
    76     76.0 MiB      0.0 MiB        1574                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB        1574                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB        1343           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB        1343           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         121       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         121           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         121           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         121           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         121           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         121           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        1080           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB         960               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB         480                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB         480                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB         960               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         185                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         185                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         185                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         185                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         185                       count += 1
    76     76.0 MiB      0.0 MiB         185                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         185                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         120           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         120           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.0 MiB     75.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.0 MiB      0.0 MiB         129       for row in grid:
    30     75.0 MiB      0.0 MiB       16512           for spot in row:
    31     75.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.0 MiB      0.0 MiB           1       count = 0
    34     75.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.0 MiB      0.0 MiB           1       came_from = {}
    37     75.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.0 MiB      0.0 MiB          64       while not open_set.empty():
    47     75.0 MiB      0.0 MiB          64           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.0 MiB      0.0 MiB          64           current = open_set.get()[2]
    53     75.0 MiB      0.0 MiB          64           open_set_hash.remove(current)
    54                                         
    55     75.0 MiB      0.0 MiB          64           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.0 MiB      0.0 MiB          64           if current == end:
    60     75.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.0 MiB      0.0 MiB         567           for neighbor in current.neighbors:
    65     75.0 MiB      0.0 MiB         504               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.0 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.0 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.0 MiB      0.0 MiB         504               if temp_g_score < g_score[neighbor]:
    71     75.0 MiB      0.0 MiB         110                   came_from[neighbor] = current
    72     75.0 MiB      0.0 MiB         110                   g_score[neighbor] = temp_g_score
    73     75.0 MiB      0.0 MiB         110                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.0 MiB      0.0 MiB         110                   if neighbor not in open_set_hash:
    75     75.0 MiB      0.0 MiB         110                       count += 1
    76     75.0 MiB      0.0 MiB         110                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.0 MiB      0.0 MiB         110                       open_set_hash.add(neighbor)
    78                                                             
    79     75.0 MiB      0.0 MiB          63           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.0 MiB      0.0 MiB          63           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.0 MiB     75.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.0 MiB      0.0 MiB         129       for row in grid:
    30     75.0 MiB      0.0 MiB       16512           for spot in row:
    31     75.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.0 MiB      0.0 MiB           1       count = 0
    34     75.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.0 MiB      0.0 MiB           1       came_from = {}
    37     75.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.0 MiB      0.0 MiB         112       while not open_set.empty():
    47     75.0 MiB      0.0 MiB         112           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.0 MiB      0.0 MiB         112           current = open_set.get()[2]
    53     75.0 MiB      0.0 MiB         112           open_set_hash.remove(current)
    54                                         
    55     75.0 MiB      0.0 MiB         112           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.0 MiB      0.0 MiB         112           if current == end:
    60     75.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.0 MiB      0.0 MiB         999           for neighbor in current.neighbors:
    65     75.0 MiB      0.0 MiB         888               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.0 MiB      0.0 MiB         444                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.0 MiB      0.0 MiB         444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.0 MiB      0.0 MiB         888               if temp_g_score < g_score[neighbor]:
    71     75.0 MiB      0.0 MiB         182                   came_from[neighbor] = current
    72     75.0 MiB      0.0 MiB         182                   g_score[neighbor] = temp_g_score
    73     75.0 MiB      0.0 MiB         182                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.0 MiB      0.0 MiB         182                   if neighbor not in open_set_hash:
    75     75.0 MiB      0.0 MiB         182                       count += 1
    76     75.0 MiB      0.0 MiB         182                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.0 MiB      0.0 MiB         182                       open_set_hash.add(neighbor)
    78                                                             
    79     75.0 MiB      0.0 MiB         111           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.0 MiB      0.0 MiB         111           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.0 MiB     74.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.0 MiB      0.0 MiB         129       for row in grid:
    30     74.0 MiB      0.0 MiB       16512           for spot in row:
    31     74.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     74.0 MiB      0.0 MiB           1       count = 0
    34     74.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.0 MiB      0.0 MiB           1       came_from = {}
    37     74.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.0 MiB      0.0 MiB         615       while not open_set.empty():
    47     74.0 MiB      0.0 MiB         615           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.0 MiB      0.0 MiB         615           current = open_set.get()[2]
    53     74.0 MiB      0.0 MiB         615           open_set_hash.remove(current)
    54                                         
    55     74.0 MiB      0.0 MiB         615           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.0 MiB      0.0 MiB         615           if current == end:
    60     74.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.0 MiB      0.0 MiB        5526           for neighbor in current.neighbors:
    65     74.0 MiB      0.0 MiB        4912               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.0 MiB      0.0 MiB        2456                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.0 MiB      0.0 MiB        2456                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.0 MiB      0.0 MiB        4912               if temp_g_score < g_score[neighbor]:
    71     74.0 MiB      0.0 MiB         807                   came_from[neighbor] = current
    72     74.0 MiB      0.0 MiB         807                   g_score[neighbor] = temp_g_score
    73     74.0 MiB      0.0 MiB         807                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.0 MiB      0.0 MiB         807                   if neighbor not in open_set_hash:
    75     74.0 MiB      0.0 MiB         807                       count += 1
    76     74.0 MiB      0.0 MiB         807                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.0 MiB      0.0 MiB         807                       open_set_hash.add(neighbor)
    78                                                             
    79     74.0 MiB      0.0 MiB         614           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.0 MiB      0.0 MiB         614           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.0 MiB     74.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.0 MiB      0.0 MiB         129       for row in grid:
    30     74.0 MiB      0.0 MiB       16512           for spot in row:
    31     74.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     74.0 MiB      0.0 MiB           1       count = 0
    34     74.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.0 MiB      0.0 MiB           1       came_from = {}
    37     74.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.0 MiB      0.0 MiB          15       while not open_set.empty():
    47     74.0 MiB      0.0 MiB          15           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.0 MiB      0.0 MiB          15           current = open_set.get()[2]
    53     74.0 MiB      0.0 MiB          15           open_set_hash.remove(current)
    54                                         
    55     74.0 MiB      0.0 MiB          15           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.0 MiB      0.0 MiB          15           if current == end:
    60     74.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.0 MiB      0.0 MiB         126           for neighbor in current.neighbors:
    65     74.0 MiB      0.0 MiB         112               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.0 MiB      0.0 MiB          56                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.0 MiB      0.0 MiB          56                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.0 MiB      0.0 MiB         112               if temp_g_score < g_score[neighbor]:
    71     74.0 MiB      0.0 MiB          73                   came_from[neighbor] = current
    72     74.0 MiB      0.0 MiB          73                   g_score[neighbor] = temp_g_score
    73     74.0 MiB      0.0 MiB          73                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.0 MiB      0.0 MiB          73                   if neighbor not in open_set_hash:
    75     74.0 MiB      0.0 MiB          73                       count += 1
    76     74.0 MiB      0.0 MiB          73                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.0 MiB      0.0 MiB          73                       open_set_hash.add(neighbor)
    78                                                             
    79     74.0 MiB      0.0 MiB          14           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.0 MiB      0.0 MiB          14           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.0 MiB     74.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.0 MiB      0.0 MiB         129       for row in grid:
    30     74.0 MiB      0.0 MiB       16512           for spot in row:
    31     74.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     74.0 MiB      0.0 MiB           1       count = 0
    34     74.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.0 MiB      0.0 MiB           1       came_from = {}
    37     74.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.0 MiB      0.0 MiB         120       while not open_set.empty():
    47     74.0 MiB      0.0 MiB         120           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.0 MiB      0.0 MiB         120           current = open_set.get()[2]
    53     74.0 MiB      0.0 MiB         120           open_set_hash.remove(current)
    54                                         
    55     74.0 MiB      0.0 MiB         120           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.0 MiB      0.0 MiB         120           if current == end:
    60     74.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.0 MiB      0.0 MiB        1071           for neighbor in current.neighbors:
    65     74.0 MiB      0.0 MiB         952               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.0 MiB      0.0 MiB         476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.0 MiB      0.0 MiB         476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.0 MiB      0.0 MiB         952               if temp_g_score < g_score[neighbor]:
    71     74.0 MiB      0.0 MiB         180                   came_from[neighbor] = current
    72     74.0 MiB      0.0 MiB         180                   g_score[neighbor] = temp_g_score
    73     74.0 MiB      0.0 MiB         180                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.0 MiB      0.0 MiB         180                   if neighbor not in open_set_hash:
    75     74.0 MiB      0.0 MiB         180                       count += 1
    76     74.0 MiB      0.0 MiB         180                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.0 MiB      0.0 MiB         180                       open_set_hash.add(neighbor)
    78                                                             
    79     74.0 MiB      0.0 MiB         119           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.0 MiB      0.0 MiB         119           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.8 MiB     75.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.8 MiB      0.0 MiB         129       for row in grid:
    30     75.8 MiB      0.0 MiB       16512           for spot in row:
    31     75.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.8 MiB      0.0 MiB           1       count = 0
    34     75.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.8 MiB      0.0 MiB           1       came_from = {}
    37     75.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.8 MiB      0.0 MiB          66       while not open_set.empty():
    47     75.8 MiB      0.0 MiB          66           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.8 MiB      0.0 MiB          66           current = open_set.get()[2]
    53     75.8 MiB      0.0 MiB          66           open_set_hash.remove(current)
    54                                         
    55     75.8 MiB      0.0 MiB          66           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.8 MiB      0.0 MiB          66           if current == end:
    60     75.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.8 MiB      0.0 MiB         552           for neighbor in current.neighbors:
    65     75.8 MiB      0.0 MiB         487               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.8 MiB      0.0 MiB         238                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.8 MiB      0.0 MiB         249                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.8 MiB      0.0 MiB         487               if temp_g_score < g_score[neighbor]:
    71     75.8 MiB      0.0 MiB          97                   came_from[neighbor] = current
    72     75.8 MiB      0.0 MiB          97                   g_score[neighbor] = temp_g_score
    73     75.8 MiB      0.0 MiB          97                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.8 MiB      0.0 MiB          97                   if neighbor not in open_set_hash:
    75     75.8 MiB      0.0 MiB          97                       count += 1
    76     75.8 MiB      0.0 MiB          97                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.8 MiB      0.0 MiB          97                       open_set_hash.add(neighbor)
    78                                                             
    79     75.8 MiB      0.0 MiB          65           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.8 MiB      0.0 MiB          65           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB        2728       while not open_set.empty():
    47     76.0 MiB      0.0 MiB        2728           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB        2728           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB        2728           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB        2728           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB        2728           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB       24540           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB       21813               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB       10906                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB       10907                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB       21813               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB        3023                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB        3023                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB        3023                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB        3023                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB        3023                       count += 1
    76     76.0 MiB      0.0 MiB        3023                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB        3023                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB        2727           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB        2727           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         610       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         610           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         610           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         610           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         610           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         610           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        5481           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        4872               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        2436                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        2436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        4872               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         770                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         770                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         770                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         770                       count += 1
    76     76.0 MiB      0.0 MiB         770                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         770                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         609           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         609           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         432       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         432           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         432           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         432           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         432           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         432           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        3879           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        3448               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        1724                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        1724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        3448               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         662                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         662                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         662                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         662                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         662                       count += 1
    76     76.0 MiB      0.0 MiB         662                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         662                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         431           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         431           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         416       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         416           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         416           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         416           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         416           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         416           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        3735           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        3320               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        1660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        1660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        3320               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         568                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         568                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         568                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         568                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         568                       count += 1
    76     76.0 MiB      0.0 MiB         568                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         568                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         415           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         415           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB        2773       while not open_set.empty():
    47     76.0 MiB      0.0 MiB        2773           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB        2773           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB        2773           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB        2773           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB        2773           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB       24948           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB       22176               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB       11088                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB       11088                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB       22176               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB        3101                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB        3101                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB        3101                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB        3101                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB        3101                       count += 1
    76     76.0 MiB      0.0 MiB        3101                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB        3101                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB        2772           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB        2772           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         340       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         340           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         340           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         340           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         340           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         340           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        3051           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        2712               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        1356                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        1356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        2712               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         446                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         446                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         446                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         446                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         446                       count += 1
    76     76.0 MiB      0.0 MiB         446                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         446                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         339           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         339           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         868       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         868           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         868           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         868           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         868           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         868           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        7803           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        6936               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        3468                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        3468                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        6936               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB        1040                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB        1040                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB        1040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB        1040                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB        1040                       count += 1
    76     76.0 MiB      0.0 MiB        1040                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB        1040                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         867           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         867           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         351       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         351           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         351           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         351           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         351           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         351           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        3150           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        2800               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        1400                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        1400                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        2800               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         523                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         523                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         523                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         523                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         523                       count += 1
    76     76.0 MiB      0.0 MiB         523                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         523                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         350           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         350           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB         510       while not open_set.empty():
    47     76.0 MiB      0.0 MiB         510           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB         510           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB         510           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB         510           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB         510           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        4578           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        4069               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        2034                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        2035                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        4069               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         659                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         659                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         659                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         659                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         659                       count += 1
    76     76.0 MiB      0.0 MiB         659                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         659                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB         509           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB         509           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB        1089       while not open_set.empty():
    47     76.0 MiB      0.0 MiB        1089           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB        1089           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB        1089           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB        1089           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB        1089           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB        9792           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB        8704               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB        4352                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB        4352                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB        8704               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB        1285                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB        1285                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB        1285                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB        1285                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB        1285                       count += 1
    76     76.0 MiB      0.0 MiB        1285                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB        1285                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB        1088           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB        1088           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     76.0 MiB     76.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     76.0 MiB      0.0 MiB         129       for row in grid:
    30     76.0 MiB      0.0 MiB       16512           for spot in row:
    31     76.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB      0.0 MiB           1       count = 0
    34     76.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     76.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     76.0 MiB      0.0 MiB           1       came_from = {}
    37     76.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.0 MiB      0.0 MiB          74       while not open_set.empty():
    47     76.0 MiB      0.0 MiB          74           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.0 MiB      0.0 MiB          74           current = open_set.get()[2]
    53     76.0 MiB      0.0 MiB          74           open_set_hash.remove(current)
    54                                         
    55     76.0 MiB      0.0 MiB          74           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.0 MiB      0.0 MiB          74           if current == end:
    60     76.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.0 MiB      0.0 MiB         657           for neighbor in current.neighbors:
    65     76.0 MiB      0.0 MiB         584               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.0 MiB      0.0 MiB         292                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.0 MiB      0.0 MiB         292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.0 MiB      0.0 MiB         584               if temp_g_score < g_score[neighbor]:
    71     76.0 MiB      0.0 MiB         154                   came_from[neighbor] = current
    72     76.0 MiB      0.0 MiB         154                   g_score[neighbor] = temp_g_score
    73     76.0 MiB      0.0 MiB         154                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.0 MiB      0.0 MiB         154                   if neighbor not in open_set_hash:
    75     76.0 MiB      0.0 MiB         154                       count += 1
    76     76.0 MiB      0.0 MiB         154                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.0 MiB      0.0 MiB         154                       open_set_hash.add(neighbor)
    78                                                             
    79     76.0 MiB      0.0 MiB          73           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.0 MiB      0.0 MiB          73           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.1 MiB     75.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.1 MiB      0.0 MiB         129       for row in grid:
    30     75.1 MiB      0.0 MiB       16512           for spot in row:
    31     75.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.1 MiB      0.0 MiB           1       count = 0
    34     75.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.1 MiB      0.0 MiB           1       came_from = {}
    37     75.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.1 MiB      0.0 MiB         320       while not open_set.empty():
    47     75.1 MiB      0.0 MiB         320           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.1 MiB      0.0 MiB         320           current = open_set.get()[2]
    53     75.1 MiB      0.0 MiB         320           open_set_hash.remove(current)
    54                                         
    55     75.1 MiB      0.0 MiB         320           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.1 MiB      0.0 MiB         320           if current == end:
    60     75.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.1 MiB      0.0 MiB        2871           for neighbor in current.neighbors:
    65     75.1 MiB      0.0 MiB        2552               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.1 MiB      0.0 MiB        1276                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.1 MiB      0.0 MiB        1276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.1 MiB      0.0 MiB        2552               if temp_g_score < g_score[neighbor]:
    71     75.1 MiB      0.0 MiB         430                   came_from[neighbor] = current
    72     75.1 MiB      0.0 MiB         430                   g_score[neighbor] = temp_g_score
    73     75.1 MiB      0.0 MiB         430                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.1 MiB      0.0 MiB         430                   if neighbor not in open_set_hash:
    75     75.1 MiB      0.0 MiB         430                       count += 1
    76     75.1 MiB      0.0 MiB         430                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.1 MiB      0.0 MiB         430                       open_set_hash.add(neighbor)
    78                                                             
    79     75.1 MiB      0.0 MiB         319           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.1 MiB      0.0 MiB         319           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.1 MiB     75.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.1 MiB      0.0 MiB         129       for row in grid:
    30     75.1 MiB      0.0 MiB       16512           for spot in row:
    31     75.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.1 MiB      0.0 MiB           1       count = 0
    34     75.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.1 MiB      0.0 MiB           1       came_from = {}
    37     75.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     75.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.1 MiB      0.0 MiB        1148       while not open_set.empty():
    47     75.1 MiB      0.0 MiB        1148           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.1 MiB      0.0 MiB        1148           current = open_set.get()[2]
    53     75.1 MiB      0.0 MiB        1148           open_set_hash.remove(current)
    54                                         
    55     75.1 MiB      0.0 MiB        1148           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.1 MiB      0.0 MiB        1148           if current == end:
    60     75.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.1 MiB      0.0 MiB       10323           for neighbor in current.neighbors:
    65     75.1 MiB      0.0 MiB        9176               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.1 MiB      0.0 MiB        4588                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.1 MiB      0.0 MiB        4588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.1 MiB      0.0 MiB        9176               if temp_g_score < g_score[neighbor]:
    71     75.1 MiB      0.0 MiB        1366                   came_from[neighbor] = current
    72     75.1 MiB      0.0 MiB        1366                   g_score[neighbor] = temp_g_score
    73     75.1 MiB      0.0 MiB        1366                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.1 MiB      0.0 MiB        1366                   if neighbor not in open_set_hash:
    75     75.1 MiB      0.0 MiB        1366                       count += 1
    76     75.1 MiB      0.0 MiB        1366                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.1 MiB      0.0 MiB        1366                       open_set_hash.add(neighbor)
    78                                                             
    79     75.1 MiB      0.0 MiB        1147           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.1 MiB      0.0 MiB        1147           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.1 MiB     74.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.1 MiB      0.0 MiB         129       for row in grid:
    30     74.1 MiB      0.0 MiB       16512           for spot in row:
    31     74.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     74.1 MiB      0.0 MiB           1       count = 0
    34     74.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.1 MiB      0.0 MiB           1       came_from = {}
    37     74.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.1 MiB      0.0 MiB         252       while not open_set.empty():
    47     74.1 MiB      0.0 MiB         252           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.1 MiB      0.0 MiB         252           current = open_set.get()[2]
    53     74.1 MiB      0.0 MiB         252           open_set_hash.remove(current)
    54                                         
    55     74.1 MiB      0.0 MiB         252           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.1 MiB      0.0 MiB         252           if current == end:
    60     74.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.1 MiB      0.0 MiB        2259           for neighbor in current.neighbors:
    65     74.1 MiB      0.0 MiB        2008               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.1 MiB      0.0 MiB        1004                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.1 MiB      0.0 MiB        1004                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.1 MiB      0.0 MiB        2008               if temp_g_score < g_score[neighbor]:
    71     74.1 MiB      0.0 MiB         350                   came_from[neighbor] = current
    72     74.1 MiB      0.0 MiB         350                   g_score[neighbor] = temp_g_score
    73     74.1 MiB      0.0 MiB         350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.1 MiB      0.0 MiB         350                   if neighbor not in open_set_hash:
    75     74.1 MiB      0.0 MiB         350                       count += 1
    76     74.1 MiB      0.0 MiB         350                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.1 MiB      0.0 MiB         350                       open_set_hash.add(neighbor)
    78                                                             
    79     74.1 MiB      0.0 MiB         251           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.1 MiB      0.0 MiB         251           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.1 MiB     74.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.1 MiB      0.0 MiB         129       for row in grid:
    30     74.1 MiB      0.0 MiB       16512           for spot in row:
    31     74.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     74.1 MiB      0.0 MiB           1       count = 0
    34     74.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.1 MiB      0.0 MiB           1       came_from = {}
    37     74.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.1 MiB      0.0 MiB         372       while not open_set.empty():
    47     74.1 MiB      0.0 MiB         372           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.1 MiB      0.0 MiB         372           current = open_set.get()[2]
    53     74.1 MiB      0.0 MiB         372           open_set_hash.remove(current)
    54                                         
    55     74.1 MiB      0.0 MiB         372           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.1 MiB      0.0 MiB         372           if current == end:
    60     74.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.1 MiB      0.0 MiB        3339           for neighbor in current.neighbors:
    65     74.1 MiB      0.0 MiB        2968               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.1 MiB      0.0 MiB        1484                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.1 MiB      0.0 MiB        1484                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.1 MiB      0.0 MiB        2968               if temp_g_score < g_score[neighbor]:
    71     74.1 MiB      0.0 MiB         480                   came_from[neighbor] = current
    72     74.1 MiB      0.0 MiB         480                   g_score[neighbor] = temp_g_score
    73     74.1 MiB      0.0 MiB         480                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.1 MiB      0.0 MiB         480                   if neighbor not in open_set_hash:
    75     74.1 MiB      0.0 MiB         480                       count += 1
    76     74.1 MiB      0.0 MiB         480                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.1 MiB      0.0 MiB         480                       open_set_hash.add(neighbor)
    78                                                             
    79     74.1 MiB      0.0 MiB         371           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.1 MiB      0.0 MiB         371           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     74.1 MiB     74.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     74.1 MiB      0.0 MiB         129       for row in grid:
    30     74.1 MiB      0.0 MiB       16512           for spot in row:
    31     74.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     74.1 MiB      0.0 MiB           1       count = 0
    34     74.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     74.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     74.1 MiB      0.0 MiB           1       came_from = {}
    37     74.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     74.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     74.1 MiB      0.0 MiB        2982       while not open_set.empty():
    47     74.1 MiB      0.0 MiB        2982           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     74.1 MiB      0.0 MiB        2982           current = open_set.get()[2]
    53     74.1 MiB      0.0 MiB        2982           open_set_hash.remove(current)
    54                                         
    55     74.1 MiB      0.0 MiB        2982           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     74.1 MiB      0.0 MiB        2982           if current == end:
    60     74.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     74.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     74.1 MiB      0.0 MiB       26829           for neighbor in current.neighbors:
    65     74.1 MiB      0.0 MiB       23848               if current.row != neighbor.row and current.col != neighbor.col:
    66     74.1 MiB      0.0 MiB       11924                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     74.1 MiB      0.0 MiB       11924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     74.1 MiB      0.0 MiB       23848               if temp_g_score < g_score[neighbor]:
    71     74.1 MiB      0.0 MiB        3290                   came_from[neighbor] = current
    72     74.1 MiB      0.0 MiB        3290                   g_score[neighbor] = temp_g_score
    73     74.1 MiB      0.0 MiB        3290                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     74.1 MiB      0.0 MiB        3290                   if neighbor not in open_set_hash:
    75     74.1 MiB      0.0 MiB        3290                       count += 1
    76     74.1 MiB      0.0 MiB        3290                       open_set.put((f_score[neighbor], count, neighbor))
    77     74.1 MiB      0.0 MiB        3290                       open_set_hash.add(neighbor)
    78                                                             
    79     74.1 MiB      0.0 MiB        2981           if draw is not None:
    80                                                     draw()
    81                                         
    82     74.1 MiB      0.0 MiB        2981           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     75.9 MiB     75.9 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     75.9 MiB      0.0 MiB         129       for row in grid:
    30     75.9 MiB      0.0 MiB       16512           for spot in row:
    31     75.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     75.9 MiB      0.0 MiB           1       count = 0
    34     75.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     75.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     75.9 MiB      0.0 MiB           1       came_from = {}
    37     76.1 MiB -15977.8 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.0 MiB     -8.1 MiB           1       g_score[start] = 0
    39     68.3 MiB      0.3 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.3 MiB   -948.1 MiB         816       while not open_set.empty():
    47     68.3 MiB   -948.1 MiB         816           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.3 MiB   -948.3 MiB         816           current = open_set.get()[2]
    53     68.3 MiB   -948.3 MiB         816           open_set_hash.remove(current)
    54                                         
    55     68.3 MiB   -948.3 MiB         816           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.3 MiB   -948.3 MiB         816           if current == end:
    60     66.7 MiB     -1.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.3 MiB  -8524.9 MiB        7335           for neighbor in current.neighbors:
    65     68.3 MiB  -7577.6 MiB        6520               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.3 MiB  -3790.0 MiB        3260                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.3 MiB  -3787.8 MiB        3260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.3 MiB  -7578.0 MiB        6520               if temp_g_score < g_score[neighbor]:
    71     68.3 MiB  -1070.7 MiB         978                   came_from[neighbor] = current
    72     68.3 MiB  -1070.7 MiB         978                   g_score[neighbor] = temp_g_score
    73     68.3 MiB  -1070.7 MiB         978                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.3 MiB  -1070.7 MiB         978                   if neighbor not in open_set_hash:
    75     68.3 MiB  -1070.7 MiB         978                       count += 1
    76     68.3 MiB  -1070.7 MiB         978                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.3 MiB  -1070.7 MiB         978                       open_set_hash.add(neighbor)
    78                                                             
    79     68.3 MiB   -947.7 MiB         815           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.3 MiB   -947.8 MiB         815           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     66.7 MiB     66.7 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     66.7 MiB      0.0 MiB         129       for row in grid:
    30     66.7 MiB      0.0 MiB       16512           for spot in row:
    31     66.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     66.7 MiB      0.0 MiB           1       count = 0
    34     66.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     66.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     66.7 MiB      0.0 MiB           1       came_from = {}
    37     66.8 MiB      0.1 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.4 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.4 MiB      0.0 MiB        2130       while not open_set.empty():
    47     67.4 MiB      0.0 MiB        2130           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.4 MiB      0.0 MiB        2130           current = open_set.get()[2]
    53     67.4 MiB      0.0 MiB        2130           open_set_hash.remove(current)
    54                                         
    55     67.4 MiB      0.0 MiB        2130           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.4 MiB      0.0 MiB        2130           if current == end:
    60     67.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.4 MiB      0.0 MiB       19161           for neighbor in current.neighbors:
    65     67.4 MiB      0.0 MiB       17032               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.4 MiB      0.0 MiB        8516                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.4 MiB      0.0 MiB        8516                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.4 MiB      0.0 MiB       17032               if temp_g_score < g_score[neighbor]:
    71     67.4 MiB      0.0 MiB        2390                   came_from[neighbor] = current
    72     67.4 MiB      0.0 MiB        2390                   g_score[neighbor] = temp_g_score
    73     67.4 MiB      0.0 MiB        2390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.4 MiB      0.0 MiB        2390                   if neighbor not in open_set_hash:
    75     67.4 MiB      0.0 MiB        2390                       count += 1
    76     67.4 MiB      0.0 MiB        2390                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.4 MiB      0.0 MiB        2390                       open_set_hash.add(neighbor)
    78                                                             
    79     67.4 MiB      0.0 MiB        2129           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.4 MiB      0.0 MiB        2129           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.4 MiB     67.4 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.4 MiB      0.0 MiB         129       for row in grid:
    30     67.4 MiB      0.0 MiB       16512           for spot in row:
    31     67.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     67.4 MiB      0.0 MiB           1       count = 0
    34     67.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.4 MiB      0.0 MiB           1       came_from = {}
    37     67.5 MiB      0.1 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     67.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     67.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     67.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     67.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     67.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.5 MiB      0.0 MiB        1088       while not open_set.empty():
    47     67.5 MiB      0.0 MiB        1088           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.5 MiB      0.0 MiB        1088           current = open_set.get()[2]
    53     67.5 MiB      0.0 MiB        1088           open_set_hash.remove(current)
    54                                         
    55     67.5 MiB      0.0 MiB        1088           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.5 MiB      0.0 MiB        1088           if current == end:
    60     67.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     67.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.5 MiB      0.0 MiB        9783           for neighbor in current.neighbors:
    65     67.5 MiB      0.0 MiB        8696               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.5 MiB      0.0 MiB        4348                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.5 MiB      0.0 MiB        4348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.5 MiB      0.0 MiB        8696               if temp_g_score < g_score[neighbor]:
    71     67.5 MiB      0.0 MiB        1282                   came_from[neighbor] = current
    72     67.5 MiB      0.0 MiB        1282                   g_score[neighbor] = temp_g_score
    73     67.5 MiB      0.0 MiB        1282                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.5 MiB      0.0 MiB        1282                   if neighbor not in open_set_hash:
    75     67.5 MiB      0.0 MiB        1282                       count += 1
    76     67.5 MiB      0.0 MiB        1282                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.5 MiB      0.0 MiB        1282                       open_set_hash.add(neighbor)
    78                                                             
    79     67.5 MiB      0.0 MiB        1087           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.5 MiB      0.0 MiB        1087           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.5 MiB     67.5 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     67.5 MiB      0.0 MiB         129       for row in grid:
    30     67.5 MiB      0.0 MiB       16512           for spot in row:
    31     67.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     67.5 MiB      0.0 MiB           1       count = 0
    34     67.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     67.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     67.5 MiB      0.0 MiB           1       came_from = {}
    37     67.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.1 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.1 MiB      0.0 MiB         500       while not open_set.empty():
    47     68.1 MiB      0.0 MiB         500           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.1 MiB      0.0 MiB         500           current = open_set.get()[2]
    53     68.1 MiB      0.0 MiB         500           open_set_hash.remove(current)
    54                                         
    55     68.1 MiB      0.0 MiB         500           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.1 MiB      0.0 MiB         500           if current == end:
    60     68.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.1 MiB      0.0 MiB        4491           for neighbor in current.neighbors:
    65     68.1 MiB      0.0 MiB        3992               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.1 MiB      0.0 MiB        1996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.1 MiB      0.0 MiB        1996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.1 MiB      0.0 MiB        3992               if temp_g_score < g_score[neighbor]:
    71     68.1 MiB      0.0 MiB         638                   came_from[neighbor] = current
    72     68.1 MiB      0.0 MiB         638                   g_score[neighbor] = temp_g_score
    73     68.1 MiB      0.0 MiB         638                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.1 MiB      0.0 MiB         638                   if neighbor not in open_set_hash:
    75     68.1 MiB      0.0 MiB         638                       count += 1
    76     68.1 MiB      0.0 MiB         638                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.1 MiB      0.0 MiB         638                       open_set_hash.add(neighbor)
    78                                                             
    79     68.1 MiB      0.0 MiB         499           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.1 MiB      0.0 MiB         499           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     68.1 MiB     68.1 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.1 MiB      0.0 MiB         129       for row in grid:
    30     68.1 MiB      0.0 MiB       16512           for spot in row:
    31     68.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    32                                             
    33     68.1 MiB      0.0 MiB           1       count = 0
    34     68.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     68.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     68.1 MiB      0.0 MiB           1       came_from = {}
    37     68.5 MiB      0.4 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    38     68.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     68.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    40     68.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     68.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     68.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     68.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     68.5 MiB     -1.0 MiB         518       while not open_set.empty():
    47     68.5 MiB     -1.0 MiB         518           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     68.5 MiB     -1.0 MiB         518           current = open_set.get()[2]
    53     68.5 MiB     -1.0 MiB         518           open_set_hash.remove(current)
    54                                         
    55     68.5 MiB     -1.0 MiB         518           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     68.5 MiB     -1.0 MiB         518           if current == end:
    60     68.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     68.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     68.5 MiB     -8.9 MiB        4653           for neighbor in current.neighbors:
    65     68.5 MiB     -7.9 MiB        4136               if current.row != neighbor.row and current.col != neighbor.col:
    66     68.5 MiB     -3.9 MiB        2068                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     68.5 MiB     -4.0 MiB        2068                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     68.5 MiB     -7.9 MiB        4136               if temp_g_score < g_score[neighbor]:
    71     68.5 MiB     -1.3 MiB         692                   came_from[neighbor] = current
    72     68.5 MiB     -1.3 MiB         692                   g_score[neighbor] = temp_g_score
    73     68.5 MiB     -1.3 MiB         692                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     68.5 MiB     -1.3 MiB         692                   if neighbor not in open_set_hash:
    75     68.5 MiB     -1.3 MiB         692                       count += 1
    76     68.5 MiB     -1.3 MiB         692                       open_set.put((f_score[neighbor], count, neighbor))
    77     68.5 MiB     -1.3 MiB         692                       open_set_hash.add(neighbor)
    78                                                             
    79     68.5 MiB     -1.0 MiB         517           if draw is not None:
    80                                                     draw()
    81                                         
    82     68.5 MiB     -1.0 MiB         517           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


