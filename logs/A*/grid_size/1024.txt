Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    975.9 MiB    975.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    975.9 MiB -120736.3 MiB        1025       for row in grid:
    30    975.9 MiB -123473692.5 MiB     1049600           for spot in row:
    31    975.9 MiB -123353295.3 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    510.5 MiB   -465.4 MiB           1       count = 0
    34    510.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    511.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    511.0 MiB      0.0 MiB           1       came_from = {}
    37    546.1 MiB -88999967.3 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    322.8 MiB   -223.4 MiB           1       g_score[start] = 0
    39    370.0 MiB -18477119.9 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    348.8 MiB    -21.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    348.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    348.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    348.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    482.3 MiB -183183.8 MiB       13974       while not open_set.empty():
    47    482.3 MiB -183185.2 MiB       13974           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    482.3 MiB -183189.0 MiB       13974           current = open_set.get()[2]
    53    482.3 MiB -183191.0 MiB       13974           open_set_hash.remove(current)
    54                                         
    55    482.3 MiB -183192.8 MiB       13974           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    482.3 MiB -183193.9 MiB       13974           if current == end:
    60    392.4 MiB    -89.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    392.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    482.3 MiB -1648111.4 MiB      125757           for neighbor in current.neighbors:
    65    482.3 MiB -1464927.9 MiB      111784               if current.row != neighbor.row and current.col != neighbor.col:
    66    482.3 MiB -732518.2 MiB       55892                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    482.3 MiB -732436.0 MiB       55892                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    482.3 MiB -1464965.2 MiB      111784               if temp_g_score < g_score[neighbor]:
    71    482.3 MiB -204512.2 MiB       15684                   came_from[neighbor] = current
    72    482.3 MiB -204545.3 MiB       15684                   g_score[neighbor] = temp_g_score
    73    482.3 MiB -204551.4 MiB       15684                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    482.3 MiB -204552.9 MiB       15684                   if neighbor not in open_set_hash:
    75    482.3 MiB -204553.9 MiB       15684                       count += 1
    76    482.3 MiB -204420.7 MiB       15684                       open_set.put((f_score[neighbor], count, neighbor))
    77    482.3 MiB -204540.4 MiB       15684                       open_set_hash.add(neighbor)
    78                                                             
    79    482.3 MiB -183181.4 MiB       13973           if draw is not None:
    80                                                     draw()
    81                                         
    82    482.3 MiB -183182.8 MiB       13973           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    911.0 MiB    911.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    911.0 MiB -493796.5 MiB        1025       for row in grid:
    30    911.0 MiB -505919053.5 MiB     1049600           for spot in row:
    31    911.0 MiB -505425583.5 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    306.0 MiB   -605.1 MiB           1       count = 0
    34    306.3 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    306.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    306.5 MiB      0.0 MiB           1       came_from = {}
    37    354.7 MiB -20100241.3 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    292.0 MiB    -62.7 MiB           1       g_score[start] = 0
    39    337.3 MiB -9258125.2 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    334.4 MiB     -2.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    334.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    334.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    334.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    484.1 MiB -4623627.5 MiB       47712       while not open_set.empty():
    47    484.1 MiB -4623632.4 MiB       47712           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    484.1 MiB -4623641.4 MiB       47712           current = open_set.get()[2]
    53    484.1 MiB -4623648.1 MiB       47712           open_set_hash.remove(current)
    54                                         
    55    484.1 MiB -4623652.2 MiB       47712           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    484.1 MiB -4623655.7 MiB       47712           if current == end:
    60    310.3 MiB   -173.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    310.5 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    484.1 MiB -41611947.7 MiB      429399           for neighbor in current.neighbors:
    65    484.1 MiB -36988358.1 MiB      381688               if current.row != neighbor.row and current.col != neighbor.col:
    66    484.1 MiB -18494297.1 MiB      190844                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    484.1 MiB -18494133.5 MiB      190844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    484.1 MiB -36988463.4 MiB      381688               if temp_g_score < g_score[neighbor]:
    71    484.1 MiB -4729987.6 MiB       49010                   came_from[neighbor] = current
    72    484.1 MiB -4729998.0 MiB       49010                   g_score[neighbor] = temp_g_score
    73    484.1 MiB -4730003.2 MiB       49010                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    484.1 MiB -4730007.7 MiB       49010                   if neighbor not in open_set_hash:
    75    484.1 MiB -4730033.7 MiB       49010                       count += 1
    76    484.1 MiB -4729808.6 MiB       49010                       open_set.put((f_score[neighbor], count, neighbor))
    77    484.1 MiB -4729950.8 MiB       49010                       open_set_hash.add(neighbor)
    78                                                             
    79    484.1 MiB -4623612.1 MiB       47711           if draw is not None:
    80                                                     draw()
    81                                         
    82    484.1 MiB -4623620.0 MiB       47711           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    975.9 MiB    975.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    975.9 MiB -120736.3 MiB        1025       for row in grid:
    30    975.9 MiB -123473692.5 MiB     1049600           for spot in row:
    31    975.9 MiB -123353295.3 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    510.5 MiB   -465.4 MiB           1       count = 0
    34    510.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    511.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    511.0 MiB      0.0 MiB           1       came_from = {}
    37    546.1 MiB -88999967.3 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    322.8 MiB   -223.4 MiB           1       g_score[start] = 0
    39    370.0 MiB -18477119.9 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    348.8 MiB    -21.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    348.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    348.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    348.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    482.3 MiB -183183.8 MiB       13974       while not open_set.empty():
    47    482.3 MiB -183185.2 MiB       13974           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    482.3 MiB -183189.0 MiB       13974           current = open_set.get()[2]
    53    482.3 MiB -183191.0 MiB       13974           open_set_hash.remove(current)
    54                                         
    55    482.3 MiB -183192.8 MiB       13974           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    482.3 MiB -183193.9 MiB       13974           if current == end:
    60    392.4 MiB    -89.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    392.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    482.3 MiB -1648111.4 MiB      125757           for neighbor in current.neighbors:
    65    482.3 MiB -1464927.9 MiB      111784               if current.row != neighbor.row and current.col != neighbor.col:
    66    482.3 MiB -732518.2 MiB       55892                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    482.3 MiB -732436.0 MiB       55892                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    482.3 MiB -1464965.2 MiB      111784               if temp_g_score < g_score[neighbor]:
    71    482.3 MiB -204512.2 MiB       15684                   came_from[neighbor] = current
    72    482.3 MiB -204545.3 MiB       15684                   g_score[neighbor] = temp_g_score
    73    482.3 MiB -204551.4 MiB       15684                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    482.3 MiB -204552.9 MiB       15684                   if neighbor not in open_set_hash:
    75    482.3 MiB -204553.9 MiB       15684                       count += 1
    76    482.3 MiB -204420.7 MiB       15684                       open_set.put((f_score[neighbor], count, neighbor))
    77    482.3 MiB -204540.4 MiB       15684                       open_set_hash.add(neighbor)
    78                                                             
    79    482.3 MiB -183181.4 MiB       13973           if draw is not None:
    80                                                     draw()
    81                                         
    82    482.3 MiB -183182.8 MiB       13973           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    990.7 MiB    990.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    990.7 MiB -298194.9 MiB        1025       for row in grid:
    30    990.7 MiB -305394562.6 MiB     1049600           for spot in row:
    31    990.7 MiB -305096793.8 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    305.8 MiB   -684.9 MiB           1       count = 0
    34    306.1 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    306.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    306.4 MiB      0.0 MiB           1       came_from = {}
    37    404.2 MiB -13824656.4 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    366.5 MiB    -37.7 MiB           1       g_score[start] = 0
    39    373.4 MiB -77363780.1 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    277.4 MiB    -95.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    277.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    277.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    277.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    455.2 MiB -73692.6 MiB       43392       while not open_set.empty():
    47    455.2 MiB -73693.3 MiB       43392           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    455.2 MiB -73694.0 MiB       43392           current = open_set.get()[2]
    53    455.2 MiB -73694.2 MiB       43392           open_set_hash.remove(current)
    54                                         
    55    455.2 MiB -73694.7 MiB       43392           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    455.2 MiB -73695.0 MiB       43392           if current == end:
    60    446.8 MiB     -8.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    446.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    455.2 MiB -663149.8 MiB      390519           for neighbor in current.neighbors:
    65    455.2 MiB -589444.5 MiB      347128               if current.row != neighbor.row and current.col != neighbor.col:
    66    455.2 MiB -294732.1 MiB      173564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    455.2 MiB -294732.3 MiB      173564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    455.2 MiB -589470.2 MiB      347128               if temp_g_score < g_score[neighbor]:
    71    455.2 MiB -75904.5 MiB       44580                   came_from[neighbor] = current
    72    455.2 MiB -75906.9 MiB       44580                   g_score[neighbor] = temp_g_score
    73    455.2 MiB -75907.6 MiB       44580                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    455.2 MiB -75907.9 MiB       44580                   if neighbor not in open_set_hash:
    75    455.2 MiB -75908.2 MiB       44580                       count += 1
    76    455.2 MiB -75745.5 MiB       44580                       open_set.put((f_score[neighbor], count, neighbor))
    77    455.2 MiB -75901.8 MiB       44580                       open_set_hash.add(neighbor)
    78                                                             
    79    455.2 MiB -73691.0 MiB       43391           if draw is not None:
    80                                                     draw()
    81                                         
    82    455.2 MiB -73691.8 MiB       43391           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    968.0 MiB    968.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    968.0 MiB -212937.2 MiB        1025       for row in grid:
    30    968.0 MiB -218030752.4 MiB     1049600           for spot in row:
    31    968.0 MiB -217818107.5 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    516.2 MiB   -451.9 MiB           1       count = 0
    34    516.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    516.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    516.7 MiB      0.0 MiB           1       came_from = {}
    37    518.1 MiB -156075849.0 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    355.1 MiB   -163.1 MiB           1       g_score[start] = 0
    39    435.8 MiB -528157.2 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    436.0 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    436.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    436.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    436.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    528.7 MiB -5311971.0 MiB       65026       while not open_set.empty():
    47    528.7 MiB -5311973.6 MiB       65026           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    528.7 MiB -5311981.3 MiB       65026           current = open_set.get()[2]
    53    528.7 MiB -5311996.4 MiB       65026           open_set_hash.remove(current)
    54                                         
    55    528.7 MiB -5311998.9 MiB       65026           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    528.7 MiB -5312001.5 MiB       65026           if current == end:
    60    393.0 MiB   -135.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    397.4 MiB      4.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    528.7 MiB -47807117.0 MiB      585225           for neighbor in current.neighbors:
    65    528.7 MiB -42495159.3 MiB      520200               if current.row != neighbor.row and current.col != neighbor.col:
    66    528.7 MiB -21247724.1 MiB      260100                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    528.7 MiB -21247468.9 MiB      260100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    528.7 MiB -42495222.2 MiB      520200               if temp_g_score < g_score[neighbor]:
    71    528.7 MiB -5486860.8 MiB       67400                   came_from[neighbor] = current
    72    528.7 MiB -5486865.6 MiB       67400                   g_score[neighbor] = temp_g_score
    73    528.7 MiB -5486877.3 MiB       67400                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    528.7 MiB -5486881.2 MiB       67400                   if neighbor not in open_set_hash:
    75    528.7 MiB -5486884.6 MiB       67400                       count += 1
    76    528.7 MiB -5486769.3 MiB       67400                       open_set.put((f_score[neighbor], count, neighbor))
    77    528.7 MiB -5486859.6 MiB       67400                       open_set_hash.add(neighbor)
    78                                                             
    79    528.7 MiB -5311963.8 MiB       65025           if draw is not None:
    80                                                     draw()
    81                                         
    82    528.7 MiB -5311966.5 MiB       65025           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    990.7 MiB    990.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    990.7 MiB -298194.9 MiB        1025       for row in grid:
    30    990.7 MiB -305394562.6 MiB     1049600           for spot in row:
    31    990.7 MiB -305096793.8 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    305.8 MiB   -684.9 MiB           1       count = 0
    34    306.1 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    306.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    306.4 MiB      0.0 MiB           1       came_from = {}
    37    404.2 MiB -13824656.4 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    366.5 MiB    -37.7 MiB           1       g_score[start] = 0
    39    373.4 MiB -77363780.1 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    277.4 MiB    -95.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    277.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    277.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    277.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    455.2 MiB -73692.6 MiB       43392       while not open_set.empty():
    47    455.2 MiB -73693.3 MiB       43392           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    455.2 MiB -73694.0 MiB       43392           current = open_set.get()[2]
    53    455.2 MiB -73694.2 MiB       43392           open_set_hash.remove(current)
    54                                         
    55    455.2 MiB -73694.7 MiB       43392           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    455.2 MiB -73695.0 MiB       43392           if current == end:
    60    446.8 MiB     -8.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    446.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    455.2 MiB -663149.8 MiB      390519           for neighbor in current.neighbors:
    65    455.2 MiB -589444.5 MiB      347128               if current.row != neighbor.row and current.col != neighbor.col:
    66    455.2 MiB -294732.1 MiB      173564                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    455.2 MiB -294732.3 MiB      173564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    455.2 MiB -589470.2 MiB      347128               if temp_g_score < g_score[neighbor]:
    71    455.2 MiB -75904.5 MiB       44580                   came_from[neighbor] = current
    72    455.2 MiB -75906.9 MiB       44580                   g_score[neighbor] = temp_g_score
    73    455.2 MiB -75907.6 MiB       44580                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    455.2 MiB -75907.9 MiB       44580                   if neighbor not in open_set_hash:
    75    455.2 MiB -75908.2 MiB       44580                       count += 1
    76    455.2 MiB -75745.5 MiB       44580                       open_set.put((f_score[neighbor], count, neighbor))
    77    455.2 MiB -75901.8 MiB       44580                       open_set_hash.add(neighbor)
    78                                                             
    79    455.2 MiB -73691.0 MiB       43391           if draw is not None:
    80                                                     draw()
    81                                         
    82    455.2 MiB -73691.8 MiB       43391           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    950.5 MiB    950.5 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    950.5 MiB -455374.8 MiB        1025       for row in grid:
    30    950.5 MiB -466571253.3 MiB     1049600           for spot in row:
    31    950.5 MiB -466116230.5 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    351.8 MiB   -598.8 MiB           1       count = 0
    34    352.1 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    352.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    352.3 MiB      0.0 MiB           1       came_from = {}
    37    463.6 MiB -3729549.3 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    451.5 MiB    -12.1 MiB           1       g_score[start] = 0
    39    533.0 MiB -6069440.8 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    519.2 MiB    -13.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    519.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    519.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    519.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    584.9 MiB -40020.8 MiB        5250       while not open_set.empty():
    47    584.9 MiB -40021.2 MiB        5250           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    584.9 MiB -40021.3 MiB        5250           current = open_set.get()[2]
    53    584.9 MiB -40022.1 MiB        5250           open_set_hash.remove(current)
    54                                         
    55    584.9 MiB -40022.6 MiB        5250           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    584.9 MiB -40023.2 MiB        5250           if current == end:
    60    571.8 MiB    -13.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    571.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    584.9 MiB -360095.7 MiB       47241           for neighbor in current.neighbors:
    65    584.9 MiB -320066.3 MiB       41992               if current.row != neighbor.row and current.col != neighbor.col:
    66    584.9 MiB -160047.8 MiB       20996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    584.9 MiB -160028.9 MiB       20996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    584.9 MiB -320079.4 MiB       41992               if temp_g_score < g_score[neighbor]:
    71    584.9 MiB -51415.8 MiB        6776                   came_from[neighbor] = current
    72    584.9 MiB -51416.6 MiB        6776                   g_score[neighbor] = temp_g_score
    73    584.9 MiB -51417.3 MiB        6776                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    584.9 MiB -51418.0 MiB        6776                   if neighbor not in open_set_hash:
    75    584.9 MiB -51418.5 MiB        6776                       count += 1
    76    584.9 MiB -51363.9 MiB        6776                       open_set.put((f_score[neighbor], count, neighbor))
    77    584.9 MiB -51420.5 MiB        6776                       open_set_hash.add(neighbor)
    78                                                             
    79    584.9 MiB -40020.2 MiB        5249           if draw is not None:
    80                                                     draw()
    81                                         
    82    584.9 MiB -40020.5 MiB        5249           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    966.4 MiB    966.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    966.7 MiB -390506.9 MiB        1025       for row in grid:
    30    966.7 MiB -399996313.4 MiB     1049600           for spot in row:
    31    966.7 MiB -399606203.4 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    339.9 MiB   -626.8 MiB           1       count = 0
    34    340.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    340.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    340.5 MiB      0.0 MiB           1       came_from = {}
    37    462.0 MiB -2996313.1 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    442.7 MiB    -19.3 MiB           1       g_score[start] = 0
    39    442.9 MiB -94607320.9 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    340.0 MiB   -102.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    340.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    340.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    340.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    493.8 MiB -733222.2 MiB       25647       while not open_set.empty():
    47    493.8 MiB -733225.4 MiB       25647           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    493.8 MiB -733229.8 MiB       25647           current = open_set.get()[2]
    53    493.8 MiB -733232.2 MiB       25647           open_set_hash.remove(current)
    54                                         
    55    493.8 MiB -733235.2 MiB       25647           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    493.8 MiB -733237.7 MiB       25647           if current == end:
    60    400.4 MiB    -93.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    402.8 MiB      2.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    493.8 MiB -6598574.6 MiB      230814           for neighbor in current.neighbors:
    65    493.8 MiB -5865361.6 MiB      205168               if current.row != neighbor.row and current.col != neighbor.col:
    66    493.8 MiB -2932760.4 MiB      102584                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    493.8 MiB -2932622.5 MiB      102584                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    493.8 MiB -5865405.1 MiB      205168               if temp_g_score < g_score[neighbor]:
    71    493.8 MiB -763582.4 MiB       26847                   came_from[neighbor] = current
    72    493.8 MiB -763584.6 MiB       26847                   g_score[neighbor] = temp_g_score
    73    493.8 MiB -763587.8 MiB       26847                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    493.8 MiB -763589.5 MiB       26847                   if neighbor not in open_set_hash:
    75    493.8 MiB -763591.8 MiB       26847                       count += 1
    76    493.8 MiB -763436.9 MiB       26847                       open_set.put((f_score[neighbor], count, neighbor))
    77    493.8 MiB -763588.1 MiB       26847                       open_set_hash.add(neighbor)
    78                                                             
    79    493.8 MiB -733218.2 MiB       25646           if draw is not None:
    80                                                     draw()
    81                                         
    82    493.8 MiB -733219.8 MiB       25646           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    962.9 MiB    962.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    962.9 MiB -534223.8 MiB        1025       for row in grid:
    30    962.9 MiB -547293316.1 MiB     1049600           for spot in row:
    31    962.9 MiB -546759511.2 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    266.3 MiB   -696.6 MiB           1       count = 0
    34    266.7 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    266.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    266.9 MiB      0.0 MiB           1       came_from = {}
    37    268.5 MiB -126610319.0 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    119.6 MiB   -148.9 MiB           1       g_score[start] = 0
    39    140.3 MiB -44137391.6 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40     89.4 MiB    -50.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     89.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     89.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     89.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    435.6 MiB -14765542.9 MiB       58534       while not open_set.empty():
    47    435.6 MiB -14771928.1 MiB       58534           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    435.6 MiB -14771946.5 MiB       58534           current = open_set.get()[2]
    53    435.6 MiB -14768900.2 MiB       58534           open_set_hash.remove(current)
    54                                         
    55    435.6 MiB -14768910.1 MiB       58534           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    435.6 MiB -14768919.0 MiB       58534           if current == end:
    60    434.8 MiB     -0.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    435.1 MiB      0.3 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    435.6 MiB -132895838.2 MiB      526797           for neighbor in current.neighbors:
    65    435.6 MiB -118129648.7 MiB      468264               if current.row != neighbor.row and current.col != neighbor.col:
    66    435.6 MiB -59063946.8 MiB      234132                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    435.6 MiB -59063698.1 MiB      234132                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    435.6 MiB -118126483.6 MiB      468264               if temp_g_score < g_score[neighbor]:
    71    435.6 MiB -14980296.1 MiB       59954                   came_from[neighbor] = current
    72    435.6 MiB -14980307.7 MiB       59954                   g_score[neighbor] = temp_g_score
    73    435.6 MiB -14980286.1 MiB       59954                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    435.6 MiB -14980296.8 MiB       59954                   if neighbor not in open_set_hash:
    75    435.6 MiB -14980307.8 MiB       59954                       count += 1
    76    435.6 MiB -14979594.5 MiB       59954                       open_set.put((f_score[neighbor], count, neighbor))
    77    435.6 MiB -14979954.0 MiB       59954                       open_set_hash.add(neighbor)
    78                                                             
    79    435.6 MiB -14766078.5 MiB       58533           if draw is not None:
    80                                                     draw()
    81                                         
    82    435.6 MiB -14765532.1 MiB       58533           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    965.6 MiB    965.6 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    965.6 MiB -621934.1 MiB        1025       for row in grid:
    30    965.6 MiB -637079343.6 MiB     1049600           for spot in row:
    31    965.6 MiB -636457882.1 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    240.2 MiB   -725.4 MiB           1       count = 0
    34    240.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    240.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    240.7 MiB      0.0 MiB           1       came_from = {}
    37    326.5 MiB -7536846.2 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    307.6 MiB    -18.9 MiB           1       g_score[start] = 0
    39    356.1 MiB -49184232.3 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    194.9 MiB   -161.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    194.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    194.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    194.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    463.6 MiB -5594247.2 MiB       67344       while not open_set.empty():
    47    463.6 MiB -5594253.4 MiB       67344           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    463.6 MiB -5594263.4 MiB       67344           current = open_set.get()[2]
    53    463.6 MiB -5594269.5 MiB       67344           open_set_hash.remove(current)
    54                                         
    55    463.6 MiB -5594275.5 MiB       67344           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    463.6 MiB -5594280.8 MiB       67344           if current == end:
    60    167.2 MiB   -296.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    170.4 MiB      3.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    463.6 MiB -50346875.4 MiB      606087           for neighbor in current.neighbors:
    65    463.6 MiB -44752658.4 MiB      538744               if current.row != neighbor.row and current.col != neighbor.col:
    66    463.6 MiB -22376619.6 MiB      269372                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    463.6 MiB -22376113.0 MiB      269372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    463.6 MiB -44752806.2 MiB      538744               if temp_g_score < g_score[neighbor]:
    71    463.6 MiB -5754723.0 MiB       69570                   came_from[neighbor] = current
    72    463.6 MiB -5754733.1 MiB       69570                   g_score[neighbor] = temp_g_score
    73    463.6 MiB -5754736.0 MiB       69570                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    463.6 MiB -5754741.6 MiB       69570                   if neighbor not in open_set_hash:
    75    463.6 MiB -5754747.4 MiB       69570                       count += 1
    76    463.6 MiB -5754519.4 MiB       69570                       open_set.put((f_score[neighbor], count, neighbor))
    77    463.6 MiB -5754759.9 MiB       69570                       open_set_hash.add(neighbor)
    78                                                             
    79    463.6 MiB -5594234.3 MiB       67343           if draw is not None:
    80                                                     draw()
    81                                         
    82    463.6 MiB -5594240.1 MiB       67343           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    938.8 MiB    938.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    938.8 MiB -574450.7 MiB        1025       for row in grid:
    30    938.8 MiB -588430851.0 MiB     1049600           for spot in row:
    31    938.8 MiB -587856785.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    222.3 MiB   -716.5 MiB           1       count = 0
    34    222.7 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    222.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    222.9 MiB      0.0 MiB           1       came_from = {}
    37    340.7 MiB -1424881.7 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    333.4 MiB     -7.3 MiB           1       g_score[start] = 0
    39    363.5 MiB -11838004.1 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    312.0 MiB    -51.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    312.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    312.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    312.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    486.1 MiB -1415954.5 MiB       30576       while not open_set.empty():
    47    486.1 MiB -1415958.3 MiB       30576           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    486.1 MiB -1415967.2 MiB       30576           current = open_set.get()[2]
    53    486.1 MiB -1415972.6 MiB       30576           open_set_hash.remove(current)
    54                                         
    55    486.1 MiB -1415978.7 MiB       30576           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    486.1 MiB -1415983.4 MiB       30576           if current == end:
    60    271.1 MiB   -215.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    271.3 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    486.1 MiB -12742741.4 MiB      275175           for neighbor in current.neighbors:
    65    486.1 MiB -11326827.2 MiB      244600               if current.row != neighbor.row and current.col != neighbor.col:
    66    486.1 MiB -5663601.0 MiB      122300                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    486.1 MiB -5663274.7 MiB      122300                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    486.1 MiB -11326912.1 MiB      244600               if temp_g_score < g_score[neighbor]:
    71    486.1 MiB -1462634.5 MiB       31610                   came_from[neighbor] = current
    72    486.1 MiB -1462639.8 MiB       31610                   g_score[neighbor] = temp_g_score
    73    486.1 MiB -1462650.0 MiB       31610                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    486.1 MiB -1462654.7 MiB       31610                   if neighbor not in open_set_hash:
    75    486.1 MiB -1462658.4 MiB       31610                       count += 1
    76    486.1 MiB -1462489.1 MiB       31610                       open_set.put((f_score[neighbor], count, neighbor))
    77    486.1 MiB -1462654.0 MiB       31610                       open_set_hash.add(neighbor)
    78                                                             
    79    486.1 MiB -1415945.8 MiB       30575           if draw is not None:
    80                                                     draw()
    81                                         
    82    486.1 MiB -1415949.7 MiB       30575           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    810.2 MiB    810.2 MiB           1   @profile(stream=open('logs/A*/num_goals/1.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    810.4 MiB -562530.0 MiB        1025       for row in grid:
    30    810.4 MiB -576223313.0 MiB     1049600           for spot in row:
    31    810.4 MiB -575661163.3 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    159.0 MiB   -651.4 MiB           1       count = 0
    34    159.4 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    159.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    159.6 MiB      0.0 MiB           1       came_from = {}
    37    293.9 MiB -1269531.3 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    293.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    343.3 MiB -4444596.7 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    323.3 MiB    -20.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    323.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    323.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    323.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    326.9 MiB      0.0 MiB         492       while not open_set.empty():
    47    326.9 MiB      0.0 MiB         492           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    326.9 MiB      0.0 MiB         492           current = open_set.get()[2]
    53    326.9 MiB      0.0 MiB         492           open_set_hash.remove(current)
    54                                         
    55    326.9 MiB      0.0 MiB         492           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    326.9 MiB      0.0 MiB         492           if current == end:
    60    326.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    327.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    326.9 MiB      0.6 MiB        4419           for neighbor in current.neighbors:
    65    326.9 MiB      2.7 MiB        3928               if current.row != neighbor.row and current.col != neighbor.col:
    66    326.9 MiB      0.0 MiB        1964                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    326.9 MiB      0.0 MiB        1964                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    326.9 MiB      0.0 MiB        3928               if temp_g_score < g_score[neighbor]:
    71    326.9 MiB      0.0 MiB         678                   came_from[neighbor] = current
    72    326.9 MiB      0.0 MiB         678                   g_score[neighbor] = temp_g_score
    73    326.9 MiB      0.0 MiB         678                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    326.9 MiB      0.0 MiB         678                   if neighbor not in open_set_hash:
    75    326.9 MiB      0.0 MiB         678                       count += 1
    76    326.9 MiB      0.1 MiB         678                       open_set.put((f_score[neighbor], count, neighbor))
    77    326.9 MiB      0.0 MiB         678                       open_set_hash.add(neighbor)
    78                                                             
    79    326.9 MiB      0.0 MiB         491           if draw is not None:
    80                                                     draw()
    81                                         
    82    326.9 MiB      0.0 MiB         491           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    961.0 MiB    961.0 MiB           1   @profile(stream=open('logs/A*/num_goals/1.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    961.0 MiB -711080.9 MiB        1025       for row in grid:
    30    961.0 MiB -728529408.6 MiB     1049600           for spot in row:
    31    961.0 MiB -727818774.1 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    208.5 MiB   -752.4 MiB           1       count = 0
    34    208.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    209.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    209.1 MiB      0.0 MiB           1       came_from = {}
    37    223.3 MiB -41186061.0 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    156.4 MiB    -66.9 MiB           1       g_score[start] = 0
    39    203.9 MiB -14014745.8 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    146.9 MiB    -57.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    147.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    147.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    147.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    452.9 MiB -4227823.1 MiB       38533       while not open_set.empty():
    47    452.9 MiB -4227834.0 MiB       38533           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    452.9 MiB -4227852.2 MiB       38533           current = open_set.get()[2]
    53    452.9 MiB -4227857.8 MiB       38533           open_set_hash.remove(current)
    54                                         
    55    452.9 MiB -4227862.2 MiB       38533           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    452.9 MiB -4227869.7 MiB       38533           if current == end:
    60    100.8 MiB   -352.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.3 MiB      4.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    452.9 MiB -38048828.0 MiB      346788           for neighbor in current.neighbors:
    65    452.9 MiB -33821060.1 MiB      308256               if current.row != neighbor.row and current.col != neighbor.col:
    66    452.9 MiB -16910915.4 MiB      154128                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    452.9 MiB -16910225.0 MiB      154128                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    452.9 MiB -33821183.5 MiB      308256               if temp_g_score < g_score[neighbor]:
    71    452.9 MiB -4342602.9 MiB       39665                   came_from[neighbor] = current
    72    452.9 MiB -4342619.0 MiB       39665                   g_score[neighbor] = temp_g_score
    73    452.9 MiB -4342602.7 MiB       39665                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    452.9 MiB -4342609.5 MiB       39665                   if neighbor not in open_set_hash:
    75    452.9 MiB -4342619.6 MiB       39665                       count += 1
    76    452.9 MiB -4342318.1 MiB       39665                       open_set.put((f_score[neighbor], count, neighbor))
    77    452.9 MiB -4342618.3 MiB       39665                       open_set_hash.add(neighbor)
    78                                                             
    79    452.9 MiB -4227812.7 MiB       38532           if draw is not None:
    80                                                     draw()
    81                                         
    82    452.9 MiB -4227817.4 MiB       38532           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    968.2 MiB    968.2 MiB           1   @profile(stream=open('logs/A*/num_goals/7.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    968.2 MiB -633520.6 MiB        1025       for row in grid:
    30    968.2 MiB -648887091.7 MiB     1049600           for spot in row:
    31    968.2 MiB -648254038.2 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    140.5 MiB   -827.8 MiB           1       count = 0
    34    140.9 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    141.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    141.1 MiB      0.0 MiB           1       came_from = {}
    37    206.1 MiB -73900200.6 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38     66.8 MiB   -139.3 MiB           1       g_score[start] = 0
    39    165.5 MiB -14199721.7 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    136.6 MiB    -28.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    136.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    136.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    136.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    451.0 MiB -251375.5 MiB        8378       while not open_set.empty():
    47    451.0 MiB -251377.0 MiB        8378           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    451.0 MiB -251377.7 MiB        8378           current = open_set.get()[2]
    53    451.0 MiB -251378.4 MiB        8378           open_set_hash.remove(current)
    54                                         
    55    451.0 MiB -251378.8 MiB        8378           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    451.0 MiB -251379.2 MiB        8378           if current == end:
    60    451.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    451.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    451.0 MiB -2262346.2 MiB       75393           for neighbor in current.neighbors:
    65    451.0 MiB -2010979.2 MiB       67016               if current.row != neighbor.row and current.col != neighbor.col:
    66    451.0 MiB -1005465.2 MiB       33508                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    451.0 MiB -1005527.1 MiB       33508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    451.0 MiB -2010979.1 MiB       67016               if temp_g_score < g_score[neighbor]:
    71    451.0 MiB -268266.1 MiB        9062                   came_from[neighbor] = current
    72    451.0 MiB -268273.5 MiB        9062                   g_score[neighbor] = temp_g_score
    73    451.0 MiB -268272.3 MiB        9062                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    451.0 MiB -268273.9 MiB        9062                   if neighbor not in open_set_hash:
    75    451.0 MiB -268274.5 MiB        9062                       count += 1
    76    451.0 MiB -267935.4 MiB        9062                       open_set.put((f_score[neighbor], count, neighbor))
    77    451.0 MiB -268226.2 MiB        9062                       open_set_hash.add(neighbor)
    78                                                             
    79    451.0 MiB -251372.8 MiB        8377           if draw is not None:
    80                                                     draw()
    81                                         
    82    451.0 MiB -251374.3 MiB        8377           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    967.3 MiB    967.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    967.3 MiB -454003.8 MiB        1025       for row in grid:
    30    967.3 MiB -465087161.4 MiB     1049600           for spot in row:
    31    967.3 MiB -464633474.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    390.9 MiB   -576.5 MiB           1       count = 0
    34    391.2 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    391.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    391.4 MiB      0.0 MiB           1       came_from = {}
    37    492.2 MiB -8034052.5 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    425.8 MiB    -66.5 MiB           1       g_score[start] = 0
    39    456.9 MiB -13187587.4 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    417.6 MiB    -39.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    417.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    417.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    417.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    473.3 MiB -12933898.5 MiB       91930       while not open_set.empty():
    47    473.3 MiB -12933905.1 MiB       91930           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    473.3 MiB -12933923.3 MiB       91930           current = open_set.get()[2]
    53    473.3 MiB -12933936.8 MiB       91930           open_set_hash.remove(current)
    54                                         
    55    473.3 MiB -12933946.0 MiB       91930           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    473.3 MiB -12933954.5 MiB       91930           if current == end:
    60    453.5 MiB    -19.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    453.7 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    473.3 MiB -116405498.5 MiB      827361           for neighbor in current.neighbors:
    65    473.3 MiB -103471712.5 MiB      735432               if current.row != neighbor.row and current.col != neighbor.col:
    66    473.3 MiB -51735746.6 MiB      367716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    473.3 MiB -51736112.9 MiB      367716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    473.3 MiB -103471933.8 MiB      735432               if temp_g_score < g_score[neighbor]:
    71    473.3 MiB -13131880.1 MiB       93776                   came_from[neighbor] = current
    72    473.3 MiB -13131900.1 MiB       93776                   g_score[neighbor] = temp_g_score
    73    473.3 MiB -13131908.3 MiB       93776                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    473.3 MiB -13131918.1 MiB       93776                   if neighbor not in open_set_hash:
    75    473.3 MiB -13131927.7 MiB       93776                       count += 1
    76    473.3 MiB -13131370.7 MiB       93776                       open_set.put((f_score[neighbor], count, neighbor))
    77    473.3 MiB -13131429.5 MiB       93776                       open_set_hash.add(neighbor)
    78                                                             
    79    473.3 MiB -12933871.9 MiB       91929           if draw is not None:
    80                                                     draw()
    81                                         
    82    473.3 MiB -12933880.1 MiB       91929           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    894.0 MiB    894.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    894.0 MiB -260301.4 MiB        1025       for row in grid:
    30    894.0 MiB -266488308.0 MiB     1049600           for spot in row:
    31    894.0 MiB -266228328.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    303.0 MiB   -591.0 MiB           1       count = 0
    34    303.4 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    303.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    303.6 MiB      0.0 MiB           1       came_from = {}
    37    305.6 MiB -175892118.2 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    186.1 MiB   -119.4 MiB           1       g_score[start] = 0
    39    265.8 MiB -3742833.5 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    247.4 MiB    -18.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    247.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    247.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    247.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    478.0 MiB -463223.6 MiB       23712       while not open_set.empty():
    47    478.0 MiB -463225.3 MiB       23712           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    478.0 MiB -463227.0 MiB       23712           current = open_set.get()[2]
    53    478.0 MiB -463228.3 MiB       23712           open_set_hash.remove(current)
    54                                         
    55    478.0 MiB -463230.9 MiB       23712           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    478.0 MiB -463232.8 MiB       23712           if current == end:
    60    414.1 MiB    -63.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    414.5 MiB      0.3 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    478.0 MiB -4168706.1 MiB      213399           for neighbor in current.neighbors:
    65    478.0 MiB -3705472.3 MiB      189688               if current.row != neighbor.row and current.col != neighbor.col:
    66    478.0 MiB -1852808.0 MiB       94844                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    478.0 MiB -1852703.0 MiB       94844                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    478.0 MiB -3705521.0 MiB      189688               if temp_g_score < g_score[neighbor]:
    71    478.0 MiB -489168.7 MiB       25082                   came_from[neighbor] = current
    72    478.0 MiB -489172.9 MiB       25082                   g_score[neighbor] = temp_g_score
    73    478.0 MiB -489175.4 MiB       25082                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    478.0 MiB -489177.8 MiB       25082                   if neighbor not in open_set_hash:
    75    478.0 MiB -489180.3 MiB       25082                       count += 1
    76    478.0 MiB -488952.5 MiB       25082                       open_set.put((f_score[neighbor], count, neighbor))
    77    478.0 MiB -489163.1 MiB       25082                       open_set_hash.add(neighbor)
    78                                                             
    79    478.0 MiB -463218.2 MiB       23711           if draw is not None:
    80                                                     draw()
    81                                         
    82    478.0 MiB -463222.1 MiB       23711           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    963.1 MiB    963.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    963.1 MiB -200553.7 MiB        1025       for row in grid:
    30    963.1 MiB -205192413.5 MiB     1049600           for spot in row:
    31    963.1 MiB -204992231.3 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    412.0 MiB   -551.1 MiB           1       count = 0
    34    412.4 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    412.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    412.6 MiB      0.0 MiB           1       came_from = {}
    37    439.9 MiB -26755100.4 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    378.1 MiB    -61.8 MiB           1       g_score[start] = 0
    39    473.2 MiB -1546021.8 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    470.7 MiB     -2.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    470.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    470.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    470.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    562.8 MiB -678081.5 MiB       41515       while not open_set.empty():
    47    562.8 MiB -678082.5 MiB       41515           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    562.8 MiB -678084.7 MiB       41515           current = open_set.get()[2]
    53    562.8 MiB -678086.1 MiB       41515           open_set_hash.remove(current)
    54                                         
    55    562.8 MiB -678088.3 MiB       41515           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    562.8 MiB -678089.8 MiB       41515           if current == end:
    60    512.0 MiB    -50.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    512.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    562.8 MiB -6102477.8 MiB      373626           for neighbor in current.neighbors:
    65    562.8 MiB -5424393.4 MiB      332112               if current.row != neighbor.row and current.col != neighbor.col:
    66    562.8 MiB -2712236.8 MiB      166056                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    562.8 MiB -2712179.5 MiB      166056                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    562.8 MiB -5424429.3 MiB      332112               if temp_g_score < g_score[neighbor]:
    71    562.8 MiB -697801.5 MiB       42695                   came_from[neighbor] = current
    72    562.8 MiB -697804.2 MiB       42695                   g_score[neighbor] = temp_g_score
    73    562.8 MiB -697807.7 MiB       42695                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    562.8 MiB -697809.7 MiB       42695                   if neighbor not in open_set_hash:
    75    562.8 MiB -697811.1 MiB       42695                       count += 1
    76    562.8 MiB -697699.5 MiB       42695                       open_set.put((f_score[neighbor], count, neighbor))
    77    562.8 MiB -697781.4 MiB       42695                       open_set_hash.add(neighbor)
    78                                                             
    79    562.8 MiB -678078.0 MiB       41514           if draw is not None:
    80                                                     draw()
    81                                         
    82    562.8 MiB -678079.8 MiB       41514           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    986.9 MiB    986.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    986.9 MiB -155421.6 MiB        1025       for row in grid:
    30    986.9 MiB -159172043.1 MiB     1049600           for spot in row:
    31    986.9 MiB -159016768.5 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    753.9 MiB   -233.0 MiB           1       count = 0
    34    753.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    754.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    754.0 MiB      0.0 MiB           1       came_from = {}
    37    757.0 MiB -158162037.5 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    401.3 MiB   -355.7 MiB           1       g_score[start] = 0
    39    463.4 MiB -8088478.2 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    461.6 MiB     -1.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    461.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    461.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    461.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    559.9 MiB -20375678.4 MiB      116109       while not open_set.empty():
    47    559.8 MiB -20375686.1 MiB      116109           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    559.8 MiB -20372394.1 MiB      116109           current = open_set.get()[2]
    53    559.8 MiB -20367443.5 MiB      116109           open_set_hash.remove(current)
    54                                         
    55    559.8 MiB -20367451.0 MiB      116109           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    559.8 MiB -20367470.3 MiB      116109           if current == end:
    60    214.8 MiB   -345.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    215.0 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    559.9 MiB -183371353.2 MiB     1044972           for neighbor in current.neighbors:
    65    559.9 MiB -163004017.1 MiB      928864               if current.row != neighbor.row and current.col != neighbor.col:
    66    559.9 MiB -81502248.7 MiB      464432                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    559.8 MiB -81501836.2 MiB      464432                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    559.9 MiB -162971070.1 MiB      928864               if temp_g_score < g_score[neighbor]:
    71    559.9 MiB -20630752.9 MiB      118069                   came_from[neighbor] = current
    72    559.9 MiB -20630759.0 MiB      118069                   g_score[neighbor] = temp_g_score
    73    559.9 MiB -20630766.2 MiB      118069                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    559.9 MiB -20630771.2 MiB      118069                   if neighbor not in open_set_hash:
    75    559.9 MiB -20630775.0 MiB      118069                       count += 1
    76    559.9 MiB -20630683.8 MiB      118069                       open_set.put((f_score[neighbor], count, neighbor))
    77    559.9 MiB -20630785.8 MiB      118069                       open_set_hash.add(neighbor)
    78                                                             
    79    559.9 MiB -20375656.7 MiB      116108           if draw is not None:
    80                                                     draw()
    81                                         
    82    559.9 MiB -20375670.1 MiB      116108           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    971.3 MiB    971.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    971.3 MiB -602947.7 MiB        1025       for row in grid:
    30    971.3 MiB -617701032.7 MiB     1049600           for spot in row:
    31    971.3 MiB -617098283.6 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    258.4 MiB   -712.9 MiB           1       count = 0
    34    258.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    259.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    259.0 MiB      0.0 MiB           1       came_from = {}
    37    298.2 MiB -49730689.7 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    188.2 MiB   -110.0 MiB           1       g_score[start] = 0
    39    235.8 MiB -21158661.8 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    236.2 MiB      0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    236.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    236.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    236.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    518.4 MiB -1802746.6 MiB       60792       while not open_set.empty():
    47    518.4 MiB -1802748.6 MiB       60792           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    518.4 MiB -1802753.2 MiB       60792           current = open_set.get()[2]
    53    518.4 MiB -1802754.9 MiB       60792           open_set_hash.remove(current)
    54                                         
    55    518.4 MiB -1802756.6 MiB       60792           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    518.4 MiB -1802758.6 MiB       60792           if current == end:
    60    454.4 MiB    -64.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    454.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    518.4 MiB -16224422.3 MiB      547119           for neighbor in current.neighbors:
    65    518.4 MiB -14421659.1 MiB      486328               if current.row != neighbor.row and current.col != neighbor.col:
    66    518.4 MiB -7210897.1 MiB      243164                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    518.4 MiB -7210791.2 MiB      243164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    518.4 MiB -14421705.8 MiB      486328               if temp_g_score < g_score[neighbor]:
    71    518.4 MiB -1855512.9 MiB       62850                   came_from[neighbor] = current
    72    518.4 MiB -1855516.2 MiB       62850                   g_score[neighbor] = temp_g_score
    73    518.4 MiB -1855518.0 MiB       62850                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    518.4 MiB -1855520.5 MiB       62850                   if neighbor not in open_set_hash:
    75    518.4 MiB -1855525.0 MiB       62850                       count += 1
    76    518.4 MiB -1855265.2 MiB       62850                       open_set.put((f_score[neighbor], count, neighbor))
    77    518.4 MiB -1855527.5 MiB       62850                       open_set_hash.add(neighbor)
    78                                                             
    79    518.4 MiB -1802743.8 MiB       60791           if draw is not None:
    80                                                     draw()
    81                                         
    82    518.4 MiB -1802745.2 MiB       60791           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    999.8 MiB    999.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    999.8 MiB -548650.9 MiB        1025       for row in grid:
    30    999.8 MiB -562104765.3 MiB     1049600           for spot in row:
    31    999.8 MiB -561556458.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    360.4 MiB   -639.4 MiB           1       count = 0
    34    360.8 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    361.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    361.0 MiB      0.0 MiB           1       came_from = {}
    37    482.6 MiB -22086830.2 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    394.1 MiB    -88.4 MiB           1       g_score[start] = 0
    39    420.5 MiB -261806508.0 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.4 MiB   -323.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    455.6 MiB -25585577.2 MiB       77127       while not open_set.empty():
    47    455.6 MiB -25585588.2 MiB       77127           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    455.5 MiB -25585605.7 MiB       77127           current = open_set.get()[2]
    53    455.5 MiB -25583534.0 MiB       77127           open_set_hash.remove(current)
    54                                         
    55    455.5 MiB -25583550.5 MiB       77127           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    455.5 MiB -25583558.6 MiB       77127           if current == end:
    60     71.3 MiB   -384.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     71.7 MiB      0.3 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    455.6 MiB -230266435.5 MiB      694134           for neighbor in current.neighbors:
    65    455.6 MiB -204683007.2 MiB      617008               if current.row != neighbor.row and current.col != neighbor.col:
    66    455.6 MiB -102341842.2 MiB      308504                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    455.5 MiB -102341272.7 MiB      308504                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    455.6 MiB -204674861.0 MiB      617008               if temp_g_score < g_score[neighbor]:
    71    455.6 MiB -26005635.2 MiB       78783                   came_from[neighbor] = current
    72    455.6 MiB -26005643.9 MiB       78783                   g_score[neighbor] = temp_g_score
    73    455.6 MiB -26005640.6 MiB       78783                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    455.6 MiB -26005650.3 MiB       78783                   if neighbor not in open_set_hash:
    75    455.6 MiB -26005659.8 MiB       78783                       count += 1
    76    455.6 MiB -26005286.4 MiB       78783                       open_set.put((f_score[neighbor], count, neighbor))
    77    455.6 MiB -26005650.3 MiB       78783                       open_set_hash.add(neighbor)
    78                                                             
    79    455.6 MiB -25585552.9 MiB       77126           if draw is not None:
    80                                                     draw()
    81                                         
    82    455.6 MiB -25585568.3 MiB       77126           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    981.7 MiB    981.7 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    981.7 MiB -532463.0 MiB        1025       for row in grid:
    30    981.7 MiB -545497226.8 MiB     1049600           for spot in row:
    31    981.7 MiB -544965070.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    407.8 MiB   -573.9 MiB           1       count = 0
    34    408.2 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    408.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    408.4 MiB      0.0 MiB           1       came_from = {}
    37    440.2 MiB -21916551.4 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    407.5 MiB    -32.7 MiB           1       g_score[start] = 0
    39    412.3 MiB -20208836.3 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    406.9 MiB     -5.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    406.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    406.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    406.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    546.5 MiB -28963781.5 MiB       89870       while not open_set.empty():
    47    546.5 MiB -28963789.8 MiB       89870           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    546.5 MiB -28963815.5 MiB       89870           current = open_set.get()[2]
    53    546.5 MiB -28963824.1 MiB       89870           open_set_hash.remove(current)
    54                                         
    55    546.5 MiB -28963847.7 MiB       89870           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    546.5 MiB -28963860.4 MiB       89870           if current == end:
    60    132.8 MiB   -413.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    136.4 MiB      3.6 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    546.5 MiB -260672282.2 MiB      808821           for neighbor in current.neighbors:
    65    546.5 MiB -231708570.2 MiB      718952               if current.row != neighbor.row and current.col != neighbor.col:
    66    546.5 MiB -115854650.0 MiB      359476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    546.5 MiB -115854004.2 MiB      359476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    546.5 MiB -231708708.5 MiB      718952               if temp_g_score < g_score[neighbor]:
    71    546.5 MiB -29518954.5 MiB       92006                   came_from[neighbor] = current
    72    546.5 MiB -29518964.1 MiB       92006                   g_score[neighbor] = temp_g_score
    73    546.5 MiB -29518959.5 MiB       92006                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    546.5 MiB -29518967.8 MiB       92006                   if neighbor not in open_set_hash:
    75    546.5 MiB -29518977.0 MiB       92006                       count += 1
    76    546.5 MiB -29518850.2 MiB       92006                       open_set.put((f_score[neighbor], count, neighbor))
    77    546.5 MiB -29518993.7 MiB       92006                       open_set_hash.add(neighbor)
    78                                                             
    79    546.5 MiB -28963759.4 MiB       89869           if draw is not None:
    80                                                     draw()
    81                                         
    82    546.5 MiB -28963768.6 MiB       89869           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    959.0 MiB    959.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    959.0 MiB -462217.6 MiB        1025       for row in grid:
    30    959.0 MiB -473671494.6 MiB     1049600           for spot in row:
    31    959.0 MiB -473209486.7 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    501.5 MiB   -457.4 MiB           1       count = 0
    34    501.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    502.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    502.1 MiB      0.0 MiB           1       came_from = {}
    37    601.4 MiB -4261747.6 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    563.7 MiB    -37.7 MiB           1       g_score[start] = 0
    39    588.4 MiB -114190371.3 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    210.4 MiB   -378.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    210.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    210.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    210.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    473.0 MiB -6188548.7 MiB       45838       while not open_set.empty():
    47    473.0 MiB -6188556.2 MiB       45838           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    473.0 MiB -6188570.2 MiB       45838           current = open_set.get()[2]
    53    473.0 MiB -6188582.6 MiB       45838           open_set_hash.remove(current)
    54                                         
    55    473.0 MiB -6188592.4 MiB       45838           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    473.0 MiB -6188599.9 MiB       45838           if current == end:
    60    149.2 MiB   -323.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    149.5 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    473.0 MiB -55695814.7 MiB      412533           for neighbor in current.neighbors:
    65    473.0 MiB -49507369.3 MiB      366696               if current.row != neighbor.row and current.col != neighbor.col:
    66    473.0 MiB -24753921.4 MiB      183348                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    473.0 MiB -24753517.8 MiB      183348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    473.0 MiB -49507476.0 MiB      366696               if temp_g_score < g_score[neighbor]:
    71    473.0 MiB -6362310.0 MiB       47246                   came_from[neighbor] = current
    72    473.0 MiB -6362318.0 MiB       47246                   g_score[neighbor] = temp_g_score
    73    473.0 MiB -6362326.8 MiB       47246                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    473.0 MiB -6362335.8 MiB       47246                   if neighbor not in open_set_hash:
    75    473.0 MiB -6362341.9 MiB       47246                       count += 1
    76    473.0 MiB -6362036.4 MiB       47246                       open_set.put((f_score[neighbor], count, neighbor))
    77    473.0 MiB -6362296.0 MiB       47246                       open_set_hash.add(neighbor)
    78                                                             
    79    473.0 MiB -6188532.8 MiB       45837           if draw is not None:
    80                                                     draw()
    81                                         
    82    473.0 MiB -6188539.2 MiB       45837           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    978.6 MiB    978.6 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    978.6 MiB -622456.5 MiB        1025       for row in grid:
    30    978.6 MiB -637651564.7 MiB     1049600           for spot in row:
    31    978.6 MiB -637029418.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    355.4 MiB   -623.2 MiB           1       count = 0
    34    355.8 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    356.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    356.0 MiB      0.0 MiB           1       came_from = {}
    37    368.9 MiB -61225772.5 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    337.5 MiB    -31.3 MiB           1       g_score[start] = 0
    39    360.8 MiB -99124408.6 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    223.1 MiB   -137.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    223.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    223.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    223.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    494.1 MiB -5399429.3 MiB       86900       while not open_set.empty():
    47    494.1 MiB -5399440.4 MiB       86900           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    494.1 MiB -5399455.5 MiB       86900           current = open_set.get()[2]
    53    494.1 MiB -5399463.0 MiB       86900           open_set_hash.remove(current)
    54                                         
    55    494.1 MiB -5399470.4 MiB       86900           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    494.1 MiB -5399486.4 MiB       86900           if current == end:
    60    122.3 MiB   -371.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    124.3 MiB      2.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    494.1 MiB -48593320.9 MiB      782091           for neighbor in current.neighbors:
    65    494.1 MiB -43193960.4 MiB      695192               if current.row != neighbor.row and current.col != neighbor.col:
    66    494.1 MiB -21597263.0 MiB      347596                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    494.1 MiB -21596790.0 MiB      347596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    494.1 MiB -43194111.5 MiB      695192               if temp_g_score < g_score[neighbor]:
    71    494.1 MiB -5527355.2 MiB       88630                   came_from[neighbor] = current
    72    494.1 MiB -5527375.6 MiB       88630                   g_score[neighbor] = temp_g_score
    73    494.1 MiB -5527384.3 MiB       88630                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    494.1 MiB -5527390.9 MiB       88630                   if neighbor not in open_set_hash:
    75    494.1 MiB -5527397.1 MiB       88630                       count += 1
    76    494.1 MiB -5527130.6 MiB       88630                       open_set.put((f_score[neighbor], count, neighbor))
    77    494.1 MiB -5527382.5 MiB       88630                       open_set_hash.add(neighbor)
    78                                                             
    79    494.1 MiB -5399407.8 MiB       86899           if draw is not None:
    80                                                     draw()
    81                                         
    82    494.1 MiB -5399415.7 MiB       86899           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    969.3 MiB    969.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    969.3 MiB -634066.2 MiB        1025       for row in grid:
    30    969.3 MiB -649727423.5 MiB     1049600           for spot in row:
    31    969.3 MiB -649093644.1 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    408.2 MiB   -561.2 MiB           1       count = 0
    34    408.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    408.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    408.7 MiB      0.0 MiB           1       came_from = {}
    37    492.9 MiB -4652409.6 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    485.4 MiB     -7.5 MiB           1       g_score[start] = 0
    39    535.0 MiB -27867047.7 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    321.4 MiB   -213.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    321.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    321.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    321.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    541.4 MiB -21083406.5 MiB      114318       while not open_set.empty():
    47    541.4 MiB -21083417.2 MiB      114318           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    541.4 MiB -21083449.0 MiB      114318           current = open_set.get()[2]
    53    541.4 MiB -21083459.8 MiB      114318           open_set_hash.remove(current)
    54                                         
    55    541.4 MiB -21083468.8 MiB      114318           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    541.4 MiB -21083479.2 MiB      114318           if current == end:
    60     81.4 MiB   -460.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     91.3 MiB      9.9 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    541.4 MiB -189748728.7 MiB     1028853           for neighbor in current.neighbors:
    65    541.4 MiB -168665389.5 MiB      914536               if current.row != neighbor.row and current.col != neighbor.col:
    66    541.4 MiB -84333099.8 MiB      457268                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    541.4 MiB -84332378.4 MiB      457268                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    541.4 MiB -168665536.8 MiB      914536               if temp_g_score < g_score[neighbor]:
    71    541.4 MiB -21568970.9 MiB      117292                   came_from[neighbor] = current
    72    541.4 MiB -21568978.8 MiB      117292                   g_score[neighbor] = temp_g_score
    73    541.4 MiB -21568971.0 MiB      117292                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    541.4 MiB -21568982.7 MiB      117292                   if neighbor not in open_set_hash:
    75    541.4 MiB -21569003.2 MiB      117292                       count += 1
    76    541.4 MiB -21568802.6 MiB      117292                       open_set.put((f_score[neighbor], count, neighbor))
    77    541.4 MiB -21569025.2 MiB      117292                       open_set_hash.add(neighbor)
    78                                                             
    79    541.4 MiB -21083380.6 MiB      114317           if draw is not None:
    80                                                     draw()
    81                                         
    82    541.4 MiB -21083388.7 MiB      114317           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    985.2 MiB    985.2 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    985.2 MiB -473294.7 MiB        1025       for row in grid:
    30    985.2 MiB -484641052.1 MiB     1049600           for spot in row:
    31    985.2 MiB -484168133.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    242.1 MiB   -743.1 MiB           1       count = 0
    34    242.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    242.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    242.6 MiB      0.0 MiB           1       came_from = {}
    37    242.7 MiB -56148743.2 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    209.8 MiB    -32.9 MiB           1       g_score[start] = 0
    39    234.7 MiB -71603924.0 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    125.2 MiB   -109.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    125.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    125.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    125.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    491.3 MiB  -3598.5 MiB       11715       while not open_set.empty():
    47    491.3 MiB  -3599.1 MiB       11715           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    491.3 MiB  -3599.5 MiB       11715           current = open_set.get()[2]
    53    491.3 MiB  -3600.0 MiB       11715           open_set_hash.remove(current)
    54                                         
    55    491.3 MiB  -3603.9 MiB       11715           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    491.3 MiB  -3604.2 MiB       11715           if current == end:
    60    491.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    491.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    491.3 MiB -32417.2 MiB      105426           for neighbor in current.neighbors:
    65    491.3 MiB -28807.2 MiB       93712               if current.row != neighbor.row and current.col != neighbor.col:
    66    491.3 MiB -14409.3 MiB       46856                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    491.3 MiB -14415.9 MiB       46856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    491.3 MiB -28797.7 MiB       93712               if temp_g_score < g_score[neighbor]:
    71    491.3 MiB  -3895.9 MiB       12327                   came_from[neighbor] = current
    72    491.3 MiB  -3897.7 MiB       12327                   g_score[neighbor] = temp_g_score
    73    491.3 MiB  -3898.4 MiB       12327                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    491.3 MiB  -3898.8 MiB       12327                   if neighbor not in open_set_hash:
    75    491.3 MiB  -3899.2 MiB       12327                       count += 1
    76    491.3 MiB  -3573.0 MiB       12327                       open_set.put((f_score[neighbor], count, neighbor))
    77    491.3 MiB  -3886.6 MiB       12327                       open_set_hash.add(neighbor)
    78                                                             
    79    491.3 MiB  -3597.8 MiB       11714           if draw is not None:
    80                                                     draw()
    81                                         
    82    491.3 MiB  -3598.2 MiB       11714           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    972.0 MiB    972.0 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    972.0 MiB -791050.1 MiB        1025       for row in grid:
    30    972.0 MiB -810482393.3 MiB     1049600           for spot in row:
    31    972.0 MiB -809691733.2 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    230.1 MiB   -741.8 MiB           1       count = 0
    34    230.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    230.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    230.7 MiB      0.0 MiB           1       came_from = {}
    37    256.5 MiB -40415515.4 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    256.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    258.0 MiB -42968870.7 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    256.2 MiB     -1.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    256.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    256.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    256.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    480.5 MiB -2002471.0 MiB       18232       while not open_set.empty():
    47    480.5 MiB -2002474.7 MiB       18232           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    480.5 MiB -2002480.8 MiB       18232           current = open_set.get()[2]
    53    480.5 MiB -2002485.3 MiB       18232           open_set_hash.remove(current)
    54                                         
    55    480.5 MiB -2002489.2 MiB       18232           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    480.5 MiB -2002492.5 MiB       18232           if current == end:
    60    479.4 MiB     -1.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    479.9 MiB      0.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    480.5 MiB -18030356.7 MiB      164079           for neighbor in current.neighbors:
    65    480.5 MiB -16027922.7 MiB      145848               if current.row != neighbor.row and current.col != neighbor.col:
    66    480.5 MiB -8014037.3 MiB       72924                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    480.5 MiB -8013922.6 MiB       72924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    480.5 MiB -16027969.4 MiB      145848               if temp_g_score < g_score[neighbor]:
    71    480.5 MiB -2057497.9 MiB       18998                   came_from[neighbor] = current
    72    480.5 MiB -2057501.2 MiB       18998                   g_score[neighbor] = temp_g_score
    73    480.5 MiB -2057503.1 MiB       18998                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    480.5 MiB -2057514.6 MiB       18998                   if neighbor not in open_set_hash:
    75    480.5 MiB -2057518.6 MiB       18998                       count += 1
    76    480.5 MiB -2057154.8 MiB       18998                       open_set.put((f_score[neighbor], count, neighbor))
    77    480.5 MiB -2057367.9 MiB       18998                       open_set_hash.add(neighbor)
    78                                                             
    79    480.5 MiB -2003436.7 MiB       18231           if draw is not None:
    80                                                     draw()
    81                                         
    82    480.5 MiB -2002466.2 MiB       18231           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    876.4 MiB    876.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    876.4 MiB -657744.8 MiB        1025       for row in grid:
    30    876.4 MiB -673796671.2 MiB     1049600           for spot in row:
    31    876.4 MiB -673139251.2 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    192.8 MiB   -683.6 MiB           1       count = 0
    34    193.2 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    193.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    193.4 MiB      0.0 MiB           1       came_from = {}
    37    273.7 MiB -24789255.9 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    191.3 MiB    -82.5 MiB           1       g_score[start] = 0
    39    225.1 MiB -18612678.7 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    191.1 MiB    -34.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    191.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    191.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    191.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    192.8 MiB    -49.4 MiB         210       while not open_set.empty():
    47    192.8 MiB    -49.6 MiB         210           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    192.8 MiB    -49.3 MiB         210           current = open_set.get()[2]
    53    192.8 MiB    -49.6 MiB         210           open_set_hash.remove(current)
    54                                         
    55    192.8 MiB    -49.6 MiB         210           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    192.8 MiB    -49.6 MiB         210           if current == end:
    60    191.9 MiB     -0.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    192.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    192.8 MiB   -442.0 MiB        1881           for neighbor in current.neighbors:
    65    192.8 MiB   -392.1 MiB        1672               if current.row != neighbor.row and current.col != neighbor.col:
    66    192.8 MiB   -197.3 MiB         836                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    192.8 MiB   -195.7 MiB         836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    192.8 MiB   -393.1 MiB        1672               if temp_g_score < g_score[neighbor]:
    71    192.8 MiB    -64.9 MiB         290                   came_from[neighbor] = current
    72    192.8 MiB    -65.0 MiB         290                   g_score[neighbor] = temp_g_score
    73    192.8 MiB    -65.1 MiB         290                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    192.8 MiB    -65.1 MiB         290                   if neighbor not in open_set_hash:
    75    192.8 MiB    -65.1 MiB         290                       count += 1
    76    192.8 MiB    -65.1 MiB         290                       open_set.put((f_score[neighbor], count, neighbor))
    77    192.8 MiB    -65.2 MiB         290                       open_set_hash.add(neighbor)
    78                                                             
    79    192.8 MiB    -49.6 MiB         209           if draw is not None:
    80                                                     draw()
    81                                         
    82    192.8 MiB    -49.5 MiB         209           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    950.1 MiB    950.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    950.1 MiB -740317.2 MiB        1025       for row in grid:
    30    950.1 MiB -758288370.2 MiB     1049600           for spot in row:
    31    950.1 MiB -757548418.8 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    179.7 MiB   -770.4 MiB           1       count = 0
    34    180.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    180.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    180.3 MiB      0.0 MiB           1       came_from = {}
    37    304.1 MiB -1072399.8 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    302.7 MiB     -1.4 MiB           1       g_score[start] = 0
    39    306.5 MiB -66283597.0 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    248.2 MiB    -58.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    248.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    248.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    248.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    492.9 MiB -4367261.3 MiB       84588       while not open_set.empty():
    47    492.9 MiB -4367266.8 MiB       84588           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    492.9 MiB -4367277.3 MiB       84588           current = open_set.get()[2]
    53    492.9 MiB -4367282.5 MiB       84588           open_set_hash.remove(current)
    54                                         
    55    492.9 MiB -4367287.1 MiB       84588           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    492.9 MiB -4367292.4 MiB       84588           if current == end:
    60    377.8 MiB   -115.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    379.0 MiB      1.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    492.9 MiB -39304782.7 MiB      761283           for neighbor in current.neighbors:
    65    492.9 MiB -34937578.8 MiB      676696               if current.row != neighbor.row and current.col != neighbor.col:
    66    492.9 MiB -17468797.9 MiB      338348                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    492.9 MiB -17468860.7 MiB      338348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    492.9 MiB -34937687.6 MiB      676696               if temp_g_score < g_score[neighbor]:
    71    492.9 MiB -4478084.4 MiB       86286                   came_from[neighbor] = current
    72    492.9 MiB -4478093.8 MiB       86286                   g_score[neighbor] = temp_g_score
    73    492.9 MiB -4478081.6 MiB       86286                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    492.9 MiB -4478087.8 MiB       86286                   if neighbor not in open_set_hash:
    75    492.9 MiB -4478093.1 MiB       86286                       count += 1
    76    492.9 MiB -4477695.1 MiB       86286                       open_set.put((f_score[neighbor], count, neighbor))
    77    492.9 MiB -4477924.3 MiB       86286                       open_set_hash.add(neighbor)
    78                                                             
    79    492.9 MiB -4367219.7 MiB       84587           if draw is not None:
    80                                                     draw()
    81                                         
    82    492.9 MiB -4367254.7 MiB       84587           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    975.4 MiB    975.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    975.4 MiB  -8928.5 MiB        1025       for row in grid:
    30    975.4 MiB -9096353.8 MiB     1049600           for spot in row:
    31    975.4 MiB -9087508.9 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    855.5 MiB   -119.9 MiB           1       count = 0
    34    855.6 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35    855.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    855.6 MiB      0.0 MiB           1       came_from = {}
    37    876.6 MiB -48207554.8 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    793.4 MiB    -83.1 MiB           1       g_score[start] = 0
    39    800.8 MiB -49856119.6 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    647.5 MiB   -153.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    647.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    647.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    647.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    742.8 MiB -4473524.3 MiB       56322       while not open_set.empty():
    47    742.8 MiB -4473528.8 MiB       56322           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    742.8 MiB -4473538.7 MiB       56322           current = open_set.get()[2]
    53    742.8 MiB -4473543.4 MiB       56322           open_set_hash.remove(current)
    54                                         
    55    742.8 MiB -4473548.2 MiB       56322           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    742.8 MiB -4473552.7 MiB       56322           if current == end:
    60    545.9 MiB   -196.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    546.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    742.8 MiB -40260870.8 MiB      506889           for neighbor in current.neighbors:
    65    742.8 MiB -35787366.8 MiB      450568               if current.row != neighbor.row and current.col != neighbor.col:
    66    742.8 MiB -17893869.2 MiB      225284                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    742.8 MiB -17893535.9 MiB      225284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    742.8 MiB -35787441.0 MiB      450568               if temp_g_score < g_score[neighbor]:
    71    742.8 MiB -4616303.8 MiB       58360                   came_from[neighbor] = current
    72    742.8 MiB -4616308.7 MiB       58360                   g_score[neighbor] = temp_g_score
    73    742.8 MiB -4616315.7 MiB       58360                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    742.8 MiB -4616320.1 MiB       58360                   if neighbor not in open_set_hash:
    75    742.8 MiB -4616324.5 MiB       58360                       count += 1
    76    742.8 MiB -4616244.0 MiB       58360                       open_set.put((f_score[neighbor], count, neighbor))
    77    742.8 MiB -4616337.4 MiB       58360                       open_set_hash.add(neighbor)
    78                                                             
    79    742.8 MiB -4473515.1 MiB       56321           if draw is not None:
    80                                                     draw()
    81                                         
    82    742.8 MiB -4473519.1 MiB       56321           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26   1006.8 MiB   1006.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29   1006.8 MiB  -9818.2 MiB        1025       for row in grid:
    30   1006.8 MiB -9853395.6 MiB     1049600           for spot in row:
    31   1006.8 MiB -9843786.8 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    711.2 MiB   -295.7 MiB           1       count = 0
    34    711.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    711.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    711.2 MiB      0.0 MiB           1       came_from = {}
    37    739.5 MiB -44542215.2 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    664.5 MiB    -75.0 MiB           1       g_score[start] = 0
    39    720.1 MiB -20350220.5 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    540.4 MiB   -179.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    540.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    540.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    540.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    552.6 MiB      0.0 MiB        6417       while not open_set.empty():
    47    552.6 MiB      0.0 MiB        6417           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    552.6 MiB      0.0 MiB        6417           current = open_set.get()[2]
    53    552.6 MiB      0.0 MiB        6417           open_set_hash.remove(current)
    54                                         
    55    552.6 MiB      0.0 MiB        6417           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    552.6 MiB      0.0 MiB        6417           if current == end:
    60    552.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    552.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    552.6 MiB      3.3 MiB       57744           for neighbor in current.neighbors:
    65    552.6 MiB      8.5 MiB       51328               if current.row != neighbor.row and current.col != neighbor.col:
    66    552.6 MiB      0.0 MiB       25664                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    552.6 MiB      0.0 MiB       25664                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    552.6 MiB      0.0 MiB       51328               if temp_g_score < g_score[neighbor]:
    71    552.6 MiB      0.4 MiB        6925                   came_from[neighbor] = current
    72    552.6 MiB      0.0 MiB        6925                   g_score[neighbor] = temp_g_score
    73    552.6 MiB      0.0 MiB        6925                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    552.6 MiB      0.0 MiB        6925                   if neighbor not in open_set_hash:
    75    552.6 MiB      0.0 MiB        6925                       count += 1
    76    552.6 MiB      0.1 MiB        6925                       open_set.put((f_score[neighbor], count, neighbor))
    77    552.6 MiB      0.0 MiB        6925                       open_set_hash.add(neighbor)
    78                                                             
    79    552.6 MiB      0.0 MiB        6416           if draw is not None:
    80                                                     draw()
    81                                         
    82    552.6 MiB      0.0 MiB        6416           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    940.5 MiB    940.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    940.5 MiB -50455.7 MiB        1025       for row in grid:
    30    940.5 MiB -51616506.7 MiB     1049600           for spot in row:
    31    940.5 MiB -51566206.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    702.0 MiB   -238.5 MiB           1       count = 0
    34    702.0 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35    702.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    702.0 MiB      0.0 MiB           1       came_from = {}
    37    752.1 MiB -120288801.0 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    536.5 MiB   -215.6 MiB           1       g_score[start] = 0
    39    539.3 MiB -65699735.1 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    483.2 MiB    -56.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    483.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    483.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    483.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    563.8 MiB -593722.0 MiB       29748       while not open_set.empty():
    47    563.8 MiB -593723.2 MiB       29748           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    563.8 MiB -593726.3 MiB       29748           current = open_set.get()[2]
    53    563.8 MiB -593727.7 MiB       29748           open_set_hash.remove(current)
    54                                         
    55    563.8 MiB -593728.7 MiB       29748           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    563.8 MiB -593729.8 MiB       29748           if current == end:
    60    561.7 MiB     -2.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    561.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    563.8 MiB -5343576.8 MiB      267723           for neighbor in current.neighbors:
    65    563.8 MiB -4749864.9 MiB      237976               if current.row != neighbor.row and current.col != neighbor.col:
    66    563.8 MiB -2374935.4 MiB      118988                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    563.8 MiB -2374942.5 MiB      118988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    563.8 MiB -4749891.8 MiB      237976               if temp_g_score < g_score[neighbor]:
    71    563.8 MiB -616397.3 MiB       30726                   came_from[neighbor] = current
    72    563.8 MiB -616399.7 MiB       30726                   g_score[neighbor] = temp_g_score
    73    563.8 MiB -616400.7 MiB       30726                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    563.8 MiB -616401.4 MiB       30726                   if neighbor not in open_set_hash:
    75    563.8 MiB -616402.1 MiB       30726                       count += 1
    76    563.8 MiB -616268.0 MiB       30726                       open_set.put((f_score[neighbor], count, neighbor))
    77    563.8 MiB -616346.4 MiB       30726                       open_set_hash.add(neighbor)
    78                                                             
    79    563.8 MiB -593718.9 MiB       29747           if draw is not None:
    80                                                     draw()
    81                                         
    82    563.8 MiB -593720.3 MiB       29747           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26   1014.5 MiB   1014.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29   1014.5 MiB -269931.5 MiB        1025       for row in grid:
    30   1014.5 MiB -276335564.7 MiB     1049600           for spot in row:
    31   1014.5 MiB -276066019.7 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    373.8 MiB   -640.8 MiB           1       count = 0
    34    373.9 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35    373.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    373.9 MiB      0.0 MiB           1       came_from = {}
    37    398.0 MiB -25504135.5 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    398.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    458.1 MiB -3789685.4 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    453.2 MiB     -4.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    453.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    453.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    453.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    608.6 MiB      0.0 MiB        3094       while not open_set.empty():
    47    608.6 MiB      0.0 MiB        3094           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    608.6 MiB      0.0 MiB        3094           current = open_set.get()[2]
    53    608.6 MiB      0.0 MiB        3094           open_set_hash.remove(current)
    54                                         
    55    608.6 MiB      0.0 MiB        3094           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    608.6 MiB      0.0 MiB        3094           if current == end:
    60    608.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    608.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    608.6 MiB      0.2 MiB       27837           for neighbor in current.neighbors:
    65    608.6 MiB      8.4 MiB       24744               if current.row != neighbor.row and current.col != neighbor.col:
    66    608.6 MiB      0.0 MiB       12372                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    608.6 MiB      0.0 MiB       12372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    608.6 MiB      0.0 MiB       24744               if temp_g_score < g_score[neighbor]:
    71    608.6 MiB      0.3 MiB        4004                   came_from[neighbor] = current
    72    608.6 MiB      0.0 MiB        4004                   g_score[neighbor] = temp_g_score
    73    608.6 MiB      0.0 MiB        4004                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    608.6 MiB      0.0 MiB        4004                   if neighbor not in open_set_hash:
    75    608.6 MiB      0.0 MiB        4004                       count += 1
    76    608.6 MiB    146.2 MiB        4004                       open_set.put((f_score[neighbor], count, neighbor))
    77    608.6 MiB      0.2 MiB        4004                       open_set_hash.add(neighbor)
    78                                                             
    79    608.6 MiB      0.0 MiB        3093           if draw is not None:
    80                                                     draw()
    81                                         
    82    608.6 MiB      0.0 MiB        3093           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    986.5 MiB    986.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    986.5 MiB -71448.1 MiB        1025       for row in grid:
    30    986.5 MiB -73173794.5 MiB     1049600           for spot in row:
    31    986.5 MiB -73102431.4 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    855.4 MiB   -131.0 MiB           1       count = 0
    34    855.7 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    856.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    856.0 MiB      0.0 MiB           1       came_from = {}
    37    917.1 MiB -8148403.7 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    900.0 MiB    -17.0 MiB           1       g_score[start] = 0
    39    910.7 MiB -10391313.5 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    883.0 MiB    -27.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    883.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    883.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    883.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    883.2 MiB -285799.4 MiB       28207       while not open_set.empty():
    47    883.2 MiB -285800.6 MiB       28207           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    883.2 MiB -285802.5 MiB       28207           current = open_set.get()[2]
    53    883.2 MiB -285802.8 MiB       28207           open_set_hash.remove(current)
    54                                         
    55    883.2 MiB -285803.4 MiB       28207           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    883.2 MiB -285804.3 MiB       28207           if current == end:
    60    866.8 MiB    -16.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    866.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    883.2 MiB -2572128.9 MiB      253854           for neighbor in current.neighbors:
    65    883.2 MiB -2286336.2 MiB      225648               if current.row != neighbor.row and current.col != neighbor.col:
    66    883.2 MiB -1143171.4 MiB      112824                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    883.2 MiB -1143168.7 MiB      112824                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    883.2 MiB -2286342.9 MiB      225648               if temp_g_score < g_score[neighbor]:
    71    883.2 MiB -303098.1 MiB       30023                   came_from[neighbor] = current
    72    883.2 MiB -303098.5 MiB       30023                   g_score[neighbor] = temp_g_score
    73    883.2 MiB -303098.9 MiB       30023                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    883.2 MiB -303099.2 MiB       30023                   if neighbor not in open_set_hash:
    75    883.2 MiB -303099.6 MiB       30023                       count += 1
    76    883.2 MiB -303093.0 MiB       30023                       open_set.put((f_score[neighbor], count, neighbor))
    77    883.2 MiB -303093.2 MiB       30023                       open_set_hash.add(neighbor)
    78                                                             
    79    883.2 MiB -285797.5 MiB       28206           if draw is not None:
    80                                                     draw()
    81                                         
    82    883.2 MiB -285798.4 MiB       28206           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    990.8 MiB    990.8 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    990.8 MiB -283173.9 MiB        1025       for row in grid:
    30    990.8 MiB -289977784.8 MiB     1049600           for spot in row:
    31    990.8 MiB -289694933.7 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    491.0 MiB   -499.8 MiB           1       count = 0
    34    491.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    491.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    491.5 MiB      0.0 MiB           1       came_from = {}
    37    524.5 MiB -20456417.5 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    513.1 MiB    -11.4 MiB           1       g_score[start] = 0
    39    543.1 MiB -9053304.8 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    543.2 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    543.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    543.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    543.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    619.5 MiB      0.0 MiB         632       while not open_set.empty():
    47    619.5 MiB      0.0 MiB         632           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    619.5 MiB      0.0 MiB         632           current = open_set.get()[2]
    53    619.5 MiB      0.0 MiB         632           open_set_hash.remove(current)
    54                                         
    55    619.5 MiB      0.0 MiB         632           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    619.5 MiB      0.0 MiB         632           if current == end:
    60    619.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    619.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    619.5 MiB      0.0 MiB        5679           for neighbor in current.neighbors:
    65    619.5 MiB      0.0 MiB        5048               if current.row != neighbor.row and current.col != neighbor.col:
    66    619.5 MiB      0.0 MiB        2524                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    619.5 MiB      0.0 MiB        2524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    619.5 MiB      0.0 MiB        5048               if temp_g_score < g_score[neighbor]:
    71    619.5 MiB      0.1 MiB        1270                   came_from[neighbor] = current
    72    619.5 MiB      0.0 MiB        1270                   g_score[neighbor] = temp_g_score
    73    619.5 MiB      0.0 MiB        1270                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    619.5 MiB      0.0 MiB        1270                   if neighbor not in open_set_hash:
    75    619.5 MiB      0.0 MiB        1270                       count += 1
    76    619.5 MiB     75.9 MiB        1270                       open_set.put((f_score[neighbor], count, neighbor))
    77    619.5 MiB      0.1 MiB        1270                       open_set_hash.add(neighbor)
    78                                                             
    79    619.5 MiB      0.0 MiB         631           if draw is not None:
    80                                                     draw()
    81                                         
    82    619.5 MiB      0.0 MiB         631           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    972.4 MiB    972.4 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    972.4 MiB -371829.0 MiB        1025       for row in grid:
    30    972.4 MiB -380932475.5 MiB     1049600           for spot in row:
    31    972.4 MiB -380560960.5 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    403.1 MiB   -569.2 MiB           1       count = 0
    34    403.5 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    403.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    403.7 MiB      0.0 MiB           1       came_from = {}
    37    471.5 MiB -10020578.2 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    423.3 MiB    -48.1 MiB           1       g_score[start] = 0
    39    496.0 MiB -30499203.9 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    329.0 MiB   -167.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    329.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    329.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    329.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    525.7 MiB -275964.8 MiB       21093       while not open_set.empty():
    47    525.7 MiB -275965.5 MiB       21093           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    525.7 MiB -275967.1 MiB       21093           current = open_set.get()[2]
    53    525.7 MiB -275967.8 MiB       21093           open_set_hash.remove(current)
    54                                         
    55    525.7 MiB -275968.4 MiB       21093           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    525.7 MiB -275969.0 MiB       21093           if current == end:
    60    502.5 MiB    -23.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    502.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    525.7 MiB -2483585.6 MiB      189828           for neighbor in current.neighbors:
    65    525.7 MiB -2207626.8 MiB      168736               if current.row != neighbor.row and current.col != neighbor.col:
    66    525.7 MiB -1103830.1 MiB       84368                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    525.7 MiB -1103802.9 MiB       84368                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    525.7 MiB -2207638.6 MiB      168736               if temp_g_score < g_score[neighbor]:
    71    525.7 MiB -285388.2 MiB       21921                   came_from[neighbor] = current
    72    525.7 MiB -285389.3 MiB       21921                   g_score[neighbor] = temp_g_score
    73    525.7 MiB -285390.4 MiB       21921                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    525.7 MiB -285390.9 MiB       21921                   if neighbor not in open_set_hash:
    75    525.7 MiB -285391.5 MiB       21921                       count += 1
    76    525.7 MiB -285189.5 MiB       21921                       open_set.put((f_score[neighbor], count, neighbor))
    77    525.7 MiB -285386.3 MiB       21921                       open_set_hash.add(neighbor)
    78                                                             
    79    525.7 MiB -275962.2 MiB       21092           if draw is not None:
    80                                                     draw()
    81                                         
    82    525.7 MiB -275963.0 MiB       21092           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    990.5 MiB    990.5 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    990.5 MiB -465408.5 MiB        1025       for row in grid:
    30    990.5 MiB -476800241.3 MiB     1049600           for spot in row:
    31    990.5 MiB -476335188.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    420.7 MiB   -569.8 MiB           1       count = 0
    34    421.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    421.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    421.2 MiB      0.0 MiB           1       came_from = {}
    37    521.0 MiB -14877767.1 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    471.5 MiB    -49.5 MiB           1       g_score[start] = 0
    39    570.6 MiB -7021016.6 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    547.0 MiB    -23.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    547.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    547.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    547.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    644.7 MiB -23526581.3 MiB       80372       while not open_set.empty():
    47    644.7 MiB -23526591.5 MiB       80372           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    644.7 MiB -23526625.9 MiB       80372           current = open_set.get()[2]
    53    644.7 MiB -23526634.9 MiB       80372           open_set_hash.remove(current)
    54                                         
    55    644.7 MiB -23526646.2 MiB       80372           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    644.7 MiB -23526655.9 MiB       80372           if current == end:
    60    117.5 MiB   -527.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    119.9 MiB      2.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    644.7 MiB -211736867.2 MiB      723339           for neighbor in current.neighbors:
    65    644.7 MiB -188210403.7 MiB      642968               if current.row != neighbor.row and current.col != neighbor.col:
    66    644.7 MiB -94105666.7 MiB      321484                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    644.7 MiB -94104830.0 MiB      321484                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    644.7 MiB -188210572.0 MiB      642968               if temp_g_score < g_score[neighbor]:
    71    644.7 MiB -23871279.4 MiB       82070                   came_from[neighbor] = current
    72    644.7 MiB -23871290.0 MiB       82070                   g_score[neighbor] = temp_g_score
    73    644.7 MiB -23871302.8 MiB       82070                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    644.7 MiB -23871322.9 MiB       82070                   if neighbor not in open_set_hash:
    75    644.7 MiB -23871333.7 MiB       82070                       count += 1
    76    644.7 MiB -23871242.5 MiB       82070                       open_set.put((f_score[neighbor], count, neighbor))
    77    644.7 MiB -23871348.8 MiB       82070                       open_set_hash.add(neighbor)
    78                                                             
    79    644.7 MiB -23526559.0 MiB       80371           if draw is not None:
    80                                                     draw()
    81                                         
    82    644.7 MiB -23526569.0 MiB       80371           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    982.9 MiB    982.9 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    982.9 MiB -568176.2 MiB        1025       for row in grid:
    30    982.9 MiB -582130123.1 MiB     1049600           for spot in row:
    31    982.9 MiB -581562275.9 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    382.9 MiB   -600.0 MiB           1       count = 0
    34    383.2 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    383.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    383.4 MiB      0.0 MiB           1       came_from = {}
    37    436.3 MiB -9031295.1 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    428.2 MiB     -8.1 MiB           1       g_score[start] = 0
    39    442.1 MiB -99661170.8 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    293.1 MiB   -149.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    293.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    293.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    293.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    535.0 MiB -1339283.3 MiB       40898       while not open_set.empty():
    47    535.0 MiB -1339284.8 MiB       40898           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    535.0 MiB -1339288.8 MiB       40898           current = open_set.get()[2]
    53    535.0 MiB -1339291.9 MiB       40898           open_set_hash.remove(current)
    54                                         
    55    535.0 MiB -1339300.9 MiB       40898           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    535.0 MiB -1339309.7 MiB       40898           if current == end:
    60    465.5 MiB    -69.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    465.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    535.0 MiB -12053338.1 MiB      368073           for neighbor in current.neighbors:
    65    535.0 MiB -10714064.6 MiB      327176               if current.row != neighbor.row and current.col != neighbor.col:
    66    535.0 MiB -5357070.1 MiB      163588                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    535.0 MiB -5357022.0 MiB      163588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    535.0 MiB -10714111.6 MiB      327176               if temp_g_score < g_score[neighbor]:
    71    535.0 MiB -1380660.5 MiB       42056                   came_from[neighbor] = current
    72    535.0 MiB -1380665.6 MiB       42056                   g_score[neighbor] = temp_g_score
    73    535.0 MiB -1380669.4 MiB       42056                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    535.0 MiB -1380680.3 MiB       42056                   if neighbor not in open_set_hash:
    75    535.0 MiB -1380683.7 MiB       42056                       count += 1
    76    535.0 MiB -1380374.1 MiB       42056                       open_set.put((f_score[neighbor], count, neighbor))
    77    535.0 MiB -1380614.5 MiB       42056                       open_set_hash.add(neighbor)
    78                                                             
    79    535.0 MiB -1339279.7 MiB       40897           if draw is not None:
    80                                                     draw()
    81                                         
    82    535.0 MiB -1339281.7 MiB       40897           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    927.1 MiB    927.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    927.1 MiB -658311.7 MiB        1025       for row in grid:
    30    927.1 MiB -674395122.3 MiB     1049600           for spot in row:
    31    927.1 MiB -673737088.6 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    279.6 MiB   -647.6 MiB           1       count = 0
    34    279.9 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    280.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    280.1 MiB      0.0 MiB           1       came_from = {}
    37    281.3 MiB -59383876.2 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    192.3 MiB    -89.0 MiB           1       g_score[start] = 0
    39    213.0 MiB -10795144.2 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    157.4 MiB    -55.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    157.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    157.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    157.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    497.2 MiB -42274917.0 MiB      118482       while not open_set.empty():
    47    497.2 MiB -42274925.8 MiB      118482           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    497.2 MiB -42274929.9 MiB      118482           current = open_set.get()[2]
    53    497.2 MiB -42274941.6 MiB      118482           open_set_hash.remove(current)
    54                                         
    55    497.2 MiB -42274951.6 MiB      118482           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    497.2 MiB -42274959.7 MiB      118482           if current == end:
    60     70.2 MiB   -427.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     77.6 MiB      7.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    497.2 MiB -380472382.5 MiB     1066329           for neighbor in current.neighbors:
    65    497.2 MiB -338197628.7 MiB      947848               if current.row != neighbor.row and current.col != neighbor.col:
    66    497.2 MiB -169099205.8 MiB      473924                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    497.2 MiB -169098547.9 MiB      473924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    497.2 MiB -338197813.5 MiB      947848               if temp_g_score < g_score[neighbor]:
    71    497.2 MiB -42822413.9 MiB      120510                   came_from[neighbor] = current
    72    497.2 MiB -42822423.9 MiB      120510                   g_score[neighbor] = temp_g_score
    73    497.2 MiB -42822371.4 MiB      120510                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    497.2 MiB -42822377.9 MiB      120510                   if neighbor not in open_set_hash:
    75    497.2 MiB -42822406.8 MiB      120510                       count += 1
    76    497.2 MiB -42822047.9 MiB      120510                       open_set.put((f_score[neighbor], count, neighbor))
    77    497.2 MiB -42822387.8 MiB      120510                       open_set_hash.add(neighbor)
    78                                                             
    79    497.2 MiB -42274895.2 MiB      118481           if draw is not None:
    80                                                     draw()
    81                                         
    82    497.2 MiB -42274901.8 MiB      118481           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    966.4 MiB    966.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    966.4 MiB -731649.3 MiB        1025       for row in grid:
    30    966.4 MiB -749524638.5 MiB     1049600           for spot in row:
    31    966.4 MiB -748793288.8 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    183.5 MiB   -783.0 MiB           1       count = 0
    34    183.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    184.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    184.0 MiB      0.0 MiB           1       came_from = {}
    37    199.7 MiB -50035046.4 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    121.6 MiB    -78.1 MiB           1       g_score[start] = 0
    39    178.0 MiB -29119933.4 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40     81.6 MiB    -96.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     81.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     81.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     81.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    976.8 MiB -24968797.6 MiB       67952       while not open_set.empty():
    47    976.8 MiB -24968871.3 MiB       67952           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    976.8 MiB -24968955.6 MiB       67952           current = open_set.get()[2]
    53    976.8 MiB -24968988.9 MiB       67952           open_set_hash.remove(current)
    54                                         
    55    976.8 MiB -24969052.1 MiB       67952           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    976.8 MiB -24969061.2 MiB       67952           if current == end:
    60     33.6 MiB   -943.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     41.7 MiB      8.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    976.8 MiB -224716378.8 MiB      611559           for neighbor in current.neighbors:
    65    976.8 MiB -199747919.4 MiB      543608               if current.row != neighbor.row and current.col != neighbor.col:
    66    976.8 MiB -99874734.6 MiB      271804                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    976.8 MiB -99873628.3 MiB      271804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    976.8 MiB -199748554.6 MiB      543608               if temp_g_score < g_score[neighbor]:
    71    976.8 MiB -25775464.6 MiB       70390                   came_from[neighbor] = current
    72    976.8 MiB -25775484.2 MiB       70390                   g_score[neighbor] = temp_g_score
    73    976.8 MiB -25775419.9 MiB       70390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    976.8 MiB -25775452.2 MiB       70390                   if neighbor not in open_set_hash:
    75    976.8 MiB -25775464.0 MiB       70390                       count += 1
    76    976.8 MiB -25773788.1 MiB       70390                       open_set.put((f_score[neighbor], count, neighbor))
    77    976.8 MiB -25774758.5 MiB       70390                       open_set_hash.add(neighbor)
    78                                                             
    79    976.8 MiB -24968638.6 MiB       67951           if draw is not None:
    80                                                     draw()
    81                                         
    82    976.8 MiB -24968653.2 MiB       67951           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    575.2 MiB    575.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    575.2 MiB -547514.4 MiB        1025       for row in grid:
    30    575.3 MiB -560867947.3 MiB     1049600           for spot in row:
    31    575.3 MiB -560320762.4 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33     31.6 MiB   -543.6 MiB           1       count = 0
    34     32.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     32.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     32.2 MiB      0.0 MiB           1       came_from = {}
    37     89.5 MiB -12378866.2 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38     64.4 MiB    -25.1 MiB           1       g_score[start] = 0
    39    103.1 MiB -27455044.5 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40     71.0 MiB    -32.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     71.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     71.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     71.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    479.8 MiB -26006710.3 MiB       72930       while not open_set.empty():
    47    479.8 MiB -26006718.1 MiB       72930           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    479.8 MiB -26006729.3 MiB       72930           current = open_set.get()[2]
    53    479.8 MiB -26006744.8 MiB       72930           open_set_hash.remove(current)
    54                                         
    55    479.8 MiB -26006773.5 MiB       72930           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    479.8 MiB -26006823.5 MiB       72930           if current == end:
    60     72.5 MiB   -407.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     80.0 MiB      7.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    479.8 MiB -234058577.1 MiB      656361           for neighbor in current.neighbors:
    65    479.8 MiB -208052027.4 MiB      583432               if current.row != neighbor.row and current.col != neighbor.col:
    66    479.8 MiB -104026388.9 MiB      291716                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    479.8 MiB -104025706.2 MiB      291716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    479.8 MiB -208052083.5 MiB      583432               if temp_g_score < g_score[neighbor]:
    71    479.8 MiB -26396219.1 MiB       74472                   came_from[neighbor] = current
    72    479.8 MiB -26396239.5 MiB       74472                   g_score[neighbor] = temp_g_score
    73    479.8 MiB -26396178.0 MiB       74472                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    479.8 MiB -26396187.4 MiB       74472                   if neighbor not in open_set_hash:
    75    479.8 MiB -26396196.6 MiB       74472                       count += 1
    76    479.8 MiB -26395744.5 MiB       74472                       open_set.put((f_score[neighbor], count, neighbor))
    77    479.8 MiB -26396193.3 MiB       74472                       open_set_hash.add(neighbor)
    78                                                             
    79    479.8 MiB -26006692.7 MiB       72929           if draw is not None:
    80                                                     draw()
    81                                         
    82    479.8 MiB -26006699.4 MiB       72929           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    939.9 MiB    939.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    939.9 MiB -825396.4 MiB        1025       for row in grid:
    30    939.9 MiB -845565294.8 MiB     1049600           for spot in row:
    31    939.9 MiB -844740227.2 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    126.6 MiB   -813.3 MiB           1       count = 0
    34    127.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    127.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    127.2 MiB      0.0 MiB           1       came_from = {}
    37    172.1 MiB -31936828.7 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    115.4 MiB    -56.8 MiB           1       g_score[start] = 0
    39    161.5 MiB -19288927.1 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    136.4 MiB    -25.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    492.6 MiB -20923679.8 MiB       66906       while not open_set.empty():
    47    492.6 MiB -20923694.0 MiB       66906           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    492.6 MiB -20923713.7 MiB       66906           current = open_set.get()[2]
    53    492.6 MiB -20923726.1 MiB       66906           open_set_hash.remove(current)
    54                                         
    55    492.6 MiB -20923733.1 MiB       66906           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    492.6 MiB -20923739.6 MiB       66906           if current == end:
    60    123.7 MiB   -368.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    126.9 MiB      3.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    492.6 MiB -188311578.9 MiB      602145           for neighbor in current.neighbors:
    65    492.6 MiB -167387861.5 MiB      535240               if current.row != neighbor.row and current.col != neighbor.col:
    66    492.6 MiB -83694387.1 MiB      267620                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    492.6 MiB -83693644.0 MiB      267620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    492.6 MiB -167388056.5 MiB      535240               if temp_g_score < g_score[neighbor]:
    71    492.6 MiB -21326296.2 MiB       68510                   came_from[neighbor] = current
    72    492.6 MiB -21326375.0 MiB       68510                   g_score[neighbor] = temp_g_score
    73    492.6 MiB -21326313.3 MiB       68510                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    492.6 MiB -21326340.9 MiB       68510                   if neighbor not in open_set_hash:
    75    492.6 MiB -21326348.1 MiB       68510                       count += 1
    76    492.6 MiB -21325915.8 MiB       68510                       open_set.put((f_score[neighbor], count, neighbor))
    77    492.6 MiB -21326273.4 MiB       68510                       open_set_hash.add(neighbor)
    78                                                             
    79    492.6 MiB -20923662.3 MiB       66905           if draw is not None:
    80                                                     draw()
    81                                         
    82    492.6 MiB -20923670.5 MiB       66905           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    940.7 MiB    940.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    940.7 MiB -837520.4 MiB        1025       for row in grid:
    30    940.7 MiB -857992722.2 MiB     1049600           for spot in row:
    31    940.7 MiB -857155613.2 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    103.5 MiB   -837.1 MiB           1       count = 0
    34    103.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    104.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    104.1 MiB      0.0 MiB           1       came_from = {}
    37    132.9 MiB -33427093.4 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    129.7 MiB     -3.2 MiB           1       g_score[start] = 0
    39    166.3 MiB -23819864.4 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    130.2 MiB    -36.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    130.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    130.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    130.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    497.9 MiB -19291739.9 MiB       61710       while not open_set.empty():
    47    497.9 MiB -19291748.0 MiB       61710           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    497.9 MiB -19291804.8 MiB       61710           current = open_set.get()[2]
    53    497.9 MiB -19291820.2 MiB       61710           open_set_hash.remove(current)
    54                                         
    55    497.9 MiB -19291834.4 MiB       61710           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    497.9 MiB -19291839.7 MiB       61710           if current == end:
    60     69.6 MiB   -428.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.6 MiB      3.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    497.9 MiB -173623437.3 MiB      555381           for neighbor in current.neighbors:
    65    497.9 MiB -154331832.4 MiB      493672               if current.row != neighbor.row and current.col != neighbor.col:
    66    497.9 MiB -77166167.2 MiB      246836                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    497.9 MiB -77165750.6 MiB      246836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    497.9 MiB -154331942.0 MiB      493672               if temp_g_score < g_score[neighbor]:
    71    497.9 MiB -19620030.8 MiB       63212                   came_from[neighbor] = current
    72    497.9 MiB -19620038.6 MiB       63212                   g_score[neighbor] = temp_g_score
    73    497.9 MiB -19619999.2 MiB       63212                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    497.9 MiB -19620022.0 MiB       63212                   if neighbor not in open_set_hash:
    75    497.9 MiB -19620042.8 MiB       63212                       count += 1
    76    497.9 MiB -19619689.0 MiB       63212                       open_set.put((f_score[neighbor], count, neighbor))
    77    497.9 MiB -19620040.0 MiB       63212                       open_set_hash.add(neighbor)
    78                                                             
    79    497.9 MiB -19291691.8 MiB       61709           if draw is not None:
    80                                                     draw()
    81                                         
    82    497.9 MiB -19291721.6 MiB       61709           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    977.5 MiB    977.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    977.5 MiB -799509.6 MiB        1025       for row in grid:
    30    977.5 MiB -819051712.1 MiB     1049600           for spot in row:
    31    977.5 MiB -818252635.3 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33     72.6 MiB   -904.8 MiB           1       count = 0
    34     73.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     73.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     73.2 MiB      0.0 MiB           1       came_from = {}
    37    132.4 MiB -21616293.1 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38     82.3 MiB    -50.1 MiB           1       g_score[start] = 0
    39    146.9 MiB -12111465.8 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    123.0 MiB    -24.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    123.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    123.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    123.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    491.2 MiB -34553277.7 MiB       93120       while not open_set.empty():
    47    491.2 MiB -34553285.6 MiB       93120           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    491.2 MiB -34553300.3 MiB       93120           current = open_set.get()[2]
    53    491.2 MiB -34553305.5 MiB       93120           open_set_hash.remove(current)
    54                                         
    55    491.2 MiB -34553311.9 MiB       93120           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    491.2 MiB -34553316.3 MiB       93120           if current == end:
    60     72.9 MiB   -418.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     80.8 MiB      7.8 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    491.2 MiB -310977493.0 MiB      838068           for neighbor in current.neighbors:
    65    491.2 MiB -276424219.5 MiB      744949               if current.row != neighbor.row and current.col != neighbor.col:
    66    491.2 MiB -138212823.8 MiB      372474                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    491.2 MiB -138211586.3 MiB      372475                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    491.2 MiB -276424561.0 MiB      744949               if temp_g_score < g_score[neighbor]:
    71    491.2 MiB -35016679.3 MiB       94851                   came_from[neighbor] = current
    72    491.2 MiB -35016687.8 MiB       94851                   g_score[neighbor] = temp_g_score
    73    491.2 MiB -35016632.5 MiB       94851                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    491.2 MiB -35016638.7 MiB       94851                   if neighbor not in open_set_hash:
    75    491.2 MiB -35016645.2 MiB       94851                       count += 1
    76    491.2 MiB -35016244.4 MiB       94851                       open_set.put((f_score[neighbor], count, neighbor))
    77    491.2 MiB -35016645.9 MiB       94851                       open_set_hash.add(neighbor)
    78                                                             
    79    491.2 MiB -34553263.6 MiB       93119           if draw is not None:
    80                                                     draw()
    81                                         
    82    491.2 MiB -34553267.2 MiB       93119           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    949.3 MiB    949.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    949.3 MiB -804613.1 MiB        1025       for row in grid:
    30    949.3 MiB -824237174.9 MiB     1049600           for spot in row:
    31    949.3 MiB -823433041.9 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33     40.6 MiB   -908.7 MiB           1       count = 0
    34     40.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     41.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     41.1 MiB      0.0 MiB           1       came_from = {}
    37     99.6 MiB -18249930.0 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38     53.2 MiB    -46.4 MiB           1       g_score[start] = 0
    39     89.9 MiB -16154442.4 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.1 MiB    -19.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    493.5 MiB -19128261.5 MiB       59000       while not open_set.empty():
    47    493.5 MiB -19128279.4 MiB       59000           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    493.5 MiB -19128284.7 MiB       59000           current = open_set.get()[2]
    53    493.5 MiB -19128302.0 MiB       59000           open_set_hash.remove(current)
    54                                         
    55    493.5 MiB -19128305.8 MiB       59000           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    493.5 MiB -19128309.9 MiB       59000           if current == end:
    60     54.4 MiB   -439.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.5 MiB      3.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    493.5 MiB -172152481.1 MiB      530991           for neighbor in current.neighbors:
    65    493.5 MiB -153024333.0 MiB      471992               if current.row != neighbor.row and current.col != neighbor.col:
    66    493.5 MiB -76512585.4 MiB      235996                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    493.5 MiB -76511860.0 MiB      235996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    493.5 MiB -153024495.2 MiB      471992               if temp_g_score < g_score[neighbor]:
    71    493.5 MiB -19519596.9 MiB       60578                   came_from[neighbor] = current
    72    493.5 MiB -19519635.9 MiB       60578                   g_score[neighbor] = temp_g_score
    73    493.5 MiB -19519611.8 MiB       60578                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    493.5 MiB -19519619.6 MiB       60578                   if neighbor not in open_set_hash:
    75    493.5 MiB -19519623.6 MiB       60578                       count += 1
    76    493.5 MiB -19519194.1 MiB       60578                       open_set.put((f_score[neighbor], count, neighbor))
    77    493.5 MiB -19519604.9 MiB       60578                       open_set_hash.add(neighbor)
    78                                                             
    79    493.5 MiB -19128237.3 MiB       58999           if draw is not None:
    80                                                     draw()
    81                                         
    82    493.5 MiB -19128242.3 MiB       58999           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    898.6 MiB    898.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    898.6 MiB -794362.8 MiB        1025       for row in grid:
    30    898.6 MiB -813758322.5 MiB     1049600           for spot in row:
    31    898.6 MiB -812964194.0 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    167.4 MiB   -731.2 MiB           1       count = 0
    34    167.7 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    168.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    168.0 MiB      0.0 MiB           1       came_from = {}
    37    245.7 MiB -12910333.9 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    192.6 MiB    -53.0 MiB           1       g_score[start] = 0
    39    194.6 MiB -109914813.9 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.1 MiB   -132.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    502.4 MiB -19652694.2 MiB       64408       while not open_set.empty():
    47    502.4 MiB -19652699.1 MiB       64408           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    502.4 MiB -19652703.3 MiB       64408           current = open_set.get()[2]
    53    502.4 MiB -19652713.7 MiB       64408           open_set_hash.remove(current)
    54                                         
    55    502.4 MiB -19652721.8 MiB       64408           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    502.4 MiB -19652728.0 MiB       64408           if current == end:
    60     51.9 MiB   -450.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     59.4 MiB      7.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    502.4 MiB -176872346.4 MiB      579663           for neighbor in current.neighbors:
    65    502.4 MiB -157219706.7 MiB      515256               if current.row != neighbor.row and current.col != neighbor.col:
    66    502.4 MiB -78610256.9 MiB      257628                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    502.4 MiB -78609541.4 MiB      257628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    502.4 MiB -157219806.9 MiB      515256               if temp_g_score < g_score[neighbor]:
    71    502.4 MiB -19964139.5 MiB       65846                   came_from[neighbor] = current
    72    502.4 MiB -19964139.5 MiB       65846                   g_score[neighbor] = temp_g_score
    73    502.4 MiB -19964098.2 MiB       65846                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    502.4 MiB -19964108.5 MiB       65846                   if neighbor not in open_set_hash:
    75    502.4 MiB -19964116.1 MiB       65846                       count += 1
    76    502.4 MiB -19963755.4 MiB       65846                       open_set.put((f_score[neighbor], count, neighbor))
    77    502.4 MiB -19964167.7 MiB       65846                       open_set_hash.add(neighbor)
    78                                                             
    79    502.4 MiB -19652681.8 MiB       64407           if draw is not None:
    80                                                     draw()
    81                                         
    82    502.4 MiB -19652687.8 MiB       64407           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    809.1 MiB    809.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    809.1 MiB -651789.9 MiB        1025       for row in grid:
    30    809.1 MiB -667862943.8 MiB     1049600           for spot in row:
    31    809.1 MiB -667211430.8 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    196.7 MiB   -612.5 MiB           1       count = 0
    34    197.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    197.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    197.2 MiB      0.0 MiB           1       came_from = {}
    37    220.8 MiB -58692560.3 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    148.2 MiB    -72.6 MiB           1       g_score[start] = 0
    39    181.4 MiB -35225081.8 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    120.4 MiB    -61.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    120.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    120.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    120.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    502.8 MiB -25883.4 MiB       14070       while not open_set.empty():
    47    502.8 MiB -25883.8 MiB       14070           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    502.8 MiB -25884.0 MiB       14070           current = open_set.get()[2]
    53    502.8 MiB -25884.7 MiB       14070           open_set_hash.remove(current)
    54                                         
    55    502.8 MiB -25886.0 MiB       14070           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    502.8 MiB -25886.4 MiB       14070           if current == end:
    60    496.7 MiB     -6.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    497.0 MiB      0.3 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    502.8 MiB -232879.7 MiB      126621           for neighbor in current.neighbors:
    65    502.8 MiB -207044.7 MiB      112552               if current.row != neighbor.row and current.col != neighbor.col:
    66    502.8 MiB -103522.1 MiB       56276                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    502.8 MiB -103539.0 MiB       56276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    502.8 MiB -206809.1 MiB      112552               if temp_g_score < g_score[neighbor]:
    71    502.8 MiB -27244.4 MiB       14756                   came_from[neighbor] = current
    72    502.8 MiB -27246.3 MiB       14756                   g_score[neighbor] = temp_g_score
    73    502.8 MiB -27245.1 MiB       14756                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    502.8 MiB -27247.1 MiB       14756                   if neighbor not in open_set_hash:
    75    502.8 MiB -27247.3 MiB       14756                       count += 1
    76    502.8 MiB -26876.0 MiB       14756                       open_set.put((f_score[neighbor], count, neighbor))
    77    502.8 MiB -27236.0 MiB       14756                       open_set_hash.add(neighbor)
    78                                                             
    79    502.8 MiB -25889.2 MiB       14069           if draw is not None:
    80                                                     draw()
    81                                         
    82    502.8 MiB -25883.3 MiB       14069           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    982.2 MiB    982.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    982.2 MiB -611806.1 MiB        1025       for row in grid:
    30    982.2 MiB -626613042.8 MiB     1049600           for spot in row:
    31    982.2 MiB -626001693.2 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    152.7 MiB   -829.6 MiB           1       count = 0
    34    153.0 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    153.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    153.2 MiB      0.0 MiB           1       came_from = {}
    37    241.9 MiB -13690348.7 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    194.5 MiB    -47.5 MiB           1       g_score[start] = 0
    39    197.8 MiB -47454557.4 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    133.1 MiB    -64.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    133.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    133.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    133.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    496.2 MiB -6587201.0 MiB       46368       while not open_set.empty():
    47    496.2 MiB -6587206.2 MiB       46368           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    496.2 MiB -6587218.3 MiB       46368           current = open_set.get()[2]
    53    496.2 MiB -6587223.9 MiB       46368           open_set_hash.remove(current)
    54                                         
    55    496.2 MiB -6587228.5 MiB       46368           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    496.2 MiB -6587234.7 MiB       46368           if current == end:
    60     98.4 MiB   -397.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.7 MiB      3.3 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    496.2 MiB -59290447.4 MiB      417303           for neighbor in current.neighbors:
    65    496.2 MiB -52697731.9 MiB      370936               if current.row != neighbor.row and current.col != neighbor.col:
    66    496.2 MiB -26350887.4 MiB      185468                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    496.2 MiB -26350302.5 MiB      185468                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    496.2 MiB -52698477.2 MiB      370936               if temp_g_score < g_score[neighbor]:
    71    496.2 MiB -6734466.3 MiB       47606                   came_from[neighbor] = current
    72    496.2 MiB -6734473.3 MiB       47606                   g_score[neighbor] = temp_g_score
    73    496.2 MiB -6734503.0 MiB       47606                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    496.2 MiB -6733339.4 MiB       47606                   if neighbor not in open_set_hash:
    75    496.2 MiB -6733351.0 MiB       47606                       count += 1
    76    496.2 MiB -6732979.3 MiB       47606                       open_set.put((f_score[neighbor], count, neighbor))
    77    496.2 MiB -6733338.5 MiB       47606                       open_set_hash.add(neighbor)
    78                                                             
    79    496.2 MiB -6587447.7 MiB       46367           if draw is not None:
    80                                                     draw()
    81                                         
    82    496.2 MiB -6587188.2 MiB       46367           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    876.1 MiB    876.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    876.1 MiB -602487.0 MiB        1025       for row in grid:
    30    876.1 MiB -617253161.6 MiB     1049600           for spot in row:
    31    876.1 MiB -616651041.9 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    216.2 MiB   -659.9 MiB           1       count = 0
    34    216.6 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    216.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    216.8 MiB      0.0 MiB           1       came_from = {}
    37    258.3 MiB -88634648.0 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.3 MiB   -148.0 MiB           1       g_score[start] = 0
    39    213.8 MiB -14412682.5 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    143.7 MiB    -70.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    143.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    143.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    143.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    508.1 MiB -9386943.5 MiB       43769       while not open_set.empty():
    47    508.1 MiB -9386953.0 MiB       43769           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    508.1 MiB -9386966.2 MiB       43769           current = open_set.get()[2]
    53    508.1 MiB -9386971.0 MiB       43769           open_set_hash.remove(current)
    54                                         
    55    508.1 MiB -9386980.0 MiB       43769           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    508.1 MiB -9386990.5 MiB       43769           if current == end:
    60     49.1 MiB   -459.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     51.2 MiB      2.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    508.1 MiB -84480235.5 MiB      393912           for neighbor in current.neighbors:
    65    508.1 MiB -75093366.4 MiB      350144               if current.row != neighbor.row and current.col != neighbor.col:
    66    508.1 MiB -37547054.6 MiB      175072                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    508.1 MiB -37546384.8 MiB      175072                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    508.1 MiB -75091573.4 MiB      350144               if temp_g_score < g_score[neighbor]:
    71    508.1 MiB -9596959.6 MiB       44965                   came_from[neighbor] = current
    72    508.1 MiB -9596970.6 MiB       44965                   g_score[neighbor] = temp_g_score
    73    508.1 MiB -9596944.1 MiB       44965                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    508.1 MiB -9596970.1 MiB       44965                   if neighbor not in open_set_hash:
    75    508.1 MiB -9596990.1 MiB       44965                       count += 1
    76    508.1 MiB -9596588.0 MiB       44965                       open_set.put((f_score[neighbor], count, neighbor))
    77    508.1 MiB -9596956.2 MiB       44965                       open_set_hash.add(neighbor)
    78                                                             
    79    508.1 MiB -9386926.0 MiB       43768           if draw is not None:
    80                                                     draw()
    81                                         
    82    508.1 MiB -9386937.8 MiB       43768           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    969.3 MiB    969.3 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    969.3 MiB -634066.2 MiB        1025       for row in grid:
    30    969.3 MiB -649727423.5 MiB     1049600           for spot in row:
    31    969.3 MiB -649093644.1 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    408.2 MiB   -561.2 MiB           1       count = 0
    34    408.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    408.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    408.7 MiB      0.0 MiB           1       came_from = {}
    37    492.9 MiB -4652409.6 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    485.4 MiB     -7.5 MiB           1       g_score[start] = 0
    39    535.0 MiB -27867047.7 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    321.4 MiB   -213.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    321.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    321.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    321.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    541.4 MiB -21083406.5 MiB      114318       while not open_set.empty():
    47    541.4 MiB -21083417.2 MiB      114318           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    541.4 MiB -21083449.0 MiB      114318           current = open_set.get()[2]
    53    541.4 MiB -21083459.8 MiB      114318           open_set_hash.remove(current)
    54                                         
    55    541.4 MiB -21083468.8 MiB      114318           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    541.4 MiB -21083479.2 MiB      114318           if current == end:
    60     81.4 MiB   -460.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     91.3 MiB      9.9 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    541.4 MiB -189748728.7 MiB     1028853           for neighbor in current.neighbors:
    65    541.4 MiB -168665389.5 MiB      914536               if current.row != neighbor.row and current.col != neighbor.col:
    66    541.4 MiB -84333099.8 MiB      457268                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    541.4 MiB -84332378.4 MiB      457268                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    541.4 MiB -168665536.8 MiB      914536               if temp_g_score < g_score[neighbor]:
    71    541.4 MiB -21568970.9 MiB      117292                   came_from[neighbor] = current
    72    541.4 MiB -21568978.8 MiB      117292                   g_score[neighbor] = temp_g_score
    73    541.4 MiB -21568971.0 MiB      117292                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    541.4 MiB -21568982.7 MiB      117292                   if neighbor not in open_set_hash:
    75    541.4 MiB -21569003.2 MiB      117292                       count += 1
    76    541.4 MiB -21568802.6 MiB      117292                       open_set.put((f_score[neighbor], count, neighbor))
    77    541.4 MiB -21569025.2 MiB      117292                       open_set_hash.add(neighbor)
    78                                                             
    79    541.4 MiB -21083380.6 MiB      114317           if draw is not None:
    80                                                     draw()
    81                                         
    82    541.4 MiB -21083388.7 MiB      114317           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None

    Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    927.1 MiB    927.1 MiB           1   @profile(stream=open('logs/A*/num_goals/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    927.1 MiB -658311.7 MiB        1025       for row in grid:
    30    927.1 MiB -674395122.3 MiB     1049600           for spot in row:
    31    927.1 MiB -673737088.6 MiB     1048576               spot.update_neighbors(grid)
    32                                             
    33    279.6 MiB   -647.6 MiB           1       count = 0
    34    279.9 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35    280.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    280.1 MiB      0.0 MiB           1       came_from = {}
    37    281.3 MiB -59383876.2 MiB     1049603       g_score = {spot: float("inf") for row in grid for spot in row}
    38    192.3 MiB    -89.0 MiB           1       g_score[start] = 0
    39    213.0 MiB -10795144.2 MiB     1049603       f_score = {spot: float("inf") for row in grid for spot in row}
    40    157.4 MiB    -55.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    157.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    157.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    157.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    497.2 MiB -42274917.0 MiB      118482       while not open_set.empty():
    47    497.2 MiB -42274925.8 MiB      118482           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    497.2 MiB -42274929.9 MiB      118482           current = open_set.get()[2]
    53    497.2 MiB -42274941.6 MiB      118482           open_set_hash.remove(current)
    54                                         
    55    497.2 MiB -42274951.6 MiB      118482           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    497.2 MiB -42274959.7 MiB      118482           if current == end:
    60     70.2 MiB   -427.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     77.6 MiB      7.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    497.2 MiB -380472382.5 MiB     1066329           for neighbor in current.neighbors:
    65    497.2 MiB -338197628.7 MiB      947848               if current.row != neighbor.row and current.col != neighbor.col:
    66    497.2 MiB -169099205.8 MiB      473924                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    497.2 MiB -169098547.9 MiB      473924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    497.2 MiB -338197813.5 MiB      947848               if temp_g_score < g_score[neighbor]:
    71    497.2 MiB -42822413.9 MiB      120510                   came_from[neighbor] = current
    72    497.2 MiB -42822423.9 MiB      120510                   g_score[neighbor] = temp_g_score
    73    497.2 MiB -42822371.4 MiB      120510                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    497.2 MiB -42822377.9 MiB      120510                   if neighbor not in open_set_hash:
    75    497.2 MiB -42822406.8 MiB      120510                       count += 1
    76    497.2 MiB -42822047.9 MiB      120510                       open_set.put((f_score[neighbor], count, neighbor))
    77    497.2 MiB -42822387.8 MiB      120510                       open_set_hash.add(neighbor)
    78                                                             
    79    497.2 MiB -42274895.2 MiB      118481           if draw is not None:
    80                                                     draw()
    81                                         
    82    497.2 MiB -42274901.8 MiB      118481           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None