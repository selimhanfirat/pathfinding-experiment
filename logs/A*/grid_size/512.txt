Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    134.4 MiB    134.4 MiB           1   @profile(stream=open('logs/A*/grid_size/512.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    150.4 MiB      0.0 MiB         513       for row in grid:
    30    150.4 MiB      0.0 MiB      262656           for spot in row:
    31    150.4 MiB     16.0 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    150.4 MiB      0.0 MiB           1       count = 0
    34    150.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    150.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    150.4 MiB      0.0 MiB           1       came_from = {}
    37    178.2 MiB     27.7 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    178.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    205.4 MiB     27.2 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    205.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    205.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    205.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    205.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    205.8 MiB      0.0 MiB        9672       while not open_set.empty():
    47    205.8 MiB      0.0 MiB        9672           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    205.8 MiB      0.0 MiB        9672           current = open_set.get()[2]
    53    205.8 MiB      0.0 MiB        9672           open_set_hash.remove(current)
    54                                         
    55    205.8 MiB      0.0 MiB        9672           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    205.8 MiB      0.0 MiB        9672           if current == end:
    60    205.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    205.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    205.8 MiB      0.0 MiB       87039           for neighbor in current.neighbors:
    65    205.8 MiB      0.0 MiB       77368               if current.row != neighbor.row and current.col != neighbor.col:
    66    205.8 MiB      0.0 MiB       38684                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    205.8 MiB      0.0 MiB       38684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    205.8 MiB      0.0 MiB       77368               if temp_g_score < g_score[neighbor]:
    71    205.8 MiB      0.3 MiB       10572                   came_from[neighbor] = current
    72    205.8 MiB      0.0 MiB       10572                   g_score[neighbor] = temp_g_score
    73    205.8 MiB      0.0 MiB       10572                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    205.8 MiB      0.0 MiB       10572                   if neighbor not in open_set_hash:
    75    205.8 MiB      0.0 MiB       10572                       count += 1
    76    205.8 MiB      0.1 MiB       10572                       open_set.put((f_score[neighbor], count, neighbor))
    77    205.8 MiB      0.0 MiB       10572                       open_set_hash.add(neighbor)
    78                                                             
    79    205.8 MiB      0.0 MiB        9671           if draw is not None:
    80                                                     draw()
    81                                         
    82    205.8 MiB      0.0 MiB        9671           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    276.5 MiB    276.5 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    292.5 MiB      0.0 MiB         513       for row in grid:
    30    292.5 MiB      0.0 MiB      262656           for spot in row:
    31    292.5 MiB     16.0 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    292.5 MiB      0.0 MiB           1       count = 0
    34    292.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    292.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    292.5 MiB      0.0 MiB           1       came_from = {}
    37    301.2 MiB      8.7 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    301.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    312.3 MiB     11.1 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    312.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    312.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    312.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    312.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    312.3 MiB      0.0 MiB       11200       while not open_set.empty():
    47    312.3 MiB      0.0 MiB       11200           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    312.3 MiB      0.0 MiB       11200           current = open_set.get()[2]
    53    312.3 MiB      0.0 MiB       11200           open_set_hash.remove(current)
    54                                         
    55    312.3 MiB      0.0 MiB       11200           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    312.3 MiB      0.0 MiB       11200           if current == end:
    60    312.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    312.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    312.3 MiB      0.0 MiB      100791           for neighbor in current.neighbors:
    65    312.3 MiB      0.0 MiB       89592               if current.row != neighbor.row and current.col != neighbor.col:
    66    312.3 MiB      0.0 MiB       44796                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    312.3 MiB      0.0 MiB       44796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    312.3 MiB      0.0 MiB       89592               if temp_g_score < g_score[neighbor]:
    71    312.3 MiB      0.0 MiB       11822                   came_from[neighbor] = current
    72    312.3 MiB      0.0 MiB       11822                   g_score[neighbor] = temp_g_score
    73    312.3 MiB      0.0 MiB       11822                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    312.3 MiB      0.0 MiB       11822                   if neighbor not in open_set_hash:
    75    312.3 MiB      0.0 MiB       11822                       count += 1
    76    312.3 MiB      0.0 MiB       11822                       open_set.put((f_score[neighbor], count, neighbor))
    77    312.3 MiB      0.0 MiB       11822                       open_set_hash.add(neighbor)
    78                                                             
    79    312.3 MiB      0.0 MiB       11199           if draw is not None:
    80                                                     draw()
    81                                         
    82    312.3 MiB      0.0 MiB       11199           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    286.8 MiB    286.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    290.9 MiB  -9405.7 MiB         513       for row in grid:
    30    290.9 MiB -4812765.8 MiB      262656           for spot in row:
    31    290.9 MiB -4803385.1 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    251.4 MiB    -39.5 MiB           1       count = 0
    34    251.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    251.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    251.4 MiB      0.0 MiB           1       came_from = {}
    37    279.2 MiB     27.8 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    279.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    300.5 MiB     21.3 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    300.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    300.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    300.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    300.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    301.8 MiB      0.0 MiB        7705       while not open_set.empty():
    47    301.8 MiB      0.0 MiB        7705           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    301.8 MiB      0.0 MiB        7705           current = open_set.get()[2]
    53    301.8 MiB      0.0 MiB        7705           open_set_hash.remove(current)
    54                                         
    55    301.8 MiB      0.0 MiB        7705           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    301.8 MiB      0.0 MiB        7705           if current == end:
    60    301.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    301.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    301.8 MiB      0.3 MiB       69336           for neighbor in current.neighbors:
    65    301.8 MiB      0.0 MiB       61632               if current.row != neighbor.row and current.col != neighbor.col:
    66    301.8 MiB      0.0 MiB       30816                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    301.8 MiB      0.0 MiB       30816                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    301.8 MiB      0.0 MiB       61632               if temp_g_score < g_score[neighbor]:
    71    301.8 MiB      0.3 MiB        9089                   came_from[neighbor] = current
    72    301.8 MiB      0.0 MiB        9089                   g_score[neighbor] = temp_g_score
    73    301.8 MiB      0.0 MiB        9089                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    301.8 MiB      0.0 MiB        9089                   if neighbor not in open_set_hash:
    75    301.8 MiB      0.0 MiB        9089                       count += 1
    76    301.8 MiB      0.7 MiB        9089                       open_set.put((f_score[neighbor], count, neighbor))
    77    301.8 MiB      0.0 MiB        9089                       open_set_hash.add(neighbor)
    78                                                             
    79    301.8 MiB      0.0 MiB        7704           if draw is not None:
    80                                                     draw()
    81                                         
    82    301.8 MiB      0.0 MiB        7704           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    275.2 MiB    275.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    286.7 MiB      0.0 MiB         513       for row in grid:
    30    286.7 MiB      0.0 MiB      262656           for spot in row:
    31    286.7 MiB     11.5 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    286.7 MiB      0.0 MiB           1       count = 0
    34    286.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    286.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    286.7 MiB      0.0 MiB           1       came_from = {}
    37    299.1 MiB     12.4 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    299.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    314.6 MiB     15.6 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    314.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    314.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    314.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    314.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    314.7 MiB      0.0 MiB        6708       while not open_set.empty():
    47    314.7 MiB      0.0 MiB        6708           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    314.7 MiB      0.0 MiB        6708           current = open_set.get()[2]
    53    314.7 MiB      0.0 MiB        6708           open_set_hash.remove(current)
    54                                         
    55    314.7 MiB      0.0 MiB        6708           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    314.7 MiB      0.0 MiB        6708           if current == end:
    60    314.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    314.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    314.7 MiB      0.0 MiB       60363           for neighbor in current.neighbors:
    65    314.7 MiB      0.0 MiB       53656               if current.row != neighbor.row and current.col != neighbor.col:
    66    314.7 MiB      0.0 MiB       26828                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    314.7 MiB      0.0 MiB       26828                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    314.7 MiB      0.0 MiB       53656               if temp_g_score < g_score[neighbor]:
    71    314.7 MiB      0.0 MiB        7326                   came_from[neighbor] = current
    72    314.7 MiB      0.0 MiB        7326                   g_score[neighbor] = temp_g_score
    73    314.7 MiB      0.0 MiB        7326                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    314.7 MiB      0.0 MiB        7326                   if neighbor not in open_set_hash:
    75    314.7 MiB      0.0 MiB        7326                       count += 1
    76    314.7 MiB      0.0 MiB        7326                       open_set.put((f_score[neighbor], count, neighbor))
    77    314.7 MiB      0.0 MiB        7326                       open_set_hash.add(neighbor)
    78                                                             
    79    314.7 MiB      0.0 MiB        6707           if draw is not None:
    80                                                     draw()
    81                                         
    82    314.7 MiB      0.0 MiB        6707           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    288.8 MiB    288.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    298.7 MiB      0.0 MiB         513       for row in grid:
    30    298.7 MiB      0.0 MiB      262656           for spot in row:
    31    298.7 MiB      9.9 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    298.7 MiB      0.0 MiB           1       count = 0
    34    298.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    298.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    298.7 MiB      0.0 MiB           1       came_from = {}
    37    309.2 MiB     10.5 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    309.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    314.8 MiB -864207.8 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    314.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    314.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    314.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    314.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    314.9 MiB      0.0 MiB        5980       while not open_set.empty():
    47    314.9 MiB      0.0 MiB        5980           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    314.9 MiB      0.0 MiB        5980           current = open_set.get()[2]
    53    314.9 MiB      0.0 MiB        5980           open_set_hash.remove(current)
    54                                         
    55    314.9 MiB      0.0 MiB        5980           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    314.9 MiB      0.0 MiB        5980           if current == end:
    60    314.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    314.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    314.9 MiB      0.0 MiB       53811           for neighbor in current.neighbors:
    65    314.9 MiB      0.0 MiB       47832               if current.row != neighbor.row and current.col != neighbor.col:
    66    314.9 MiB      0.0 MiB       23916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    314.9 MiB      0.0 MiB       23916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    314.9 MiB      0.0 MiB       47832               if temp_g_score < g_score[neighbor]:
    71    314.9 MiB      0.0 MiB        6422                   came_from[neighbor] = current
    72    314.9 MiB      0.0 MiB        6422                   g_score[neighbor] = temp_g_score
    73    314.9 MiB      0.0 MiB        6422                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    314.9 MiB      0.0 MiB        6422                   if neighbor not in open_set_hash:
    75    314.9 MiB      0.0 MiB        6422                       count += 1
    76    314.9 MiB      0.0 MiB        6422                       open_set.put((f_score[neighbor], count, neighbor))
    77    314.9 MiB      0.0 MiB        6422                       open_set_hash.add(neighbor)
    78                                                             
    79    314.9 MiB      0.0 MiB        5979           if draw is not None:
    80                                                     draw()
    81                                         
    82    314.9 MiB      0.0 MiB        5979           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    291.3 MiB    291.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    291.3 MiB  -2790.6 MiB         513       for row in grid:
    30    291.3 MiB -1429099.0 MiB      262656           for spot in row:
    31    291.3 MiB -1426311.9 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    283.7 MiB     -7.5 MiB           1       count = 0
    34    283.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    283.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    283.7 MiB      0.0 MiB           1       came_from = {}
    37    294.6 MiB -216089.8 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    294.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    309.6 MiB     15.0 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    309.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    309.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    309.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    309.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    309.6 MiB      0.0 MiB         424       while not open_set.empty():
    47    309.6 MiB      0.0 MiB         424           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    309.6 MiB      0.0 MiB         424           current = open_set.get()[2]
    53    309.6 MiB      0.0 MiB         424           open_set_hash.remove(current)
    54                                         
    55    309.6 MiB      0.0 MiB         424           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    309.6 MiB      0.0 MiB         424           if current == end:
    60    309.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    309.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    309.6 MiB      0.0 MiB        3807           for neighbor in current.neighbors:
    65    309.6 MiB      0.0 MiB        3384               if current.row != neighbor.row and current.col != neighbor.col:
    66    309.6 MiB      0.0 MiB        1692                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    309.6 MiB      0.0 MiB        1692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    309.6 MiB      0.0 MiB        3384               if temp_g_score < g_score[neighbor]:
    71    309.6 MiB      0.0 MiB         650                   came_from[neighbor] = current
    72    309.6 MiB      0.0 MiB         650                   g_score[neighbor] = temp_g_score
    73    309.6 MiB      0.0 MiB         650                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    309.6 MiB      0.0 MiB         650                   if neighbor not in open_set_hash:
    75    309.6 MiB      0.0 MiB         650                       count += 1
    76    309.6 MiB      0.0 MiB         650                       open_set.put((f_score[neighbor], count, neighbor))
    77    309.6 MiB      0.0 MiB         650                       open_set_hash.add(neighbor)
    78                                                             
    79    309.6 MiB      0.0 MiB         423           if draw is not None:
    80                                                     draw()
    81                                         
    82    309.6 MiB      0.0 MiB         423           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    287.9 MiB    287.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    289.8 MiB  -1727.4 MiB         513       for row in grid:
    30    289.9 MiB -881715.9 MiB      262656           for spot in row:
    31    289.9 MiB -879995.4 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    283.7 MiB     -6.1 MiB           1       count = 0
    34    283.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    283.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    283.7 MiB      0.0 MiB           1       came_from = {}
    37    295.8 MiB     12.0 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    295.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    316.6 MiB    -12.5 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    316.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    316.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    316.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    316.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    316.7 MiB -109049.7 MiB        8721       while not open_set.empty():
    47    316.7 MiB -109050.6 MiB        8721           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    316.7 MiB -109052.7 MiB        8721           current = open_set.get()[2]
    53    316.7 MiB -109053.4 MiB        8721           open_set_hash.remove(current)
    54                                         
    55    316.7 MiB -109054.1 MiB        8721           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    316.7 MiB -109054.6 MiB        8721           if current == end:
    60    297.2 MiB    -19.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    297.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    316.7 MiB -981375.3 MiB       78480           for neighbor in current.neighbors:
    65    316.7 MiB -872332.6 MiB       69760               if current.row != neighbor.row and current.col != neighbor.col:
    66    316.7 MiB -436184.8 MiB       34880                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    316.7 MiB -436152.6 MiB       34880                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    316.7 MiB -872341.4 MiB       69760               if temp_g_score < g_score[neighbor]:
    71    316.7 MiB -117570.2 MiB        9473                   came_from[neighbor] = current
    72    316.7 MiB -117571.0 MiB        9473                   g_score[neighbor] = temp_g_score
    73    316.7 MiB -117572.0 MiB        9473                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    316.7 MiB -117573.0 MiB        9473                   if neighbor not in open_set_hash:
    75    316.7 MiB -117573.8 MiB        9473                       count += 1
    76    316.7 MiB -117563.4 MiB        9473                       open_set.put((f_score[neighbor], count, neighbor))
    77    316.7 MiB -117564.4 MiB        9473                       open_set_hash.add(neighbor)
    78                                                             
    79    316.7 MiB -109047.9 MiB        8720           if draw is not None:
    80                                                     draw()
    81                                         
    82    316.7 MiB -109048.7 MiB        8720           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    274.5 MiB    274.5 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    281.3 MiB      0.0 MiB         513       for row in grid:
    30    281.3 MiB      0.0 MiB      262656           for spot in row:
    31    281.3 MiB      6.9 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    281.3 MiB      0.0 MiB           1       count = 0
    34    281.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    281.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    281.3 MiB      0.0 MiB           1       came_from = {}
    37    296.7 MiB -68168.4 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    296.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    310.3 MiB     13.7 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    310.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    310.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    310.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    310.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    310.3 MiB -95290.2 MiB       13080       while not open_set.empty():
    47    310.3 MiB -95290.2 MiB       13080           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    310.3 MiB -95290.3 MiB       13080           current = open_set.get()[2]
    53    310.3 MiB -95290.3 MiB       13080           open_set_hash.remove(current)
    54                                         
    55    310.3 MiB -95290.3 MiB       13080           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    310.3 MiB -95290.3 MiB       13080           if current == end:
    60    299.8 MiB    -10.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    299.8 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    310.3 MiB -857551.8 MiB      117711           for neighbor in current.neighbors:
    65    310.3 MiB -762262.1 MiB      104632               if current.row != neighbor.row and current.col != neighbor.col:
    66    310.3 MiB -381140.7 MiB       52316                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    310.3 MiB -381122.0 MiB       52316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    310.3 MiB -762263.4 MiB      104632               if temp_g_score < g_score[neighbor]:
    71    310.3 MiB -99247.0 MiB       13754                   came_from[neighbor] = current
    72    310.3 MiB -99247.2 MiB       13754                   g_score[neighbor] = temp_g_score
    73    310.3 MiB -99247.4 MiB       13754                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    310.3 MiB -99247.5 MiB       13754                   if neighbor not in open_set_hash:
    75    310.3 MiB -99255.1 MiB       13754                       count += 1
    76    310.3 MiB -99252.3 MiB       13754                       open_set.put((f_score[neighbor], count, neighbor))
    77    310.3 MiB -99252.3 MiB       13754                       open_set_hash.add(neighbor)
    78                                                             
    79    310.3 MiB -95290.2 MiB       13079           if draw is not None:
    80                                                     draw()
    81                                         
    82    310.3 MiB -95290.2 MiB       13079           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    281.7 MiB    281.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    282.8 MiB   -553.4 MiB         513       for row in grid:
    30    282.8 MiB -284182.9 MiB      262656           for spot in row:
    31    282.8 MiB -283632.4 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    281.5 MiB     -1.3 MiB           1       count = 0
    34    281.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    281.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    281.5 MiB      0.0 MiB           1       came_from = {}
    37    293.8 MiB -83425.4 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    293.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    302.9 MiB -153850.0 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    302.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    302.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    302.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    302.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    302.9 MiB -11147.5 MiB        3916       while not open_set.empty():
    47    302.9 MiB -11147.7 MiB        3916           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    302.9 MiB -11147.9 MiB        3916           current = open_set.get()[2]
    53    302.9 MiB -11148.1 MiB        3916           open_set_hash.remove(current)
    54                                         
    55    302.9 MiB -11148.2 MiB        3916           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    302.9 MiB -11148.3 MiB        3916           if current == end:
    60    300.0 MiB     -3.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    300.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    302.9 MiB -100320.7 MiB       35235           for neighbor in current.neighbors:
    65    302.9 MiB -89173.7 MiB       31320               if current.row != neighbor.row and current.col != neighbor.col:
    66    302.9 MiB -44588.5 MiB       15660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    302.9 MiB -44585.6 MiB       15660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    302.9 MiB -89174.4 MiB       31320               if temp_g_score < g_score[neighbor]:
    71    302.9 MiB -12232.3 MiB        4358                   came_from[neighbor] = current
    72    302.9 MiB -12232.3 MiB        4358                   g_score[neighbor] = temp_g_score
    73    302.9 MiB -12232.5 MiB        4358                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    302.9 MiB -12232.6 MiB        4358                   if neighbor not in open_set_hash:
    75    302.9 MiB -12232.7 MiB        4358                       count += 1
    76    302.9 MiB -12232.8 MiB        4358                       open_set.put((f_score[neighbor], count, neighbor))
    77    302.9 MiB -12232.9 MiB        4358                       open_set_hash.add(neighbor)
    78                                                             
    79    302.9 MiB -11147.3 MiB        3915           if draw is not None:
    80                                                     draw()
    81                                         
    82    302.9 MiB -11147.4 MiB        3915           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    280.3 MiB    280.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    282.6 MiB    -84.5 MiB         513       for row in grid:
    30    282.6 MiB -43601.0 MiB      262656           for spot in row:
    31    282.6 MiB -43513.8 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    282.6 MiB      0.0 MiB           1       count = 0
    34    282.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    282.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    282.6 MiB      0.0 MiB           1       came_from = {}
    37    296.2 MiB     13.7 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    296.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    303.3 MiB -15627.6 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    303.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    303.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    303.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    303.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    303.3 MiB      0.0 MiB        1344       while not open_set.empty():
    47    303.3 MiB      0.0 MiB        1344           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    303.3 MiB      0.0 MiB        1344           current = open_set.get()[2]
    53    303.3 MiB      0.0 MiB        1344           open_set_hash.remove(current)
    54                                         
    55    303.3 MiB      0.0 MiB        1344           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    303.3 MiB      0.0 MiB        1344           if current == end:
    60    303.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    303.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    303.3 MiB      0.0 MiB       12087           for neighbor in current.neighbors:
    65    303.3 MiB      0.0 MiB       10744               if current.row != neighbor.row and current.col != neighbor.col:
    66    303.3 MiB      0.0 MiB        5372                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    303.3 MiB      0.0 MiB        5372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    303.3 MiB      0.0 MiB       10744               if temp_g_score < g_score[neighbor]:
    71    303.3 MiB      0.0 MiB        1754                   came_from[neighbor] = current
    72    303.3 MiB      0.0 MiB        1754                   g_score[neighbor] = temp_g_score
    73    303.3 MiB      0.0 MiB        1754                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    303.3 MiB      0.0 MiB        1754                   if neighbor not in open_set_hash:
    75    303.3 MiB      0.0 MiB        1754                       count += 1
    76    303.3 MiB      0.0 MiB        1754                       open_set.put((f_score[neighbor], count, neighbor))
    77    303.3 MiB      0.0 MiB        1754                       open_set_hash.add(neighbor)
    78                                                             
    79    303.3 MiB      0.0 MiB        1343           if draw is not None:
    80                                                     draw()
    81                                         
    82    303.3 MiB      0.0 MiB        1343           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    286.3 MiB    286.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    286.3 MiB  -3508.5 MiB         513       for row in grid:
    30    286.3 MiB -1799290.2 MiB      262656           for spot in row:
    31    286.3 MiB -1795784.6 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    280.9 MiB     -5.4 MiB           1       count = 0
    34    280.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    280.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    280.9 MiB      0.0 MiB           1       came_from = {}
    37    296.7 MiB     15.8 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    296.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    315.8 MiB     13.5 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    315.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    315.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    315.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    315.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    315.9 MiB  -1322.0 MiB        1911       while not open_set.empty():
    47    315.9 MiB  -1322.0 MiB        1911           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    315.9 MiB  -1322.1 MiB        1911           current = open_set.get()[2]
    53    315.9 MiB  -1322.3 MiB        1911           open_set_hash.remove(current)
    54                                         
    55    315.9 MiB  -1322.5 MiB        1911           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    315.9 MiB  -1322.7 MiB        1911           if current == end:
    60    309.8 MiB     -6.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    309.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    315.9 MiB -11880.4 MiB       17190           for neighbor in current.neighbors:
    65    315.9 MiB -10559.5 MiB       15280               if current.row != neighbor.row and current.col != neighbor.col:
    66    315.9 MiB  -5285.9 MiB        7640                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    315.9 MiB  -5274.5 MiB        7640                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    315.9 MiB -10561.3 MiB       15280               if temp_g_score < g_score[neighbor]:
    71    315.9 MiB  -1553.6 MiB        2175                   came_from[neighbor] = current
    72    315.9 MiB  -1553.9 MiB        2175                   g_score[neighbor] = temp_g_score
    73    315.9 MiB  -1554.3 MiB        2175                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    315.9 MiB  -1554.8 MiB        2175                   if neighbor not in open_set_hash:
    75    315.9 MiB  -1555.1 MiB        2175                       count += 1
    76    315.9 MiB  -1555.1 MiB        2175                       open_set.put((f_score[neighbor], count, neighbor))
    77    315.9 MiB  -1555.1 MiB        2175                       open_set_hash.add(neighbor)
    78                                                             
    79    315.9 MiB  -1322.0 MiB        1910           if draw is not None:
    80                                                     draw()
    81                                         
    82    315.9 MiB  -1322.0 MiB        1910           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    290.9 MiB    290.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    293.9 MiB      0.0 MiB         513       for row in grid:
    30    293.9 MiB      0.0 MiB      262656           for spot in row:
    31    293.9 MiB      2.9 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    293.9 MiB      0.0 MiB           1       count = 0
    34    293.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    293.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    293.9 MiB      0.0 MiB           1       came_from = {}
    37    307.6 MiB     13.8 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    307.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    320.7 MiB     13.0 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    320.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    320.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    320.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    320.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    320.8 MiB      0.0 MiB        9243       while not open_set.empty():
    47    320.8 MiB      0.0 MiB        9243           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    320.8 MiB      0.0 MiB        9243           current = open_set.get()[2]
    53    320.8 MiB      0.0 MiB        9243           open_set_hash.remove(current)
    54                                         
    55    320.8 MiB      0.0 MiB        9243           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    320.8 MiB      0.0 MiB        9243           if current == end:
    60    320.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    320.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    320.8 MiB      0.0 MiB       83178           for neighbor in current.neighbors:
    65    320.8 MiB      0.0 MiB       73936               if current.row != neighbor.row and current.col != neighbor.col:
    66    320.8 MiB      0.0 MiB       36968                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    320.8 MiB      0.0 MiB       36968                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    320.8 MiB      0.0 MiB       73936               if temp_g_score < g_score[neighbor]:
    71    320.8 MiB      0.0 MiB        9871                   came_from[neighbor] = current
    72    320.8 MiB      0.0 MiB        9871                   g_score[neighbor] = temp_g_score
    73    320.8 MiB      0.0 MiB        9871                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    320.8 MiB      0.0 MiB        9871                   if neighbor not in open_set_hash:
    75    320.8 MiB      0.0 MiB        9871                       count += 1
    76    320.8 MiB      0.0 MiB        9871                       open_set.put((f_score[neighbor], count, neighbor))
    77    320.8 MiB      0.1 MiB        9871                       open_set_hash.add(neighbor)
    78                                                             
    79    320.8 MiB      0.0 MiB        9242           if draw is not None:
    80                                                     draw()
    81                                         
    82    320.8 MiB      0.0 MiB        9242           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    302.8 MiB    302.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    304.7 MiB      0.0 MiB         513       for row in grid:
    30    304.7 MiB      0.0 MiB      262656           for spot in row:
    31    304.7 MiB      1.9 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    304.7 MiB      0.0 MiB           1       count = 0
    34    304.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    304.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    304.7 MiB      0.0 MiB           1       came_from = {}
    37    312.7 MiB      8.0 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    312.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    323.1 MiB     10.4 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    323.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    323.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    323.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    323.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    323.9 MiB      0.0 MiB       11934       while not open_set.empty():
    47    323.9 MiB      0.0 MiB       11934           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    323.9 MiB      0.0 MiB       11934           current = open_set.get()[2]
    53    323.9 MiB      0.0 MiB       11934           open_set_hash.remove(current)
    54                                         
    55    323.9 MiB      0.0 MiB       11934           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    323.9 MiB      0.0 MiB       11934           if current == end:
    60    323.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    323.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    323.9 MiB      0.0 MiB      107397           for neighbor in current.neighbors:
    65    323.9 MiB      0.0 MiB       95464               if current.row != neighbor.row and current.col != neighbor.col:
    66    323.9 MiB      0.0 MiB       47732                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    323.9 MiB      0.0 MiB       47732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    323.9 MiB      0.0 MiB       95464               if temp_g_score < g_score[neighbor]:
    71    323.9 MiB      0.7 MiB       12574                   came_from[neighbor] = current
    72    323.9 MiB      0.0 MiB       12574                   g_score[neighbor] = temp_g_score
    73    323.9 MiB      0.0 MiB       12574                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    323.9 MiB      0.0 MiB       12574                   if neighbor not in open_set_hash:
    75    323.9 MiB      0.0 MiB       12574                       count += 1
    76    323.9 MiB      0.0 MiB       12574                       open_set.put((f_score[neighbor], count, neighbor))
    77    323.9 MiB      0.1 MiB       12574                       open_set_hash.add(neighbor)
    78                                                             
    79    323.9 MiB      0.0 MiB       11933           if draw is not None:
    80                                                     draw()
    81                                         
    82    323.9 MiB      0.0 MiB       11933           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    307.0 MiB    307.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    309.8 MiB      0.0 MiB         513       for row in grid:
    30    309.8 MiB      0.0 MiB      262656           for spot in row:
    31    309.8 MiB      2.9 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    309.8 MiB      0.0 MiB           1       count = 0
    34    309.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    309.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    309.8 MiB      0.0 MiB           1       came_from = {}
    37    320.5 MiB     10.6 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    320.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    330.6 MiB     10.2 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    330.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    330.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    330.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    330.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    330.7 MiB      0.0 MiB       19270       while not open_set.empty():
    47    330.7 MiB      0.0 MiB       19270           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    330.7 MiB      0.0 MiB       19270           current = open_set.get()[2]
    53    330.7 MiB      0.0 MiB       19270           open_set_hash.remove(current)
    54                                         
    55    330.7 MiB      0.0 MiB       19270           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    330.7 MiB      0.0 MiB       19270           if current == end:
    60    330.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    330.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    330.7 MiB      0.0 MiB      173421           for neighbor in current.neighbors:
    65    330.7 MiB      0.0 MiB      154152               if current.row != neighbor.row and current.col != neighbor.col:
    66    330.7 MiB      0.0 MiB       77076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    330.7 MiB      0.0 MiB       77076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    330.7 MiB      0.0 MiB      154152               if temp_g_score < g_score[neighbor]:
    71    330.7 MiB      0.0 MiB       20066                   came_from[neighbor] = current
    72    330.7 MiB      0.0 MiB       20066                   g_score[neighbor] = temp_g_score
    73    330.7 MiB      0.0 MiB       20066                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    330.7 MiB      0.0 MiB       20066                   if neighbor not in open_set_hash:
    75    330.7 MiB      0.0 MiB       20066                       count += 1
    76    330.7 MiB      0.0 MiB       20066                       open_set.put((f_score[neighbor], count, neighbor))
    77    330.7 MiB      0.0 MiB       20066                       open_set_hash.add(neighbor)
    78                                                             
    79    330.7 MiB      0.0 MiB       19269           if draw is not None:
    80                                                     draw()
    81                                         
    82    330.7 MiB      0.0 MiB       19269           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    314.8 MiB    314.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    315.2 MiB      0.0 MiB         513       for row in grid:
    30    315.2 MiB      0.0 MiB      262656           for spot in row:
    31    315.2 MiB      0.4 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    315.2 MiB      0.0 MiB           1       count = 0
    34    315.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    315.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    315.2 MiB      0.0 MiB           1       came_from = {}
    37    316.8 MiB -2430721.0 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    307.2 MiB     -9.6 MiB           1       g_score[start] = 0
    39    318.1 MiB     10.9 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    318.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    318.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    318.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    318.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    318.1 MiB    -42.3 MiB        3584       while not open_set.empty():
    47    318.1 MiB    -42.3 MiB        3584           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    318.1 MiB    -42.3 MiB        3584           current = open_set.get()[2]
    53    318.1 MiB    -42.3 MiB        3584           open_set_hash.remove(current)
    54                                         
    55    318.1 MiB    -42.3 MiB        3584           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    318.1 MiB    -42.3 MiB        3584           if current == end:
    60    318.1 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    318.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    318.1 MiB   -380.1 MiB       32247           for neighbor in current.neighbors:
    65    318.1 MiB   -337.9 MiB       28664               if current.row != neighbor.row and current.col != neighbor.col:
    66    318.1 MiB   -169.1 MiB       14332                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    318.1 MiB   -168.8 MiB       14332                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    318.1 MiB   -337.9 MiB       28664               if temp_g_score < g_score[neighbor]:
    71    318.1 MiB    -47.1 MiB        3950                   came_from[neighbor] = current
    72    318.1 MiB    -47.1 MiB        3950                   g_score[neighbor] = temp_g_score
    73    318.1 MiB    -47.1 MiB        3950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    318.1 MiB    -47.1 MiB        3950                   if neighbor not in open_set_hash:
    75    318.1 MiB    -47.1 MiB        3950                       count += 1
    76    318.1 MiB    -47.1 MiB        3950                       open_set.put((f_score[neighbor], count, neighbor))
    77    318.1 MiB    -47.1 MiB        3950                       open_set_hash.add(neighbor)
    78                                                             
    79    318.1 MiB    -42.3 MiB        3583           if draw is not None:
    80                                                     draw()
    81                                         
    82    318.1 MiB    -42.3 MiB        3583           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    300.9 MiB    300.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    302.9 MiB      0.0 MiB         513       for row in grid:
    30    302.9 MiB      0.0 MiB      262656           for spot in row:
    31    302.9 MiB      1.9 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    302.9 MiB      0.0 MiB           1       count = 0
    34    302.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    302.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    302.9 MiB      0.0 MiB           1       came_from = {}
    37    311.0 MiB  -3396.0 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    310.8 MiB     -0.1 MiB           1       g_score[start] = 0
    39    311.8 MiB -1406969.5 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    309.6 MiB     -2.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    309.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    309.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    309.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    309.7 MiB  -4321.4 MiB        8528       while not open_set.empty():
    47    309.7 MiB  -4321.4 MiB        8528           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    309.7 MiB  -4321.4 MiB        8528           current = open_set.get()[2]
    53    309.7 MiB  -4321.4 MiB        8528           open_set_hash.remove(current)
    54                                         
    55    309.7 MiB  -4321.4 MiB        8528           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    309.7 MiB  -4321.4 MiB        8528           if current == end:
    60    306.5 MiB     -3.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    306.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    309.7 MiB -38872.6 MiB       76743           for neighbor in current.neighbors:
    65    309.7 MiB -34551.9 MiB       68216               if current.row != neighbor.row and current.col != neighbor.col:
    66    309.7 MiB -17279.2 MiB       34108                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    309.7 MiB -17273.2 MiB       34108                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    309.7 MiB -34553.0 MiB       68216               if temp_g_score < g_score[neighbor]:
    71    309.7 MiB  -4720.1 MiB        9286                   came_from[neighbor] = current
    72    309.7 MiB  -4720.1 MiB        9286                   g_score[neighbor] = temp_g_score
    73    309.7 MiB  -4720.2 MiB        9286                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    309.7 MiB  -4720.4 MiB        9286                   if neighbor not in open_set_hash:
    75    309.7 MiB  -4720.5 MiB        9286                       count += 1
    76    309.7 MiB  -4720.6 MiB        9286                       open_set.put((f_score[neighbor], count, neighbor))
    77    309.7 MiB  -4720.7 MiB        9286                       open_set_hash.add(neighbor)
    78                                                             
    79    309.7 MiB  -4321.2 MiB        8527           if draw is not None:
    80                                                     draw()
    81                                         
    82    309.7 MiB  -4321.3 MiB        8527           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    294.0 MiB    294.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    294.4 MiB    -56.1 MiB         513       for row in grid:
    30    294.4 MiB -28752.4 MiB      262656           for spot in row:
    31    294.4 MiB -28696.1 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    294.1 MiB     -0.3 MiB           1       count = 0
    34    294.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    294.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    294.1 MiB      0.0 MiB           1       came_from = {}
    37    299.7 MiB      5.7 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    299.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    310.0 MiB     10.2 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    310.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    310.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    310.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    310.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    310.2 MiB      0.0 MiB        7106       while not open_set.empty():
    47    310.2 MiB      0.0 MiB        7106           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    310.2 MiB      0.0 MiB        7106           current = open_set.get()[2]
    53    310.2 MiB      0.0 MiB        7106           open_set_hash.remove(current)
    54                                         
    55    310.2 MiB      0.0 MiB        7106           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    310.2 MiB      0.0 MiB        7106           if current == end:
    60    310.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    310.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    310.2 MiB      0.0 MiB       63942           for neighbor in current.neighbors:
    65    310.2 MiB      0.0 MiB       56837               if current.row != neighbor.row and current.col != neighbor.col:
    66    310.2 MiB      0.0 MiB       28418                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    310.2 MiB      0.0 MiB       28419                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    310.2 MiB      0.0 MiB       56837               if temp_g_score < g_score[neighbor]:
    71    310.2 MiB      0.2 MiB        7925                   came_from[neighbor] = current
    72    310.2 MiB      0.0 MiB        7925                   g_score[neighbor] = temp_g_score
    73    310.2 MiB      0.0 MiB        7925                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    310.2 MiB      0.0 MiB        7925                   if neighbor not in open_set_hash:
    75    310.2 MiB      0.0 MiB        7925                       count += 1
    76    310.2 MiB      0.0 MiB        7925                       open_set.put((f_score[neighbor], count, neighbor))
    77    310.2 MiB      0.0 MiB        7925                       open_set_hash.add(neighbor)
    78                                                             
    79    310.2 MiB      0.0 MiB        7105           if draw is not None:
    80                                                     draw()
    81                                         
    82    310.2 MiB      0.0 MiB        7105           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    294.2 MiB    294.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    294.7 MiB      0.0 MiB         513       for row in grid:
    30    294.7 MiB      0.0 MiB      262656           for spot in row:
    31    294.7 MiB      0.4 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    294.7 MiB      0.0 MiB           1       count = 0
    34    294.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    294.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    294.7 MiB      0.0 MiB           1       came_from = {}
    37    304.7 MiB     10.0 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    304.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    312.6 MiB -13577.4 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    312.3 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    312.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    312.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    312.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    312.3 MiB     -3.5 MiB       25025       while not open_set.empty():
    47    312.3 MiB     -3.5 MiB       25025           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    312.3 MiB     -3.5 MiB       25025           current = open_set.get()[2]
    53    312.3 MiB     -3.5 MiB       25025           open_set_hash.remove(current)
    54                                         
    55    312.3 MiB     -3.5 MiB       25025           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    312.3 MiB     -3.5 MiB       25025           if current == end:
    60    312.1 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    312.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    312.3 MiB    -31.0 MiB      225216           for neighbor in current.neighbors:
    65    312.3 MiB    -27.5 MiB      200192               if current.row != neighbor.row and current.col != neighbor.col:
    66    312.3 MiB    -14.0 MiB      100096                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    312.3 MiB    -13.5 MiB      100096                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    312.3 MiB    -27.7 MiB      200192               if temp_g_score < g_score[neighbor]:
    71    312.3 MiB     -5.4 MiB       26009                   came_from[neighbor] = current
    72    312.3 MiB     -5.4 MiB       26009                   g_score[neighbor] = temp_g_score
    73    312.3 MiB     -5.4 MiB       26009                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    312.3 MiB     -5.4 MiB       26009                   if neighbor not in open_set_hash:
    75    312.3 MiB     -5.4 MiB       26009                       count += 1
    76    312.3 MiB     -5.3 MiB       26009                       open_set.put((f_score[neighbor], count, neighbor))
    77    312.3 MiB     -5.4 MiB       26009                       open_set_hash.add(neighbor)
    78                                                             
    79    312.3 MiB     -3.5 MiB       25024           if draw is not None:
    80                                                     draw()
    81                                         
    82    312.3 MiB     -3.5 MiB       25024           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    297.1 MiB    297.1 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    297.5 MiB      0.0 MiB         513       for row in grid:
    30    297.5 MiB      0.0 MiB      262656           for spot in row:
    31    297.5 MiB      0.4 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    297.5 MiB      0.0 MiB           1       count = 0
    34    297.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    297.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    297.5 MiB      0.0 MiB           1       came_from = {}
    37    308.2 MiB     10.7 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    308.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    317.2 MiB      9.0 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    317.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    317.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    317.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    317.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    317.3 MiB -17558.5 MiB        5913       while not open_set.empty():
    47    317.3 MiB -17558.6 MiB        5913           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    317.3 MiB -17558.6 MiB        5913           current = open_set.get()[2]
    53    317.3 MiB -17558.6 MiB        5913           open_set_hash.remove(current)
    54                                         
    55    317.3 MiB -17558.7 MiB        5913           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    317.3 MiB -17558.7 MiB        5913           if current == end:
    60    312.2 MiB     -5.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    312.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    317.3 MiB -157993.7 MiB       53208           for neighbor in current.neighbors:
    65    317.3 MiB -140436.6 MiB       47296               if current.row != neighbor.row and current.col != neighbor.col:
    66    317.3 MiB -70223.4 MiB       23648                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    317.3 MiB -70213.9 MiB       23648                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    317.3 MiB -140437.9 MiB       47296               if temp_g_score < g_score[neighbor]:
    71    317.3 MiB -18971.7 MiB        6457                   came_from[neighbor] = current
    72    317.3 MiB -18972.0 MiB        6457                   g_score[neighbor] = temp_g_score
    73    317.3 MiB -18972.3 MiB        6457                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    317.3 MiB -18972.5 MiB        6457                   if neighbor not in open_set_hash:
    75    317.3 MiB -18972.7 MiB        6457                       count += 1
    76    317.3 MiB -18973.0 MiB        6457                       open_set.put((f_score[neighbor], count, neighbor))
    77    317.3 MiB -18973.2 MiB        6457                       open_set_hash.add(neighbor)
    78                                                             
    79    317.3 MiB -17558.1 MiB        5912           if draw is not None:
    80                                                     draw()
    81                                         
    82    317.3 MiB -17558.3 MiB        5912           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    296.6 MiB    296.6 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    296.6 MiB  -5085.4 MiB         513       for row in grid:
    30    296.6 MiB -2606597.6 MiB      262656           for spot in row:
    31    296.6 MiB -2601525.7 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    277.1 MiB    -19.4 MiB           1       count = 0
    34    277.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    277.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    277.1 MiB      0.0 MiB           1       came_from = {}
    37    298.4 MiB     21.2 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    298.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    311.0 MiB     12.7 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    311.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    311.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    311.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    311.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    311.1 MiB -3136813.8 MiB       31376       while not open_set.empty():
    47    311.1 MiB -3136817.5 MiB       31376           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    311.1 MiB -3136823.8 MiB       31376           current = open_set.get()[2]
    53    311.1 MiB -3136827.2 MiB       31376           open_set_hash.remove(current)
    54                                         
    55    311.1 MiB -3136830.4 MiB       31376           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    311.1 MiB -3136833.5 MiB       31376           if current == end:
    60    171.9 MiB   -139.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    172.0 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    311.1 MiB -28230714.6 MiB      282375           for neighbor in current.neighbors:
    65    311.1 MiB -25093937.7 MiB      251000               if current.row != neighbor.row and current.col != neighbor.col:
    66    311.1 MiB -12547075.1 MiB      125500                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    311.1 MiB -12546892.1 MiB      125500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    311.1 MiB -25093995.3 MiB      251000               if temp_g_score < g_score[neighbor]:
    71    311.1 MiB -3209959.0 MiB       32390                   came_from[neighbor] = current
    72    311.1 MiB -3209961.0 MiB       32390                   g_score[neighbor] = temp_g_score
    73    311.1 MiB -3209964.9 MiB       32390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    311.1 MiB -3209967.6 MiB       32390                   if neighbor not in open_set_hash:
    75    311.1 MiB -3209971.0 MiB       32390                       count += 1
    76    311.1 MiB -3209939.8 MiB       32390                       open_set.put((f_score[neighbor], count, neighbor))
    77    311.1 MiB -3209943.4 MiB       32390                       open_set_hash.add(neighbor)
    78                                                             
    79    311.1 MiB -3136805.8 MiB       31375           if draw is not None:
    80                                                     draw()
    81                                         
    82    311.1 MiB -3136809.1 MiB       31375           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    275.9 MiB    275.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    276.3 MiB      0.0 MiB         513       for row in grid:
    30    276.3 MiB      0.0 MiB      262656           for spot in row:
    31    276.3 MiB      0.4 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    276.3 MiB      0.0 MiB           1       count = 0
    34    276.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    276.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    276.3 MiB      0.0 MiB           1       came_from = {}
    37    288.0 MiB -144395.4 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    288.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    303.4 MiB     15.4 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    303.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    303.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    303.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    303.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    304.1 MiB  -3307.1 MiB       15660       while not open_set.empty():
    47    304.1 MiB  -3307.2 MiB       15660           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    304.1 MiB  -3307.6 MiB       15660           current = open_set.get()[2]
    53    304.1 MiB  -3307.6 MiB       15660           open_set_hash.remove(current)
    54                                         
    55    304.1 MiB  -3307.6 MiB       15660           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    304.1 MiB  -3307.6 MiB       15660           if current == end:
    60    302.1 MiB     -2.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    302.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    304.1 MiB -29753.5 MiB      140931           for neighbor in current.neighbors:
    65    304.1 MiB -26446.8 MiB      125272               if current.row != neighbor.row and current.col != neighbor.col:
    66    304.1 MiB -13224.4 MiB       62636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    304.1 MiB -13222.4 MiB       62636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    304.1 MiB -26447.2 MiB      125272               if temp_g_score < g_score[neighbor]:
    71    304.1 MiB  -3525.9 MiB       16380                   came_from[neighbor] = current
    72    304.1 MiB  -3526.6 MiB       16380                   g_score[neighbor] = temp_g_score
    73    304.1 MiB  -3526.7 MiB       16380                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    304.1 MiB  -3526.7 MiB       16380                   if neighbor not in open_set_hash:
    75    304.1 MiB  -3526.7 MiB       16380                       count += 1
    76    304.1 MiB  -3526.7 MiB       16380                       open_set.put((f_score[neighbor], count, neighbor))
    77    304.1 MiB  -3526.7 MiB       16380                       open_set_hash.add(neighbor)
    78                                                             
    79    304.1 MiB  -3306.8 MiB       15659           if draw is not None:
    80                                                     draw()
    81                                         
    82    304.1 MiB  -3306.9 MiB       15659           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    291.8 MiB    291.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    292.1 MiB    -30.6 MiB         513       for row in grid:
    30    292.1 MiB -15680.8 MiB      262656           for spot in row:
    31    292.1 MiB -15649.8 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    292.1 MiB      0.0 MiB           1       count = 0
    34    292.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    292.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    292.1 MiB      0.0 MiB           1       came_from = {}
    37    298.8 MiB -478169.0 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    294.2 MiB     -4.6 MiB           1       g_score[start] = 0
    39    306.9 MiB -193454.8 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    302.3 MiB     -4.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    302.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    302.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    302.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    302.4 MiB  -9006.9 MiB       25488       while not open_set.empty():
    47    302.4 MiB  -9006.9 MiB       25488           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    302.4 MiB  -9006.9 MiB       25488           current = open_set.get()[2]
    53    302.4 MiB  -9006.9 MiB       25488           open_set_hash.remove(current)
    54                                         
    55    302.4 MiB  -9006.9 MiB       25488           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    302.4 MiB  -9006.9 MiB       25488           if current == end:
    60    301.8 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    301.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    302.4 MiB -81061.0 MiB      229383           for neighbor in current.neighbors:
    65    302.4 MiB -72054.1 MiB      203896               if current.row != neighbor.row and current.col != neighbor.col:
    66    302.4 MiB -36027.7 MiB      101948                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    302.4 MiB -36026.6 MiB      101948                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    302.4 MiB -72054.5 MiB      203896               if temp_g_score < g_score[neighbor]:
    71    302.4 MiB  -9235.5 MiB       26390                   came_from[neighbor] = current
    72    302.4 MiB  -9235.5 MiB       26390                   g_score[neighbor] = temp_g_score
    73    302.4 MiB  -9235.5 MiB       26390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    302.4 MiB  -9235.5 MiB       26390                   if neighbor not in open_set_hash:
    75    302.4 MiB  -9235.5 MiB       26390                       count += 1
    76    302.4 MiB  -9235.5 MiB       26390                       open_set.put((f_score[neighbor], count, neighbor))
    77    302.4 MiB  -9235.5 MiB       26390                       open_set_hash.add(neighbor)
    78                                                             
    79    302.4 MiB  -9006.9 MiB       25487           if draw is not None:
    80                                                     draw()
    81                                         
    82    302.4 MiB  -9006.9 MiB       25487           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    294.0 MiB    294.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    294.0 MiB  -3415.0 MiB         513       for row in grid:
    30    294.0 MiB -1748946.3 MiB      262656           for spot in row:
    31    294.0 MiB -1745536.0 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    287.2 MiB     -6.8 MiB           1       count = 0
    34    287.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    287.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    287.2 MiB      0.0 MiB           1       came_from = {}
    37    289.0 MiB -879746.9 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    210.2 MiB    -78.8 MiB           1       g_score[start] = 0
    39    215.0 MiB -2113597.1 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    215.3 MiB      0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    215.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    215.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    215.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    228.9 MiB -84557.6 MiB        3507       while not open_set.empty():
    47    228.9 MiB -84559.0 MiB        3507           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    228.9 MiB -84560.6 MiB        3507           current = open_set.get()[2]
    53    228.9 MiB -84562.0 MiB        3507           open_set_hash.remove(current)
    54                                         
    55    228.9 MiB -84563.1 MiB        3507           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    228.9 MiB -84564.0 MiB        3507           if current == end:
    60    211.8 MiB    -17.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    211.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    228.9 MiB -761008.7 MiB       31554           for neighbor in current.neighbors:
    65    228.9 MiB -676459.2 MiB       28048               if current.row != neighbor.row and current.col != neighbor.col:
    66    228.9 MiB -338256.6 MiB       14024                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    228.9 MiB -338212.8 MiB       14024                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    228.9 MiB -676476.9 MiB       28048               if temp_g_score < g_score[neighbor]:
    71    228.9 MiB -100729.0 MiB        4215                   came_from[neighbor] = current
    72    228.9 MiB -100730.3 MiB        4215                   g_score[neighbor] = temp_g_score
    73    228.9 MiB -100732.2 MiB        4215                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    228.9 MiB -100733.6 MiB        4215                   if neighbor not in open_set_hash:
    75    228.9 MiB -100734.9 MiB        4215                       count += 1
    76    228.9 MiB -100687.6 MiB        4215                       open_set.put((f_score[neighbor], count, neighbor))
    77    228.9 MiB -100701.5 MiB        4215                       open_set_hash.add(neighbor)
    78                                                             
    79    228.9 MiB -84555.6 MiB        3506           if draw is not None:
    80                                                     draw()
    81                                         
    82    228.9 MiB -84556.8 MiB        3506           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    278.8 MiB    278.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    278.8 MiB  -4320.6 MiB         513       for row in grid:
    30    278.8 MiB -2215944.1 MiB      262656           for spot in row:
    31    278.8 MiB -2211629.7 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    269.5 MiB     -9.3 MiB           1       count = 0
    34    269.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    269.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    269.5 MiB      0.0 MiB           1       came_from = {}
    37    286.3 MiB -10073.6 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    286.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    296.7 MiB -199262.0 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    296.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    296.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    296.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    296.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    297.0 MiB      0.0 MiB        5808       while not open_set.empty():
    47    297.0 MiB      0.0 MiB        5808           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    297.0 MiB      0.0 MiB        5808           current = open_set.get()[2]
    53    297.0 MiB      0.0 MiB        5808           open_set_hash.remove(current)
    54                                         
    55    297.0 MiB      0.0 MiB        5808           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    297.0 MiB      0.0 MiB        5808           if current == end:
    60    297.0 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    297.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    297.0 MiB      0.0 MiB       52263           for neighbor in current.neighbors:
    65    297.0 MiB      0.0 MiB       46456               if current.row != neighbor.row and current.col != neighbor.col:
    66    297.0 MiB      0.0 MiB       23228                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    297.0 MiB      0.0 MiB       23228                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    297.0 MiB      0.0 MiB       46456               if temp_g_score < g_score[neighbor]:
    71    297.0 MiB      0.1 MiB        6906                   came_from[neighbor] = current
    72    297.0 MiB      0.0 MiB        6906                   g_score[neighbor] = temp_g_score
    73    297.0 MiB      0.0 MiB        6906                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    297.0 MiB      0.0 MiB        6906                   if neighbor not in open_set_hash:
    75    297.0 MiB      0.0 MiB        6906                       count += 1
    76    297.0 MiB      0.1 MiB        6906                       open_set.put((f_score[neighbor], count, neighbor))
    77    297.0 MiB      0.0 MiB        6906                       open_set_hash.add(neighbor)
    78                                                             
    79    297.0 MiB      0.0 MiB        5807           if draw is not None:
    80                                                     draw()
    81                                         
    82    297.0 MiB      0.0 MiB        5807           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    287.2 MiB    287.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    287.2 MiB  -6401.8 MiB         513       for row in grid:
    30    287.2 MiB -3278632.9 MiB      262656           for spot in row:
    31    287.2 MiB -3272248.7 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    262.9 MiB    -24.2 MiB           1       count = 0
    34    262.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    262.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    262.9 MiB      0.0 MiB           1       came_from = {}
    37    276.4 MiB  -9628.3 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    276.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    298.2 MiB     17.8 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    298.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    298.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    298.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    298.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    298.2 MiB -268419.0 MiB       22140       while not open_set.empty():
    47    298.2 MiB -268422.5 MiB       22140           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    298.2 MiB -268427.4 MiB       22140           current = open_set.get()[2]
    53    298.2 MiB -268430.8 MiB       22140           open_set_hash.remove(current)
    54                                         
    55    298.2 MiB -268433.8 MiB       22140           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    298.2 MiB -268436.6 MiB       22140           if current == end:
    60    137.0 MiB   -161.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    140.0 MiB      3.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    298.2 MiB -2415021.7 MiB      199251           for neighbor in current.neighbors:
    65    298.2 MiB -2146638.5 MiB      177112               if current.row != neighbor.row and current.col != neighbor.col:
    66    298.2 MiB -1073453.0 MiB       88556                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    298.2 MiB -1073207.9 MiB       88556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    298.2 MiB -2146683.7 MiB      177112               if temp_g_score < g_score[neighbor]:
    71    298.2 MiB -284530.7 MiB       23116                   came_from[neighbor] = current
    72    298.2 MiB -284533.5 MiB       23116                   g_score[neighbor] = temp_g_score
    73    298.2 MiB -284537.8 MiB       23116                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    298.2 MiB -284539.9 MiB       23116                   if neighbor not in open_set_hash:
    75    298.2 MiB -284553.5 MiB       23116                       count += 1
    76    298.2 MiB -284558.8 MiB       23116                       open_set.put((f_score[neighbor], count, neighbor))
    77    298.2 MiB -284562.0 MiB       23116                       open_set_hash.add(neighbor)
    78                                                             
    79    298.2 MiB -268409.3 MiB       22139           if draw is not None:
    80                                                     draw()
    81                                         
    82    298.2 MiB -268414.5 MiB       22139           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    275.7 MiB    275.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    275.9 MiB    -84.2 MiB         513       for row in grid:
    30    275.9 MiB -43172.8 MiB      262656           for spot in row:
    31    275.9 MiB -43088.4 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    275.9 MiB      0.0 MiB           1       count = 0
    34    275.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    275.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    275.9 MiB      0.0 MiB           1       came_from = {}
    37    283.8 MiB -177358.5 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    283.0 MiB     -0.9 MiB           1       g_score[start] = 0
    39    291.7 MiB -296674.7 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    291.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    291.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    291.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    291.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    291.8 MiB -1025942.5 MiB       12040       while not open_set.empty():
    47    291.8 MiB -1025947.2 MiB       12040           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    291.8 MiB -1025954.8 MiB       12040           current = open_set.get()[2]
    53    291.8 MiB -1025958.9 MiB       12040           open_set_hash.remove(current)
    54                                         
    55    291.8 MiB -1025962.7 MiB       12040           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    291.8 MiB -1025967.6 MiB       12040           if current == end:
    60    160.9 MiB   -130.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    161.1 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    291.8 MiB -9232952.3 MiB      108351           for neighbor in current.neighbors:
    65    291.8 MiB -8207057.9 MiB       96312               if current.row != neighbor.row and current.col != neighbor.col:
    66    291.8 MiB -4103608.1 MiB       48156                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    291.8 MiB -4103483.8 MiB       48156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    291.8 MiB -8207127.2 MiB       96312               if temp_g_score < g_score[neighbor]:
    71    291.8 MiB -1072383.7 MiB       12770                   came_from[neighbor] = current
    72    291.8 MiB -1072388.6 MiB       12770                   g_score[neighbor] = temp_g_score
    73    291.8 MiB -1072395.5 MiB       12770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    291.8 MiB -1072400.2 MiB       12770                   if neighbor not in open_set_hash:
    75    291.8 MiB -1072405.0 MiB       12770                       count += 1
    76    291.8 MiB -1072321.0 MiB       12770                       open_set.put((f_score[neighbor], count, neighbor))
    77    291.8 MiB -1072326.2 MiB       12770                       open_set_hash.add(neighbor)
    78                                                             
    79    291.8 MiB -1025932.5 MiB       12039           if draw is not None:
    80                                                     draw()
    81                                         
    82    291.8 MiB -1025936.9 MiB       12039           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    271.2 MiB    271.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    271.2 MiB  -2723.6 MiB         513       for row in grid:
    30    271.2 MiB -1393139.3 MiB      262656           for spot in row:
    31    271.2 MiB -1390423.2 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    259.7 MiB    -11.5 MiB           1       count = 0
    34    259.9 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35    260.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    260.1 MiB      0.0 MiB           1       came_from = {}
    37    277.1 MiB   -108.7 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    277.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    300.2 MiB  -6865.5 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    300.4 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    300.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    300.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    300.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    300.5 MiB -1140172.7 MiB       10472       while not open_set.empty():
    47    300.5 MiB -1140176.4 MiB       10472           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    300.5 MiB -1140185.2 MiB       10472           current = open_set.get()[2]
    53    300.5 MiB -1140189.8 MiB       10472           open_set_hash.remove(current)
    54                                         
    55    300.5 MiB -1140195.5 MiB       10472           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    300.5 MiB -1140200.6 MiB       10472           if current == end:
    60    159.5 MiB   -141.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    159.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    300.5 MiB -10261080.9 MiB       94239           for neighbor in current.neighbors:
    65    300.5 MiB -9120955.7 MiB       83768               if current.row != neighbor.row and current.col != neighbor.col:
    66    300.5 MiB -4560560.6 MiB       41884                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    300.5 MiB -4560424.9 MiB       41884                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    300.5 MiB -9121016.5 MiB       83768               if temp_g_score < g_score[neighbor]:
    71    300.5 MiB -1185609.2 MiB       11060                   came_from[neighbor] = current
    72    300.5 MiB -1185612.8 MiB       11060                   g_score[neighbor] = temp_g_score
    73    300.5 MiB -1185616.0 MiB       11060                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    300.5 MiB -1185619.6 MiB       11060                   if neighbor not in open_set_hash:
    75    300.5 MiB -1185623.1 MiB       11060                       count += 1
    76    300.5 MiB -1185572.7 MiB       11060                       open_set.put((f_score[neighbor], count, neighbor))
    77    300.5 MiB -1185576.4 MiB       11060                       open_set_hash.add(neighbor)
    78                                                             
    79    300.5 MiB -1140163.7 MiB       10471           if draw is not None:
    80                                                     draw()
    81                                         
    82    300.5 MiB -1140168.3 MiB       10471           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    272.9 MiB    272.9 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    272.9 MiB   -456.5 MiB         513       for row in grid:
    30    272.9 MiB -233871.9 MiB      262656           for spot in row:
    31    272.9 MiB -233416.6 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    271.4 MiB     -1.5 MiB           1       count = 0
    34    271.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    271.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    271.4 MiB      0.0 MiB           1       came_from = {}
    37    283.1 MiB   -370.5 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    283.1 MiB     -0.0 MiB           1       g_score[start] = 0
    39    299.6 MiB  -6769.6 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    299.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    299.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    299.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    299.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    300.4 MiB      0.0 MiB        5882       while not open_set.empty():
    47    300.4 MiB      0.0 MiB        5882           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    300.4 MiB      0.0 MiB        5882           current = open_set.get()[2]
    53    300.4 MiB      0.0 MiB        5882           open_set_hash.remove(current)
    54                                         
    55    300.4 MiB      0.0 MiB        5882           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    300.4 MiB      0.0 MiB        5882           if current == end:
    60    300.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    300.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    300.4 MiB      0.0 MiB       52929           for neighbor in current.neighbors:
    65    300.4 MiB      0.2 MiB       47048               if current.row != neighbor.row and current.col != neighbor.col:
    66    300.4 MiB      0.0 MiB       23524                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    300.4 MiB      0.0 MiB       23524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    300.4 MiB      0.0 MiB       47048               if temp_g_score < g_score[neighbor]:
    71    300.4 MiB      0.5 MiB        6362                   came_from[neighbor] = current
    72    300.4 MiB      0.0 MiB        6362                   g_score[neighbor] = temp_g_score
    73    300.4 MiB      0.0 MiB        6362                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    300.4 MiB      0.0 MiB        6362                   if neighbor not in open_set_hash:
    75    300.4 MiB      0.0 MiB        6362                       count += 1
    76    300.4 MiB      0.0 MiB        6362                       open_set.put((f_score[neighbor], count, neighbor))
    77    300.4 MiB      0.0 MiB        6362                       open_set_hash.add(neighbor)
    78                                                             
    79    300.4 MiB      0.0 MiB        5881           if draw is not None:
    80                                                     draw()
    81                                         
    82    300.4 MiB      0.0 MiB        5881           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    295.6 MiB    295.6 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    295.6 MiB  -8459.8 MiB         513       for row in grid:
    30    295.6 MiB -4334433.3 MiB      262656           for spot in row:
    31    295.6 MiB -4325998.8 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    258.8 MiB    -36.8 MiB           1       count = 0
    34    258.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    258.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    258.8 MiB      0.0 MiB           1       came_from = {}
    37    276.5 MiB -1308164.2 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    259.2 MiB    -17.3 MiB           1       g_score[start] = 0
    39    282.5 MiB -1419491.3 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    262.1 MiB    -20.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    262.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    262.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    262.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    262.2 MiB -1562686.3 MiB       21087       while not open_set.empty():
    47    262.2 MiB -1562687.7 MiB       21087           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    262.2 MiB -1562692.8 MiB       21087           current = open_set.get()[2]
    53    262.2 MiB -1562701.4 MiB       21087           open_set_hash.remove(current)
    54                                         
    55    262.2 MiB -1562702.9 MiB       21087           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    262.2 MiB -1562705.0 MiB       21087           if current == end:
    60    173.5 MiB    -88.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    173.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    262.2 MiB -14063762.2 MiB      189774           for neighbor in current.neighbors:
    65    262.2 MiB -12501096.9 MiB      168688               if current.row != neighbor.row and current.col != neighbor.col:
    66    262.2 MiB -6250608.3 MiB       84344                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    262.2 MiB -6250507.4 MiB       84344                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    262.2 MiB -12501127.4 MiB      168688               if temp_g_score < g_score[neighbor]:
    71    262.2 MiB -1612793.2 MiB       21963                   came_from[neighbor] = current
    72    262.2 MiB -1612795.6 MiB       21963                   g_score[neighbor] = temp_g_score
    73    262.2 MiB -1612798.4 MiB       21963                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    262.2 MiB -1612800.5 MiB       21963                   if neighbor not in open_set_hash:
    75    262.2 MiB -1612802.8 MiB       21963                       count += 1
    76    262.2 MiB -1612785.0 MiB       21963                       open_set.put((f_score[neighbor], count, neighbor))
    77    262.2 MiB -1612788.2 MiB       21963                       open_set_hash.add(neighbor)
    78                                                             
    79    262.2 MiB -1562682.9 MiB       21086           if draw is not None:
    80                                                     draw()
    81                                         
    82    262.2 MiB -1562684.5 MiB       21086           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    273.3 MiB    273.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    273.3 MiB  -7639.5 MiB         513       for row in grid:
    30    273.3 MiB -3913136.0 MiB      262656           for spot in row:
    31    273.3 MiB -3905513.3 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    241.5 MiB    -31.8 MiB           1       count = 0
    34    241.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35    241.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    241.9 MiB      0.0 MiB           1       came_from = {}
    37    244.2 MiB -5649999.0 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    219.0 MiB    -25.2 MiB           1       g_score[start] = 0
    39    246.5 MiB     27.5 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    246.7 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    246.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    246.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    246.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    250.2 MiB -100474.4 MiB        6402       while not open_set.empty():
    47    250.2 MiB -100476.2 MiB        6402           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    250.2 MiB -100481.5 MiB        6402           current = open_set.get()[2]
    53    250.2 MiB -100485.8 MiB        6402           open_set_hash.remove(current)
    54                                         
    55    250.2 MiB -100491.1 MiB        6402           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    250.2 MiB -100492.9 MiB        6402           if current == end:
    60    106.0 MiB   -144.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.6 MiB      1.7 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    250.2 MiB -903625.4 MiB       57609           for neighbor in current.neighbors:
    65    250.2 MiB -803183.0 MiB       51208               if current.row != neighbor.row and current.col != neighbor.col:
    66    250.2 MiB -401673.1 MiB       25604                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    250.2 MiB -401524.2 MiB       25604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    250.2 MiB -803209.6 MiB       51208               if temp_g_score < g_score[neighbor]:
    71    250.2 MiB -110065.1 MiB        6858                   came_from[neighbor] = current
    72    250.2 MiB -110067.1 MiB        6858                   g_score[neighbor] = temp_g_score
    73    250.2 MiB -110068.9 MiB        6858                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    250.2 MiB -110074.0 MiB        6858                   if neighbor not in open_set_hash:
    75    250.2 MiB -110109.4 MiB        6858                       count += 1
    76    250.2 MiB -110114.0 MiB        6858                       open_set.put((f_score[neighbor], count, neighbor))
    77    250.2 MiB -110116.4 MiB        6858                       open_set_hash.add(neighbor)
    78                                                             
    79    250.2 MiB -100470.6 MiB        6401           if draw is not None:
    80                                                     draw()
    81                                         
    82    250.2 MiB -100472.2 MiB        6401           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    272.4 MiB    272.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    272.4 MiB    -72.4 MiB         513       for row in grid:
    30    272.4 MiB -37048.7 MiB      262656           for spot in row:
    31    272.4 MiB -36976.4 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    272.2 MiB     -0.2 MiB           1       count = 0
    34    272.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    272.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    272.2 MiB      0.0 MiB           1       came_from = {}
    37    283.3 MiB     11.1 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    283.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    284.1 MiB -4113431.6 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    269.6 MiB    -14.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    269.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    269.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    269.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    270.2 MiB      0.0 MiB        8064       while not open_set.empty():
    47    270.2 MiB      0.0 MiB        8064           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    270.2 MiB      0.0 MiB        8064           current = open_set.get()[2]
    53    270.2 MiB      0.0 MiB        8064           open_set_hash.remove(current)
    54                                         
    55    270.2 MiB      0.0 MiB        8064           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    270.2 MiB      0.0 MiB        8064           if current == end:
    60    270.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    270.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    270.2 MiB      0.0 MiB       72567           for neighbor in current.neighbors:
    65    270.2 MiB      0.0 MiB       64504               if current.row != neighbor.row and current.col != neighbor.col:
    66    270.2 MiB      0.0 MiB       32252                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    270.2 MiB      0.0 MiB       32252                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    270.2 MiB      0.0 MiB       64504               if temp_g_score < g_score[neighbor]:
    71    270.2 MiB      0.3 MiB        8614                   came_from[neighbor] = current
    72    270.2 MiB      0.0 MiB        8614                   g_score[neighbor] = temp_g_score
    73    270.2 MiB      0.0 MiB        8614                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    270.2 MiB      0.0 MiB        8614                   if neighbor not in open_set_hash:
    75    270.2 MiB      0.0 MiB        8614                       count += 1
    76    270.2 MiB      0.1 MiB        8614                       open_set.put((f_score[neighbor], count, neighbor))
    77    270.2 MiB      0.1 MiB        8614                       open_set_hash.add(neighbor)
    78                                                             
    79    270.2 MiB      0.0 MiB        8063           if draw is not None:
    80                                                     draw()
    81                                         
    82    270.2 MiB      0.0 MiB        8063           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    282.1 MiB    282.1 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    282.1 MiB  -1866.5 MiB         513       for row in grid:
    30    282.1 MiB -954852.0 MiB      262656           for spot in row:
    31    282.1 MiB -952995.5 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    267.6 MiB    -14.5 MiB           1       count = 0
    34    267.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    267.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    267.6 MiB      0.0 MiB           1       came_from = {}
    37    279.7 MiB -161373.9 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    279.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    303.7 MiB     24.0 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    303.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    303.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    303.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    303.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    303.8 MiB -1698072.3 MiB       11534       while not open_set.empty():
    47    303.8 MiB -1698077.0 MiB       11534           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    303.8 MiB -1698083.4 MiB       11534           current = open_set.get()[2]
    53    303.8 MiB -1698086.5 MiB       11534           open_set_hash.remove(current)
    54                                         
    55    303.8 MiB -1698090.0 MiB       11534           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    303.8 MiB -1698094.0 MiB       11534           if current == end:
    60    158.3 MiB   -145.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    158.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    303.8 MiB -15282022.2 MiB      103797           for neighbor in current.neighbors:
    65    303.8 MiB -13583994.9 MiB       92264               if current.row != neighbor.row and current.col != neighbor.col:
    66    303.8 MiB -6792105.0 MiB       46132                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    303.8 MiB -6791922.4 MiB       46132                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    303.8 MiB -13584060.7 MiB       92264               if temp_g_score < g_score[neighbor]:
    71    303.8 MiB -1759239.6 MiB       12140                   came_from[neighbor] = current
    72    303.8 MiB -1759243.0 MiB       12140                   g_score[neighbor] = temp_g_score
    73    303.8 MiB -1759248.1 MiB       12140                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    303.8 MiB -1759251.4 MiB       12140                   if neighbor not in open_set_hash:
    75    303.8 MiB -1759254.7 MiB       12140                       count += 1
    76    303.8 MiB -1759208.8 MiB       12140                       open_set.put((f_score[neighbor], count, neighbor))
    77    303.8 MiB -1759213.3 MiB       12140                       open_set_hash.add(neighbor)
    78                                                             
    79    303.8 MiB -1698059.1 MiB       11533           if draw is not None:
    80                                                     draw()
    81                                         
    82    303.8 MiB -1698068.0 MiB       11533           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    274.4 MiB    274.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    274.4 MiB  -2199.7 MiB         513       for row in grid:
    30    274.4 MiB -1126746.8 MiB      262656           for spot in row:
    31    274.4 MiB -1124552.0 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    267.3 MiB     -7.1 MiB           1       count = 0
    34    267.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    267.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    267.3 MiB      0.0 MiB           1       came_from = {}
    37    280.7 MiB   -589.9 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    280.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    301.3 MiB  -8071.4 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    301.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    301.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    301.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    301.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    301.6 MiB -115324.4 MiB       20592       while not open_set.empty():
    47    301.6 MiB -115326.3 MiB       20592           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    301.6 MiB -115328.3 MiB       20592           current = open_set.get()[2]
    53    301.6 MiB -115329.1 MiB       20592           open_set_hash.remove(current)
    54                                         
    55    301.6 MiB -115330.2 MiB       20592           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    301.6 MiB -115331.2 MiB       20592           if current == end:
    60    260.2 MiB    -41.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    260.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    301.6 MiB -1037753.3 MiB      185319           for neighbor in current.neighbors:
    65    301.6 MiB -922437.6 MiB      164728               if current.row != neighbor.row and current.col != neighbor.col:
    66    301.6 MiB -461254.2 MiB       82364                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    301.6 MiB -461189.5 MiB       82364                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    301.6 MiB -922448.7 MiB      164728               if temp_g_score < g_score[neighbor]:
    71    301.6 MiB -121106.6 MiB       21478                   came_from[neighbor] = current
    72    301.6 MiB -121107.5 MiB       21478                   g_score[neighbor] = temp_g_score
    73    301.6 MiB -121108.7 MiB       21478                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    301.6 MiB -121109.4 MiB       21478                   if neighbor not in open_set_hash:
    75    301.6 MiB -121110.1 MiB       21478                       count += 1
    76    301.6 MiB -121112.3 MiB       21478                       open_set.put((f_score[neighbor], count, neighbor))
    77    301.6 MiB -121113.4 MiB       21478                       open_set_hash.add(neighbor)
    78                                                             
    79    301.6 MiB -115322.5 MiB       20591           if draw is not None:
    80                                                     draw()
    81                                         
    82    301.6 MiB -115323.3 MiB       20591           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    276.0 MiB    276.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    276.0 MiB  -1854.2 MiB         513       for row in grid:
    30    276.0 MiB -949622.3 MiB      262656           for spot in row:
    31    276.0 MiB -947774.1 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    267.1 MiB     -8.9 MiB           1       count = 0
    34    267.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    267.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    267.1 MiB      0.0 MiB           1       came_from = {}
    37    278.2 MiB  -2099.1 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    278.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    298.2 MiB   -719.0 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    298.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    298.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    298.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    298.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    298.2 MiB -1742243.2 MiB       12533       while not open_set.empty():
    47    298.2 MiB -1742246.2 MiB       12533           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    298.2 MiB -1742252.6 MiB       12533           current = open_set.get()[2]
    53    298.2 MiB -1742256.0 MiB       12533           open_set_hash.remove(current)
    54                                         
    55    298.2 MiB -1742259.1 MiB       12533           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    298.2 MiB -1742262.6 MiB       12533           if current == end:
    60    171.5 MiB   -126.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    171.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    298.2 MiB -15679688.3 MiB      112788           for neighbor in current.neighbors:
    65    298.2 MiB -13937489.5 MiB      100256               if current.row != neighbor.row and current.col != neighbor.col:
    66    298.2 MiB -6968854.3 MiB       50128                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    298.2 MiB -6968662.9 MiB       50128                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    298.2 MiB -13937545.2 MiB      100256               if temp_g_score < g_score[neighbor]:
    71    298.2 MiB -1829291.0 MiB       13301                   came_from[neighbor] = current
    72    298.2 MiB -1829294.8 MiB       13301                   g_score[neighbor] = temp_g_score
    73    298.2 MiB -1829301.9 MiB       13301                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    298.2 MiB -1829306.1 MiB       13301                   if neighbor not in open_set_hash:
    75    298.2 MiB -1829309.6 MiB       13301                       count += 1
    76    298.2 MiB -1829262.4 MiB       13301                       open_set.put((f_score[neighbor], count, neighbor))
    77    298.2 MiB -1829266.8 MiB       13301                       open_set_hash.add(neighbor)
    78                                                             
    79    298.2 MiB -1742236.8 MiB       12532           if draw is not None:
    80                                                     draw()
    81                                         
    82    298.2 MiB -1742239.6 MiB       12532           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    275.5 MiB    275.5 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    275.5 MiB   -373.0 MiB         513       for row in grid:
    30    275.5 MiB -190918.4 MiB      262656           for spot in row:
    31    275.5 MiB -190546.2 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    274.3 MiB     -1.2 MiB           1       count = 0
    34    274.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    274.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    274.3 MiB      0.0 MiB           1       came_from = {}
    37    284.9 MiB -31792.1 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    284.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    300.4 MiB -65023.0 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    300.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    300.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    300.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    300.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    300.5 MiB      0.0 MiB         684       while not open_set.empty():
    47    300.5 MiB      0.0 MiB         684           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    300.5 MiB      0.0 MiB         684           current = open_set.get()[2]
    53    300.5 MiB      0.0 MiB         684           open_set_hash.remove(current)
    54                                         
    55    300.5 MiB      0.0 MiB         684           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    300.5 MiB      0.0 MiB         684           if current == end:
    60    300.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    300.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    300.5 MiB      0.0 MiB        6147           for neighbor in current.neighbors:
    65    300.5 MiB      0.0 MiB        5464               if current.row != neighbor.row and current.col != neighbor.col:
    66    300.5 MiB      0.0 MiB        2732                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    300.5 MiB      0.0 MiB        2732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    300.5 MiB      0.0 MiB        5464               if temp_g_score < g_score[neighbor]:
    71    300.5 MiB      0.0 MiB        1150                   came_from[neighbor] = current
    72    300.5 MiB      0.0 MiB        1150                   g_score[neighbor] = temp_g_score
    73    300.5 MiB      0.0 MiB        1150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    300.5 MiB      0.0 MiB        1150                   if neighbor not in open_set_hash:
    75    300.5 MiB      0.0 MiB        1150                       count += 1
    76    300.5 MiB      0.0 MiB        1150                       open_set.put((f_score[neighbor], count, neighbor))
    77    300.5 MiB      0.0 MiB        1150                       open_set_hash.add(neighbor)
    78                                                             
    79    300.5 MiB      0.0 MiB         683           if draw is not None:
    80                                                     draw()
    81                                         
    82    300.5 MiB      0.0 MiB         683           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    291.7 MiB    291.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    291.7 MiB  -5396.8 MiB         513       for row in grid:
    30    291.7 MiB -2765466.5 MiB      262656           for spot in row:
    31    291.7 MiB -2760082.9 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    272.6 MiB    -19.0 MiB           1       count = 0
    34    272.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    272.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    272.6 MiB      0.0 MiB           1       came_from = {}
    37    286.8 MiB -15077.5 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    286.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    298.0 MiB     -5.5 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    298.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    298.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    298.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    298.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    298.0 MiB -318012.7 MiB       23100       while not open_set.empty():
    47    298.0 MiB -318012.8 MiB       23100           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    298.0 MiB -318013.5 MiB       23100           current = open_set.get()[2]
    53    298.0 MiB -318013.8 MiB       23100           open_set_hash.remove(current)
    54                                         
    55    298.0 MiB -318014.8 MiB       23100           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    298.0 MiB -318015.4 MiB       23100           if current == end:
    60    278.0 MiB    -20.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    278.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    298.0 MiB -2862049.2 MiB      207891           for neighbor in current.neighbors:
    65    298.0 MiB -2544041.6 MiB      184792               if current.row != neighbor.row and current.col != neighbor.col:
    66    298.0 MiB -1272035.4 MiB       92396                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    298.0 MiB -1272009.6 MiB       92396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    298.0 MiB -2544052.0 MiB      184792               if temp_g_score < g_score[neighbor]:
    71    298.0 MiB -329458.6 MiB       24158                   came_from[neighbor] = current
    72    298.0 MiB -329458.9 MiB       24158                   g_score[neighbor] = temp_g_score
    73    298.0 MiB -329459.3 MiB       24158                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    298.0 MiB -329459.6 MiB       24158                   if neighbor not in open_set_hash:
    75    298.0 MiB -329459.8 MiB       24158                       count += 1
    76    298.0 MiB -329454.2 MiB       24158                       open_set.put((f_score[neighbor], count, neighbor))
    77    298.0 MiB -329455.0 MiB       24158                       open_set_hash.add(neighbor)
    78                                                             
    79    298.0 MiB -318012.3 MiB       23099           if draw is not None:
    80                                                     draw()
    81                                         
    82    298.0 MiB -318012.6 MiB       23099           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    279.4 MiB    279.4 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    279.4 MiB   -137.8 MiB         513       for row in grid:
    30    279.4 MiB -70375.5 MiB      262656           for spot in row:
    31    279.4 MiB -70238.3 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    278.4 MiB     -1.0 MiB           1       count = 0
    34    278.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    278.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    278.4 MiB      0.0 MiB           1       came_from = {}
    37    287.9 MiB -22644.8 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    287.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    302.3 MiB  -9044.1 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    302.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    302.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    302.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    302.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    302.3 MiB -929549.2 MiB       28085       while not open_set.empty():
    47    302.3 MiB -929549.7 MiB       28085           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    302.3 MiB -929550.7 MiB       28085           current = open_set.get()[2]
    53    302.3 MiB -929551.5 MiB       28085           open_set_hash.remove(current)
    54                                         
    55    302.3 MiB -929551.6 MiB       28085           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    302.3 MiB -929551.8 MiB       28085           if current == end:
    60    256.0 MiB    -46.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    256.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    302.3 MiB -8365694.8 MiB      252756           for neighbor in current.neighbors:
    65    302.3 MiB -7436156.8 MiB      224672               if current.row != neighbor.row and current.col != neighbor.col:
    66    302.3 MiB -3718119.0 MiB      112336                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    302.3 MiB -3718045.3 MiB      112336                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    302.3 MiB -7436173.2 MiB      224672               if temp_g_score < g_score[neighbor]:
    71    302.3 MiB -957567.0 MiB       29177                   came_from[neighbor] = current
    72    302.3 MiB -957568.1 MiB       29177                   g_score[neighbor] = temp_g_score
    73    302.3 MiB -957569.1 MiB       29177                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    302.3 MiB -957571.1 MiB       29177                   if neighbor not in open_set_hash:
    75    302.3 MiB -957574.2 MiB       29177                       count += 1
    76    302.3 MiB -957566.9 MiB       29177                       open_set.put((f_score[neighbor], count, neighbor))
    77    302.3 MiB -957568.9 MiB       29177                       open_set_hash.add(neighbor)
    78                                                             
    79    302.3 MiB -929548.2 MiB       28084           if draw is not None:
    80                                                     draw()
    81                                         
    82    302.3 MiB -929548.9 MiB       28084           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    276.7 MiB    276.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    276.7 MiB  -1774.7 MiB         513       for row in grid:
    30    276.7 MiB -907329.2 MiB      262656           for spot in row:
    31    276.7 MiB -905558.8 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    269.8 MiB     -6.9 MiB           1       count = 0
    34    269.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    269.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    269.8 MiB      0.0 MiB           1       came_from = {}
    37    285.6 MiB     15.8 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    285.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    300.8 MiB     15.2 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    300.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    300.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    300.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    300.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    300.9 MiB -2684521.4 MiB       20385       while not open_set.empty():
    47    300.9 MiB -2684523.8 MiB       20385           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    300.9 MiB -2684529.7 MiB       20385           current = open_set.get()[2]
    53    300.9 MiB -2684533.3 MiB       20385           open_set_hash.remove(current)
    54                                         
    55    300.9 MiB -2684537.4 MiB       20385           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    300.9 MiB -2684541.8 MiB       20385           if current == end:
    60    158.8 MiB   -142.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    158.9 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    300.9 MiB -24160106.4 MiB      183456           for neighbor in current.neighbors:
    65    300.9 MiB -21475618.7 MiB      163072               if current.row != neighbor.row and current.col != neighbor.col:
    66    300.9 MiB -10737914.7 MiB       81536                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    300.9 MiB -10737738.5 MiB       81536                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    300.9 MiB -21475681.9 MiB      163072               if temp_g_score < g_score[neighbor]:
    71    300.9 MiB -2773303.8 MiB       21257                   came_from[neighbor] = current
    72    300.9 MiB -2773308.8 MiB       21257                   g_score[neighbor] = temp_g_score
    73    300.9 MiB -2773313.5 MiB       21257                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    300.9 MiB -2773318.4 MiB       21257                   if neighbor not in open_set_hash:
    75    300.9 MiB -2773322.2 MiB       21257                       count += 1
    76    300.9 MiB -2773279.9 MiB       21257                       open_set.put((f_score[neighbor], count, neighbor))
    77    300.9 MiB -2773285.3 MiB       21257                       open_set_hash.add(neighbor)
    78                                                             
    79    300.9 MiB -2684514.6 MiB       20384           if draw is not None:
    80                                                     draw()
    81                                         
    82    300.9 MiB -2684518.4 MiB       20384           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    274.7 MiB    274.7 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    274.7 MiB   -701.7 MiB         513       for row in grid:
    30    274.7 MiB -359224.1 MiB      262656           for spot in row:
    31    274.7 MiB -358524.6 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    271.7 MiB     -3.0 MiB           1       count = 0
    34    271.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    271.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    271.7 MiB      0.0 MiB           1       came_from = {}
    37    281.8 MiB -39898.2 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    281.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    291.7 MiB -19252.4 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    291.8 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    291.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    291.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    291.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    292.0 MiB -13100.0 MiB        3666       while not open_set.empty():
    47    292.0 MiB -13100.4 MiB        3666           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    292.0 MiB -13100.9 MiB        3666           current = open_set.get()[2]
    53    292.0 MiB -13101.1 MiB        3666           open_set_hash.remove(current)
    54                                         
    55    292.0 MiB -13101.3 MiB        3666           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    292.0 MiB -13101.7 MiB        3666           if current == end:
    60    279.5 MiB    -12.5 MiB           1               if draw:
    61                                                         end.make_end()
    62    279.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    292.0 MiB -117836.5 MiB       32985           for neighbor in current.neighbors:
    65    292.0 MiB -104740.0 MiB       29320               if current.row != neighbor.row and current.col != neighbor.col:
    66    292.0 MiB -52377.0 MiB       14660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    292.0 MiB -52365.0 MiB       14660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    292.0 MiB -104743.8 MiB       29320               if temp_g_score < g_score[neighbor]:
    71    292.0 MiB -17118.3 MiB        4818                   came_from[neighbor] = current
    72    292.0 MiB -17118.3 MiB        4818                   g_score[neighbor] = temp_g_score
    73    292.0 MiB -17118.3 MiB        4818                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    292.0 MiB -17118.3 MiB        4818                   if neighbor not in open_set_hash:
    75    292.0 MiB -17118.6 MiB        4818                       count += 1
    76    292.0 MiB -17118.8 MiB        4818                       open_set.put((f_score[neighbor], count, neighbor))
    77    292.0 MiB -17119.2 MiB        4818                       open_set_hash.add(neighbor)
    78                                                             
    79    292.0 MiB -13098.9 MiB        3665           if draw is not None:
    80                                                     draw()
    81                                         
    82    292.0 MiB -13099.4 MiB        3665           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    280.3 MiB    280.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    280.3 MiB  -2658.0 MiB         513       for row in grid:
    30    280.3 MiB -1361371.1 MiB      262656           for spot in row:
    31    280.3 MiB -1358717.3 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    273.5 MiB     -6.8 MiB           1       count = 0
    34    273.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    273.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    273.5 MiB      0.0 MiB           1       came_from = {}
    37    283.4 MiB -1876155.4 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    254.1 MiB    -29.3 MiB           1       g_score[start] = 0
    39    264.2 MiB -5988504.7 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    185.2 MiB    -79.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    185.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    185.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    185.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    186.7 MiB      0.0 MiB         117       while not open_set.empty():
    47    186.7 MiB      0.0 MiB         117           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    186.7 MiB      0.0 MiB         117           current = open_set.get()[2]
    53    186.7 MiB      0.0 MiB         117           open_set_hash.remove(current)
    54                                         
    55    186.7 MiB      0.0 MiB         117           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    186.7 MiB      0.0 MiB         117           if current == end:
    60    186.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    186.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    186.7 MiB      0.0 MiB        1044           for neighbor in current.neighbors:
    65    186.7 MiB      1.4 MiB         928               if current.row != neighbor.row and current.col != neighbor.col:
    66    186.7 MiB      0.0 MiB         464                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    186.7 MiB      0.0 MiB         464                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    186.7 MiB      0.0 MiB         928               if temp_g_score < g_score[neighbor]:
    71    186.7 MiB      0.0 MiB         353                   came_from[neighbor] = current
    72    186.7 MiB      0.0 MiB         353                   g_score[neighbor] = temp_g_score
    73    186.7 MiB      0.0 MiB         353                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    186.7 MiB      0.0 MiB         353                   if neighbor not in open_set_hash:
    75    186.7 MiB      0.0 MiB         353                       count += 1
    76    186.7 MiB      0.0 MiB         353                       open_set.put((f_score[neighbor], count, neighbor))
    77    186.7 MiB      0.0 MiB         353                       open_set_hash.add(neighbor)
    78                                                             
    79    186.7 MiB      0.0 MiB         116           if draw is not None:
    80                                                     draw()
    81                                         
    82    186.7 MiB      0.0 MiB         116           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    286.0 MiB    286.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    286.0 MiB      0.0 MiB         513       for row in grid:
    30    286.0 MiB      0.0 MiB      262656           for spot in row:
    31    286.0 MiB      0.0 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    286.0 MiB      0.0 MiB           1       count = 0
    34    286.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    286.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    286.0 MiB      0.0 MiB           1       came_from = {}
    37    291.4 MiB      5.5 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    291.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    304.1 MiB -360663.2 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    300.4 MiB     -3.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    300.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    300.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    300.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    300.5 MiB      0.0 MiB        4370       while not open_set.empty():
    47    300.5 MiB      0.0 MiB        4370           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    300.5 MiB      0.0 MiB        4370           current = open_set.get()[2]
    53    300.5 MiB      0.0 MiB        4370           open_set_hash.remove(current)
    54                                         
    55    300.5 MiB      0.0 MiB        4370           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    300.5 MiB      0.0 MiB        4370           if current == end:
    60    300.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    300.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    300.5 MiB      0.0 MiB       39321           for neighbor in current.neighbors:
    65    300.5 MiB      0.0 MiB       34952               if current.row != neighbor.row and current.col != neighbor.col:
    66    300.5 MiB      0.0 MiB       17476                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    300.5 MiB      0.0 MiB       17476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    300.5 MiB      0.0 MiB       34952               if temp_g_score < g_score[neighbor]:
    71    300.5 MiB      0.1 MiB        4904                   came_from[neighbor] = current
    72    300.5 MiB      0.0 MiB        4904                   g_score[neighbor] = temp_g_score
    73    300.5 MiB      0.0 MiB        4904                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    300.5 MiB      0.0 MiB        4904                   if neighbor not in open_set_hash:
    75    300.5 MiB      0.0 MiB        4904                       count += 1
    76    300.5 MiB      0.0 MiB        4904                       open_set.put((f_score[neighbor], count, neighbor))
    77    300.5 MiB      0.0 MiB        4904                       open_set_hash.add(neighbor)
    78                                                             
    79    300.5 MiB      0.0 MiB        4369           if draw is not None:
    80                                                     draw()
    81                                         
    82    300.5 MiB      0.0 MiB        4369           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    299.8 MiB    299.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    299.8 MiB -13950.5 MiB         513       for row in grid:
    30    299.8 MiB -7131199.9 MiB      262656           for spot in row:
    31    299.8 MiB -7117296.0 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    230.3 MiB    -69.5 MiB           1       count = 0
    34    230.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35    230.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    230.7 MiB      0.0 MiB           1       came_from = {}
    37    249.5 MiB -3153842.2 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    216.7 MiB    -32.9 MiB           1       g_score[start] = 0
    39    221.4 MiB -12682191.9 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    140.7 MiB    -80.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    140.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    140.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    140.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    141.3 MiB      0.0 MiB         666       while not open_set.empty():
    47    141.3 MiB      0.0 MiB         666           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    141.3 MiB      0.0 MiB         666           current = open_set.get()[2]
    53    141.3 MiB      0.0 MiB         666           open_set_hash.remove(current)
    54                                         
    55    141.3 MiB      0.0 MiB         666           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    141.3 MiB      0.0 MiB         666           if current == end:
    60    141.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    141.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    141.3 MiB      0.0 MiB        5985           for neighbor in current.neighbors:
    65    141.3 MiB      0.3 MiB        5320               if current.row != neighbor.row and current.col != neighbor.col:
    66    141.3 MiB      0.0 MiB        2660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    141.3 MiB      0.0 MiB        2660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    141.3 MiB      0.0 MiB        5320               if temp_g_score < g_score[neighbor]:
    71    141.3 MiB      0.0 MiB         810                   came_from[neighbor] = current
    72    141.3 MiB      0.0 MiB         810                   g_score[neighbor] = temp_g_score
    73    141.3 MiB      0.0 MiB         810                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    141.3 MiB      0.0 MiB         810                   if neighbor not in open_set_hash:
    75    141.3 MiB      0.0 MiB         810                       count += 1
    76    141.3 MiB      0.1 MiB         810                       open_set.put((f_score[neighbor], count, neighbor))
    77    141.3 MiB      0.1 MiB         810                       open_set_hash.add(neighbor)
    78                                                             
    79    141.3 MiB      0.0 MiB         665           if draw is not None:
    80                                                     draw()
    81                                         
    82    141.3 MiB      0.0 MiB         665           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    283.2 MiB    283.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    283.2 MiB  -2538.7 MiB         513       for row in grid:
    30    283.2 MiB -1297308.6 MiB      262656           for spot in row:
    31    283.2 MiB -1294780.2 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    269.1 MiB    -14.2 MiB           1       count = 0
    34    269.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    269.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    269.1 MiB      0.0 MiB           1       came_from = {}
    37    288.5 MiB     19.4 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    288.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    295.3 MiB -322340.5 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    293.6 MiB     -1.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    293.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    293.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    293.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    293.8 MiB -830089.8 MiB       17928       while not open_set.empty():
    47    293.8 MiB -830091.8 MiB       17928           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    293.8 MiB -830096.0 MiB       17928           current = open_set.get()[2]
    53    293.8 MiB -830097.8 MiB       17928           open_set_hash.remove(current)
    54                                         
    55    293.8 MiB -830099.7 MiB       17928           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    293.8 MiB -830101.1 MiB       17928           if current == end:
    60    241.2 MiB    -52.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    241.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    293.8 MiB -7470585.3 MiB      161343           for neighbor in current.neighbors:
    65    293.8 MiB -6640515.7 MiB      143416               if current.row != neighbor.row and current.col != neighbor.col:
    66    293.8 MiB -3320285.3 MiB       71708                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    293.8 MiB -3320244.6 MiB       71708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    293.8 MiB -6640542.3 MiB      143416               if temp_g_score < g_score[neighbor]:
    71    293.8 MiB -855217.1 MiB       18690                   came_from[neighbor] = current
    72    293.8 MiB -855219.0 MiB       18690                   g_score[neighbor] = temp_g_score
    73    293.8 MiB -855222.0 MiB       18690                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    293.8 MiB -855224.1 MiB       18690                   if neighbor not in open_set_hash:
    75    293.8 MiB -855226.3 MiB       18690                       count += 1
    76    293.8 MiB -855195.1 MiB       18690                       open_set.put((f_score[neighbor], count, neighbor))
    77    293.8 MiB -855197.3 MiB       18690                       open_set_hash.add(neighbor)
    78                                                             
    79    293.8 MiB -830084.9 MiB       17927           if draw is not None:
    80                                                     draw()
    81                                         
    82    293.8 MiB -830087.3 MiB       17927           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    282.6 MiB    282.6 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    282.6 MiB  -2807.2 MiB         513       for row in grid:
    30    282.6 MiB -1435981.8 MiB      262656           for spot in row:
    31    282.6 MiB -1433183.3 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    270.2 MiB    -12.3 MiB           1       count = 0
    34    270.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    270.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    270.2 MiB      0.0 MiB           1       came_from = {}
    37    289.1 MiB -38834.1 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    288.2 MiB     -0.9 MiB           1       g_score[start] = 0
    39    299.7 MiB     11.5 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    299.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    299.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    299.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    299.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    299.7 MiB   -841.3 MiB         396       while not open_set.empty():
    47    299.7 MiB   -841.3 MiB         396           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    299.7 MiB   -841.3 MiB         396           current = open_set.get()[2]
    53    299.7 MiB   -841.3 MiB         396           open_set_hash.remove(current)
    54                                         
    55    299.7 MiB   -841.3 MiB         396           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    299.7 MiB   -841.4 MiB         396           if current == end:
    60    296.3 MiB     -3.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    296.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    299.7 MiB  -7557.5 MiB        3555           for neighbor in current.neighbors:
    65    299.7 MiB  -6718.3 MiB        3160               if current.row != neighbor.row and current.col != neighbor.col:
    66    299.7 MiB  -3364.3 MiB        1580                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    299.7 MiB  -3354.5 MiB        1580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    299.7 MiB  -6718.8 MiB        3160               if temp_g_score < g_score[neighbor]:
    71    299.7 MiB  -1265.4 MiB         608                   came_from[neighbor] = current
    72    299.7 MiB  -1265.4 MiB         608                   g_score[neighbor] = temp_g_score
    73    299.7 MiB  -1265.4 MiB         608                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    299.7 MiB  -1265.4 MiB         608                   if neighbor not in open_set_hash:
    75    299.7 MiB  -1265.4 MiB         608                       count += 1
    76    299.7 MiB  -1265.4 MiB         608                       open_set.put((f_score[neighbor], count, neighbor))
    77    299.7 MiB  -1265.4 MiB         608                       open_set_hash.add(neighbor)
    78                                                             
    79    299.7 MiB   -841.3 MiB         395           if draw is not None:
    80                                                     draw()
    81                                         
    82    299.7 MiB   -841.3 MiB         395           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    295.8 MiB    295.8 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    295.8 MiB  -5102.7 MiB         513       for row in grid:
    30    295.8 MiB -2612950.6 MiB      262656           for spot in row:
    31    295.8 MiB -2607858.1 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    281.3 MiB    -14.5 MiB           1       count = 0
    34    281.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    281.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    281.3 MiB      0.0 MiB           1       came_from = {}
    37    290.0 MiB  -2780.7 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    289.8 MiB     -0.2 MiB           1       g_score[start] = 0
    39    303.5 MiB  -1639.0 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    303.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    303.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    303.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    303.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    303.5 MiB -726656.5 MiB       10512       while not open_set.empty():
    47    303.5 MiB -726658.2 MiB       10512           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    303.5 MiB -726661.2 MiB       10512           current = open_set.get()[2]
    53    303.5 MiB -726663.6 MiB       10512           open_set_hash.remove(current)
    54                                         
    55    303.5 MiB -726665.3 MiB       10512           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    303.5 MiB -726666.5 MiB       10512           if current == end:
    60    241.7 MiB    -61.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    241.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    303.5 MiB -6539591.7 MiB       94599           for neighbor in current.neighbors:
    65    303.5 MiB -5812957.6 MiB       84088               if current.row != neighbor.row and current.col != neighbor.col:
    66    303.5 MiB -2906501.9 MiB       42044                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    303.5 MiB -2906470.3 MiB       42044                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    303.5 MiB -5812989.6 MiB       84088               if temp_g_score < g_score[neighbor]:
    71    303.5 MiB -767239.0 MiB       11238                   came_from[neighbor] = current
    72    303.5 MiB -767241.2 MiB       11238                   g_score[neighbor] = temp_g_score
    73    303.5 MiB -767244.0 MiB       11238                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    303.5 MiB -767246.2 MiB       11238                   if neighbor not in open_set_hash:
    75    303.5 MiB -767248.2 MiB       11238                       count += 1
    76    303.5 MiB -767216.6 MiB       11238                       open_set.put((f_score[neighbor], count, neighbor))
    77    303.5 MiB -767218.9 MiB       11238                       open_set_hash.add(neighbor)
    78                                                             
    79    303.5 MiB -726651.6 MiB       10511           if draw is not None:
    80                                                     draw()
    81                                         
    82    303.5 MiB -726654.2 MiB       10511           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    282.2 MiB    282.2 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    282.2 MiB -15826.3 MiB         513       for row in grid:
    30    282.2 MiB -8104589.0 MiB      262656           for spot in row:
    31    282.2 MiB -8088788.9 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    238.3 MiB    -43.9 MiB           1       count = 0
    34    238.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35    238.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    238.7 MiB      0.0 MiB           1       came_from = {}
    37    254.8 MiB -3283355.3 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    208.2 MiB    -46.6 MiB           1       g_score[start] = 0
    39    218.6 MiB -7073980.4 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    134.5 MiB    -84.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    134.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    134.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    134.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    142.2 MiB    -28.2 MiB        3060       while not open_set.empty():
    47    142.2 MiB    -28.3 MiB        3060           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    142.2 MiB    -28.3 MiB        3060           current = open_set.get()[2]
    53    142.2 MiB    -28.3 MiB        3060           open_set_hash.remove(current)
    54                                         
    55    142.2 MiB    -28.3 MiB        3060           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    142.2 MiB    -28.3 MiB        3060           if current == end:
    60    142.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    142.3 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    142.2 MiB   -252.2 MiB       27531           for neighbor in current.neighbors:
    65    142.2 MiB   -219.8 MiB       24472               if current.row != neighbor.row and current.col != neighbor.col:
    66    142.2 MiB   -112.8 MiB       12236                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    142.2 MiB   -112.2 MiB       12236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    142.2 MiB   -224.6 MiB       24472               if temp_g_score < g_score[neighbor]:
    71    142.2 MiB    -32.2 MiB        3616                   came_from[neighbor] = current
    72    142.2 MiB    -32.3 MiB        3616                   g_score[neighbor] = temp_g_score
    73    142.2 MiB    -31.5 MiB        3616                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    142.2 MiB    -32.2 MiB        3616                   if neighbor not in open_set_hash:
    75    142.2 MiB    -32.2 MiB        3616                       count += 1
    76    142.2 MiB    -32.2 MiB        3616                       open_set.put((f_score[neighbor], count, neighbor))
    77    142.2 MiB    -32.2 MiB        3616                       open_set_hash.add(neighbor)
    78                                                             
    79    142.2 MiB    -28.3 MiB        3059           if draw is not None:
    80                                                     draw()
    81                                         
    82    142.2 MiB    -28.3 MiB        3059           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    277.1 MiB    277.1 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    277.1 MiB  -2697.7 MiB         513       for row in grid:
    30    277.1 MiB -1379147.0 MiB      262656           for spot in row:
    31    277.1 MiB -1376481.6 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33    230.3 MiB    -46.8 MiB           1       count = 0
    34    230.6 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35    230.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36    230.8 MiB      0.0 MiB           1       came_from = {}
    37    247.6 MiB -1030214.4 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    234.4 MiB    -13.2 MiB           1       g_score[start] = 0
    39    238.5 MiB -863924.7 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    238.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    238.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    238.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    238.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    239.2 MiB -1143208.9 MiB       18632       while not open_set.empty():
    47    239.2 MiB -1143211.9 MiB       18632           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    239.2 MiB -1143215.4 MiB       18632           current = open_set.get()[2]
    53    239.2 MiB -1143218.7 MiB       18632           open_set_hash.remove(current)
    54                                         
    55    239.2 MiB -1143221.5 MiB       18632           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    239.2 MiB -1143224.6 MiB       18632           if current == end:
    60    131.4 MiB   -107.8 MiB           1               if draw:
    61                                                         end.make_end()
    62    131.7 MiB      0.3 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    239.2 MiB -10288548.5 MiB      167679           for neighbor in current.neighbors:
    65    239.2 MiB -9145402.6 MiB      149048               if current.row != neighbor.row and current.col != neighbor.col:
    66    239.2 MiB -4572839.5 MiB       74524                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    239.2 MiB -4572589.4 MiB       74524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    239.2 MiB -9145452.1 MiB      149048               if temp_g_score < g_score[neighbor]:
    71    239.2 MiB -1183386.3 MiB       19450                   came_from[neighbor] = current
    72    239.2 MiB -1183390.5 MiB       19450                   g_score[neighbor] = temp_g_score
    73    239.2 MiB -1183394.5 MiB       19450                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    239.2 MiB -1183397.1 MiB       19450                   if neighbor not in open_set_hash:
    75    239.2 MiB -1183399.3 MiB       19450                       count += 1
    76    239.2 MiB -1183333.2 MiB       19450                       open_set.put((f_score[neighbor], count, neighbor))
    77    239.2 MiB -1183336.1 MiB       19450                       open_set_hash.add(neighbor)
    78                                                             
    79    239.2 MiB -1143203.2 MiB       18631           if draw is not None:
    80                                                     draw()
    81                                         
    82    239.2 MiB -1143205.6 MiB       18631           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    276.3 MiB    276.3 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    276.3 MiB -69074.6 MiB         513       for row in grid:
    30    276.3 MiB -35387262.2 MiB      262656           for spot in row:
    31    276.3 MiB -35318301.5 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33     83.6 MiB   -192.7 MiB           1       count = 0
    34     84.0 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     84.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     84.2 MiB      0.0 MiB           1       came_from = {}
    37     85.2 MiB -7673477.3 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.3 MiB    -17.9 MiB           1       g_score[start] = 0
    39     86.3 MiB -324220.9 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40     84.6 MiB     -1.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     84.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     84.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     84.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    159.6 MiB -259629.3 MiB       18659       while not open_set.empty():
    47    159.6 MiB -259631.7 MiB       18659           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    159.6 MiB -259638.5 MiB       18659           current = open_set.get()[2]
    53    159.6 MiB -259640.9 MiB       18659           open_set_hash.remove(current)
    54                                         
    55    159.6 MiB -259642.1 MiB       18659           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    159.6 MiB -259643.1 MiB       18659           if current == end:
    60    159.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    159.9 MiB      0.3 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    159.6 MiB -2336713.6 MiB      167922           for neighbor in current.neighbors:
    65    159.6 MiB -2077078.6 MiB      149264               if current.row != neighbor.row and current.col != neighbor.col:
    66    159.6 MiB -1038568.5 MiB       74632                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    159.6 MiB -1038532.8 MiB       74632                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    159.6 MiB -2077106.2 MiB      149264               if temp_g_score < g_score[neighbor]:
    71    159.6 MiB -271124.6 MiB       19639                   came_from[neighbor] = current
    72    159.6 MiB -271126.9 MiB       19639                   g_score[neighbor] = temp_g_score
    73    159.6 MiB -271124.2 MiB       19639                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    159.6 MiB -271124.9 MiB       19639                   if neighbor not in open_set_hash:
    75    159.6 MiB -271125.6 MiB       19639                       count += 1
    76    159.6 MiB -271020.9 MiB       19639                       open_set.put((f_score[neighbor], count, neighbor))
    77    159.6 MiB -271084.3 MiB       19639                       open_set_hash.add(neighbor)
    78                                                             
    79    159.6 MiB -259625.5 MiB       18658           if draw is not None:
    80                                                     draw()
    81                                         
    82    159.6 MiB -259626.9 MiB       18658           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    274.0 MiB    274.0 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    274.0 MiB -61675.9 MiB         513       for row in grid:
    30    274.0 MiB -31592388.3 MiB      262656           for spot in row:
    31    274.0 MiB -31530824.8 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33     89.5 MiB   -184.5 MiB           1       count = 0
    34     89.9 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     90.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     90.1 MiB      0.0 MiB           1       came_from = {}
    37    130.0 MiB     40.0 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    130.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    132.8 MiB -2007679.9 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    128.3 MiB     -4.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    128.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    128.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    128.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    131.8 MiB -242579.5 MiB        7007       while not open_set.empty():
    47    131.8 MiB -242582.1 MiB        7007           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    131.8 MiB -242586.3 MiB        7007           current = open_set.get()[2]
    53    131.8 MiB -242588.0 MiB        7007           open_set_hash.remove(current)
    54                                         
    55    131.8 MiB -242591.4 MiB        7007           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    131.8 MiB -242594.0 MiB        7007           if current == end:
    60     33.5 MiB    -98.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     34.2 MiB      0.7 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    131.8 MiB -2182745.0 MiB       63054           for neighbor in current.neighbors:
    65    131.8 MiB -1940190.5 MiB       56048               if current.row != neighbor.row and current.col != neighbor.col:
    66    131.8 MiB -970171.2 MiB       28024                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    131.8 MiB -970037.4 MiB       28024                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    131.8 MiB -1940218.7 MiB       56048               if temp_g_score < g_score[neighbor]:
    71    131.8 MiB -256028.7 MiB        7523                   came_from[neighbor] = current
    72    131.8 MiB -256031.4 MiB        7523                   g_score[neighbor] = temp_g_score
    73    131.8 MiB -256031.6 MiB        7523                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    131.8 MiB -256033.7 MiB        7523                   if neighbor not in open_set_hash:
    75    131.8 MiB -256035.9 MiB        7523                       count += 1
    76    131.8 MiB -256039.2 MiB        7523                       open_set.put((f_score[neighbor], count, neighbor))
    77    131.8 MiB -256041.7 MiB        7523                       open_set_hash.add(neighbor)
    78                                                             
    79    131.8 MiB -242569.7 MiB        7006           if draw is not None:
    80                                                     draw()
    81                                         
    82    131.8 MiB -242576.3 MiB        7006           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    259.5 MiB    259.5 MiB           1   @profile(stream=open('logs/A*/grid_size/1024.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    259.5 MiB -37653.1 MiB         513       for row in grid:
    30    259.5 MiB -19264311.2 MiB      262656           for spot in row:
    31    259.5 MiB -19226776.8 MiB      262144               spot.update_neighbors(grid)
    32                                             
    33     79.6 MiB   -179.9 MiB           1       count = 0
    34     80.0 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     80.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     80.2 MiB      0.0 MiB           1       came_from = {}
    37    117.5 MiB -111665.6 MiB      262659       g_score = {spot: float("inf") for row in grid for spot in row}
    38    114.0 MiB     -3.5 MiB           1       g_score[start] = 0
    39    135.0 MiB -25432.9 MiB      262659       f_score = {spot: float("inf") for row in grid for spot in row}
    40    135.2 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    135.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    135.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    135.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    135.3 MiB -96654.1 MiB        3520       while not open_set.empty():
    47    135.3 MiB -96655.0 MiB        3520           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    135.3 MiB -96656.0 MiB        3520           current = open_set.get()[2]
    53    135.3 MiB -96656.5 MiB        3520           open_set_hash.remove(current)
    54                                         
    55    135.3 MiB -96657.2 MiB        3520           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    135.3 MiB -96657.6 MiB        3520           if current == end:
    60    106.4 MiB    -29.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.6 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    135.3 MiB -869735.4 MiB       31671           for neighbor in current.neighbors:
    65    135.3 MiB -773084.2 MiB       28152               if current.row != neighbor.row and current.col != neighbor.col:
    66    135.3 MiB -386572.3 MiB       14076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    135.3 MiB -386517.6 MiB       14076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    135.3 MiB -773094.8 MiB       28152               if temp_g_score < g_score[neighbor]:
    71    135.3 MiB -104004.8 MiB        3866                   came_from[neighbor] = current
    72    135.3 MiB -104005.7 MiB        3866                   g_score[neighbor] = temp_g_score
    73    135.3 MiB -104007.4 MiB        3866                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    135.3 MiB -104007.8 MiB        3866                   if neighbor not in open_set_hash:
    75    135.3 MiB -104008.6 MiB        3866                       count += 1
    76    135.3 MiB -104010.9 MiB        3866                       open_set.put((f_score[neighbor], count, neighbor))
    77    135.3 MiB -104011.8 MiB        3866                       open_set_hash.add(neighbor)
    78                                                             
    79    135.3 MiB -96652.9 MiB        3519           if draw is not None:
    80                                                     draw()
    81                                         
    82    135.3 MiB -96653.4 MiB        3519           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


